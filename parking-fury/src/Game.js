!function(a) {
    if ("object" == typeof exports)
        module.exports = a();
    else {
        var b;
        "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self),
        b.p2 = a()
    }
}(function() {
    return function a(b, c, d) {
        function e(g, h) {
            if (!c[g]) {
                if (!b[g]) {
                    var i = "function" == typeof require && require;
                    if (!h && i)
                        return i(g, !0);
                    if (f)
                        return f(g, !0);
                    throw new Error("Cannot find module '" + g + "'")
                }
                var j = c[g] = {
                    exports: {}
                };
                b[g][0].call(j.exports, function(a) {
                    var c = b[g][1][a];
                    return e(c || a)
                }, j, j.exports, a, b, c, d)
            }
            return c[g].exports
        }
        for (var f = "function" == typeof require && require, g = 0; g < d.length; g++)
            e(d[g]);
        return e
    }({
        1: [function(a, b, c) {
            function e() {}
            var d = a("./Scalar");
            b.exports = e,
            e.lineInt = function(a, b, c) {
                c = c || 0;
                var f, g, h, i, j, k, l, e = [0, 0];
                return f = a[1][1] - a[0][1],
                g = a[0][0] - a[1][0],
                h = f * a[0][0] + g * a[0][1],
                i = b[1][1] - b[0][1],
                j = b[0][0] - b[1][0],
                k = i * b[0][0] + j * b[0][1],
                l = f * j - i * g,
                d.eq(l, 0, c) || (e[0] = (j * h - g * k) / l,
                e[1] = (f * k - i * h) / l),
                e
            }
            ,
            e.segmentsIntersect = function(a, b, c, d) {
                var e = b[0] - a[0]
                  , f = b[1] - a[1]
                  , g = d[0] - c[0]
                  , h = d[1] - c[1];
                if (g * f - h * e == 0)
                    return !1;
                var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e)
                  , j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
                return i >= 0 && i <= 1 && j >= 0 && j <= 1
            }
        }
        , {
            "./Scalar": 4
        }],
        2: [function(a, b, c) {
            function d() {}
            b.exports = d,
            d.area = function(a, b, c) {
                return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])
            }
            ,
            d.left = function(a, b, c) {
                return d.area(a, b, c) > 0
            }
            ,
            d.leftOn = function(a, b, c) {
                return d.area(a, b, c) >= 0
            }
            ,
            d.right = function(a, b, c) {
                return d.area(a, b, c) < 0
            }
            ,
            d.rightOn = function(a, b, c) {
                return d.area(a, b, c) <= 0
            }
            ;
            var e = []
              , f = [];
            d.collinear = function(a, b, c, g) {
                if (g) {
                    var h = e
                      , i = f;
                    h[0] = b[0] - a[0],
                    h[1] = b[1] - a[1],
                    i[0] = c[0] - b[0],
                    i[1] = c[1] - b[1];
                    var j = h[0] * i[0] + h[1] * i[1]
                      , k = Math.sqrt(h[0] * h[0] + h[1] * h[1])
                      , l = Math.sqrt(i[0] * i[0] + i[1] * i[1]);
                    return Math.acos(j / (k * l)) < g
                }
                return 0 == d.area(a, b, c)
            }
            ,
            d.sqdist = function(a, b) {
                var c = b[0] - a[0]
                  , d = b[1] - a[1];
                return c * c + d * d
            }
        }
        , {}],
        3: [function(a, b, c) {
            function g() {
                this.vertices = []
            }
            function j(a, b, c, d, e) {
                e = e || 0;
                var g = b[1] - a[1]
                  , h = a[0] - b[0]
                  , i = g * a[0] + h * a[1]
                  , j = d[1] - c[1]
                  , k = c[0] - d[0]
                  , l = j * c[0] + k * c[1]
                  , m = g * k - j * h;
                return f.eq(m, 0, e) ? [0, 0] : [(k * i - h * l) / m, (g * l - j * i) / m]
            }
            var d = a("./Line")
              , e = a("./Point")
              , f = a("./Scalar");
            b.exports = g,
            g.prototype.at = function(a) {
                var b = this.vertices
                  , c = b.length;
                return b[a < 0 ? a % c + c : a % c]
            }
            ,
            g.prototype.first = function() {
                return this.vertices[0]
            }
            ,
            g.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            }
            ,
            g.prototype.clear = function() {
                this.vertices.length = 0
            }
            ,
            g.prototype.append = function(a, b, c) {
                if (void 0 === b)
                    throw new Error("From is not given!");
                if (void 0 === c)
                    throw new Error("To is not given!");
                if (c - 1 < b)
                    throw new Error("lol1");
                if (c > a.vertices.length)
                    throw new Error("lol2");
                if (b < 0)
                    throw new Error("lol3");
                for (var d = b; d < c; d++)
                    this.vertices.push(a.vertices[d])
            }
            ,
            g.prototype.makeCCW = function() {
                for (var a = 0, b = this.vertices, c = 1; c < this.vertices.length; ++c)
                    (b[c][1] < b[a][1] || b[c][1] == b[a][1] && b[c][0] > b[a][0]) && (a = c);
                e.left(this.at(a - 1), this.at(a), this.at(a + 1)) || this.reverse()
            }
            ,
            g.prototype.reverse = function() {
                for (var a = [], b = 0, c = this.vertices.length; b !== c; b++)
                    a.push(this.vertices.pop());
                this.vertices = a
            }
            ,
            g.prototype.isReflex = function(a) {
                return e.right(this.at(a - 1), this.at(a), this.at(a + 1))
            }
            ;
            var h = []
              , i = [];
            g.prototype.canSee = function(a, b) {
                var c, f, g = h, j = i;
                if (e.leftOn(this.at(a + 1), this.at(a), this.at(b)) && e.rightOn(this.at(a - 1), this.at(a), this.at(b)))
                    return !1;
                f = e.sqdist(this.at(a), this.at(b));
                for (var k = 0; k !== this.vertices.length; ++k)
                    if ((k + 1) % this.vertices.length !== a && k !== a && e.leftOn(this.at(a), this.at(b), this.at(k + 1)) && e.rightOn(this.at(a), this.at(b), this.at(k)) && (g[0] = this.at(a),
                    g[1] = this.at(b),
                    j[0] = this.at(k),
                    j[1] = this.at(k + 1),
                    c = d.lineInt(g, j),
                    e.sqdist(this.at(a), c) < f))
                        return !1;
                return !0
            }
            ,
            g.prototype.copy = function(a, b, c) {
                var d = c || new g;
                if (d.clear(),
                a < b)
                    for (var e = a; e <= b; e++)
                        d.vertices.push(this.vertices[e]);
                else {
                    for (var e = 0; e <= b; e++)
                        d.vertices.push(this.vertices[e]);
                    for (var e = a; e < this.vertices.length; e++)
                        d.vertices.push(this.vertices[e])
                }
                return d
            }
            ,
            g.prototype.getCutEdges = function() {
                for (var a = [], b = [], c = [], d = new g, e = Number.MAX_VALUE, f = 0; f < this.vertices.length; ++f)
                    if (this.isReflex(f))
                        for (var h = 0; h < this.vertices.length; ++h)
                            if (this.canSee(f, h)) {
                                b = this.copy(f, h, d).getCutEdges(),
                                c = this.copy(h, f, d).getCutEdges();
                                for (var i = 0; i < c.length; i++)
                                    b.push(c[i]);
                                b.length < e && (a = b,
                                e = b.length,
                                a.push([this.at(f), this.at(h)]))
                            }
                return a
            }
            ,
            g.prototype.decomp = function() {
                var a = this.getCutEdges();
                return a.length > 0 ? this.slice(a) : [this]
            }
            ,
            g.prototype.slice = function(a) {
                if (0 == a.length)
                    return [this];
                if (a instanceof Array && a.length && a[0]instanceof Array && 2 == a[0].length && a[0][0]instanceof Array) {
                    for (var b = [this], c = 0; c < a.length; c++)
                        for (var d = a[c], e = 0; e < b.length; e++) {
                            var f = b[e]
                              , g = f.slice(d);
                            if (g) {
                                b.splice(e, 1),
                                b.push(g[0], g[1]);
                                break
                            }
                        }
                    return b
                }
                var d = a
                  , c = this.vertices.indexOf(d[0])
                  , e = this.vertices.indexOf(d[1]);
                return -1 != c && -1 != e && [this.copy(c, e), this.copy(e, c)]
            }
            ,
            g.prototype.isSimple = function() {
                for (var a = this.vertices, b = 0; b < a.length - 1; b++)
                    for (var c = 0; c < b - 1; c++)
                        if (d.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1]))
                            return !1;
                for (var b = 1; b < a.length - 2; b++)
                    if (d.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1]))
                        return !1;
                return !0
            }
            ,
            g.prototype.quickDecomp = function(a, b, c, d, f, h) {
                f = f || 100,
                h = h || 0,
                d = d || 25,
                a = void 0 !== a ? a : [],
                b = b || [],
                c = c || [];
                var i = [0, 0]
                  , k = [0, 0]
                  , l = [0, 0]
                  , m = 0
                  , n = 0
                  , o = 0
                  , p = 0
                  , q = 0
                  , r = 0
                  , s = 0
                  , t = new g
                  , u = new g
                  , v = this
                  , w = this.vertices;
                if (w.length < 3)
                    return a;
                if (++h > f)
                    return console.warn("quickDecomp: max level (" + f + ") reached."),
                    a;
                for (var x = 0; x < this.vertices.length; ++x)
                    if (v.isReflex(x)) {
                        b.push(v.vertices[x]),
                        m = n = Number.MAX_VALUE;
                        for (var y = 0; y < this.vertices.length; ++y)
                            e.left(v.at(x - 1), v.at(x), v.at(y)) && e.rightOn(v.at(x - 1), v.at(x), v.at(y - 1)) && (l = j(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1)),
                            e.right(v.at(x + 1), v.at(x), l) && (o = e.sqdist(v.vertices[x], l)) < n && (n = o,
                            k = l,
                            r = y)),
                            e.left(v.at(x + 1), v.at(x), v.at(y + 1)) && e.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (l = j(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1)),
                            e.left(v.at(x - 1), v.at(x), l) && (o = e.sqdist(v.vertices[x], l)) < m && (m = o,
                            i = l,
                            q = y));
                        if (r == (q + 1) % this.vertices.length)
                            l[0] = (k[0] + i[0]) / 2,
                            l[1] = (k[1] + i[1]) / 2,
                            c.push(l),
                            x < q ? (t.append(v, x, q + 1),
                            t.vertices.push(l),
                            u.vertices.push(l),
                            0 != r && u.append(v, r, v.vertices.length),
                            u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, v.vertices.length),
                            t.append(v, 0, q + 1),
                            t.vertices.push(l),
                            u.vertices.push(l),
                            u.append(v, r, x + 1));
                        else {
                            if (r > q && (q += this.vertices.length),
                            p = Number.MAX_VALUE,
                            q < r)
                                return a;
                            for (var y = r; y <= q; ++y)
                                e.leftOn(v.at(x - 1), v.at(x), v.at(y)) && e.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (o = e.sqdist(v.at(x), v.at(y))) < p && (p = o,
                                s = y % this.vertices.length);
                            x < s ? (t.append(v, x, s + 1),
                            0 != s && u.append(v, s, w.length),
                            u.append(v, 0, x + 1)) : (0 != x && t.append(v, x, w.length),
                            t.append(v, 0, s + 1),
                            u.append(v, s, x + 1))
                        }
                        return t.vertices.length < u.vertices.length ? (t.quickDecomp(a, b, c, d, f, h),
                        u.quickDecomp(a, b, c, d, f, h)) : (u.quickDecomp(a, b, c, d, f, h),
                        t.quickDecomp(a, b, c, d, f, h)),
                        a
                    }
                return a.push(this),
                a
            }
            ,
            g.prototype.removeCollinearPoints = function(a) {
                for (var b = 0, c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c)
                    e.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a) && (this.vertices.splice(c % this.vertices.length, 1),
                    c--,
                    b++);
                return b
            }
        }
        , {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4: [function(a, b, c) {
            function d() {}
            b.exports = d,
            d.eq = function(a, b, c) {
                return c = c || 0,
                Math.abs(a - b) < c
            }
        }
        , {}],
        5: [function(a, b, c) {
            b.exports = {
                Polygon: a("./Polygon"),
                Point: a("./Point")
            }
        }
        , {
            "./Point": 2,
            "./Polygon": 3
        }],
        6: [function(a, b, c) {
            b.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            }
        }
        , {}],
        7: [function(a, b, c) {
            function f(a) {
                this.lowerBound = d.create(),
                a && a.lowerBound && d.copy(this.lowerBound, a.lowerBound),
                this.upperBound = d.create(),
                a && a.upperBound && d.copy(this.upperBound, a.upperBound)
            }
            var d = a("../math/vec2");
            a("../utils/Utils");
            b.exports = f;
            var g = d.create();
            f.prototype.setFromPoints = function(a, b, c, e) {
                var f = this.lowerBound
                  , h = this.upperBound;
                "number" != typeof c && (c = 0),
                0 !== c ? d.rotate(f, a[0], c) : d.copy(f, a[0]),
                d.copy(h, f);
                for (var i = Math.cos(c), j = Math.sin(c), k = 1; k < a.length; k++) {
                    var l = a[k];
                    if (0 !== c) {
                        var m = l[0]
                          , n = l[1];
                        g[0] = i * m - j * n,
                        g[1] = j * m + i * n,
                        l = g
                    }
                    for (var o = 0; o < 2; o++)
                        l[o] > h[o] && (h[o] = l[o]),
                        l[o] < f[o] && (f[o] = l[o])
                }
                b && (d.add(this.lowerBound, this.lowerBound, b),
                d.add(this.upperBound, this.upperBound, b)),
                e && (this.lowerBound[0] -= e,
                this.lowerBound[1] -= e,
                this.upperBound[0] += e,
                this.upperBound[1] += e)
            }
            ,
            f.prototype.copy = function(a) {
                d.copy(this.lowerBound, a.lowerBound),
                d.copy(this.upperBound, a.upperBound)
            }
            ,
            f.prototype.extend = function(a) {
                for (var b = 2; b--; ) {
                    var c = a.lowerBound[b];
                    this.lowerBound[b] > c && (this.lowerBound[b] = c);
                    var d = a.upperBound[b];
                    this.upperBound[b] < d && (this.upperBound[b] = d)
                }
            }
            ,
            f.prototype.overlaps = function(a) {
                var b = this.lowerBound
                  , c = this.upperBound
                  , d = a.lowerBound
                  , e = a.upperBound;
                return (d[0] <= c[0] && c[0] <= e[0] || b[0] <= e[0] && e[0] <= c[0]) && (d[1] <= c[1] && c[1] <= e[1] || b[1] <= e[1] && e[1] <= c[1])
            }
            ,
            f.prototype.containsPoint = function(a) {
                var b = this.lowerBound
                  , c = this.upperBound;
                return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1]
            }
            ,
            f.prototype.overlapsRay = function(a) {
                var c = 1 / a.direction[0]
                  , d = 1 / a.direction[1]
                  , e = (this.lowerBound[0] - a.from[0]) * c
                  , f = (this.upperBound[0] - a.from[0]) * c
                  , g = (this.lowerBound[1] - a.from[1]) * d
                  , h = (this.upperBound[1] - a.from[1]) * d
                  , i = Math.max(Math.max(Math.min(e, f), Math.min(g, h)))
                  , j = Math.min(Math.min(Math.max(e, f), Math.max(g, h)));
                return j < 0 ? -1 : i > j ? -1 : i
            }
        }
        , {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8: [function(a, b, c) {
            function f(a) {
                this.type = a,
                this.result = [],
                this.world = null,
                this.boundingVolumeType = f.AABB
            }
            var d = a("../math/vec2")
              , e = a("../objects/Body");
            b.exports = f,
            f.AABB = 1,
            f.BOUNDING_CIRCLE = 2,
            f.prototype.setWorld = function(a) {
                this.world = a
            }
            ,
            f.prototype.getCollisionPairs = function(a) {}
            ;
            var g = d.create();
            f.boundingRadiusCheck = function(a, b) {
                d.sub(g, a.position, b.position);
                var c = d.squaredLength(g)
                  , e = a.boundingRadius + b.boundingRadius;
                return c <= e * e
            }
            ,
            f.aabbCheck = function(a, b) {
                return a.getAABB().overlaps(b.getAABB())
            }
            ,
            f.prototype.boundingVolumeCheck = function(a, b) {
                var c;
                switch (this.boundingVolumeType) {
                case f.BOUNDING_CIRCLE:
                    c = f.boundingRadiusCheck(a, b);
                    break;
                case f.AABB:
                    c = f.aabbCheck(a, b);
                    break;
                default:
                    throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return c
            }
            ,
            f.canCollide = function(a, b) {
                var c = e.KINEMATIC
                  , d = e.STATIC;
                return (a.type !== d || b.type !== d) && (!(a.type === c && b.type === d || a.type === d && b.type === c) && ((a.type !== c || b.type !== c) && ((a.sleepState !== e.SLEEPING || b.sleepState !== e.SLEEPING) && !(a.sleepState === e.SLEEPING && b.type === d || b.sleepState === e.SLEEPING && a.type === d))))
            }
            ,
            f.NAIVE = 1,
            f.SAP = 2
        }
        , {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9: [function(a, b, c) {
            function j() {
                h.call(this, h.NAIVE)
            }
            var h = (a("../shapes/Circle"),
            a("../shapes/Plane"),
            a("../shapes/Shape"),
            a("../shapes/Particle"),
            a("../collision/Broadphase"));
            a("../math/vec2");
            b.exports = j,
            j.prototype = new h,
            j.prototype.constructor = j,
            j.prototype.getCollisionPairs = function(a) {
                var b = a.bodies
                  , c = this.result;
                c.length = 0;
                for (var d = 0, e = b.length; d !== e; d++)
                    for (var f = b[d], g = 0; g < d; g++) {
                        var i = b[g];
                        h.canCollide(f, i) && this.boundingVolumeCheck(f, i) && c.push(f, i)
                    }
                return c
            }
            ,
            j.prototype.aabbQuery = function(a, b, c) {
                c = c || [];
                for (var d = a.bodies, e = 0; e < d.length; e++) {
                    var f = d[e];
                    f.aabbNeedsUpdate && f.updateAABB(),
                    f.aabb.overlaps(b) && c.push(f)
                }
                return c
            }
        }
        , {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10: [function(a, b, c) {
            function N() {
                this.contactEquations = [],
                this.frictionEquations = [],
                this.enableFriction = !0,
                this.enabledEquations = !0,
                this.slipForce = 10,
                this.frictionCoefficient = .3,
                this.surfaceVelocity = 0,
                this.contactEquationPool = new i({
                    size: 32
                }),
                this.frictionEquationPool = new j({
                    size: 64
                }),
                this.restitution = 0,
                this.stiffness = l.DEFAULT_STIFFNESS,
                this.relaxation = l.DEFAULT_RELAXATION,
                this.frictionStiffness = l.DEFAULT_STIFFNESS,
                this.frictionRelaxation = l.DEFAULT_RELAXATION,
                this.enableFrictionReduction = !0,
                this.collidingBodiesLastStep = new k,
                this.contactSkinSize = .01
            }
            function Q(a, b) {
                d.set(a.vertices[0], .5 * -b.length, -b.radius),
                d.set(a.vertices[1], .5 * b.length, -b.radius),
                d.set(a.vertices[2], .5 * b.length, b.radius),
                d.set(a.vertices[3], .5 * -b.length, b.radius)
            }
            function $(a, b, c, g) {
                for (var h = W, i = X, j = Y, k = Z, l = a, m = b.vertices, n = null, o = 0; o !== m.length + 1; o++) {
                    var p = m[o % m.length]
                      , q = m[(o + 1) % m.length];
                    d.rotate(h, p, g),
                    d.rotate(i, q, g),
                    f(h, h, c),
                    f(i, i, c),
                    e(j, h, l),
                    e(k, i, l);
                    var r = d.crossLength(j, k);
                    if (null === n && (n = r),
                    r * n <= 0)
                        return !1;
                    n = r
                }
                return !0
            }
            var d = a("../math/vec2")
              , e = d.sub
              , f = d.add
              , g = d.dot
              , i = (a("../utils/Utils"),
            a("../utils/ContactEquationPool"))
              , j = a("../utils/FrictionEquationPool")
              , k = a("../utils/TupleDictionary")
              , l = a("../equations/Equation")
              , o = (a("../equations/ContactEquation"),
            a("../equations/FrictionEquation"),
            a("../shapes/Circle"))
              , p = a("../shapes/Convex")
              , q = a("../shapes/Shape")
              , s = (a("../objects/Body"),
            a("../shapes/Box"));
            b.exports = N;
            var t = d.fromValues(0, 1)
              , u = d.fromValues(0, 0)
              , v = d.fromValues(0, 0)
              , w = d.fromValues(0, 0)
              , x = d.fromValues(0, 0)
              , y = d.fromValues(0, 0)
              , z = d.fromValues(0, 0)
              , A = d.fromValues(0, 0)
              , B = d.fromValues(0, 0)
              , C = d.fromValues(0, 0)
              , D = d.fromValues(0, 0)
              , E = d.fromValues(0, 0)
              , F = d.fromValues(0, 0)
              , G = d.fromValues(0, 0)
              , H = d.fromValues(0, 0)
              , I = d.fromValues(0, 0)
              , J = d.fromValues(0, 0)
              , K = d.fromValues(0, 0)
              , L = d.fromValues(0, 0)
              , M = []
              , O = d.create()
              , P = d.create();
            N.prototype.bodiesOverlap = function(a, b) {
                for (var c = O, d = P, e = 0, f = a.shapes.length; e !== f; e++) {
                    var g = a.shapes[e];
                    a.toWorldFrame(c, g.position);
                    for (var h = 0, i = b.shapes.length; h !== i; h++) {
                        var j = b.shapes[h];
                        if (b.toWorldFrame(d, j.position),
                        this[g.type | j.type](a, g, c, g.angle + a.angle, b, j, d, j.angle + b.angle, !0))
                            return !0
                    }
                }
                return !1
            }
            ,
            N.prototype.collidedLastStep = function(a, b) {
                var c = 0 | a.id
                  , d = 0 | b.id;
                return !!this.collidingBodiesLastStep.get(c, d)
            }
            ,
            N.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var a = this.contactEquations, b = a.length; b--; ) {
                    var c = a[b]
                      , d = c.bodyA.id
                      , e = c.bodyB.id;
                    this.collidingBodiesLastStep.set(d, e, !0)
                }
                for (var f = this.contactEquations, g = this.frictionEquations, h = 0; h < f.length; h++)
                    this.contactEquationPool.release(f[h]);
                for (var h = 0; h < g.length; h++)
                    this.frictionEquationPool.release(g[h]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }
            ,
            N.prototype.createContactEquation = function(a, b, c, d) {
                var e = this.contactEquationPool.get();
                return e.bodyA = a,
                e.bodyB = b,
                e.shapeA = c,
                e.shapeB = d,
                e.restitution = this.restitution,
                e.firstImpact = !this.collidedLastStep(a, b),
                e.stiffness = this.stiffness,
                e.relaxation = this.relaxation,
                e.needsUpdate = !0,
                e.enabled = this.enabledEquations,
                e.offset = this.contactSkinSize,
                e
            }
            ,
            N.prototype.createFrictionEquation = function(a, b, c, d) {
                var e = this.frictionEquationPool.get();
                return e.bodyA = a,
                e.bodyB = b,
                e.shapeA = c,
                e.shapeB = d,
                e.setSlipForce(this.slipForce),
                e.frictionCoefficient = this.frictionCoefficient,
                e.relativeVelocity = this.surfaceVelocity,
                e.enabled = this.enabledEquations,
                e.needsUpdate = !0,
                e.stiffness = this.frictionStiffness,
                e.relaxation = this.frictionRelaxation,
                e.contactEquations.length = 0,
                e
            }
            ,
            N.prototype.createFrictionFromContact = function(a) {
                var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
                return d.copy(b.contactPointA, a.contactPointA),
                d.copy(b.contactPointB, a.contactPointB),
                d.rotate90cw(b.t, a.normalA),
                b.contactEquations.push(a),
                b
            }
            ,
            N.prototype.createFrictionFromAverage = function(a) {
                var b = this.contactEquations[this.contactEquations.length - 1]
                  , c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB)
                  , e = b.bodyA;
                b.bodyB;
                d.set(c.contactPointA, 0, 0),
                d.set(c.contactPointB, 0, 0),
                d.set(c.t, 0, 0);
                for (var g = 0; g !== a; g++)
                    b = this.contactEquations[this.contactEquations.length - 1 - g],
                    b.bodyA === e ? (d.add(c.t, c.t, b.normalA),
                    d.add(c.contactPointA, c.contactPointA, b.contactPointA),
                    d.add(c.contactPointB, c.contactPointB, b.contactPointB)) : (d.sub(c.t, c.t, b.normalA),
                    d.add(c.contactPointA, c.contactPointA, b.contactPointB),
                    d.add(c.contactPointB, c.contactPointB, b.contactPointA)),
                    c.contactEquations.push(b);
                var h = 1 / a;
                return d.scale(c.contactPointA, c.contactPointA, h),
                d.scale(c.contactPointB, c.contactPointB, h),
                d.normalize(c.t, c.t),
                d.rotate90cw(c.t, c.t),
                c
            }
            ,
            N.prototype[q.LINE | q.CONVEX] = N.prototype.convexLine = function(a, b, c, d, e, f, g, h, i) {
                return !i && 0
            }
            ,
            N.prototype[q.LINE | q.BOX] = N.prototype.lineBox = function(a, b, c, d, e, f, g, h, i) {
                return !i && 0
            }
            ;
            var R = new s({
                width: 1,
                height: 1
            })
              , S = d.create();
            N.prototype[q.CAPSULE | q.CONVEX] = N.prototype[q.CAPSULE | q.BOX] = N.prototype.convexCapsule = function(a, b, c, e, f, g, h, i, j) {
                var k = S;
                d.set(k, g.length / 2, 0),
                d.rotate(k, k, i),
                d.add(k, k, h);
                var l = this.circleConvex(f, g, k, i, a, b, c, e, j, g.radius);
                d.set(k, -g.length / 2, 0),
                d.rotate(k, k, i),
                d.add(k, k, h);
                var m = this.circleConvex(f, g, k, i, a, b, c, e, j, g.radius);
                if (j && (l || m))
                    return !0;
                var n = R;
                return Q(n, g),
                this.convexConvex(a, b, c, e, f, n, h, i, j) + l + m
            }
            ,
            N.prototype[q.CAPSULE | q.LINE] = N.prototype.lineCapsule = function(a, b, c, d, e, f, g, h, i) {
                return !i && 0
            }
            ;
            var T = d.create()
              , U = d.create()
              , V = new s({
                width: 1,
                height: 1
            });
            N.prototype[q.CAPSULE | q.CAPSULE] = N.prototype.capsuleCapsule = function(a, b, c, e, f, g, h, i, j) {
                for (var k, l = T, m = U, n = 0, o = 0; o < 2; o++) {
                    d.set(l, (0 === o ? -1 : 1) * b.length / 2, 0),
                    d.rotate(l, l, e),
                    d.add(l, l, c);
                    for (var p = 0; p < 2; p++) {
                        d.set(m, (0 === p ? -1 : 1) * g.length / 2, 0),
                        d.rotate(m, m, i),
                        d.add(m, m, h),
                        this.enableFrictionReduction && (k = this.enableFriction,
                        this.enableFriction = !1);
                        var q = this.circleCircle(a, b, l, e, f, g, m, i, j, b.radius, g.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = k),
                        j && q)
                            return !0;
                        n += q
                    }
                }
                this.enableFrictionReduction && (k = this.enableFriction,
                this.enableFriction = !1);
                var r = V;
                Q(r, b);
                var s = this.convexCapsule(a, r, c, e, f, g, h, i, j);
                if (this.enableFrictionReduction && (this.enableFriction = k),
                j && s)
                    return !0;
                if (n += s,
                this.enableFrictionReduction) {
                    var k = this.enableFriction;
                    this.enableFriction = !1
                }
                Q(r, g);
                var t = this.convexCapsule(f, r, h, i, a, b, c, e, j);
                return this.enableFrictionReduction && (this.enableFriction = k),
                !(!j || !t) || (n += t,
                this.enableFrictionReduction && n && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(n)),
                n)
            }
            ,
            N.prototype[q.LINE | q.LINE] = N.prototype.lineLine = function(a, b, c, d, e, f, g, h, i) {
                return !i && 0
            }
            ,
            N.prototype[q.PLANE | q.LINE] = N.prototype.planeLine = function(a, b, c, h, i, j, k, l, m) {
                var n = u
                  , o = v
                  , p = w
                  , q = x
                  , r = y
                  , s = z
                  , D = A
                  , E = B
                  , F = C
                  , G = M
                  , H = 0;
                d.set(n, -j.length / 2, 0),
                d.set(o, j.length / 2, 0),
                d.rotate(p, n, l),
                d.rotate(q, o, l),
                f(p, p, k),
                f(q, q, k),
                d.copy(n, p),
                d.copy(o, q),
                e(r, o, n),
                d.normalize(s, r),
                d.rotate90cw(F, s),
                d.rotate(E, t, h),
                G[0] = n,
                G[1] = o;
                for (var I = 0; I < G.length; I++) {
                    var J = G[I];
                    e(D, J, c);
                    var K = g(D, E);
                    if (K < 0) {
                        if (m)
                            return !0;
                        var L = this.createContactEquation(a, i, b, j);
                        H++,
                        d.copy(L.normalA, E),
                        d.normalize(L.normalA, L.normalA),
                        d.scale(D, E, K),
                        e(L.contactPointA, J, D),
                        e(L.contactPointA, L.contactPointA, a.position),
                        e(L.contactPointB, J, k),
                        f(L.contactPointB, L.contactPointB, k),
                        e(L.contactPointB, L.contactPointB, i.position),
                        this.contactEquations.push(L),
                        this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(L))
                    }
                }
                return !m && (this.enableFrictionReduction || H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H)),
                H)
            }
            ,
            N.prototype[q.PARTICLE | q.CAPSULE] = N.prototype.particleCapsule = function(a, b, c, d, e, f, g, h, i) {
                return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0)
            }
            ,
            N.prototype[q.CIRCLE | q.LINE] = N.prototype.circleLine = function(a, b, c, h, i, j, k, l, m, n, o) {
                var n = n || 0
                  , o = void 0 !== o ? o : b.radius
                  , p = u
                  , q = v
                  , r = w
                  , s = x
                  , t = y
                  , I = z
                  , J = A
                  , K = B
                  , L = C
                  , N = D
                  , O = E
                  , P = F
                  , Q = G
                  , R = H
                  , S = M;
                d.set(K, -j.length / 2, 0),
                d.set(L, j.length / 2, 0),
                d.rotate(N, K, l),
                d.rotate(O, L, l),
                f(N, N, k),
                f(O, O, k),
                d.copy(K, N),
                d.copy(L, O),
                e(I, L, K),
                d.normalize(J, I),
                d.rotate90cw(t, J),
                e(P, c, K);
                var T = g(P, t);
                e(s, K, k),
                e(Q, c, k);
                var U = o + n;
                if (Math.abs(T) < U) {
                    d.scale(p, t, T),
                    e(r, c, p),
                    d.scale(q, t, g(t, Q)),
                    d.normalize(q, q),
                    d.scale(q, q, n),
                    f(r, r, q);
                    var V = g(J, r)
                      , W = g(J, K)
                      , X = g(J, L);
                    if (V > W && V < X) {
                        if (m)
                            return !0;
                        var Y = this.createContactEquation(a, i, b, j);
                        return d.scale(Y.normalA, p, -1),
                        d.normalize(Y.normalA, Y.normalA),
                        d.scale(Y.contactPointA, Y.normalA, o),
                        f(Y.contactPointA, Y.contactPointA, c),
                        e(Y.contactPointA, Y.contactPointA, a.position),
                        e(Y.contactPointB, r, k),
                        f(Y.contactPointB, Y.contactPointB, k),
                        e(Y.contactPointB, Y.contactPointB, i.position),
                        this.contactEquations.push(Y),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)),
                        1
                    }
                }
                S[0] = K,
                S[1] = L;
                for (var Z = 0; Z < S.length; Z++) {
                    var $ = S[Z];
                    if (e(P, $, c),
                    d.squaredLength(P) < Math.pow(U, 2)) {
                        if (m)
                            return !0;
                        var Y = this.createContactEquation(a, i, b, j);
                        return d.copy(Y.normalA, P),
                        d.normalize(Y.normalA, Y.normalA),
                        d.scale(Y.contactPointA, Y.normalA, o),
                        f(Y.contactPointA, Y.contactPointA, c),
                        e(Y.contactPointA, Y.contactPointA, a.position),
                        e(Y.contactPointB, $, k),
                        d.scale(R, Y.normalA, -n),
                        f(Y.contactPointB, Y.contactPointB, R),
                        f(Y.contactPointB, Y.contactPointB, k),
                        e(Y.contactPointB, Y.contactPointB, i.position),
                        this.contactEquations.push(Y),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Y)),
                        1
                    }
                }
                return 0
            }
            ,
            N.prototype[q.CIRCLE | q.CAPSULE] = N.prototype.circleCapsule = function(a, b, c, d, e, f, g, h, i) {
                return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius)
            }
            ,
            N.prototype[q.CIRCLE | q.CONVEX] = N.prototype[q.CIRCLE | q.BOX] = N.prototype.circleConvex = function(a, b, c, g, h, i, j, k, l, m) {
                for (var m = "number" == typeof m ? m : b.radius, n = u, o = v, p = w, q = x, r = y, M = D, N = E, R = G, S = H, T = I, U = J, V = !1, W = Number.MAX_VALUE, Y = i.vertices, Z = 0; Z !== Y.length + 1; Z++) {
                    var _ = Y[Z % Y.length]
                      , aa = Y[(Z + 1) % Y.length];
                    if (d.rotate(n, _, k),
                    d.rotate(o, aa, k),
                    f(n, n, j),
                    f(o, o, j),
                    e(p, o, n),
                    d.normalize(q, p),
                    d.rotate90cw(r, q),
                    d.scale(S, r, -b.radius),
                    f(S, S, c),
                    $(S, i, j, k)) {
                        d.sub(T, n, S);
                        var ba = Math.abs(d.dot(T, r));
                        ba < W && (d.copy(U, S),
                        W = ba,
                        d.scale(R, r, ba),
                        d.add(R, R, S),
                        V = !0)
                    }
                }
                if (V) {
                    if (l)
                        return !0;
                    var ca = this.createContactEquation(a, h, b, i);
                    return d.sub(ca.normalA, U, c),
                    d.normalize(ca.normalA, ca.normalA),
                    d.scale(ca.contactPointA, ca.normalA, m),
                    f(ca.contactPointA, ca.contactPointA, c),
                    e(ca.contactPointA, ca.contactPointA, a.position),
                    e(ca.contactPointB, R, j),
                    f(ca.contactPointB, ca.contactPointB, j),
                    e(ca.contactPointB, ca.contactPointB, h.position),
                    this.contactEquations.push(ca),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ca)),
                    1
                }
                if (m > 0)
                    for (var Z = 0; Z < Y.length; Z++) {
                        var da = Y[Z];
                        if (d.rotate(N, da, k),
                        f(N, N, j),
                        e(M, N, c),
                        d.squaredLength(M) < Math.pow(m, 2)) {
                            if (l)
                                return !0;
                            var ca = this.createContactEquation(a, h, b, i);
                            return d.copy(ca.normalA, M),
                            d.normalize(ca.normalA, ca.normalA),
                            d.scale(ca.contactPointA, ca.normalA, m),
                            f(ca.contactPointA, ca.contactPointA, c),
                            e(ca.contactPointA, ca.contactPointA, a.position),
                            e(ca.contactPointB, N, j),
                            f(ca.contactPointB, ca.contactPointB, j),
                            e(ca.contactPointB, ca.contactPointB, h.position),
                            this.contactEquations.push(ca),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ca)),
                            1
                        }
                    }
                return 0
            }
            ;
            var W = d.create()
              , X = d.create()
              , Y = d.create()
              , Z = d.create();
            N.prototype[q.PARTICLE | q.CONVEX] = N.prototype[q.PARTICLE | q.BOX] = N.prototype.particleConvex = function(a, b, c, h, i, j, k, l, m) {
                var n = u
                  , o = v
                  , p = w
                  , q = x
                  , r = y
                  , s = z
                  , t = A
                  , O = D
                  , T = G
                  , X = K
                  , Y = L
                  , Z = Number.MAX_VALUE
                  , aa = !1
                  , ba = j.vertices;
                if (!$(c, j, k, l))
                    return 0;
                if (m)
                    return !0;
                for (var da = 0; da !== ba.length + 1; da++) {
                    var ea = ba[da % ba.length]
                      , fa = ba[(da + 1) % ba.length];
                    d.rotate(n, ea, l),
                    d.rotate(o, fa, l),
                    f(n, n, k),
                    f(o, o, k),
                    e(p, o, n),
                    d.normalize(q, p),
                    d.rotate90cw(r, q),
                    e(O, c, n);
                    g(O, r);
                    e(s, n, k),
                    e(t, c, k),
                    d.sub(X, n, c);
                    var ha = Math.abs(d.dot(X, r));
                    ha < Z && (Z = ha,
                    d.scale(T, r, ha),
                    d.add(T, T, c),
                    d.copy(Y, r),
                    aa = !0)
                }
                if (aa) {
                    var ia = this.createContactEquation(a, i, b, j);
                    return d.scale(ia.normalA, Y, -1),
                    d.normalize(ia.normalA, ia.normalA),
                    d.set(ia.contactPointA, 0, 0),
                    f(ia.contactPointA, ia.contactPointA, c),
                    e(ia.contactPointA, ia.contactPointA, a.position),
                    e(ia.contactPointB, T, k),
                    f(ia.contactPointB, ia.contactPointB, k),
                    e(ia.contactPointB, ia.contactPointB, i.position),
                    this.contactEquations.push(ia),
                    this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ia)),
                    1
                }
                return 0
            }
            ,
            N.prototype[q.CIRCLE] = N.prototype.circleCircle = function(a, b, c, g, h, i, j, k, l, m, n) {
                var o = u
                  , m = m || b.radius
                  , n = n || i.radius;
                e(o, c, j);
                var p = m + n;
                if (d.squaredLength(o) > Math.pow(p, 2))
                    return 0;
                if (l)
                    return !0;
                var q = this.createContactEquation(a, h, b, i);
                return e(q.normalA, j, c),
                d.normalize(q.normalA, q.normalA),
                d.scale(q.contactPointA, q.normalA, m),
                d.scale(q.contactPointB, q.normalA, -n),
                f(q.contactPointA, q.contactPointA, c),
                e(q.contactPointA, q.contactPointA, a.position),
                f(q.contactPointB, q.contactPointB, j),
                e(q.contactPointB, q.contactPointB, h.position),
                this.contactEquations.push(q),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(q)),
                1
            }
            ,
            N.prototype[q.PLANE | q.CONVEX] = N.prototype[q.PLANE | q.BOX] = N.prototype.planeConvex = function(a, b, c, h, i, j, k, l, m) {
                var n = u
                  , o = v
                  , p = w
                  , q = 0;
                d.rotate(o, t, h);
                for (var r = 0; r !== j.vertices.length; r++) {
                    var s = j.vertices[r];
                    if (d.rotate(n, s, l),
                    f(n, n, k),
                    e(p, n, c),
                    g(p, o) <= 0) {
                        if (m)
                            return !0;
                        q++;
                        var x = this.createContactEquation(a, i, b, j);
                        e(p, n, c),
                        d.copy(x.normalA, o);
                        var y = g(p, x.normalA);
                        d.scale(p, x.normalA, y),
                        e(x.contactPointB, n, i.position),
                        e(x.contactPointA, n, p),
                        e(x.contactPointA, x.contactPointA, a.position),
                        this.contactEquations.push(x),
                        this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(x))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && q && this.frictionEquations.push(this.createFrictionFromAverage(q)),
                q
            }
            ,
            N.prototype[q.PARTICLE | q.PLANE] = N.prototype.particlePlane = function(a, b, c, f, h, i, j, k, l) {
                var m = u
                  , n = v;
                k = k || 0,
                e(m, c, j),
                d.rotate(n, t, k);
                var o = g(m, n);
                if (o > 0)
                    return 0;
                if (l)
                    return !0;
                var p = this.createContactEquation(h, a, i, b);
                return d.copy(p.normalA, n),
                d.scale(m, p.normalA, o),
                e(p.contactPointA, c, m),
                e(p.contactPointA, p.contactPointA, h.position),
                e(p.contactPointB, c, a.position),
                this.contactEquations.push(p),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)),
                1
            }
            ,
            N.prototype[q.CIRCLE | q.PARTICLE] = N.prototype.circleParticle = function(a, b, c, g, h, i, j, k, l) {
                var m = u;
                if (e(m, j, c),
                d.squaredLength(m) > Math.pow(b.radius, 2))
                    return 0;
                if (l)
                    return !0;
                var n = this.createContactEquation(a, h, b, i);
                return d.copy(n.normalA, m),
                d.normalize(n.normalA, n.normalA),
                d.scale(n.contactPointA, n.normalA, b.radius),
                f(n.contactPointA, n.contactPointA, c),
                e(n.contactPointA, n.contactPointA, a.position),
                e(n.contactPointB, j, h.position),
                this.contactEquations.push(n),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(n)),
                1
            }
            ;
            var _ = new o({
                radius: 1
            })
              , aa = d.create()
              , ba = d.create();
            d.create();
            N.prototype[q.PLANE | q.CAPSULE] = N.prototype.planeCapsule = function(a, b, c, e, g, h, i, j, k) {
                var l = aa
                  , m = ba
                  , n = _;
                d.set(l, -h.length / 2, 0),
                d.rotate(l, l, j),
                f(l, l, i),
                d.set(m, h.length / 2, 0),
                d.rotate(m, m, j),
                f(m, m, i),
                n.radius = h.radius;
                var p;
                this.enableFrictionReduction && (p = this.enableFriction,
                this.enableFriction = !1);
                var q = this.circlePlane(g, n, l, 0, a, b, c, e, k)
                  , r = this.circlePlane(g, n, m, 0, a, b, c, e, k);
                if (this.enableFrictionReduction && (this.enableFriction = p),
                k)
                    return q || r;
                var s = q + r;
                return this.enableFrictionReduction && s && this.frictionEquations.push(this.createFrictionFromAverage(s)),
                s
            }
            ,
            N.prototype[q.CIRCLE | q.PLANE] = N.prototype.circlePlane = function(a, b, c, h, i, j, k, l, m) {
                var n = a
                  , o = b
                  , p = c
                  , q = i
                  , s = k
                  , x = l;
                x = x || 0;
                var y = u
                  , z = v
                  , A = w;
                e(y, p, s),
                d.rotate(z, t, x);
                var B = g(z, y);
                if (B > o.radius)
                    return 0;
                if (m)
                    return !0;
                var C = this.createContactEquation(q, n, j, b);
                return d.copy(C.normalA, z),
                d.scale(C.contactPointB, C.normalA, -o.radius),
                f(C.contactPointB, C.contactPointB, p),
                e(C.contactPointB, C.contactPointB, n.position),
                d.scale(A, C.normalA, B),
                e(C.contactPointA, y, A),
                f(C.contactPointA, C.contactPointA, s),
                e(C.contactPointA, C.contactPointA, q.position),
                this.contactEquations.push(C),
                this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(C)),
                1
            }
            ,
            N.prototype[q.CONVEX] = N.prototype[q.CONVEX | q.BOX] = N.prototype[q.BOX] = N.prototype.convexConvex = function(a, b, c, h, i, j, k, l, m, n) {
                var o = u
                  , p = v
                  , q = w
                  , r = x
                  , s = y
                  , D = A
                  , E = B
                  , F = C
                  , G = 0
                  , n = "number" == typeof n ? n : 0;
                if (!N.findSeparatingAxis(b, c, h, j, k, l, o))
                    return 0;
                e(E, k, c),
                g(o, E) > 0 && d.scale(o, o, -1);
                var I = N.getClosestEdge(b, h, o, !0)
                  , J = N.getClosestEdge(j, l, o);
                if (-1 === I || -1 === J)
                    return 0;
                for (var K = 0; K < 2; K++) {
                    var L = I
                      , M = J
                      , O = b
                      , P = j
                      , Q = c
                      , R = k
                      , S = h
                      , T = l
                      , U = a
                      , V = i;
                    if (0 === K) {
                        var W;
                        W = L,
                        L = M,
                        M = W,
                        W = O,
                        O = P,
                        P = W,
                        W = Q,
                        Q = R,
                        R = W,
                        W = S,
                        S = T,
                        T = W,
                        W = U,
                        U = V,
                        V = W
                    }
                    for (var X = M; X < M + 2; X++) {
                        var Y = P.vertices[(X + P.vertices.length) % P.vertices.length];
                        d.rotate(p, Y, T),
                        f(p, p, R);
                        for (var Z = 0, $ = L - 1; $ < L + 2; $++) {
                            var _ = O.vertices[($ + O.vertices.length) % O.vertices.length]
                              , aa = O.vertices[($ + 1 + O.vertices.length) % O.vertices.length];
                            d.rotate(q, _, S),
                            d.rotate(r, aa, S),
                            f(q, q, Q),
                            f(r, r, Q),
                            e(s, r, q),
                            d.rotate90cw(F, s),
                            d.normalize(F, F),
                            e(E, p, q);
                            var ba = g(F, E);
                            ($ === L && ba <= n || $ !== L && ba <= 0) && Z++
                        }
                        if (Z >= 3) {
                            if (m)
                                return !0;
                            var ca = this.createContactEquation(U, V, O, P);
                            G++;
                            var _ = O.vertices[L % O.vertices.length]
                              , aa = O.vertices[(L + 1) % O.vertices.length];
                            d.rotate(q, _, S),
                            d.rotate(r, aa, S),
                            f(q, q, Q),
                            f(r, r, Q),
                            e(s, r, q),
                            d.rotate90cw(ca.normalA, s),
                            d.normalize(ca.normalA, ca.normalA),
                            e(E, p, q);
                            var ba = g(ca.normalA, E);
                            d.scale(D, ca.normalA, ba),
                            e(ca.contactPointA, p, Q),
                            e(ca.contactPointA, ca.contactPointA, D),
                            f(ca.contactPointA, ca.contactPointA, Q),
                            e(ca.contactPointA, ca.contactPointA, U.position),
                            e(ca.contactPointB, p, R),
                            f(ca.contactPointB, ca.contactPointB, R),
                            e(ca.contactPointB, ca.contactPointB, V.position),
                            this.contactEquations.push(ca),
                            this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ca))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && G && this.frictionEquations.push(this.createFrictionFromAverage(G)),
                G
            }
            ;
            var da = d.fromValues(0, 0);
            N.projectConvexOntoAxis = function(a, b, c, e, f) {
                var j, k, h = null, i = null, l = da;
                d.rotate(l, e, -c);
                for (var m = 0; m < a.vertices.length; m++)
                    j = a.vertices[m],
                    k = g(j, l),
                    (null === h || k > h) && (h = k),
                    (null === i || k < i) && (i = k);
                if (i > h) {
                    var n = i;
                    i = h,
                    h = n
                }
                var o = g(b, e);
                d.set(f, i + o, h + o)
            }
            ;
            var ea = d.fromValues(0, 0)
              , fa = d.fromValues(0, 0)
              , ga = d.fromValues(0, 0)
              , ha = d.fromValues(0, 0)
              , ia = d.fromValues(0, 0)
              , ja = d.fromValues(0, 0);
            N.findSeparatingAxis = function(a, b, c, f, g, h, i) {
                var j = null
                  , k = !1
                  , l = !1
                  , m = ea
                  , n = fa
                  , o = ga
                  , p = ha
                  , q = ia
                  , r = ja;
                if (a instanceof s && f instanceof s)
                    for (var t = 0; 2 !== t; t++) {
                        var u = a
                          , v = c;
                        1 === t && (u = f,
                        v = h);
                        for (var w = 0; 2 !== w; w++) {
                            0 === w ? d.set(p, 0, 1) : 1 === w && d.set(p, 1, 0),
                            0 !== v && d.rotate(p, p, v),
                            N.projectConvexOntoAxis(a, b, c, p, q),
                            N.projectConvexOntoAxis(f, g, h, p, r);
                            var x = q
                              , y = r;
                            q[0] > r[0] && (y = q,
                            x = r,
                            !0);
                            var A = y[0] - x[1];
                            k = A <= 0,
                            (null === j || A > j) && (d.copy(i, p),
                            j = A,
                            l = k)
                        }
                    }
                else
                    for (var t = 0; 2 !== t; t++) {
                        var u = a
                          , v = c;
                        1 === t && (u = f,
                        v = h);
                        for (var w = 0; w !== u.vertices.length; w++) {
                            d.rotate(n, u.vertices[w], v),
                            d.rotate(o, u.vertices[(w + 1) % u.vertices.length], v),
                            e(m, o, n),
                            d.rotate90cw(p, m),
                            d.normalize(p, p),
                            N.projectConvexOntoAxis(a, b, c, p, q),
                            N.projectConvexOntoAxis(f, g, h, p, r);
                            var x = q
                              , y = r;
                            q[0] > r[0] && (y = q,
                            x = r,
                            !0);
                            var A = y[0] - x[1];
                            k = A <= 0,
                            (null === j || A > j) && (d.copy(i, p),
                            j = A,
                            l = k)
                        }
                    }
                return l
            }
            ;
            var ka = d.fromValues(0, 0)
              , la = d.fromValues(0, 0)
              , ma = d.fromValues(0, 0);
            N.getClosestEdge = function(a, b, c, f) {
                var h = ka
                  , i = la
                  , j = ma;
                d.rotate(h, c, -b),
                f && d.scale(h, h, -1);
                for (var k = -1, l = a.vertices.length, m = -1, n = 0; n !== l; n++) {
                    e(i, a.vertices[(n + 1) % l], a.vertices[n % l]),
                    d.rotate90cw(j, i),
                    d.normalize(j, j);
                    var o = g(j, h);
                    (-1 === k || o > m) && (k = n % l,
                    m = o)
                }
                return k
            }
            ;
            var na = d.create()
              , oa = d.create()
              , pa = d.create()
              , qa = d.create()
              , ra = d.create()
              , sa = d.create()
              , ta = d.create();
            N.prototype[q.CIRCLE | q.HEIGHTFIELD] = N.prototype.circleHeightfield = function(a, b, c, g, h, i, j, k, l, m) {
                var n = i.heights
                  , m = m || b.radius
                  , o = i.elementWidth
                  , p = oa
                  , q = na
                  , r = ra
                  , s = ta
                  , t = sa
                  , u = pa
                  , v = qa
                  , w = Math.floor((c[0] - m - j[0]) / o)
                  , x = Math.ceil((c[0] + m - j[0]) / o);
                w < 0 && (w = 0),
                x >= n.length && (x = n.length - 1);
                for (var y = n[w], z = n[x], A = w; A < x; A++)
                    n[A] < z && (z = n[A]),
                    n[A] > y && (y = n[A]);
                if (c[1] - m > y)
                    return !l && 0;
                for (var B = !1, A = w; A < x; A++) {
                    d.set(u, A * o, n[A]),
                    d.set(v, (A + 1) * o, n[A + 1]),
                    d.add(u, u, j),
                    d.add(v, v, j),
                    d.sub(t, v, u),
                    d.rotate(t, t, Math.PI / 2),
                    d.normalize(t, t),
                    d.scale(q, t, -m),
                    d.add(q, q, c),
                    d.sub(p, q, u);
                    var C = d.dot(p, t);
                    if (q[0] >= u[0] && q[0] < v[0] && C <= 0) {
                        if (l)
                            return !0;
                        B = !0,
                        d.scale(p, t, -C),
                        d.add(r, q, p),
                        d.copy(s, t);
                        var D = this.createContactEquation(h, a, i, b);
                        d.copy(D.normalA, s),
                        d.scale(D.contactPointB, D.normalA, -m),
                        f(D.contactPointB, D.contactPointB, c),
                        e(D.contactPointB, D.contactPointB, a.position),
                        d.copy(D.contactPointA, r),
                        d.sub(D.contactPointA, D.contactPointA, h.position),
                        this.contactEquations.push(D),
                        this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                    }
                }
                if (B = !1,
                m > 0)
                    for (var A = w; A <= x; A++)
                        if (d.set(u, A * o, n[A]),
                        d.add(u, u, j),
                        d.sub(p, c, u),
                        d.squaredLength(p) < Math.pow(m, 2)) {
                            if (l)
                                return !0;
                            B = !0;
                            var D = this.createContactEquation(h, a, i, b);
                            d.copy(D.normalA, p),
                            d.normalize(D.normalA, D.normalA),
                            d.scale(D.contactPointB, D.normalA, -m),
                            f(D.contactPointB, D.contactPointB, c),
                            e(D.contactPointB, D.contactPointB, a.position),
                            e(D.contactPointA, u, j),
                            f(D.contactPointA, D.contactPointA, j),
                            e(D.contactPointA, D.contactPointA, h.position),
                            this.contactEquations.push(D),
                            this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(D))
                        }
                return B ? 1 : 0
            }
            ;
            var ua = d.create()
              , va = d.create()
              , wa = d.create()
              , xa = new p({
                vertices: [d.create(), d.create(), d.create(), d.create()]
            });
            N.prototype[q.BOX | q.HEIGHTFIELD] = N.prototype[q.CONVEX | q.HEIGHTFIELD] = N.prototype.convexHeightfield = function(a, b, c, e, f, g, h, i, j) {
                var k = g.heights
                  , l = g.elementWidth
                  , m = ua
                  , n = va
                  , o = wa
                  , p = xa
                  , q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l)
                  , r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
                q < 0 && (q = 0),
                r >= k.length && (r = k.length - 1);
                for (var s = k[q], t = k[r], u = q; u < r; u++)
                    k[u] < t && (t = k[u]),
                    k[u] > s && (s = k[u]);
                if (a.aabb.lowerBound[1] > s)
                    return !j && 0;
                for (var w = 0, u = q; u < r; u++) {
                    d.set(m, u * l, k[u]),
                    d.set(n, (u + 1) * l, k[u + 1]),
                    d.add(m, m, h),
                    d.add(n, n, h);
                    var x = 100;
                    d.set(o, .5 * (n[0] + m[0]), .5 * (n[1] + m[1] - x)),
                    d.sub(p.vertices[0], n, o),
                    d.sub(p.vertices[1], m, o),
                    d.copy(p.vertices[2], p.vertices[1]),
                    d.copy(p.vertices[3], p.vertices[0]),
                    p.vertices[2][1] -= x,
                    p.vertices[3][1] -= x,
                    w += this.convexConvex(a, b, c, e, f, p, o, 0, j)
                }
                return w
            }
        }
        , {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11: [function(a, b, c) {
            function h(a) {
                a = a || {},
                this.from = a.from ? d.fromValues(a.from[0], a.from[1]) : d.create(),
                this.to = a.to ? d.fromValues(a.to[0], a.to[1]) : d.create(),
                this.checkCollisionResponse = void 0 === a.checkCollisionResponse || a.checkCollisionResponse,
                this.skipBackfaces = !!a.skipBackfaces,
                this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : -1,
                this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : -1,
                this.mode = void 0 !== a.mode ? a.mode : h.ANY,
                this.callback = a.callback || function(a) {}
                ,
                this.direction = d.create(),
                this.length = 1,
                this.update()
            }
            function m(a, b, c) {
                d.sub(k, c, a);
                var e = d.dot(k, b);
                return d.scale(l, b, e),
                d.add(l, l, a),
                d.squaredDistance(c, l)
            }
            b.exports = h;
            var d = a("../math/vec2");
            a("../collision/RaycastResult"),
            a("../shapes/Shape"),
            a("../collision/AABB");
            h.prototype.constructor = h,
            h.CLOSEST = 1,
            h.ANY = 2,
            h.ALL = 4,
            h.prototype.update = function() {
                var a = this.direction;
                d.sub(a, this.to, this.from),
                this.length = d.length(a),
                d.normalize(a, a)
            }
            ,
            h.prototype.intersectBodies = function(a, b) {
                for (var c = 0, d = b.length; !a.shouldStop(this) && c < d; c++) {
                    var e = b[c]
                      , f = e.getAABB();
                    (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) && this.intersectBody(a, e)
                }
            }
            ;
            var i = d.create();
            h.prototype.intersectBody = function(a, b) {
                var c = this.checkCollisionResponse;
                if (!c || b.collisionResponse)
                    for (var e = i, f = 0, g = b.shapes.length; f < g; f++) {
                        var h = b.shapes[f];
                        if ((!c || h.collisionResponse) && (0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask))) {
                            d.rotate(e, h.position, b.angle),
                            d.add(e, e, b.position);
                            var j = h.angle + b.angle;
                            if (this.intersectShape(a, h, j, e, b),
                            a.shouldStop(this))
                                break
                        }
                    }
            }
            ,
            h.prototype.intersectShape = function(a, b, c, d, e) {
                m(this.from, this.direction, d) > b.boundingRadius * b.boundingRadius || (this._currentBody = e,
                this._currentShape = b,
                b.raycast(a, this, d, c),
                this._currentBody = this._currentShape = null)
            }
            ,
            h.prototype.getAABB = function(a) {
                var b = this.to
                  , c = this.from;
                d.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1])),
                d.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]))
            }
            ;
            d.create();
            h.prototype.reportIntersection = function(a, b, c, e) {
                var i = (this.from,
                this.to,
                this._currentShape)
                  , j = this._currentBody;
                if (!(this.skipBackfaces && d.dot(c, this.direction) > 0))
                    switch (this.mode) {
                    case h.ALL:
                        a.set(c, i, j, b, e),
                        this.callback(a);
                        break;
                    case h.CLOSEST:
                        (b < a.fraction || !a.hasHit()) && a.set(c, i, j, b, e);
                        break;
                    case h.ANY:
                        a.set(c, i, j, b, e)
                    }
            }
            ;
            var k = d.create()
              , l = d.create()
        }
        , {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12: [function(a, b, c) {
            function f() {
                this.normal = d.create(),
                this.shape = null,
                this.body = null,
                this.faceIndex = -1,
                this.fraction = -1,
                this.isStopped = !1
            }
            var d = a("../math/vec2")
              , e = a("../collision/Ray");
            b.exports = f,
            f.prototype.reset = function() {
                d.set(this.normal, 0, 0),
                this.shape = null,
                this.body = null,
                this.faceIndex = -1,
                this.fraction = -1,
                this.isStopped = !1
            }
            ,
            f.prototype.getHitDistance = function(a) {
                return d.distance(a.from, a.to) * this.fraction
            }
            ,
            f.prototype.hasHit = function() {
                return -1 !== this.fraction
            }
            ,
            f.prototype.getHitPoint = function(a, b) {
                d.lerp(a, b.from, b.to, this.fraction)
            }
            ,
            f.prototype.stop = function() {
                this.isStopped = !0
            }
            ,
            f.prototype.shouldStop = function(a) {
                return this.isStopped || -1 !== this.fraction && a.mode === e.ANY
            }
            ,
            f.prototype.set = function(a, b, c, e, f) {
                d.copy(this.normal, a),
                this.shape = b,
                this.body = c,
                this.fraction = e,
                this.faceIndex = f
            }
        }
        , {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13: [function(a, b, c) {
            function f() {
                e.call(this, e.SAP),
                this.axisList = [],
                this.axisIndex = 0;
                var a = this;
                this._addBodyHandler = function(b) {
                    a.axisList.push(b.body)
                }
                ,
                this._removeBodyHandler = function(b) {
                    var c = a.axisList.indexOf(b.body);
                    -1 !== c && a.axisList.splice(c, 1)
                }
            }
            var d = a("../utils/Utils")
              , e = a("../collision/Broadphase");
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.setWorld = function(a) {
                this.axisList.length = 0,
                d.appendArray(this.axisList, a.bodies),
                a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler),
                a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler),
                this.world = a
            }
            ,
            f.sortAxisList = function(a, b) {
                b |= 0;
                for (var c = 1, d = a.length; c < d; c++) {
                    for (var e = a[c], f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--)
                        a[f + 1] = a[f];
                    a[f + 1] = e
                }
                return a
            }
            ,
            f.prototype.sortList = function() {
                var a = this.axisList
                  , b = this.axisIndex;
                f.sortAxisList(a, b)
            }
            ,
            f.prototype.getCollisionPairs = function(a) {
                var b = this.axisList
                  , c = this.result
                  , d = this.axisIndex;
                c.length = 0;
                for (var f = b.length; f--; ) {
                    var g = b[f];
                    g.aabbNeedsUpdate && g.updateAABB()
                }
                this.sortList();
                for (var h = 0, i = 0 | b.length; h !== i; h++)
                    for (var j = b[h], k = h + 1; k < i; k++) {
                        var l = b[k]
                          , m = l.aabb.lowerBound[d] <= j.aabb.upperBound[d];
                        if (!m)
                            break;
                        e.canCollide(j, l) && this.boundingVolumeCheck(j, l) && c.push(j, l)
                    }
                return c
            }
            ,
            f.prototype.aabbQuery = function(a, b, c) {
                c = c || [],
                this.sortList();
                var d = this.axisIndex
                  , e = "x";
                1 === d && (e = "y"),
                2 === d && (e = "z");
                for (var f = this.axisList, i = (b.lowerBound[e],
                b.upperBound[e],
                0); i < f.length; i++) {
                    var j = f[i];
                    j.aabbNeedsUpdate && j.updateAABB(),
                    j.aabb.overlaps(b) && c.push(j)
                }
                return c
            }
        }
        , {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14: [function(a, b, c) {
            function e(a, b, c, e) {
                this.type = c,
                e = d.defaults(e, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }),
                this.equations = [],
                this.bodyA = a,
                this.bodyB = b,
                this.collideConnected = e.collideConnected,
                e.wakeUpBodies && (a && a.wakeUp(),
                b && b.wakeUp())
            }
            b.exports = e;
            var d = a("../utils/Utils");
            e.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            }
            ,
            e.DISTANCE = 1,
            e.GEAR = 2,
            e.LOCK = 3,
            e.PRISMATIC = 4,
            e.REVOLUTE = 5,
            e.prototype.setStiffness = function(a) {
                for (var b = this.equations, c = 0; c !== b.length; c++) {
                    var d = b[c];
                    d.stiffness = a,
                    d.needsUpdate = !0
                }
            }
            ,
            e.prototype.setRelaxation = function(a) {
                for (var b = this.equations, c = 0; c !== b.length; c++) {
                    var d = b[c];
                    d.relaxation = a,
                    d.needsUpdate = !0
                }
            }
        }
        , {
            "../utils/Utils": 57
        }],
        15: [function(a, b, c) {
            function h(a, b, c) {
                c = g.defaults(c, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }),
                d.call(this, a, b, d.DISTANCE, c),
                this.localAnchorA = f.fromValues(c.localAnchorA[0], c.localAnchorA[1]),
                this.localAnchorB = f.fromValues(c.localAnchorB[0], c.localAnchorB[1]);
                var h = this.localAnchorA
                  , i = this.localAnchorB;
                if (this.distance = 0,
                "number" == typeof c.distance)
                    this.distance = c.distance;
                else {
                    var j = f.create()
                      , k = f.create()
                      , l = f.create();
                    f.rotate(j, h, a.angle),
                    f.rotate(k, i, b.angle),
                    f.add(l, b.position, k),
                    f.sub(l, l, j),
                    f.sub(l, l, a.position),
                    this.distance = f.length(l)
                }
                var m;
                m = void 0 === c.maxForce ? Number.MAX_VALUE : c.maxForce;
                var n = new e(a,b,-m,m);
                this.equations = [n],
                this.maxForce = m;
                var l = f.create()
                  , o = f.create()
                  , p = f.create()
                  , q = this;
                n.computeGq = function() {
                    var a = this.bodyA
                      , b = this.bodyB
                      , c = a.position
                      , d = b.position;
                    return f.rotate(o, h, a.angle),
                    f.rotate(p, i, b.angle),
                    f.add(l, d, p),
                    f.sub(l, l, o),
                    f.sub(l, l, c),
                    f.length(l) - q.distance
                }
                ,
                this.setMaxForce(m),
                this.upperLimitEnabled = !1,
                this.upperLimit = 1,
                this.lowerLimitEnabled = !1,
                this.lowerLimit = 0,
                this.position = 0
            }
            var d = a("./Constraint")
              , e = a("../equations/Equation")
              , f = a("../math/vec2")
              , g = a("../utils/Utils");
            b.exports = h,
            h.prototype = new d,
            h.prototype.constructor = h;
            var i = f.create()
              , j = f.create()
              , k = f.create();
            h.prototype.update = function() {
                var a = this.equations[0]
                  , b = this.bodyA
                  , c = this.bodyB
                  , e = (this.distance,
                b.position)
                  , g = c.position
                  , h = this.equations[0]
                  , l = a.G;
                f.rotate(j, this.localAnchorA, b.angle),
                f.rotate(k, this.localAnchorB, c.angle),
                f.add(i, g, k),
                f.sub(i, i, j),
                f.sub(i, i, e),
                this.position = f.length(i);
                var m = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (h.maxForce = 0,
                h.minForce = -this.maxForce,
                this.distance = this.upperLimit,
                m = !0),
                this.lowerLimitEnabled && this.position < this.lowerLimit && (h.maxForce = this.maxForce,
                h.minForce = 0,
                this.distance = this.lowerLimit,
                m = !0),
                (this.lowerLimitEnabled || this.upperLimitEnabled) && !m)
                    return void (h.enabled = !1);
                h.enabled = !0,
                f.normalize(i, i);
                var n = f.crossLength(j, i)
                  , o = f.crossLength(k, i);
                l[0] = -i[0],
                l[1] = -i[1],
                l[2] = -n,
                l[3] = i[0],
                l[4] = i[1],
                l[5] = o
            }
            ,
            h.prototype.setMaxForce = function(a) {
                var b = this.equations[0];
                b.minForce = -a,
                b.maxForce = a
            }
            ,
            h.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        }
        , {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16: [function(a, b, c) {
            function h(a, b, c) {
                c = c || {},
                d.call(this, a, b, d.GEAR, c),
                this.ratio = void 0 !== c.ratio ? c.ratio : 1,
                this.angle = void 0 !== c.angle ? c.angle : b.angle - this.ratio * a.angle,
                c.angle = this.angle,
                c.ratio = this.ratio,
                this.equations = [new f(a,b,c)],
                void 0 !== c.maxTorque && this.setMaxTorque(c.maxTorque)
            }
            var d = a("./Constraint")
              , f = (a("../equations/Equation"),
            a("../equations/AngleLockEquation"));
            a("../math/vec2");
            b.exports = h,
            h.prototype = new d,
            h.prototype.constructor = h,
            h.prototype.update = function() {
                var a = this.equations[0];
                a.ratio !== this.ratio && a.setRatio(this.ratio),
                a.angle = this.angle
            }
            ,
            h.prototype.setMaxTorque = function(a) {
                this.equations[0].setMaxTorque(a)
            }
            ,
            h.prototype.getMaxTorque = function(a) {
                return this.equations[0].maxForce
            }
        }
        , {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17: [function(a, b, c) {
            function g(a, b, c) {
                c = c || {},
                d.call(this, a, b, d.LOCK, c);
                var g = void 0 === c.maxForce ? Number.MAX_VALUE : c.maxForce
                  , i = (c.localAngleB,
                new f(a,b,-g,g))
                  , j = new f(a,b,-g,g)
                  , k = new f(a,b,-g,g)
                  , l = e.create()
                  , m = e.create()
                  , n = this;
                i.computeGq = function() {
                    return e.rotate(l, n.localOffsetB, a.angle),
                    e.sub(m, b.position, a.position),
                    e.sub(m, m, l),
                    m[0]
                }
                ,
                j.computeGq = function() {
                    return e.rotate(l, n.localOffsetB, a.angle),
                    e.sub(m, b.position, a.position),
                    e.sub(m, m, l),
                    m[1]
                }
                ;
                var o = e.create()
                  , p = e.create();
                k.computeGq = function() {
                    return e.rotate(o, n.localOffsetB, b.angle - n.localAngleB),
                    e.scale(o, o, -1),
                    e.sub(m, a.position, b.position),
                    e.add(m, m, o),
                    e.rotate(p, o, -Math.PI / 2),
                    e.normalize(p, p),
                    e.dot(m, p)
                }
                ,
                this.localOffsetB = e.create(),
                c.localOffsetB ? e.copy(this.localOffsetB, c.localOffsetB) : (e.sub(this.localOffsetB, b.position, a.position),
                e.rotate(this.localOffsetB, this.localOffsetB, -a.angle)),
                this.localAngleB = 0,
                "number" == typeof c.localAngleB ? this.localAngleB = c.localAngleB : this.localAngleB = b.angle - a.angle,
                this.equations.push(i, j, k),
                this.setMaxForce(g)
            }
            var d = a("./Constraint")
              , e = a("../math/vec2")
              , f = a("../equations/Equation");
            b.exports = g,
            g.prototype = new d,
            g.prototype.constructor = g,
            g.prototype.setMaxForce = function(a) {
                for (var b = this.equations, c = 0; c < this.equations.length; c++)
                    b[c].maxForce = a,
                    b[c].minForce = -a
            }
            ,
            g.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
            ;
            var h = e.create()
              , i = e.create()
              , j = e.create()
              , k = e.fromValues(1, 0)
              , l = e.fromValues(0, 1);
            g.prototype.update = function() {
                var a = this.equations[0]
                  , b = this.equations[1]
                  , c = this.equations[2]
                  , d = this.bodyA
                  , f = this.bodyB;
                e.rotate(h, this.localOffsetB, d.angle),
                e.rotate(i, this.localOffsetB, f.angle - this.localAngleB),
                e.scale(i, i, -1),
                e.rotate(j, i, Math.PI / 2),
                e.normalize(j, j),
                a.G[0] = -1,
                a.G[1] = 0,
                a.G[2] = -e.crossLength(h, k),
                a.G[3] = 1,
                b.G[0] = 0,
                b.G[1] = -1,
                b.G[2] = -e.crossLength(h, l),
                b.G[4] = 1,
                c.G[0] = -j[0],
                c.G[1] = -j[1],
                c.G[3] = j[0],
                c.G[4] = j[1],
                c.G[5] = e.crossLength(i, j)
            }
        }
        , {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(a, b, c) {
            function i(a, b, c) {
                c = c || {},
                d.call(this, a, b, d.PRISMATIC, c);
                var i = g.fromValues(0, 0)
                  , j = g.fromValues(1, 0)
                  , k = g.fromValues(0, 0);
                c.localAnchorA && g.copy(i, c.localAnchorA),
                c.localAxisA && g.copy(j, c.localAxisA),
                c.localAnchorB && g.copy(k, c.localAnchorB),
                this.localAnchorA = i,
                this.localAnchorB = k,
                this.localAxisA = j;
                var l = this.maxForce = void 0 !== c.maxForce ? c.maxForce : Number.MAX_VALUE
                  , m = new f(a,b,-l,l)
                  , n = new g.create
                  , o = new g.create
                  , p = new g.create
                  , q = new g.create;
                if (m.computeGq = function() {
                    return g.dot(p, q)
                }
                ,
                m.updateJacobian = function() {
                    var c = this.G
                      , d = a.position
                      , e = b.position;
                    g.rotate(n, i, a.angle),
                    g.rotate(o, k, b.angle),
                    g.add(p, e, o),
                    g.sub(p, p, d),
                    g.sub(p, p, n),
                    g.rotate(q, j, a.angle + Math.PI / 2),
                    c[0] = -q[0],
                    c[1] = -q[1],
                    c[2] = -g.crossLength(n, q) + g.crossLength(q, p),
                    c[3] = q[0],
                    c[4] = q[1],
                    c[5] = g.crossLength(o, q)
                }
                ,
                this.equations.push(m),
                !c.disableRotationalLock) {
                    var r = new h(a,b,-l,l);
                    this.equations.push(r)
                }
                this.position = 0,
                this.velocity = 0,
                this.lowerLimitEnabled = void 0 !== c.lowerLimit,
                this.upperLimitEnabled = void 0 !== c.upperLimit,
                this.lowerLimit = void 0 !== c.lowerLimit ? c.lowerLimit : 0,
                this.upperLimit = void 0 !== c.upperLimit ? c.upperLimit : 1,
                this.upperLimitEquation = new e(a,b),
                this.lowerLimitEquation = new e(a,b),
                this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0,
                this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l,
                this.motorEquation = new f(a,b),
                this.motorEnabled = !1,
                this.motorSpeed = 0;
                var s = this
                  , t = this.motorEquation;
                t.computeGW;
                t.computeGq = function() {
                    return 0
                }
                ,
                t.computeGW = function() {
                    var a = this.G
                      , b = this.bodyA
                      , c = this.bodyB
                      , d = b.velocity
                      , e = c.velocity
                      , f = b.angularVelocity
                      , g = c.angularVelocity;
                    return this.gmult(a, d, f, e, g) + s.motorSpeed
                }
            }
            var d = a("./Constraint")
              , e = a("../equations/ContactEquation")
              , f = a("../equations/Equation")
              , g = a("../math/vec2")
              , h = a("../equations/RotationalLockEquation");
            b.exports = i,
            i.prototype = new d,
            i.prototype.constructor = i;
            var j = g.create()
              , k = g.create()
              , l = g.create()
              , m = g.create()
              , n = g.create()
              , o = g.create();
            i.prototype.update = function() {
                var a = this.equations
                  , b = a[0]
                  , c = this.upperLimit
                  , d = this.lowerLimit
                  , e = this.upperLimitEquation
                  , f = this.lowerLimitEquation
                  , h = this.bodyA
                  , i = this.bodyB
                  , p = this.localAxisA
                  , q = this.localAnchorA
                  , r = this.localAnchorB;
                b.updateJacobian(),
                g.rotate(j, p, h.angle),
                g.rotate(m, q, h.angle),
                g.add(k, m, h.position),
                g.rotate(n, r, i.angle),
                g.add(l, n, i.position);
                var s = this.position = g.dot(l, j) - g.dot(k, j);
                if (this.motorEnabled) {
                    var t = this.motorEquation.G;
                    t[0] = j[0],
                    t[1] = j[1],
                    t[2] = g.crossLength(j, n),
                    t[3] = -j[0],
                    t[4] = -j[1],
                    t[5] = -g.crossLength(j, m)
                }
                if (this.upperLimitEnabled && s > c)
                    g.scale(e.normalA, j, -1),
                    g.sub(e.contactPointA, k, h.position),
                    g.sub(e.contactPointB, l, i.position),
                    g.scale(o, j, c),
                    g.add(e.contactPointA, e.contactPointA, o),
                    -1 === a.indexOf(e) && a.push(e);
                else {
                    var u = a.indexOf(e);
                    -1 !== u && a.splice(u, 1)
                }
                if (this.lowerLimitEnabled && s < d)
                    g.scale(f.normalA, j, 1),
                    g.sub(f.contactPointA, k, h.position),
                    g.sub(f.contactPointB, l, i.position),
                    g.scale(o, j, d),
                    g.sub(f.contactPointB, f.contactPointB, o),
                    -1 === a.indexOf(f) && a.push(f);
                else {
                    var u = a.indexOf(f);
                    -1 !== u && a.splice(u, 1)
                }
            }
            ,
            i.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation),
                this.motorEnabled = !0)
            }
            ,
            i.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1),
                    this.motorEnabled = !1
                }
            }
            ,
            i.prototype.setLimits = function(a, b) {
                "number" == typeof a ? (this.lowerLimit = a,
                this.lowerLimitEnabled = !0) : (this.lowerLimit = a,
                this.lowerLimitEnabled = !1),
                "number" == typeof b ? (this.upperLimit = b,
                this.upperLimitEnabled = !0) : (this.upperLimit = b,
                this.upperLimitEnabled = !1)
            }
        }
        , {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(a, b, c) {
            function n(a, b, c) {
                c = c || {},
                d.call(this, a, b, d.REVOLUTE, c);
                var n = this.maxForce = void 0 !== c.maxForce ? c.maxForce : Number.MAX_VALUE;
                this.pivotA = h.create(),
                this.pivotB = h.create(),
                c.worldPivot ? (h.sub(this.pivotA, c.worldPivot, a.position),
                h.sub(this.pivotB, c.worldPivot, b.position),
                h.rotate(this.pivotA, this.pivotA, -a.angle),
                h.rotate(this.pivotB, this.pivotB, -b.angle)) : (h.copy(this.pivotA, c.localPivotA),
                h.copy(this.pivotB, c.localPivotB));
                var o = this.equations = [new e(a,b,-n,n), new e(a,b,-n,n)]
                  , p = o[0]
                  , q = o[1]
                  , r = this;
                p.computeGq = function() {
                    return h.rotate(i, r.pivotA, a.angle),
                    h.rotate(j, r.pivotB, b.angle),
                    h.add(m, b.position, j),
                    h.sub(m, m, a.position),
                    h.sub(m, m, i),
                    h.dot(m, k)
                }
                ,
                q.computeGq = function() {
                    return h.rotate(i, r.pivotA, a.angle),
                    h.rotate(j, r.pivotB, b.angle),
                    h.add(m, b.position, j),
                    h.sub(m, m, a.position),
                    h.sub(m, m, i),
                    h.dot(m, l)
                }
                ,
                q.minForce = p.minForce = -n,
                q.maxForce = p.maxForce = n,
                this.motorEquation = new f(a,b),
                this.motorEnabled = !1,
                this.angle = 0,
                this.lowerLimitEnabled = !1,
                this.upperLimitEnabled = !1,
                this.lowerLimit = 0,
                this.upperLimit = 0,
                this.upperLimitEquation = new g(a,b),
                this.lowerLimitEquation = new g(a,b),
                this.upperLimitEquation.minForce = 0,
                this.lowerLimitEquation.maxForce = 0
            }
            var d = a("./Constraint")
              , e = a("../equations/Equation")
              , f = a("../equations/RotationalVelocityEquation")
              , g = a("../equations/RotationalLockEquation")
              , h = a("../math/vec2");
            b.exports = n;
            var i = h.create()
              , j = h.create()
              , k = h.fromValues(1, 0)
              , l = h.fromValues(0, 1)
              , m = h.create();
            n.prototype = new d,
            n.prototype.constructor = n,
            n.prototype.setLimits = function(a, b) {
                "number" == typeof a ? (this.lowerLimit = a,
                this.lowerLimitEnabled = !0) : (this.lowerLimit = a,
                this.lowerLimitEnabled = !1),
                "number" == typeof b ? (this.upperLimit = b,
                this.upperLimitEnabled = !0) : (this.upperLimit = b,
                this.upperLimitEnabled = !1)
            }
            ,
            n.prototype.update = function() {
                var a = this.bodyA
                  , b = this.bodyB
                  , c = this.pivotA
                  , d = this.pivotB
                  , e = this.equations
                  , m = (e[0],
                e[1],
                e[0])
                  , n = e[1]
                  , o = this.upperLimit
                  , p = this.lowerLimit
                  , q = this.upperLimitEquation
                  , r = this.lowerLimitEquation
                  , s = this.angle = b.angle - a.angle;
                if (this.upperLimitEnabled && s > o)
                    q.angle = o,
                    -1 === e.indexOf(q) && e.push(q);
                else {
                    var t = e.indexOf(q);
                    -1 !== t && e.splice(t, 1)
                }
                if (this.lowerLimitEnabled && s < p)
                    r.angle = p,
                    -1 === e.indexOf(r) && e.push(r);
                else {
                    var t = e.indexOf(r);
                    -1 !== t && e.splice(t, 1)
                }
                h.rotate(i, c, a.angle),
                h.rotate(j, d, b.angle),
                m.G[0] = -1,
                m.G[1] = 0,
                m.G[2] = -h.crossLength(i, k),
                m.G[3] = 1,
                m.G[4] = 0,
                m.G[5] = h.crossLength(j, k),
                n.G[0] = 0,
                n.G[1] = -1,
                n.G[2] = -h.crossLength(i, l),
                n.G[3] = 0,
                n.G[4] = 1,
                n.G[5] = h.crossLength(j, l)
            }
            ,
            n.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation),
                this.motorEnabled = !0)
            }
            ,
            n.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var a = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(a, 1),
                    this.motorEnabled = !1
                }
            }
            ,
            n.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled
            }
            ,
            n.prototype.setMotorSpeed = function(a) {
                if (this.motorEnabled) {
                    var b = this.equations.indexOf(this.motorEquation);
                    this.equations[b].relativeVelocity = a
                }
            }
            ,
            n.prototype.getMotorSpeed = function() {
                return !!this.motorEnabled && this.motorEquation.relativeVelocity
            }
        }
        , {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(a, b, c) {
            function f(a, b, c) {
                c = c || {},
                d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE),
                this.angle = c.angle || 0,
                this.ratio = "number" == typeof c.ratio ? c.ratio : 1,
                this.setRatio(this.ratio)
            }
            var d = a("./Equation");
            a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            }
            ,
            f.prototype.setRatio = function(a) {
                var b = this.G;
                b[2] = a,
                b[5] = -1,
                this.ratio = a
            }
            ,
            f.prototype.setMaxTorque = function(a) {
                this.maxForce = a,
                this.minForce = -a
            }
        }
        , {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(a, b, c) {
            function f(a, b) {
                d.call(this, a, b, 0, Number.MAX_VALUE),
                this.contactPointA = e.create(),
                this.penetrationVec = e.create(),
                this.contactPointB = e.create(),
                this.normalA = e.create(),
                this.restitution = 0,
                this.firstImpact = !1,
                this.shapeA = null,
                this.shapeB = null
            }
            var d = a("./Equation")
              , e = a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeB = function(a, b, c) {
                var d = this.bodyA
                  , f = this.bodyB
                  , g = this.contactPointA
                  , h = this.contactPointB
                  , i = d.position
                  , j = f.position
                  , k = this.penetrationVec
                  , l = this.normalA
                  , m = this.G
                  , n = e.crossLength(g, l)
                  , o = e.crossLength(h, l);
                m[0] = -l[0],
                m[1] = -l[1],
                m[2] = -n,
                m[3] = l[0],
                m[4] = l[1],
                m[5] = o,
                e.add(k, j, h),
                e.sub(k, k, i),
                e.sub(k, k, g);
                var p, q;
                return this.firstImpact && 0 !== this.restitution ? (q = 0,
                p = 1 / b * (1 + this.restitution) * this.computeGW()) : (q = e.dot(l, k) + this.offset,
                p = this.computeGW()),
                -q * a - p * b - c * this.computeGiMf()
            }
        }
        , {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(a, b, c) {
            function g(a, b, c, d) {
                this.minForce = void 0 === c ? -Number.MAX_VALUE : c,
                this.maxForce = void 0 === d ? Number.MAX_VALUE : d,
                this.bodyA = a,
                this.bodyB = b,
                this.stiffness = g.DEFAULT_STIFFNESS,
                this.relaxation = g.DEFAULT_RELAXATION,
                this.G = new e.ARRAY_TYPE(6);
                for (var f = 0; f < 6; f++)
                    this.G[f] = 0;
                this.offset = 0,
                this.a = 0,
                this.b = 0,
                this.epsilon = 0,
                this.timeStep = 1 / 60,
                this.needsUpdate = !0,
                this.multiplier = 0,
                this.relativeVelocity = 0,
                this.enabled = !0
            }
            b.exports = g;
            var d = a("../math/vec2")
              , e = a("../utils/Utils");
            a("../objects/Body");
            g.prototype.constructor = g,
            g.DEFAULT_STIFFNESS = 1e6,
            g.DEFAULT_RELAXATION = 4,
            g.prototype.update = function() {
                var a = this.stiffness
                  , b = this.relaxation
                  , c = this.timeStep;
                this.a = 4 / (c * (1 + 4 * b)),
                this.b = 4 * b / (1 + 4 * b),
                this.epsilon = 4 / (c * c * a * (1 + 4 * b)),
                this.needsUpdate = !1
            }
            ,
            g.prototype.gmult = function(a, b, c, d, e) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e
            }
            ,
            g.prototype.computeB = function(a, b, c) {
                var d = this.computeGW();
                return -this.computeGq() * a - d * b - this.computeGiMf() * c
            }
            ;
            var h = d.create()
              , i = d.create();
            g.prototype.computeGq = function() {
                var a = this.G
                  , b = this.bodyA
                  , c = this.bodyB
                  , f = (b.position,
                c.position,
                b.angle)
                  , g = c.angle;
                return this.gmult(a, h, f, i, g) + this.offset
            }
            ,
            g.prototype.computeGW = function() {
                var a = this.G
                  , b = this.bodyA
                  , c = this.bodyB
                  , d = b.velocity
                  , e = c.velocity
                  , f = b.angularVelocity
                  , g = c.angularVelocity;
                return this.gmult(a, d, f, e, g) + this.relativeVelocity
            }
            ,
            g.prototype.computeGWlambda = function() {
                var a = this.G
                  , b = this.bodyA
                  , c = this.bodyB
                  , d = b.vlambda
                  , e = c.vlambda
                  , f = b.wlambda
                  , g = c.wlambda;
                return this.gmult(a, d, f, e, g)
            }
            ;
            var j = d.create()
              , k = d.create();
            g.prototype.computeGiMf = function() {
                var a = this.bodyA
                  , b = this.bodyB
                  , c = a.force
                  , e = a.angularForce
                  , f = b.force
                  , g = b.angularForce
                  , h = a.invMassSolve
                  , i = b.invMassSolve
                  , l = a.invInertiaSolve
                  , m = b.invInertiaSolve
                  , n = this.G;
                return d.scale(j, c, h),
                d.multiply(j, a.massMultiplier, j),
                d.scale(k, f, i),
                d.multiply(k, b.massMultiplier, k),
                this.gmult(n, j, e * l, k, g * m)
            }
            ,
            g.prototype.computeGiMGt = function() {
                var a = this.bodyA
                  , b = this.bodyB
                  , c = a.invMassSolve
                  , d = b.invMassSolve
                  , e = a.invInertiaSolve
                  , f = b.invInertiaSolve
                  , g = this.G;
                return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f
            }
            ;
            var l = d.create()
              , m = d.create()
              , n = d.create();
            d.create(),
            d.create(),
            d.create();
            g.prototype.addToWlambda = function(a) {
                var b = this.bodyA
                  , c = this.bodyB
                  , e = l
                  , f = m
                  , g = n
                  , j = b.invMassSolve
                  , k = c.invMassSolve
                  , r = b.invInertiaSolve
                  , s = c.invInertiaSolve
                  , u = this.G;
                f[0] = u[0],
                f[1] = u[1],
                g[0] = u[3],
                g[1] = u[4],
                d.scale(e, f, j * a),
                d.multiply(e, e, b.massMultiplier),
                d.add(b.vlambda, b.vlambda, e),
                b.wlambda += r * u[2] * a,
                d.scale(e, g, k * a),
                d.multiply(e, e, c.massMultiplier),
                d.add(c.vlambda, c.vlambda, e),
                c.wlambda += s * u[5] * a
            }
            ,
            g.prototype.computeInvC = function(a) {
                return 1 / (this.computeGiMGt() + a)
            }
        }
        , {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23: [function(a, b, c) {
            function g(a, b, c) {
                e.call(this, a, b, -c, c),
                this.contactPointA = d.create(),
                this.contactPointB = d.create(),
                this.t = d.create(),
                this.contactEquations = [],
                this.shapeA = null,
                this.shapeB = null,
                this.frictionCoefficient = .3
            }
            var d = a("../math/vec2")
              , e = a("./Equation");
            a("../utils/Utils");
            b.exports = g,
            g.prototype = new e,
            g.prototype.constructor = g,
            g.prototype.setSlipForce = function(a) {
                this.maxForce = a,
                this.minForce = -a
            }
            ,
            g.prototype.getSlipForce = function() {
                return this.maxForce
            }
            ,
            g.prototype.computeB = function(a, b, c) {
                var g = (this.bodyA,
                this.bodyB,
                this.contactPointA)
                  , h = this.contactPointB
                  , i = this.t
                  , j = this.G;
                return j[0] = -i[0],
                j[1] = -i[1],
                j[2] = -d.crossLength(g, i),
                j[3] = i[0],
                j[4] = i[1],
                j[5] = d.crossLength(h, i),
                -this.computeGW() * b - c * this.computeGiMf()
            }
        }
        , {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24: [function(a, b, c) {
            function f(a, b, c) {
                c = c || {},
                d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE),
                this.angle = c.angle || 0;
                var e = this.G;
                e[2] = 1,
                e[5] = -1
            }
            var d = a("./Equation")
              , e = a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f;
            var g = e.create()
              , h = e.create()
              , i = e.fromValues(1, 0)
              , j = e.fromValues(0, 1);
            f.prototype.computeGq = function() {
                return e.rotate(g, i, this.bodyA.angle + this.angle),
                e.rotate(h, j, this.bodyB.angle),
                e.dot(g, h)
            }
        }
        , {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(a, b, c) {
            function f(a, b) {
                d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE),
                this.relativeVelocity = 1,
                this.ratio = 1
            }
            var d = a("./Equation");
            a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeB = function(a, b, c) {
                var d = this.G;
                d[2] = -1,
                d[5] = this.ratio;
                var e = this.computeGiMf();
                return -this.computeGW() * b - c * e
            }
        }
        , {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(a, b, c) {
            var d = function() {};
            b.exports = d,
            d.prototype = {
                constructor: d,
                on: function(a, b, c) {
                    b.context = c || this,
                    void 0 === this._listeners && (this._listeners = {});
                    var d = this._listeners;
                    return void 0 === d[a] && (d[a] = []),
                    -1 === d[a].indexOf(b) && d[a].push(b),
                    this
                },
                has: function(a, b) {
                    if (void 0 === this._listeners)
                        return !1;
                    var c = this._listeners;
                    if (b) {
                        if (void 0 !== c[a] && -1 !== c[a].indexOf(b))
                            return !0
                    } else if (void 0 !== c[a])
                        return !0;
                    return !1
                },
                off: function(a, b) {
                    if (void 0 === this._listeners)
                        return this;
                    var c = this._listeners
                      , d = c[a].indexOf(b);
                    return -1 !== d && c[a].splice(d, 1),
                    this
                },
                emit: function(a) {
                    if (void 0 === this._listeners)
                        return this;
                    var b = this._listeners
                      , c = b[a.type];
                    if (void 0 !== c) {
                        a.target = this;
                        for (var d = 0, e = c.length; d < e; d++) {
                            var f = c[d];
                            f.call(f.context, a)
                        }
                    }
                    return this
                }
            }
        }
        , {}],
        27: [function(a, b, c) {
            function f(a, b, c) {
                if (c = c || {},
                !(a instanceof d && b instanceof d))
                    throw new Error("First two arguments must be Material instances.");
                this.id = f.idCounter++,
                this.materialA = a,
                this.materialB = b,
                this.friction = void 0 !== c.friction ? Number(c.friction) : .3,
                this.restitution = void 0 !== c.restitution ? Number(c.restitution) : 0,
                this.stiffness = void 0 !== c.stiffness ? Number(c.stiffness) : e.DEFAULT_STIFFNESS,
                this.relaxation = void 0 !== c.relaxation ? Number(c.relaxation) : e.DEFAULT_RELAXATION,
                this.frictionStiffness = void 0 !== c.frictionStiffness ? Number(c.frictionStiffness) : e.DEFAULT_STIFFNESS,
                this.frictionRelaxation = void 0 !== c.frictionRelaxation ? Number(c.frictionRelaxation) : e.DEFAULT_RELAXATION,
                this.surfaceVelocity = void 0 !== c.surfaceVelocity ? Number(c.surfaceVelocity) : 0,
                this.contactSkinSize = .005
            }
            var d = a("./Material")
              , e = a("../equations/Equation");
            b.exports = f,
            f.idCounter = 0
        }
        , {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(a, b, c) {
            function d(a) {
                this.id = a || d.idCounter++
            }
            b.exports = d,
            d.idCounter = 0
        }
        , {}],
        29: [function(a, b, c) {
            var d = {};
            d.GetArea = function(a) {
                if (a.length < 6)
                    return 0;
                for (var b = a.length - 2, c = 0, d = 0; d < b; d += 2)
                    c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]);
                return .5 * -(c += (a[0] - a[b]) * (a[b + 1] + a[1]))
            }
            ,
            d.Triangulate = function(a) {
                var b = a.length >> 1;
                if (b < 3)
                    return [];
                for (var c = [], e = [], f = 0; f < b; f++)
                    e.push(f);
                for (var f = 0, g = b; g > 3; ) {
                    var h = e[(f + 0) % g]
                      , i = e[(f + 1) % g]
                      , j = e[(f + 2) % g]
                      , k = a[2 * h]
                      , l = a[2 * h + 1]
                      , m = a[2 * i]
                      , n = a[2 * i + 1]
                      , o = a[2 * j]
                      , p = a[2 * j + 1]
                      , q = !1;
                    if (d._convex(k, l, m, n, o, p)) {
                        q = !0;
                        for (var r = 0; r < g; r++) {
                            var s = e[r];
                            if (s != h && s != i && s != j && d._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) {
                                q = !1;
                                break
                            }
                        }
                    }
                    if (q)
                        c.push(h, i, j),
                        e.splice((f + 1) % g, 1),
                        g--,
                        f = 0;
                    else if (f++ > 3 * g)
                        break
                }
                return c.push(e[0], e[1], e[2]),
                c
            }
            ,
            d._PointInTriangle = function(a, b, c, d, e, f, g, h) {
                var i = g - c
                  , j = h - d
                  , k = e - c
                  , l = f - d
                  , m = a - c
                  , n = b - d
                  , o = i * i + j * j
                  , p = i * k + j * l
                  , q = i * m + j * n
                  , r = k * k + l * l
                  , s = k * m + l * n
                  , t = 1 / (o * r - p * p)
                  , u = (r * q - p * s) * t
                  , v = (o * s - p * q) * t;
                return u >= 0 && v >= 0 && u + v < 1
            }
            ,
            d._convex = function(a, b, c, d, e, f) {
                return (b - d) * (e - c) + (c - a) * (f - d) >= 0
            }
            ,
            b.exports = d
        }
        , {}],
        30: [function(a, b, c) {
            var d = b.exports = {}
              , e = a("../utils/Utils");
            d.crossLength = function(a, b) {
                return a[0] * b[1] - a[1] * b[0]
            }
            ,
            d.crossVZ = function(a, b, c) {
                return d.rotate(a, b, -Math.PI / 2),
                d.scale(a, a, c),
                a
            }
            ,
            d.crossZV = function(a, b, c) {
                return d.rotate(a, c, Math.PI / 2),
                d.scale(a, a, b),
                a
            }
            ,
            d.rotate = function(a, b, c) {
                if (0 !== c) {
                    var d = Math.cos(c)
                      , e = Math.sin(c)
                      , f = b[0]
                      , g = b[1];
                    a[0] = d * f - e * g,
                    a[1] = e * f + d * g
                } else
                    a[0] = b[0],
                    a[1] = b[1]
            }
            ,
            d.rotate90cw = function(a, b) {
                var c = b[0]
                  , d = b[1];
                a[0] = d,
                a[1] = -c
            }
            ,
            d.toLocalFrame = function(a, b, c, e) {
                d.copy(a, b),
                d.sub(a, a, c),
                d.rotate(a, a, -e)
            }
            ,
            d.toGlobalFrame = function(a, b, c, e) {
                d.copy(a, b),
                d.rotate(a, a, e),
                d.add(a, a, c)
            }
            ,
            d.vectorToLocalFrame = function(a, b, c) {
                d.rotate(a, b, -c)
            }
            ,
            d.vectorToGlobalFrame = function(a, b, c) {
                d.rotate(a, b, c)
            }
            ,
            d.centroid = function(a, b, c, e) {
                return d.add(a, b, c),
                d.add(a, a, e),
                d.scale(a, a, 1 / 3),
                a
            }
            ,
            d.create = function() {
                var a = new e.ARRAY_TYPE(2);
                return a[0] = 0,
                a[1] = 0,
                a
            }
            ,
            d.clone = function(a) {
                var b = new e.ARRAY_TYPE(2);
                return b[0] = a[0],
                b[1] = a[1],
                b
            }
            ,
            d.fromValues = function(a, b) {
                var c = new e.ARRAY_TYPE(2);
                return c[0] = a,
                c[1] = b,
                c
            }
            ,
            d.copy = function(a, b) {
                return a[0] = b[0],
                a[1] = b[1],
                a
            }
            ,
            d.set = function(a, b, c) {
                return a[0] = b,
                a[1] = c,
                a
            }
            ,
            d.add = function(a, b, c) {
                return a[0] = b[0] + c[0],
                a[1] = b[1] + c[1],
                a
            }
            ,
            d.subtract = function(a, b, c) {
                return a[0] = b[0] - c[0],
                a[1] = b[1] - c[1],
                a
            }
            ,
            d.sub = d.subtract,
            d.multiply = function(a, b, c) {
                return a[0] = b[0] * c[0],
                a[1] = b[1] * c[1],
                a
            }
            ,
            d.mul = d.multiply,
            d.divide = function(a, b, c) {
                return a[0] = b[0] / c[0],
                a[1] = b[1] / c[1],
                a
            }
            ,
            d.div = d.divide,
            d.scale = function(a, b, c) {
                return a[0] = b[0] * c,
                a[1] = b[1] * c,
                a
            }
            ,
            d.distance = function(a, b) {
                var c = b[0] - a[0]
                  , d = b[1] - a[1];
                return Math.sqrt(c * c + d * d)
            }
            ,
            d.dist = d.distance,
            d.squaredDistance = function(a, b) {
                var c = b[0] - a[0]
                  , d = b[1] - a[1];
                return c * c + d * d
            }
            ,
            d.sqrDist = d.squaredDistance,
            d.length = function(a) {
                var b = a[0]
                  , c = a[1];
                return Math.sqrt(b * b + c * c)
            }
            ,
            d.len = d.length,
            d.squaredLength = function(a) {
                var b = a[0]
                  , c = a[1];
                return b * b + c * c
            }
            ,
            d.sqrLen = d.squaredLength,
            d.negate = function(a, b) {
                return a[0] = -b[0],
                a[1] = -b[1],
                a
            }
            ,
            d.normalize = function(a, b) {
                var c = b[0]
                  , d = b[1]
                  , e = c * c + d * d;
                return e > 0 && (e = 1 / Math.sqrt(e),
                a[0] = b[0] * e,
                a[1] = b[1] * e),
                a
            }
            ,
            d.dot = function(a, b) {
                return a[0] * b[0] + a[1] * b[1]
            }
            ,
            d.str = function(a) {
                return "vec2(" + a[0] + ", " + a[1] + ")"
            }
            ,
            d.lerp = function(a, b, c, d) {
                var e = b[0]
                  , f = b[1];
                return a[0] = e + d * (c[0] - e),
                a[1] = f + d * (c[1] - f),
                a
            }
            ,
            d.reflect = function(a, b, c) {
                var d = b[0] * c[0] + b[1] * c[1];
                a[0] = b[0] - 2 * c[0] * d,
                a[1] = b[1] - 2 * c[1] * d
            }
            ,
            d.getLineSegmentsIntersection = function(a, b, c, e, f) {
                var g = d.getLineSegmentsIntersectionFraction(b, c, e, f);
                return !(g < 0) && (a[0] = b[0] + g * (c[0] - b[0]),
                a[1] = b[1] + g * (c[1] - b[1]),
                !0)
            }
            ,
            d.getLineSegmentsIntersectionFraction = function(a, b, c, d) {
                var i, j, e = b[0] - a[0], f = b[1] - a[1], g = d[0] - c[0], h = d[1] - c[1];
                return i = (-f * (a[0] - c[0]) + e * (a[1] - c[1])) / (-g * f + e * h),
                j = (g * (a[1] - c[1]) - h * (a[0] - c[0])) / (-g * f + e * h),
                i >= 0 && i <= 1 && j >= 0 && j <= 1 ? j : -1
            }
        }
        , {
            "../utils/Utils": 57
        }],
        31: [function(a, b, c) {
            function k(a) {
                a = a || {},
                j.call(this),
                this.id = a.id || ++k._idCounter,
                this.world = null,
                this.shapes = [],
                this.mass = a.mass || 0,
                this.invMass = 0,
                this.inertia = 0,
                this.invInertia = 0,
                this.invMassSolve = 0,
                this.invInertiaSolve = 0,
                this.fixedRotation = !!a.fixedRotation,
                this.fixedX = !!a.fixedX,
                this.fixedY = !!a.fixedY,
                this.massMultiplier = d.create(),
                this.position = d.fromValues(0, 0),
                a.position && d.copy(this.position, a.position),
                this.interpolatedPosition = d.fromValues(0, 0),
                this.interpolatedAngle = 0,
                this.previousPosition = d.fromValues(0, 0),
                this.previousAngle = 0,
                this.velocity = d.fromValues(0, 0),
                a.velocity && d.copy(this.velocity, a.velocity),
                this.vlambda = d.fromValues(0, 0),
                this.wlambda = 0,
                this.angle = a.angle || 0,
                this.angularVelocity = a.angularVelocity || 0,
                this.force = d.create(),
                a.force && d.copy(this.force, a.force),
                this.angularForce = a.angularForce || 0,
                this.damping = "number" == typeof a.damping ? a.damping : .1,
                this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : .1,
                this.type = k.STATIC,
                void 0 !== a.type ? this.type = a.type : a.mass ? this.type = k.DYNAMIC : this.type = k.STATIC,
                this.boundingRadius = 0,
                this.aabb = new i,
                this.aabbNeedsUpdate = !0,
                this.allowSleep = void 0 === a.allowSleep || a.allowSleep,
                this.wantsToSleep = !1,
                this.sleepState = k.AWAKE,
                this.sleepSpeedLimit = void 0 !== a.sleepSpeedLimit ? a.sleepSpeedLimit : .2,
                this.sleepTimeLimit = void 0 !== a.sleepTimeLimit ? a.sleepTimeLimit : 1,
                this.gravityScale = void 0 !== a.gravityScale ? a.gravityScale : 1,
                this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse,
                this.idleTime = 0,
                this.timeLastSleepy = 0,
                this.ccdSpeedThreshold = void 0 !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1,
                this.ccdIterations = void 0 !== a.ccdIterations ? a.ccdIterations : 10,
                this.concavePath = null,
                this._wakeUpAfterNarrowphase = !1,
                this.updateMassProperties()
            }
            var d = a("../math/vec2")
              , e = a("poly-decomp")
              , f = a("../shapes/Convex")
              , g = a("../collision/RaycastResult")
              , h = a("../collision/Ray")
              , i = a("../collision/AABB")
              , j = a("../events/EventEmitter");
            b.exports = k,
            k.prototype = new j,
            k.prototype.constructor = k,
            k._idCounter = 0,
            k.prototype.updateSolveMassProperties = function() {
                this.sleepState === k.SLEEPING || this.type === k.KINEMATIC ? (this.invMassSolve = 0,
                this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass,
                this.invInertiaSolve = this.invInertia)
            }
            ,
            k.prototype.setDensity = function(a) {
                var b = this.getArea();
                this.mass = b * a,
                this.updateMassProperties()
            }
            ,
            k.prototype.getArea = function() {
                for (var a = 0, b = 0; b < this.shapes.length; b++)
                    a += this.shapes[b].area;
                return a
            }
            ,
            k.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(),
                this.aabb
            }
            ;
            var l = new i
              , m = d.create();
            k.prototype.updateAABB = function() {
                for (var a = this.shapes, b = a.length, c = m, e = this.angle, f = 0; f !== b; f++) {
                    var g = a[f]
                      , h = g.angle + e;
                    d.rotate(c, g.position, e),
                    d.add(c, c, this.position),
                    g.computeAABB(l, c, h),
                    0 === f ? this.aabb.copy(l) : this.aabb.extend(l)
                }
                this.aabbNeedsUpdate = !1
            }
            ,
            k.prototype.updateBoundingRadius = function() {
                for (var a = this.shapes, b = a.length, c = 0, e = 0; e !== b; e++) {
                    var f = a[e]
                      , g = d.length(f.position)
                      , h = f.boundingRadius;
                    g + h > c && (c = g + h)
                }
                this.boundingRadius = c
            }
            ,
            k.prototype.addShape = function(a, b, c) {
                if (a.body)
                    throw new Error("A shape can only be added to one body.");
                a.body = this,
                b ? d.copy(a.position, b) : d.set(a.position, 0, 0),
                a.angle = c || 0,
                this.shapes.push(a),
                this.updateMassProperties(),
                this.updateBoundingRadius(),
                this.aabbNeedsUpdate = !0
            }
            ,
            k.prototype.removeShape = function(a) {
                var b = this.shapes.indexOf(a);
                return -1 !== b && (this.shapes.splice(b, 1),
                this.aabbNeedsUpdate = !0,
                a.body = null,
                !0)
            }
            ,
            k.prototype.updateMassProperties = function() {
                if (this.type === k.STATIC || this.type === k.KINEMATIC)
                    this.mass = Number.MAX_VALUE,
                    this.invMass = 0,
                    this.inertia = Number.MAX_VALUE,
                    this.invInertia = 0;
                else {
                    var a = this.shapes
                      , b = a.length
                      , c = this.mass / b
                      , e = 0;
                    if (this.fixedRotation)
                        this.inertia = Number.MAX_VALUE,
                        this.invInertia = 0;
                    else {
                        for (var f = 0; f < b; f++) {
                            var g = a[f]
                              , h = d.squaredLength(g.position);
                            e += g.computeMomentOfInertia(c) + c * h
                        }
                        this.inertia = e,
                        this.invInertia = e > 0 ? 1 / e : 0
                    }
                    this.invMass = 1 / this.mass,
                    d.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            }
            ;
            d.create();
            k.prototype.applyForce = function(a, b) {
                if (d.add(this.force, this.force, a),
                b) {
                    var c = d.crossLength(b, a);
                    this.angularForce += c
                }
            }
            ;
            var o = d.create()
              , p = d.create()
              , q = d.create();
            k.prototype.applyForceLocal = function(a, b) {
                b = b || q;
                var c = o
                  , d = p;
                this.vectorToWorldFrame(c, a),
                this.vectorToWorldFrame(d, b),
                this.applyForce(c, d)
            }
            ;
            var r = d.create();
            k.prototype.applyImpulse = function(a, b) {
                if (this.type === k.DYNAMIC) {
                    var c = r;
                    if (d.scale(c, a, this.invMass),
                    d.multiply(c, this.massMultiplier, c),
                    d.add(this.velocity, c, this.velocity),
                    b) {
                        var e = d.crossLength(b, a);
                        e *= this.invInertia,
                        this.angularVelocity += e
                    }
                }
            }
            ;
            var s = d.create()
              , t = d.create()
              , u = d.create();
            k.prototype.applyImpulseLocal = function(a, b) {
                b = b || u;
                var c = s
                  , d = t;
                this.vectorToWorldFrame(c, a),
                this.vectorToWorldFrame(d, b),
                this.applyImpulse(c, d)
            }
            ,
            k.prototype.toLocalFrame = function(a, b) {
                d.toLocalFrame(a, b, this.position, this.angle)
            }
            ,
            k.prototype.toWorldFrame = function(a, b) {
                d.toGlobalFrame(a, b, this.position, this.angle)
            }
            ,
            k.prototype.vectorToLocalFrame = function(a, b) {
                d.vectorToLocalFrame(a, b, this.angle)
            }
            ,
            k.prototype.vectorToWorldFrame = function(a, b) {
                d.vectorToGlobalFrame(a, b, this.angle)
            }
            ,
            k.prototype.fromPolygon = function(a, b) {
                b = b || {};
                for (var c = this.shapes.length; c >= 0; --c)
                    this.removeShape(this.shapes[c]);
                var g = new e.Polygon;
                if (g.vertices = a,
                g.makeCCW(),
                "number" == typeof b.removeCollinearPoints && g.removeCollinearPoints(b.removeCollinearPoints),
                void 0 === b.skipSimpleCheck && !g.isSimple())
                    return !1;
                this.concavePath = g.vertices.slice(0);
                for (var c = 0; c < this.concavePath.length; c++) {
                    var h = [0, 0];
                    d.copy(h, this.concavePath[c]),
                    this.concavePath[c] = h
                }
                var i;
                i = b.optimalDecomp ? g.decomp() : g.quickDecomp();
                for (var j = d.create(), c = 0; c !== i.length; c++) {
                    for (var k = new f({
                        vertices: i[c].vertices
                    }), l = 0; l !== k.vertices.length; l++) {
                        var h = k.vertices[l];
                        d.sub(h, h, k.centerOfMass)
                    }
                    d.scale(j, k.centerOfMass, 1),
                    k.updateTriangles(),
                    k.updateCenterOfMass(),
                    k.updateBoundingRadius(),
                    this.addShape(k, j)
                }
                return this.adjustCenterOfMass(),
                this.aabbNeedsUpdate = !0,
                !0
            }
            ;
            var w = (d.fromValues(0, 0),
            d.fromValues(0, 0))
              , x = d.fromValues(0, 0)
              , y = d.fromValues(0, 0);
            k.prototype.adjustCenterOfMass = function() {
                var a = w
                  , b = x
                  , c = y
                  , e = 0;
                d.set(b, 0, 0);
                for (var f = 0; f !== this.shapes.length; f++) {
                    var g = this.shapes[f];
                    d.scale(a, g.position, g.area),
                    d.add(b, b, a),
                    e += g.area
                }
                d.scale(c, b, 1 / e);
                for (var f = 0; f !== this.shapes.length; f++) {
                    var g = this.shapes[f];
                    d.sub(g.position, g.position, c)
                }
                d.add(this.position, this.position, c);
                for (var f = 0; this.concavePath && f < this.concavePath.length; f++)
                    d.sub(this.concavePath[f], this.concavePath[f], c);
                this.updateMassProperties(),
                this.updateBoundingRadius()
            }
            ,
            k.prototype.setZeroForce = function() {
                d.set(this.force, 0, 0),
                this.angularForce = 0
            }
            ,
            k.prototype.resetConstraintVelocity = function() {
                var a = this
                  , b = a.vlambda;
                d.set(b, 0, 0),
                a.wlambda = 0
            }
            ,
            k.prototype.addConstraintVelocity = function() {
                var a = this
                  , b = a.velocity;
                d.add(b, b, a.vlambda),
                a.angularVelocity += a.wlambda
            }
            ,
            k.prototype.applyDamping = function(a) {
                if (this.type === k.DYNAMIC) {
                    var b = this.velocity;
                    d.scale(b, b, Math.pow(1 - this.damping, a)),
                    this.angularVelocity *= Math.pow(1 - this.angularDamping, a)
                }
            }
            ,
            k.prototype.wakeUp = function() {
                var a = this.sleepState;
                this.sleepState = k.AWAKE,
                this.idleTime = 0,
                a !== k.AWAKE && this.emit(k.wakeUpEvent)
            }
            ,
            k.prototype.sleep = function() {
                this.sleepState = k.SLEEPING,
                this.angularVelocity = 0,
                this.angularForce = 0,
                d.set(this.velocity, 0, 0),
                d.set(this.force, 0, 0),
                this.emit(k.sleepEvent)
            }
            ,
            k.prototype.sleepTick = function(a, b, c) {
                if (this.allowSleep && this.type !== k.SLEEPING) {
                    this.wantsToSleep = !1;
                    this.sleepState;
                    d.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0,
                    this.sleepState = k.AWAKE) : (this.idleTime += c,
                    this.sleepState = k.SLEEPY),
                    this.idleTime > this.sleepTimeLimit && (b ? this.wantsToSleep = !0 : this.sleep())
                }
            }
            ,
            k.prototype.overlaps = function(a) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, a)
            }
            ;
            var z = d.create()
              , A = d.create();
            k.prototype.integrate = function(a) {
                var b = this.invMass
                  , c = this.force
                  , e = this.position
                  , f = this.velocity;
                d.copy(this.previousPosition, this.position),
                this.previousAngle = this.angle,
                this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * a),
                d.scale(z, c, a * b),
                d.multiply(z, this.massMultiplier, z),
                d.add(f, z, f),
                this.integrateToTimeOfImpact(a) || (d.scale(A, f, a),
                d.add(e, e, A),
                this.fixedRotation || (this.angle += this.angularVelocity * a)),
                this.aabbNeedsUpdate = !0
            }
            ;
            var B = new g
              , C = new h({
                mode: h.ALL
            })
              , D = d.create()
              , E = d.create()
              , F = d.create()
              , G = d.create();
            k.prototype.integrateToTimeOfImpact = function(a) {
                if (this.ccdSpeedThreshold < 0 || d.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2))
                    return !1;
                d.normalize(D, this.velocity),
                d.scale(E, this.velocity, a),
                d.add(E, E, this.position),
                d.sub(F, E, this.position);
                var f, b = this.angularVelocity * a, c = d.length(F), e = 1, g = this;
                if (B.reset(),
                C.callback = function(a) {
                    a.body !== g && (f = a.body,
                    a.getHitPoint(E, C),
                    d.sub(F, E, g.position),
                    e = d.length(F) / c,
                    a.stop())
                }
                ,
                d.copy(C.from, this.position),
                d.copy(C.to, E),
                C.update(),
                this.world.raycast(B, C),
                !f)
                    return !1;
                var h = this.angle;
                d.copy(G, this.position);
                for (var i = 0, j = 0, k = 0, l = e; l >= j && i < this.ccdIterations; ) {
                    i++,
                    k = (l - j) / 2,
                    d.scale(A, F, e),
                    d.add(this.position, G, A),
                    this.angle = h + b * e,
                    this.updateAABB();
                    this.aabb.overlaps(f.aabb) && this.world.narrowphase.bodiesOverlap(this, f) ? j = k : l = k
                }
                return e = k,
                d.copy(this.position, G),
                this.angle = h,
                d.scale(A, F, e),
                d.add(this.position, this.position, A),
                this.fixedRotation || (this.angle += b * e),
                !0
            }
            ,
            k.prototype.getVelocityAtPoint = function(a, b) {
                return d.crossVZ(a, b, this.angularVelocity),
                d.subtract(a, this.velocity, a),
                a
            }
            ,
            k.sleepyEvent = {
                type: "sleepy"
            },
            k.sleepEvent = {
                type: "sleep"
            },
            k.wakeUpEvent = {
                type: "wakeup"
            },
            k.DYNAMIC = 1,
            k.STATIC = 2,
            k.KINEMATIC = 4,
            k.AWAKE = 0,
            k.SLEEPY = 1,
            k.SLEEPING = 2
        }
        , {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32: [function(a, b, c) {
            function g(a, b, c) {
                c = c || {},
                e.call(this, a, b, c),
                this.localAnchorA = d.fromValues(0, 0),
                this.localAnchorB = d.fromValues(0, 0),
                c.localAnchorA && d.copy(this.localAnchorA, c.localAnchorA),
                c.localAnchorB && d.copy(this.localAnchorB, c.localAnchorB),
                c.worldAnchorA && this.setWorldAnchorA(c.worldAnchorA),
                c.worldAnchorB && this.setWorldAnchorB(c.worldAnchorB);
                var f = d.create()
                  , g = d.create();
                this.getWorldAnchorA(f),
                this.getWorldAnchorB(g);
                var h = d.distance(f, g);
                this.restLength = "number" == typeof c.restLength ? c.restLength : h
            }
            var d = a("../math/vec2")
              , e = a("./Spring");
            a("../utils/Utils");
            b.exports = g,
            g.prototype = new e,
            g.prototype.constructor = g,
            g.prototype.setWorldAnchorA = function(a) {
                this.bodyA.toLocalFrame(this.localAnchorA, a)
            }
            ,
            g.prototype.setWorldAnchorB = function(a) {
                this.bodyB.toLocalFrame(this.localAnchorB, a)
            }
            ,
            g.prototype.getWorldAnchorA = function(a) {
                this.bodyA.toWorldFrame(a, this.localAnchorA)
            }
            ,
            g.prototype.getWorldAnchorB = function(a) {
                this.bodyB.toWorldFrame(a, this.localAnchorB)
            }
            ;
            var h = d.create()
              , i = d.create()
              , j = d.create()
              , k = d.create()
              , l = d.create()
              , m = d.create()
              , n = d.create()
              , o = d.create()
              , p = d.create();
            g.prototype.applyForce = function() {
                var a = this.stiffness
                  , b = this.damping
                  , c = this.restLength
                  , e = this.bodyA
                  , f = this.bodyB
                  , g = h
                  , q = i
                  , r = j
                  , s = k
                  , t = p
                  , u = l
                  , v = m
                  , w = n
                  , x = o;
                this.getWorldAnchorA(u),
                this.getWorldAnchorB(v),
                d.sub(w, u, e.position),
                d.sub(x, v, f.position),
                d.sub(g, v, u);
                var y = d.len(g);
                d.normalize(q, g),
                d.sub(r, f.velocity, e.velocity),
                d.crossZV(t, f.angularVelocity, x),
                d.add(r, r, t),
                d.crossZV(t, e.angularVelocity, w),
                d.sub(r, r, t),
                d.scale(s, q, -a * (y - c) - b * d.dot(r, q)),
                d.sub(e.force, e.force, s),
                d.add(f.force, f.force, s);
                var z = d.crossLength(w, s)
                  , A = d.crossLength(x, s);
                e.angularForce -= z,
                f.angularForce += A
            }
        }
        , {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33: [function(a, b, c) {
            function f(a, b, c) {
                c = c || {},
                e.call(this, a, b, c),
                this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle
            }
            var e = (a("../math/vec2"),
            a("./Spring"));
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.applyForce = function() {
                var a = this.stiffness
                  , b = this.damping
                  , c = this.restAngle
                  , d = this.bodyA
                  , e = this.bodyB
                  , f = e.angle - d.angle
                  , g = e.angularVelocity - d.angularVelocity
                  , h = -a * (f - c) - b * g * 0;
                d.angularForce -= h,
                e.angularForce += h
            }
        }
        , {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34: [function(a, b, c) {
            function f(a, b, c) {
                c = e.defaults(c, {
                    stiffness: 100,
                    damping: 1
                }),
                this.stiffness = c.stiffness,
                this.damping = c.damping,
                this.bodyA = a,
                this.bodyB = b
            }
            var e = (a("../math/vec2"),
            a("../utils/Utils"));
            b.exports = f,
            f.prototype.applyForce = function() {}
        }
        , {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35: [function(a, b, c) {
            function i(a, b) {
                b = b || {},
                this.chassisBody = a,
                this.wheels = [],
                this.groundBody = new h({
                    mass: 0
                }),
                this.world = null;
                var c = this;
                this.preStepCallback = function() {
                    c.update()
                }
            }
            function j(a, b) {
                b = b || {},
                this.vehicle = a,
                this.forwardEquation = new g(a.chassisBody,a.groundBody),
                this.sideEquation = new g(a.chassisBody,a.groundBody),
                this.steerValue = 0,
                this.engineForce = 0,
                this.setSideFriction(void 0 !== b.sideFriction ? b.sideFriction : 5),
                this.localForwardVector = d.fromValues(0, 1),
                b.localForwardVector && d.copy(this.localForwardVector, b.localForwardVector),
                this.localPosition = d.fromValues(0, 0),
                b.localPosition && d.copy(this.localPosition, b.localPosition),
                f.apply(this, a.chassisBody, a.groundBody),
                this.equations.push(this.forwardEquation, this.sideEquation),
                this.setBrakeForce(0)
            }
            var d = a("../math/vec2")
              , f = (a("../utils/Utils"),
            a("../constraints/Constraint"))
              , g = a("../equations/FrictionEquation")
              , h = a("../objects/Body");
            b.exports = i,
            i.prototype.addToWorld = function(a) {
                this.world = a,
                a.addBody(this.groundBody),
                a.on("preStep", this.preStepCallback);
                for (var b = 0; b < this.wheels.length; b++) {
                    var c = this.wheels[b];
                    a.addConstraint(c)
                }
            }
            ,
            i.prototype.removeFromWorld = function() {
                var a = this.world;
                a.removeBody(this.groundBody),
                a.off("preStep", this.preStepCallback);
                for (var b = 0; b < this.wheels.length; b++) {
                    var c = this.wheels[b];
                    a.removeConstraint(c)
                }
                this.world = null
            }
            ,
            i.prototype.addWheel = function(a) {
                var b = new j(this,a);
                return this.wheels.push(b),
                b
            }
            ,
            i.prototype.update = function() {
                for (var a = 0; a < this.wheels.length; a++)
                    this.wheels[a].update()
            }
            ,
            j.prototype = new f,
            j.prototype.setBrakeForce = function(a) {
                this.forwardEquation.setSlipForce(a)
            }
            ,
            j.prototype.setSideFriction = function(a) {
                this.sideEquation.setSlipForce(a)
            }
            ;
            var k = d.create()
              , l = d.create();
            j.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(l, this.localForwardVector),
                this.vehicle.chassisBody.getVelocityAtPoint(k, l),
                d.dot(k, l)
            }
            ;
            var m = d.create();
            j.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector),
                d.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2),
                this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t),
                d.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue),
                d.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue),
                this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition),
                d.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB),
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition),
                d.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA),
                d.normalize(m, this.forwardEquation.t),
                d.scale(m, m, this.engineForce),
                this.vehicle.chassisBody.applyForce(m, this.forwardEquation.contactPointA)
            }
        }
        , {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36: [function(a, b, c) {
            var d = b.exports = {
                AABB: a("./collision/AABB"),
                AngleLockEquation: a("./equations/AngleLockEquation"),
                Body: a("./objects/Body"),
                Broadphase: a("./collision/Broadphase"),
                Capsule: a("./shapes/Capsule"),
                Circle: a("./shapes/Circle"),
                Constraint: a("./constraints/Constraint"),
                ContactEquation: a("./equations/ContactEquation"),
                ContactEquationPool: a("./utils/ContactEquationPool"),
                ContactMaterial: a("./material/ContactMaterial"),
                Convex: a("./shapes/Convex"),
                DistanceConstraint: a("./constraints/DistanceConstraint"),
                Equation: a("./equations/Equation"),
                EventEmitter: a("./events/EventEmitter"),
                FrictionEquation: a("./equations/FrictionEquation"),
                FrictionEquationPool: a("./utils/FrictionEquationPool"),
                GearConstraint: a("./constraints/GearConstraint"),
                GSSolver: a("./solver/GSSolver"),
                Heightfield: a("./shapes/Heightfield"),
                Line: a("./shapes/Line"),
                LockConstraint: a("./constraints/LockConstraint"),
                Material: a("./material/Material"),
                Narrowphase: a("./collision/Narrowphase"),
                NaiveBroadphase: a("./collision/NaiveBroadphase"),
                Particle: a("./shapes/Particle"),
                Plane: a("./shapes/Plane"),
                Pool: a("./utils/Pool"),
                RevoluteConstraint: a("./constraints/RevoluteConstraint"),
                PrismaticConstraint: a("./constraints/PrismaticConstraint"),
                Ray: a("./collision/Ray"),
                RaycastResult: a("./collision/RaycastResult"),
                Box: a("./shapes/Box"),
                RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"),
                SAPBroadphase: a("./collision/SAPBroadphase"),
                Shape: a("./shapes/Shape"),
                Solver: a("./solver/Solver"),
                Spring: a("./objects/Spring"),
                TopDownVehicle: a("./objects/TopDownVehicle"),
                LinearSpring: a("./objects/LinearSpring"),
                RotationalSpring: a("./objects/RotationalSpring"),
                Utils: a("./utils/Utils"),
                World: a("./world/World"),
                vec2: a("./math/vec2"),
                version: a("../package.json").version
            };
            Object.defineProperty(d, "Rectangle", {
                get: function() {
                    return console.warn("The Rectangle class has been renamed to Box."),
                    this.Box
                }
            })
        }
        , {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37: [function(a, b, c) {
            function g(a) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = {
                    width: arguments[0],
                    height: arguments[1]
                },
                console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")),
                a = a || {};
                var b = this.width = a.width || 1
                  , c = this.height = a.height || 1
                  , g = [d.fromValues(-b / 2, -c / 2), d.fromValues(b / 2, -c / 2), d.fromValues(b / 2, c / 2), d.fromValues(-b / 2, c / 2)]
                  , h = [d.fromValues(1, 0), d.fromValues(0, 1)];
                a.vertices = g,
                a.axes = h,
                a.type = e.BOX,
                f.call(this, a)
            }
            var d = a("../math/vec2")
              , e = a("./Shape")
              , f = a("./Convex");
            b.exports = g,
            g.prototype = new f,
            g.prototype.constructor = g,
            g.prototype.computeMomentOfInertia = function(a) {
                var b = this.width
                  , c = this.height;
                return a * (c * c + b * b) / 12
            }
            ,
            g.prototype.updateBoundingRadius = function() {
                var a = this.width
                  , b = this.height;
                this.boundingRadius = Math.sqrt(a * a + b * b) / 2
            }
            ;
            d.create(),
            d.create(),
            d.create(),
            d.create();
            g.prototype.computeAABB = function(a, b, c) {
                a.setFromPoints(this.vertices, b, c, 0)
            }
            ,
            g.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }
        , {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38: [function(a, b, c) {
            function f(a) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (a = {
                    length: arguments[0],
                    radius: arguments[1]
                },
                console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")),
                a = a || {},
                this.length = a.length || 1,
                this.radius = a.radius || 1,
                a.type = d.CAPSULE,
                d.call(this, a)
            }
            var d = a("./Shape")
              , e = a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius
                  , c = this.length + b
                  , d = 2 * b;
                return a * (d * d + c * c) / 12
            }
            ,
            f.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            }
            ,
            f.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            }
            ;
            var g = e.create();
            f.prototype.computeAABB = function(a, b, c) {
                var d = this.radius;
                e.set(g, this.length / 2, 0),
                0 !== c && e.rotate(g, g, c),
                e.set(a.upperBound, Math.max(g[0] + d, -g[0] + d), Math.max(g[1] + d, -g[1] + d)),
                e.set(a.lowerBound, Math.min(g[0] - d, -g[0] - d), Math.min(g[1] - d, -g[1] - d)),
                e.add(a.lowerBound, a.lowerBound, b),
                e.add(a.upperBound, a.upperBound, b)
            }
            ;
            var h = e.create()
              , i = e.create()
              , j = e.create()
              , k = e.create()
              , l = e.fromValues(0, 1);
            f.prototype.raycast = function(a, b, c, d) {
                for (var f = b.from, g = b.to, n = (b.direction,
                h), o = i, p = j, q = k, r = this.length / 2, s = 0; s < 2; s++) {
                    var t = this.radius * (2 * s - 1);
                    e.set(p, -r, t),
                    e.set(q, r, t),
                    e.toGlobalFrame(p, p, c, d),
                    e.toGlobalFrame(q, q, c, d);
                    var u = e.getLineSegmentsIntersectionFraction(f, g, p, q);
                    if (u >= 0 && (e.rotate(o, l, d),
                    e.scale(o, o, 2 * s - 1),
                    b.reportIntersection(a, u, o, -1),
                    a.shouldStop(b)))
                        return
                }
                for (var v = Math.pow(this.radius, 2) + Math.pow(r, 2), s = 0; s < 2; s++) {
                    e.set(p, r * (2 * s - 1), 0),
                    e.toGlobalFrame(p, p, c, d);
                    var w = Math.pow(g[0] - f[0], 2) + Math.pow(g[1] - f[1], 2)
                      , x = 2 * ((g[0] - f[0]) * (f[0] - p[0]) + (g[1] - f[1]) * (f[1] - p[1]))
                      , y = Math.pow(f[0] - p[0], 2) + Math.pow(f[1] - p[1], 2) - Math.pow(this.radius, 2)
                      , u = Math.pow(x, 2) - 4 * w * y;
                    if (!(u < 0))
                        if (0 === u) {
                            if (e.lerp(n, f, g, u),
                            e.squaredDistance(n, c) > v && (e.sub(o, n, p),
                            e.normalize(o, o),
                            b.reportIntersection(a, u, o, -1),
                            a.shouldStop(b)))
                                return
                        } else {
                            var z = Math.sqrt(u)
                              , A = 1 / (2 * w)
                              , B = (-x - z) * A
                              , C = (-x + z) * A;
                            if (B >= 0 && B <= 1 && (e.lerp(n, f, g, B),
                            e.squaredDistance(n, c) > v && (e.sub(o, n, p),
                            e.normalize(o, o),
                            b.reportIntersection(a, B, o, -1),
                            a.shouldStop(b))))
                                return;
                            if (C >= 0 && C <= 1 && (e.lerp(n, f, g, C),
                            e.squaredDistance(n, c) > v && (e.sub(o, n, p),
                            e.normalize(o, o),
                            b.reportIntersection(a, C, o, -1),
                            a.shouldStop(b))))
                                return
                        }
                }
            }
        }
        , {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39: [function(a, b, c) {
            function f(a) {
                "number" == typeof arguments[0] && (a = {
                    radius: arguments[0]
                },
                console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")),
                a = a || {},
                this.radius = a.radius || 1,
                a.type = d.CIRCLE,
                d.call(this, a)
            }
            var d = a("./Shape")
              , e = a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeMomentOfInertia = function(a) {
                var b = this.radius;
                return a * b * b / 2
            }
            ,
            f.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            }
            ,
            f.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            }
            ,
            f.prototype.computeAABB = function(a, b, c) {
                var d = this.radius;
                e.set(a.upperBound, d, d),
                e.set(a.lowerBound, -d, -d),
                b && (e.add(a.lowerBound, a.lowerBound, b),
                e.add(a.upperBound, a.upperBound, b))
            }
            ;
            var g = e.create()
              , h = e.create();
            f.prototype.raycast = function(a, b, c, d) {
                var f = b.from
                  , i = b.to
                  , j = this.radius
                  , k = Math.pow(i[0] - f[0], 2) + Math.pow(i[1] - f[1], 2)
                  , l = 2 * ((i[0] - f[0]) * (f[0] - c[0]) + (i[1] - f[1]) * (f[1] - c[1]))
                  , m = Math.pow(f[0] - c[0], 2) + Math.pow(f[1] - c[1], 2) - Math.pow(j, 2)
                  , n = Math.pow(l, 2) - 4 * k * m
                  , o = g
                  , p = h;
                if (!(n < 0))
                    if (0 === n)
                        e.lerp(o, f, i, n),
                        e.sub(p, o, c),
                        e.normalize(p, p),
                        b.reportIntersection(a, n, p, -1);
                    else {
                        var q = Math.sqrt(n)
                          , r = 1 / (2 * k)
                          , s = (-l - q) * r
                          , t = (-l + q) * r;
                        if (s >= 0 && s <= 1 && (e.lerp(o, f, i, s),
                        e.sub(p, o, c),
                        e.normalize(p, p),
                        b.reportIntersection(a, s, p, -1),
                        a.shouldStop(b)))
                            return;
                        t >= 0 && t <= 1 && (e.lerp(o, f, i, t),
                        e.sub(p, o, c),
                        e.normalize(p, p),
                        b.reportIntersection(a, t, p, -1))
                    }
            }
        }
        , {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40: [function(a, b, c) {
            function h(a) {
                Array.isArray(arguments[0]) && (a = {
                    vertices: arguments[0],
                    axes: arguments[1]
                },
                console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")),
                a = a || {},
                this.vertices = [];
                for (var b = void 0 !== a.vertices ? a.vertices : [], c = 0; c < b.length; c++) {
                    var f = e.create();
                    e.copy(f, b[c]),
                    this.vertices.push(f)
                }
                if (this.axes = [],
                a.axes)
                    for (var c = 0; c < a.axes.length; c++) {
                        var g = e.create();
                        e.copy(g, a.axes[c]),
                        this.axes.push(g)
                    }
                else
                    for (var c = 0; c < this.vertices.length; c++) {
                        var h = this.vertices[c]
                          , i = this.vertices[(c + 1) % this.vertices.length]
                          , j = e.create();
                        e.sub(j, i, h),
                        e.rotate90cw(j, j),
                        e.normalize(j, j),
                        this.axes.push(j)
                    }
                if (this.centerOfMass = e.fromValues(0, 0),
                this.triangles = [],
                this.vertices.length && (this.updateTriangles(),
                this.updateCenterOfMass()),
                this.boundingRadius = 0,
                a.type = d.CONVEX,
                d.call(this, a),
                this.updateBoundingRadius(),
                this.updateArea(),
                this.area < 0)
                    throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            var d = a("./Shape")
              , e = a("../math/vec2")
              , f = a("../math/polyk");
            a("poly-decomp");
            b.exports = h,
            h.prototype = new d,
            h.prototype.constructor = h;
            var i = e.create()
              , j = e.create();
            h.prototype.projectOntoLocalAxis = function(a, b) {
                for (var f, g, c = null, d = null, a = i, h = 0; h < this.vertices.length; h++)
                    f = this.vertices[h],
                    g = e.dot(f, a),
                    (null === c || g > c) && (c = g),
                    (null === d || g < d) && (d = g);
                if (d > c) {
                    var j = d;
                    d = c,
                    c = j
                }
                e.set(b, d, c)
            }
            ,
            h.prototype.projectOntoWorldAxis = function(a, b, c, d) {
                var f = j;
                this.projectOntoLocalAxis(a, d),
                0 !== c ? e.rotate(f, a, c) : f = a;
                var g = e.dot(b, f);
                e.set(d, d[0] + g, d[1] + g)
            }
            ,
            h.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var a = [], b = 0; b < this.vertices.length; b++) {
                    var c = this.vertices[b];
                    a.push(c[0], c[1])
                }
                for (var d = f.Triangulate(a), b = 0; b < d.length; b += 3) {
                    var e = d[b]
                      , g = d[b + 1]
                      , h = d[b + 2];
                    this.triangles.push([e, g, h])
                }
            }
            ;
            var k = e.create()
              , l = e.create()
              , m = e.create()
              , n = e.create()
              , o = e.create();
            e.create(),
            e.create(),
            e.create(),
            e.create();
            h.prototype.updateCenterOfMass = function() {
                var a = this.triangles
                  , b = this.vertices
                  , c = this.centerOfMass
                  , d = k
                  , g = m
                  , i = n
                  , j = o
                  , w = l;
                e.set(c, 0, 0);
                for (var x = 0, y = 0; y !== a.length; y++) {
                    var z = a[y]
                      , g = b[z[0]]
                      , i = b[z[1]]
                      , j = b[z[2]];
                    e.centroid(d, g, i, j);
                    var A = h.triangleArea(g, i, j);
                    x += A,
                    e.scale(w, d, A),
                    e.add(c, c, w)
                }
                e.scale(c, c, 1 / x)
            }
            ,
            h.prototype.computeMomentOfInertia = function(a) {
                for (var b = 0, c = 0, d = this.vertices.length, f = d - 1, g = 0; g < d; f = g,
                g++) {
                    var h = this.vertices[f]
                      , i = this.vertices[g]
                      , j = Math.abs(e.crossLength(h, i));
                    b += j * (e.dot(i, i) + e.dot(i, h) + e.dot(h, h)),
                    c += j
                }
                return a / 6 * (b / c)
            }
            ,
            h.prototype.updateBoundingRadius = function() {
                for (var a = this.vertices, b = 0, c = 0; c !== a.length; c++) {
                    var d = e.squaredLength(a[c]);
                    d > b && (b = d)
                }
                this.boundingRadius = Math.sqrt(b)
            }
            ,
            h.triangleArea = function(a, b, c) {
                return .5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]))
            }
            ,
            h.prototype.updateArea = function() {
                this.updateTriangles(),
                this.area = 0;
                for (var a = this.triangles, b = this.vertices, c = 0; c !== a.length; c++) {
                    var d = a[c]
                      , e = b[d[0]]
                      , f = b[d[1]]
                      , g = b[d[2]]
                      , i = h.triangleArea(e, f, g);
                    this.area += i
                }
            }
            ,
            h.prototype.computeAABB = function(a, b, c) {
                a.setFromPoints(this.vertices, b, c, 0)
            }
            ;
            var t = e.create()
              , u = e.create()
              , v = e.create();
            h.prototype.raycast = function(a, b, c, d) {
                var f = t
                  , g = u
                  , h = v
                  , i = this.vertices;
                e.toLocalFrame(f, b.from, c, d),
                e.toLocalFrame(g, b.to, c, d);
                for (var j = i.length, k = 0; k < j && !a.shouldStop(b); k++) {
                    var l = i[k]
                      , m = i[(k + 1) % j]
                      , n = e.getLineSegmentsIntersectionFraction(f, g, l, m);
                    n >= 0 && (e.sub(h, m, l),
                    e.rotate(h, h, -Math.PI / 2 + d),
                    e.normalize(h, h),
                    b.reportIntersection(a, n, h, k))
                }
            }
        }
        , {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41: [function(a, b, c) {
            function g(a) {
                if (Array.isArray(arguments[0])) {
                    if (a = {
                        heights: arguments[0]
                    },
                    "object" == typeof arguments[1])
                        for (var b in arguments[1])
                            a[b] = arguments[1][b];
                    console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })")
                }
                a = a || {},
                this.heights = a.heights ? a.heights.slice(0) : [],
                this.maxValue = a.maxValue || null,
                this.minValue = a.minValue || null,
                this.elementWidth = a.elementWidth || .1,
                void 0 !== a.maxValue && void 0 !== a.minValue || this.updateMaxMinValues(),
                a.type = d.HEIGHTFIELD,
                d.call(this, a)
            }
            var d = a("./Shape")
              , e = a("../math/vec2");
            a("../utils/Utils");
            b.exports = g,
            g.prototype = new d,
            g.prototype.constructor = g,
            g.prototype.updateMaxMinValues = function() {
                for (var a = this.heights, b = a[0], c = a[0], d = 0; d !== a.length; d++) {
                    var e = a[d];
                    e > b && (b = e),
                    e < c && (c = e)
                }
                this.maxValue = b,
                this.minValue = c
            }
            ,
            g.prototype.computeMomentOfInertia = function(a) {
                return Number.MAX_VALUE
            }
            ,
            g.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }
            ,
            g.prototype.updateArea = function() {
                for (var a = this.heights, b = 0, c = 0; c < a.length - 1; c++)
                    b += (a[c] + a[c + 1]) / 2 * this.elementWidth;
                this.area = b
            }
            ;
            var h = [e.create(), e.create(), e.create(), e.create()];
            g.prototype.computeAABB = function(a, b, c) {
                e.set(h[0], 0, this.maxValue),
                e.set(h[1], this.elementWidth * this.heights.length, this.maxValue),
                e.set(h[2], this.elementWidth * this.heights.length, this.minValue),
                e.set(h[3], 0, this.minValue),
                a.setFromPoints(h, b, c)
            }
            ,
            g.prototype.getLineSegment = function(a, b, c) {
                var d = this.heights
                  , f = this.elementWidth;
                e.set(a, c * f, d[c]),
                e.set(b, (c + 1) * f, d[c + 1])
            }
            ,
            g.prototype.getSegmentIndex = function(a) {
                return Math.floor(a[0] / this.elementWidth)
            }
            ,
            g.prototype.getClampedSegmentIndex = function(a) {
                var b = this.getSegmentIndex(a);
                return b = Math.min(this.heights.length, Math.max(b, 0))
            }
            ;
            var j = (e.create(),
            e.create())
              , k = e.create()
              , l = e.create()
              , m = e.create()
              , n = e.create();
            e.fromValues(0, 1);
            g.prototype.raycast = function(a, b, c, d) {
                var f = b.from
                  , g = b.to
                  , p = (b.direction,
                j)
                  , q = k
                  , r = l
                  , s = m
                  , t = n;
                e.toLocalFrame(s, f, c, d),
                e.toLocalFrame(t, g, c, d);
                var u = this.getClampedSegmentIndex(s)
                  , v = this.getClampedSegmentIndex(t);
                if (u > v) {
                    var w = u;
                    u = v,
                    v = w
                }
                for (var x = 0; x < this.heights.length - 1; x++) {
                    this.getLineSegment(q, r, x);
                    var y = e.getLineSegmentsIntersectionFraction(s, t, q, r);
                    if (y >= 0 && (e.sub(p, r, q),
                    e.rotate(p, p, d + Math.PI / 2),
                    e.normalize(p, p),
                    b.reportIntersection(a, y, p, -1),
                    a.shouldStop(b)))
                        return
                }
            }
        }
        , {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42: [function(a, b, c) {
            function f(a) {
                "number" == typeof arguments[0] && (a = {
                    length: arguments[0]
                },
                console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")),
                a = a || {},
                this.length = a.length || 1,
                a.type = d.LINE,
                d.call(this, a)
            }
            var d = a("./Shape")
              , e = a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeMomentOfInertia = function(a) {
                return a * Math.pow(this.length, 2) / 12
            }
            ,
            f.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            }
            ;
            var g = [e.create(), e.create()];
            f.prototype.computeAABB = function(a, b, c) {
                var d = this.length / 2;
                e.set(g[0], -d, 0),
                e.set(g[1], d, 0),
                a.setFromPoints(g, b, c, 0)
            }
            ;
            var i = (e.create(),
            e.create())
              , j = e.create()
              , k = e.create()
              , l = e.fromValues(0, 1);
            f.prototype.raycast = function(a, b, c, d) {
                var f = b.from
                  , g = b.to
                  , h = j
                  , m = k
                  , n = this.length / 2;
                e.set(h, -n, 0),
                e.set(m, n, 0),
                e.toGlobalFrame(h, h, c, d),
                e.toGlobalFrame(m, m, c, d);
                var o = e.getLineSegmentsIntersectionFraction(h, m, f, g);
                if (o >= 0) {
                    var p = i;
                    e.rotate(p, l, d),
                    b.reportIntersection(a, o, p, -1)
                }
            }
        }
        , {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43: [function(a, b, c) {
            function f(a) {
                a = a || {},
                a.type = d.PARTICLE,
                d.call(this, a)
            }
            var d = a("./Shape")
              , e = a("../math/vec2");
            b.exports = f,
            f.prototype = new d,
            f.prototype.constructor = f,
            f.prototype.computeMomentOfInertia = function(a) {
                return 0
            }
            ,
            f.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            }
            ,
            f.prototype.computeAABB = function(a, b, c) {
                e.copy(a.lowerBound, b),
                e.copy(a.upperBound, b)
            }
        }
        , {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44: [function(a, b, c) {
            function g(a) {
                a = a || {},
                a.type = d.PLANE,
                d.call(this, a)
            }
            var d = a("./Shape")
              , e = a("../math/vec2");
            a("../utils/Utils");
            b.exports = g,
            g.prototype = new d,
            g.prototype.constructor = g,
            g.prototype.computeMomentOfInertia = function(a) {
                return 0
            }
            ,
            g.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }
            ,
            g.prototype.computeAABB = function(a, b, c) {
                var d = c % (2 * Math.PI)
                  , f = e.set
                  , g = Number.MAX_VALUE
                  , h = a.lowerBound
                  , i = a.upperBound;
                0 === d ? (f(h, -g, -g),
                f(i, g, 0)) : d === Math.PI / 2 ? (f(h, 0, -g),
                f(i, g, g)) : d === Math.PI ? (f(h, -g, 0),
                f(i, g, g)) : d === 3 * Math.PI / 2 ? (f(h, -g, -g),
                f(i, 0, g)) : (f(h, -g, -g),
                f(i, g, g)),
                e.add(h, h, b),
                e.add(i, i, b)
            }
            ,
            g.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            }
            ;
            var h = e.create()
              , k = (e.create(),
            e.create(),
            e.create())
              , l = e.create();
            g.prototype.raycast = function(a, b, c, d) {
                var f = b.from
                  , g = b.to
                  , m = b.direction
                  , n = h
                  , q = k
                  , r = l;
                e.set(q, 0, 1),
                e.rotate(q, q, d),
                e.sub(r, f, c);
                var s = e.dot(r, q);
                if (e.sub(r, g, c),
                !(s * e.dot(r, q) > 0 || e.squaredDistance(f, g) < s * s)) {
                    var u = e.dot(q, m);
                    e.sub(n, f, c);
                    var v = -e.dot(q, n) / u / b.length;
                    b.reportIntersection(a, v, q, -1)
                }
            }
        }
        , {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45: [function(a, b, c) {
            function e(a) {
                a = a || {},
                this.body = null,
                this.position = d.fromValues(0, 0),
                a.position && d.copy(this.position, a.position),
                this.angle = a.angle || 0,
                this.type = a.type || 0,
                this.id = e.idCounter++,
                this.boundingRadius = 0,
                this.collisionGroup = void 0 !== a.collisionGroup ? a.collisionGroup : 1,
                this.collisionResponse = void 0 === a.collisionResponse || a.collisionResponse,
                this.collisionMask = void 0 !== a.collisionMask ? a.collisionMask : 1,
                this.material = a.material || null,
                this.area = 0,
                this.sensor = void 0 !== a.sensor && a.sensor,
                this.type && this.updateBoundingRadius(),
                this.updateArea()
            }
            b.exports = e;
            var d = a("../math/vec2");
            e.idCounter = 0,
            e.CIRCLE = 1,
            e.PARTICLE = 2,
            e.PLANE = 4,
            e.CONVEX = 8,
            e.LINE = 16,
            e.BOX = 32,
            Object.defineProperty(e, "RECTANGLE", {
                get: function() {
                    return console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead."),
                    e.BOX
                }
            }),
            e.CAPSULE = 64,
            e.HEIGHTFIELD = 128,
            e.prototype.computeMomentOfInertia = function(a) {}
            ,
            e.prototype.updateBoundingRadius = function() {}
            ,
            e.prototype.updateArea = function() {}
            ,
            e.prototype.computeAABB = function(a, b, c) {}
            ,
            e.prototype.raycast = function(a, b, c, d) {}
        }
        , {
            "../math/vec2": 30
        }],
        46: [function(a, b, c) {
            function h(a) {
                e.call(this, a, e.GS),
                a = a || {},
                this.iterations = a.iterations || 10,
                this.tolerance = a.tolerance || 1e-7,
                this.arrayStep = 30,
                this.lambda = new f.ARRAY_TYPE(this.arrayStep),
                this.Bs = new f.ARRAY_TYPE(this.arrayStep),
                this.invCs = new f.ARRAY_TYPE(this.arrayStep),
                this.useZeroRHS = !1,
                this.frictionIterations = 0,
                this.usedIterations = 0
            }
            function i(a) {
                for (var b = a.length; b--; )
                    a[b] = 0
            }
            var d = a("../math/vec2")
              , e = a("./Solver")
              , f = a("../utils/Utils")
              , g = a("../equations/FrictionEquation");
            b.exports = h,
            h.prototype = new e,
            h.prototype.constructor = h,
            h.prototype.solve = function(a, b) {
                this.sortEquations();
                var c = 0
                  , e = this.iterations
                  , j = this.frictionIterations
                  , k = this.equations
                  , l = k.length
                  , m = Math.pow(this.tolerance * l, 2)
                  , n = b.bodies
                  , o = b.bodies.length
                  , r = (d.add,
                d.set,
                this.useZeroRHS)
                  , s = this.lambda;
                if (this.usedIterations = 0,
                l)
                    for (var t = 0; t !== o; t++) {
                        var u = n[t];
                        u.updateSolveMassProperties()
                    }
                s.length < l && (s = this.lambda = new f.ARRAY_TYPE(l + this.arrayStep),
                this.Bs = new f.ARRAY_TYPE(l + this.arrayStep),
                this.invCs = new f.ARRAY_TYPE(l + this.arrayStep)),
                i(s);
                for (var v = this.invCs, w = this.Bs, s = this.lambda, t = 0; t !== k.length; t++) {
                    var x = k[t];
                    (x.timeStep !== a || x.needsUpdate) && (x.timeStep = a,
                    x.update()),
                    w[t] = x.computeB(x.a, x.b, a),
                    v[t] = x.computeInvC(x.epsilon)
                }
                var x, A, t, B;
                if (0 !== l) {
                    for (t = 0; t !== o; t++) {
                        var u = n[t];
                        u.resetConstraintVelocity()
                    }
                    if (j) {
                        for (c = 0; c !== j; c++) {
                            for (A = 0,
                            B = 0; B !== l; B++) {
                                x = k[B];
                                var C = h.iterateEquation(B, x, x.epsilon, w, v, s, r, a, c);
                                A += Math.abs(C)
                            }
                            if (this.usedIterations++,
                            A * A <= m)
                                break
                        }
                        for (h.updateMultipliers(k, s, 1 / a),
                        B = 0; B !== l; B++) {
                            var D = k[B];
                            if (D instanceof g) {
                                for (var E = 0, F = 0; F !== D.contactEquations.length; F++)
                                    E += D.contactEquations[F].multiplier;
                                E *= D.frictionCoefficient / D.contactEquations.length,
                                D.maxForce = E,
                                D.minForce = -E
                            }
                        }
                    }
                    for (c = 0; c !== e; c++) {
                        for (A = 0,
                        B = 0; B !== l; B++) {
                            x = k[B];
                            var C = h.iterateEquation(B, x, x.epsilon, w, v, s, r, a, c);
                            A += Math.abs(C)
                        }
                        if (this.usedIterations++,
                        A * A <= m)
                            break
                    }
                    for (t = 0; t !== o; t++)
                        n[t].addConstraintVelocity();
                    h.updateMultipliers(k, s, 1 / a)
                }
            }
            ,
            h.updateMultipliers = function(a, b, c) {
                for (var d = a.length; d--; )
                    a[d].multiplier = b[d] * c
            }
            ,
            h.iterateEquation = function(a, b, c, d, e, f, g, h, i) {
                var j = d[a]
                  , k = e[a]
                  , l = f[a]
                  , m = b.computeGWlambda()
                  , n = b.maxForce
                  , o = b.minForce;
                g && (j = 0);
                var p = k * (j - m - c * l)
                  , q = l + p;
                return q < o * h ? p = o * h - l : q > n * h && (p = n * h - l),
                f[a] += p,
                b.addToWlambda(p),
                p
            }
        }
        , {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47: [function(a, b, c) {
            function f(a, b) {
                a = a || {},
                e.call(this),
                this.type = b,
                this.equations = [],
                this.equationSortFunction = a.equationSortFunction || !1
            }
            var e = (a("../utils/Utils"),
            a("../events/EventEmitter"));
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.solve = function(a, b) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            }
            ;
            var g = {
                bodies: []
            };
            f.prototype.solveIsland = function(a, b) {
                this.removeAllEquations(),
                b.equations.length && (this.addEquations(b.equations),
                g.bodies.length = 0,
                b.getBodies(g.bodies),
                g.bodies.length && this.solve(a, g))
            }
            ,
            f.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            }
            ,
            f.prototype.addEquation = function(a) {
                a.enabled && this.equations.push(a)
            }
            ,
            f.prototype.addEquations = function(a) {
                for (var b = 0, c = a.length; b !== c; b++) {
                    var d = a[b];
                    d.enabled && this.equations.push(d)
                }
            }
            ,
            f.prototype.removeEquation = function(a) {
                var b = this.equations.indexOf(a);
                -1 !== b && this.equations.splice(b, 1)
            }
            ,
            f.prototype.removeAllEquations = function() {
                this.equations.length = 0
            }
            ,
            f.GS = 1,
            f.ISLAND = 2
        }
        , {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48: [function(a, b, c) {
            function f() {
                e.apply(this, arguments)
            }
            var d = a("../equations/ContactEquation")
              , e = a("./Pool");
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.create = function() {
                return new d
            }
            ,
            f.prototype.destroy = function(a) {
                return a.bodyA = a.bodyB = null,
                this
            }
        }
        , {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49: [function(a, b, c) {
            function f() {
                e.apply(this, arguments)
            }
            var d = a("../equations/FrictionEquation")
              , e = a("./Pool");
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.create = function() {
                return new d
            }
            ,
            f.prototype.destroy = function(a) {
                return a.bodyA = a.bodyB = null,
                this
            }
        }
        , {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50: [function(a, b, c) {
            function f() {
                e.apply(this, arguments)
            }
            var d = a("../world/IslandNode")
              , e = a("./Pool");
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.create = function() {
                return new d
            }
            ,
            f.prototype.destroy = function(a) {
                return a.reset(),
                this
            }
        }
        , {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51: [function(a, b, c) {
            function f() {
                e.apply(this, arguments)
            }
            var d = a("../world/Island")
              , e = a("./Pool");
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.create = function() {
                return new d
            }
            ,
            f.prototype.destroy = function(a) {
                return a.reset(),
                this
            }
        }
        , {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52: [function(a, b, c) {
            function h() {
                this.overlappingShapesLastState = new d,
                this.overlappingShapesCurrentState = new d,
                this.recordPool = new f({
                    size: 16
                }),
                this.tmpDict = new d,
                this.tmpArray1 = []
            }
            var d = a("./TupleDictionary")
              , f = (a("./OverlapKeeperRecord"),
            a("./OverlapKeeperRecordPool"));
            a("./Utils");
            b.exports = h,
            h.prototype.tick = function() {
                for (var a = this.overlappingShapesLastState, b = this.overlappingShapesCurrentState, c = a.keys.length; c--; ) {
                    var d = a.keys[c]
                      , e = a.getByKey(d);
                    b.getByKey(d);
                    e && this.recordPool.release(e)
                }
                a.reset(),
                a.copy(b),
                b.reset()
            }
            ,
            h.prototype.setOverlapping = function(a, b, c, d) {
                var f = (this.overlappingShapesLastState,
                this.overlappingShapesCurrentState);
                if (!f.get(b.id, d.id)) {
                    var g = this.recordPool.get();
                    g.set(a, b, c, d),
                    f.set(b.id, d.id, g)
                }
            }
            ,
            h.prototype.getNewOverlaps = function(a) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a)
            }
            ,
            h.prototype.getEndOverlaps = function(a) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a)
            }
            ,
            h.prototype.bodiesAreOverlapping = function(a, b) {
                for (var c = this.overlappingShapesCurrentState, d = c.keys.length; d--; ) {
                    var e = c.keys[d]
                      , f = c.data[e];
                    if (f.bodyA === a && f.bodyB === b || f.bodyA === b && f.bodyB === a)
                        return !0
                }
                return !1
            }
            ,
            h.prototype.getDiff = function(a, b, c) {
                var c = c || []
                  , d = a
                  , e = b;
                c.length = 0;
                for (var f = e.keys.length; f--; ) {
                    var g = e.keys[f]
                      , h = e.data[g];
                    if (!h)
                        throw new Error("Key " + g + " had no data!");
                    d.data[g] || c.push(h)
                }
                return c
            }
            ,
            h.prototype.isNewOverlap = function(a, b) {
                var c = 0 | a.id
                  , d = 0 | b.id
                  , e = this.overlappingShapesLastState
                  , f = this.overlappingShapesCurrentState;
                return !e.get(c, d) && !!f.get(c, d)
            }
            ,
            h.prototype.getNewBodyOverlaps = function(a) {
                this.tmpArray1.length = 0;
                var b = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(b, a)
            }
            ,
            h.prototype.getEndBodyOverlaps = function(a) {
                this.tmpArray1.length = 0;
                var b = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(b, a)
            }
            ,
            h.prototype.getBodyDiff = function(a, b) {
                b = b || [];
                for (var c = this.tmpDict, d = a.length; d--; ) {
                    var e = a[d];
                    c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e)
                }
                for (d = c.keys.length; d--; ) {
                    var e = c.getByKey(c.keys[d]);
                    e && b.push(e.bodyA, e.bodyB)
                }
                return c.reset(),
                b
            }
        }
        , {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53: [function(a, b, c) {
            function d(a, b, c, d) {
                this.shapeA = b,
                this.shapeB = d,
                this.bodyA = a,
                this.bodyB = c
            }
            b.exports = d,
            d.prototype.set = function(a, b, c, e) {
                d.call(this, a, b, c, e)
            }
        }
        , {}],
        54: [function(a, b, c) {
            function f() {
                e.apply(this, arguments)
            }
            var d = a("./OverlapKeeperRecord")
              , e = a("./Pool");
            b.exports = f,
            f.prototype = new e,
            f.prototype.constructor = f,
            f.prototype.create = function() {
                return new d
            }
            ,
            f.prototype.destroy = function(a) {
                return a.bodyA = a.bodyB = a.shapeA = a.shapeB = null,
                this
            }
        }
        , {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55: [function(a, b, c) {
            function d(a) {
                a = a || {},
                this.objects = [],
                void 0 !== a.size && this.resize(a.size)
            }
            b.exports = d,
            d.prototype.resize = function(a) {
                for (var b = this.objects; b.length > a; )
                    b.pop();
                for (; b.length < a; )
                    b.push(this.create());
                return this
            }
            ,
            d.prototype.get = function() {
                var a = this.objects;
                return a.length ? a.pop() : this.create()
            }
            ,
            d.prototype.release = function(a) {
                return this.destroy(a),
                this.objects.push(a),
                this
            }
        }
        , {}],
        56: [function(a, b, c) {
            function e() {
                this.data = {},
                this.keys = []
            }
            var d = a("./Utils");
            b.exports = e,
            e.prototype.getKey = function(a, b) {
                return a |= 0,
                b |= 0,
                (0 | a) == (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? a << 16 | 65535 & b : b << 16 | 65535 & a)
            }
            ,
            e.prototype.getByKey = function(a) {
                return a |= 0,
                this.data[a]
            }
            ,
            e.prototype.get = function(a, b) {
                return this.data[this.getKey(a, b)]
            }
            ,
            e.prototype.set = function(a, b, c) {
                if (!c)
                    throw new Error("No data!");
                var d = this.getKey(a, b);
                return this.data[d] || this.keys.push(d),
                this.data[d] = c,
                d
            }
            ,
            e.prototype.reset = function() {
                for (var a = this.data, b = this.keys, c = b.length; c--; )
                    delete a[b[c]];
                b.length = 0
            }
            ,
            e.prototype.copy = function(a) {
                this.reset(),
                d.appendArray(this.keys, a.keys);
                for (var b = a.keys.length; b--; ) {
                    var c = a.keys[b];
                    this.data[c] = a.data[c]
                }
            }
        }
        , {
            "./Utils": 57
        }],
        57: [function(a, b, c) {
            function d() {}
            b.exports = d,
            d.appendArray = function(a, b) {
                if (b.length < 15e4)
                    a.push.apply(a, b);
                else
                    for (var c = 0, d = b.length; c !== d; ++c)
                        a.push(b[c])
            }
            ,
            d.splice = function(a, b, c) {
                c = c || 1;
                for (var d = b, e = a.length - c; d < e; d++)
                    a[d] = a[d + c];
                a.length = e
            }
            ,
            "undefined" != typeof P2_ARRAY_TYPE ? d.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? d.ARRAY_TYPE = Float32Array : d.ARRAY_TYPE = Array,
            d.extend = function(a, b) {
                for (var c in b)
                    a[c] = b[c]
            }
            ,
            d.defaults = function(a, b) {
                a = a || {};
                for (var c in b)
                    c in a || (a[c] = b[c]);
                return a
            }
        }
        , {}],
        58: [function(a, b, c) {
            function e() {
                this.equations = [],
                this.bodies = []
            }
            var d = a("../objects/Body");
            b.exports = e,
            e.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            }
            ;
            var f = [];
            e.prototype.getBodies = function(a) {
                var b = a || []
                  , c = this.equations;
                f.length = 0;
                for (var d = 0; d !== c.length; d++) {
                    var e = c[d];
                    -1 === f.indexOf(e.bodyA.id) && (b.push(e.bodyA),
                    f.push(e.bodyA.id)),
                    -1 === f.indexOf(e.bodyB.id) && (b.push(e.bodyB),
                    f.push(e.bodyB.id))
                }
                return b
            }
            ,
            e.prototype.wantsToSleep = function() {
                for (var a = 0; a < this.bodies.length; a++) {
                    var b = this.bodies[a];
                    if (b.type === d.DYNAMIC && !b.wantsToSleep)
                        return !1
                }
                return !0
            }
            ,
            e.prototype.sleep = function() {
                for (var a = 0; a < this.bodies.length; a++) {
                    this.bodies[a].sleep()
                }
                return !0
            }
        }
        , {
            "../objects/Body": 31
        }],
        59: [function(a, b, c) {
            function j(a) {
                this.nodePool = new g({
                    size: 16
                }),
                this.islandPool = new h({
                    size: 8
                }),
                this.equations = [],
                this.islands = [],
                this.nodes = [],
                this.queue = []
            }
            var g = (a("../math/vec2"),
            a("./Island"),
            a("./IslandNode"),
            a("./../utils/IslandNodePool"))
              , h = a("./../utils/IslandPool")
              , i = a("../objects/Body");
            b.exports = j,
            j.getUnvisitedNode = function(a) {
                for (var b = a.length, c = 0; c !== b; c++) {
                    var d = a[c];
                    if (!d.visited && d.body.type === i.DYNAMIC)
                        return d
                }
                return !1
            }
            ,
            j.prototype.visit = function(a, b, c) {
                b.push(a.body);
                for (var d = a.equations.length, e = 0; e !== d; e++) {
                    var f = a.equations[e];
                    -1 === c.indexOf(f) && c.push(f)
                }
            }
            ,
            j.prototype.bfs = function(a, b, c) {
                var d = this.queue;
                for (d.length = 0,
                d.push(a),
                a.visited = !0,
                this.visit(a, b, c); d.length; )
                    for (var f, e = d.pop(); f = j.getUnvisitedNode(e.neighbors); )
                        f.visited = !0,
                        this.visit(f, b, c),
                        f.body.type === i.DYNAMIC && d.push(f)
            }
            ,
            j.prototype.split = function(a) {
                for (var b = a.bodies, c = this.nodes, d = this.equations; c.length; )
                    this.nodePool.release(c.pop());
                for (var e = 0; e !== b.length; e++) {
                    var f = this.nodePool.get();
                    f.body = b[e],
                    c.push(f)
                }
                for (var g = 0; g !== d.length; g++) {
                    var h = d[g]
                      , e = b.indexOf(h.bodyA)
                      , i = b.indexOf(h.bodyB)
                      , k = c[e]
                      , l = c[i];
                    k.neighbors.push(l),
                    l.neighbors.push(k),
                    k.equations.push(h),
                    l.equations.push(h)
                }
                for (var m = this.islands, e = 0; e < m.length; e++)
                    this.islandPool.release(m[e]);
                m.length = 0;
                for (var n; n = j.getUnvisitedNode(c); ) {
                    var o = this.islandPool.get();
                    this.bfs(n, o.bodies, o.equations),
                    m.push(o)
                }
                return m
            }
        }
        , {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60: [function(a, b, c) {
            function d(a) {
                this.body = a,
                this.neighbors = [],
                this.equations = [],
                this.visited = !1
            }
            b.exports = d,
            d.prototype.reset = function() {
                this.equations.length = 0,
                this.neighbors.length = 0,
                this.visited = !1,
                this.body = null
            }
        }
        , {}],
        61: [function(a, b, c) {
            function I(a) {
                n.apply(this),
                a = a || {},
                this.springs = [],
                this.bodies = [],
                this.disabledBodyCollisionPairs = [],
                this.solver = a.solver || new d,
                this.narrowphase = new D(this),
                this.islandManager = new G,
                this.gravity = g.fromValues(0, -9.78),
                a.gravity && g.copy(this.gravity, a.gravity),
                this.frictionGravity = g.length(this.gravity) || 10,
                this.useWorldGravityAsFrictionGravity = !0,
                this.useFrictionGravityOnZeroGravity = !0,
                this.broadphase = a.broadphase || new C,
                this.broadphase.setWorld(this),
                this.constraints = [],
                this.defaultMaterial = new r,
                this.defaultContactMaterial = new s(this.defaultMaterial,this.defaultMaterial),
                this.lastTimeStep = 1 / 60,
                this.applySpringForces = !0,
                this.applyDamping = !0,
                this.applyGravity = !0,
                this.solveConstraints = !0,
                this.contactMaterials = [],
                this.time = 0,
                this.accumulator = 0,
                this.stepping = !1,
                this.bodiesToBeRemoved = [],
                this.islandSplit = void 0 === a.islandSplit || !!a.islandSplit,
                this.emitImpactEvent = !0,
                this._constraintIdCounter = 0,
                this._bodyIdCounter = 0,
                this.postStepEvent = {
                    type: "postStep"
                },
                this.addBodyEvent = {
                    type: "addBody",
                    body: null
                },
                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                },
                this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                },
                this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                },
                this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                },
                this.sleepMode = I.NO_SLEEPING,
                this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                },
                this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                },
                this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                },
                this.overlappingShapesLastState = {
                    keys: []
                },
                this.overlappingShapesCurrentState = {
                    keys: []
                },
                this.overlapKeeper = new F
            }
            var d = a("../solver/GSSolver")
              , g = (a("../solver/Solver"),
            a("../collision/Ray"),
            a("../math/vec2"))
              , h = a("../shapes/Circle")
              , i = a("../shapes/Convex")
              , k = (a("../shapes/Line"),
            a("../shapes/Plane"))
              , l = a("../shapes/Capsule")
              , m = a("../shapes/Particle")
              , n = a("../events/EventEmitter")
              , o = a("../objects/Body")
              , r = (a("../shapes/Shape"),
            a("../objects/LinearSpring"),
            a("../material/Material"))
              , s = a("../material/ContactMaterial")
              , B = (a("../constraints/DistanceConstraint"),
            a("../constraints/Constraint"),
            a("../constraints/LockConstraint"),
            a("../constraints/RevoluteConstraint"),
            a("../constraints/PrismaticConstraint"),
            a("../constraints/GearConstraint"),
            a("../../package.json"),
            a("../collision/Broadphase"),
            a("../collision/AABB"))
              , C = a("../collision/SAPBroadphase")
              , D = a("../collision/Narrowphase")
              , E = a("../utils/Utils")
              , F = a("../utils/OverlapKeeper")
              , G = a("./IslandManager");
            a("../objects/RotationalSpring");
            b.exports = I,
            I.prototype = new Object(n.prototype),
            I.prototype.constructor = I,
            I.NO_SLEEPING = 1,
            I.BODY_SLEEPING = 2,
            I.ISLAND_SLEEPING = 4,
            I.prototype.addConstraint = function(a) {
                this.constraints.push(a)
            }
            ,
            I.prototype.addContactMaterial = function(a) {
                this.contactMaterials.push(a)
            }
            ,
            I.prototype.removeContactMaterial = function(a) {
                var b = this.contactMaterials.indexOf(a);
                -1 !== b && E.splice(this.contactMaterials, b, 1)
            }
            ,
            I.prototype.getContactMaterial = function(a, b) {
                for (var c = this.contactMaterials, d = 0, e = c.length; d !== e; d++) {
                    var f = c[d];
                    if (f.materialA.id === a.id && f.materialB.id === b.id || f.materialA.id === b.id && f.materialB.id === a.id)
                        return f
                }
                return !1
            }
            ,
            I.prototype.removeConstraint = function(a) {
                var b = this.constraints.indexOf(a);
                -1 !== b && E.splice(this.constraints, b, 1)
            }
            ;
            var P = (g.create(),
            g.create(),
            g.create(),
            g.create(),
            g.create(),
            g.create(),
            g.create())
              , Q = g.fromValues(0, 0)
              , R = g.fromValues(0, 0);
            g.fromValues(0, 0),
            g.fromValues(0, 0);
            I.prototype.step = function(a, b, c) {
                if (c = c || 10,
                0 === (b = b || 0))
                    this.internalStep(a),
                    this.time += a;
                else {
                    this.accumulator += b;
                    for (var d = 0; this.accumulator >= a && d < c; )
                        this.internalStep(a),
                        this.time += a,
                        this.accumulator -= a,
                        d++;
                    for (var e = this.accumulator % a / a, f = 0; f !== this.bodies.length; f++) {
                        var h = this.bodies[f];
                        g.lerp(h.interpolatedPosition, h.previousPosition, h.position, e),
                        h.interpolatedAngle = h.previousAngle + e * (h.angle - h.previousAngle)
                    }
                }
            }
            ;
            var U = [];
            I.prototype.internalStep = function(a) {
                this.stepping = !0;
                var c = this.springs.length
                  , d = this.springs
                  , e = this.bodies
                  , f = this.gravity
                  , h = this.solver
                  , i = this.bodies.length
                  , j = this.broadphase
                  , k = this.narrowphase
                  , l = this.constraints
                  , r = P
                  , t = (g.scale,
                g.add)
                  , v = (g.rotate,
                this.islandManager);
                if (this.overlapKeeper.tick(),
                this.lastTimeStep = a,
                this.useWorldGravityAsFrictionGravity) {
                    var w = g.length(this.gravity);
                    0 === w && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = w)
                }
                if (this.applyGravity)
                    for (var x = 0; x !== i; x++) {
                        var y = e[x]
                          , z = y.force;
                        y.type === o.DYNAMIC && y.sleepState !== o.SLEEPING && (g.scale(r, f, y.mass * y.gravityScale),
                        t(z, z, r))
                    }
                if (this.applySpringForces)
                    for (var x = 0; x !== c; x++) {
                        var A = d[x];
                        A.applyForce()
                    }
                if (this.applyDamping)
                    for (var x = 0; x !== i; x++) {
                        var y = e[x];
                        y.type === o.DYNAMIC && y.applyDamping(a)
                    }
                for (var B = j.getCollisionPairs(this), C = this.disabledBodyCollisionPairs, x = C.length - 2; x >= 0; x -= 2)
                    for (var D = B.length - 2; D >= 0; D -= 2)
                        (C[x] === B[D] && C[x + 1] === B[D + 1] || C[x + 1] === B[D] && C[x] === B[D + 1]) && B.splice(D, 2);
                var F = l.length;
                for (x = 0; x !== F; x++) {
                    var G = l[x];
                    if (!G.collideConnected)
                        for (var D = B.length - 2; D >= 0; D -= 2)
                            (G.bodyA === B[D] && G.bodyB === B[D + 1] || G.bodyB === B[D] && G.bodyA === B[D + 1]) && B.splice(D, 2)
                }
                this.postBroadphaseEvent.pairs = B,
                this.emit(this.postBroadphaseEvent),
                this.postBroadphaseEvent.pairs = null,
                k.reset(this);
                for (var x = 0, H = B.length; x !== H; x += 2)
                    for (var J = B[x], K = B[x + 1], L = 0, M = J.shapes.length; L !== M; L++)
                        for (var Q = J.shapes[L], R = Q.position, S = Q.angle, T = 0, V = K.shapes.length; T !== V; T++) {
                            var W = K.shapes[T]
                              , X = W.position
                              , Y = W.angle
                              , Z = this.defaultContactMaterial;
                            if (Q.material && W.material) {
                                var $ = this.getContactMaterial(Q.material, W.material);
                                $ && (Z = $)
                            }
                            this.runNarrowphase(k, J, Q, R, S, K, W, X, Y, Z, this.frictionGravity)
                        }
                for (var x = 0; x !== i; x++) {
                    var _ = e[x];
                    _._wakeUpAfterNarrowphase && (_.wakeUp(),
                    _._wakeUpAfterNarrowphase = !1)
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(U);
                    for (var aa = this.endContactEvent, T = U.length; T--; ) {
                        var ba = U[T];
                        aa.shapeA = ba.shapeA,
                        aa.shapeB = ba.shapeB,
                        aa.bodyA = ba.bodyA,
                        aa.bodyB = ba.bodyB,
                        this.emit(aa)
                    }
                    U.length = 0
                }
                var ca = this.preSolveEvent;
                ca.contactEquations = k.contactEquations,
                ca.frictionEquations = k.frictionEquations,
                this.emit(ca),
                ca.contactEquations = ca.frictionEquations = null;
                var F = l.length;
                for (x = 0; x !== F; x++)
                    l[x].update();
                if (k.contactEquations.length || k.frictionEquations.length || F)
                    if (this.islandSplit) {
                        for (v.equations.length = 0,
                        E.appendArray(v.equations, k.contactEquations),
                        E.appendArray(v.equations, k.frictionEquations),
                        x = 0; x !== F; x++)
                            E.appendArray(v.equations, l[x].equations);
                        v.split(this);
                        for (var x = 0; x !== v.islands.length; x++) {
                            var da = v.islands[x];
                            da.equations.length && h.solveIsland(a, da)
                        }
                    } else {
                        for (h.addEquations(k.contactEquations),
                        h.addEquations(k.frictionEquations),
                        x = 0; x !== F; x++)
                            h.addEquations(l[x].equations);
                        this.solveConstraints && h.solve(a, this),
                        h.removeAllEquations()
                    }
                for (var x = 0; x !== i; x++) {
                    var _ = e[x];
                    _.integrate(a)
                }
                for (var x = 0; x !== i; x++)
                    e[x].setZeroForce();
                if (this.emitImpactEvent && this.has("impact"))
                    for (var ea = this.impactEvent, x = 0; x !== k.contactEquations.length; x++) {
                        var fa = k.contactEquations[x];
                        fa.firstImpact && (ea.bodyA = fa.bodyA,
                        ea.bodyB = fa.bodyB,
                        ea.shapeA = fa.shapeA,
                        ea.shapeB = fa.shapeB,
                        ea.contactEquation = fa,
                        this.emit(ea))
                    }
                if (this.sleepMode === I.BODY_SLEEPING)
                    for (x = 0; x !== i; x++)
                        e[x].sleepTick(this.time, !1, a);
                else if (this.sleepMode === I.ISLAND_SLEEPING && this.islandSplit) {
                    for (x = 0; x !== i; x++)
                        e[x].sleepTick(this.time, !0, a);
                    for (var x = 0; x < this.islandManager.islands.length; x++) {
                        var da = this.islandManager.islands[x];
                        da.wantsToSleep() && da.sleep()
                    }
                }
                this.stepping = !1;
                for (var ga = this.bodiesToBeRemoved, x = 0; x !== ga.length; x++)
                    this.removeBody(ga[x]);
                ga.length = 0,
                this.emit(this.postStepEvent)
            }
            ,
            I.prototype.runNarrowphase = function(a, b, c, d, e, f, h, i, j, k, l) {
                if (0 != (c.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & c.collisionMask)) {
                    g.rotate(Q, d, b.angle),
                    g.rotate(R, i, f.angle),
                    g.add(Q, Q, b.position),
                    g.add(R, R, f.position);
                    var m = e + b.angle
                      , n = j + f.angle;
                    a.enableFriction = k.friction > 0,
                    a.frictionCoefficient = k.friction;
                    var p;
                    p = b.type === o.STATIC || b.type === o.KINEMATIC ? f.mass : f.type === o.STATIC || f.type === o.KINEMATIC ? b.mass : b.mass * f.mass / (b.mass + f.mass),
                    a.slipForce = k.friction * l * p,
                    a.restitution = k.restitution,
                    a.surfaceVelocity = k.surfaceVelocity,
                    a.frictionStiffness = k.frictionStiffness,
                    a.frictionRelaxation = k.frictionRelaxation,
                    a.stiffness = k.stiffness,
                    a.relaxation = k.relaxation,
                    a.contactSkinSize = k.contactSkinSize,
                    a.enabledEquations = b.collisionResponse && f.collisionResponse && c.collisionResponse && h.collisionResponse;
                    var q = a[c.type | h.type]
                      , r = 0;
                    if (q) {
                        var s = c.sensor || h.sensor
                          , t = a.frictionEquations.length;
                        r = c.type < h.type ? q.call(a, b, c, Q, m, f, h, R, n, s) : q.call(a, f, h, R, n, b, c, Q, m, s);
                        var u = a.frictionEquations.length - t;
                        if (r) {
                            if (b.allowSleep && b.type === o.DYNAMIC && b.sleepState === o.SLEEPING && f.sleepState === o.AWAKE && f.type !== o.STATIC) {
                                g.squaredLength(f.velocity) + Math.pow(f.angularVelocity, 2) >= 2 * Math.pow(f.sleepSpeedLimit, 2) && (b._wakeUpAfterNarrowphase = !0)
                            }
                            if (f.allowSleep && f.type === o.DYNAMIC && f.sleepState === o.SLEEPING && b.sleepState === o.AWAKE && b.type !== o.STATIC) {
                                g.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2) >= 2 * Math.pow(b.sleepSpeedLimit, 2) && (f._wakeUpAfterNarrowphase = !0)
                            }
                            if (this.overlapKeeper.setOverlapping(b, c, f, h),
                            this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h)) {
                                var z = this.beginContactEvent;
                                if (z.shapeA = c,
                                z.shapeB = h,
                                z.bodyA = b,
                                z.bodyB = f,
                                z.contactEquations.length = 0,
                                "number" == typeof r)
                                    for (var A = a.contactEquations.length - r; A < a.contactEquations.length; A++)
                                        z.contactEquations.push(a.contactEquations[A]);
                                this.emit(z)
                            }
                            if ("number" == typeof r && u > 1)
                                for (var A = a.frictionEquations.length - u; A < a.frictionEquations.length; A++) {
                                    var B = a.frictionEquations[A];
                                    B.setSlipForce(B.getSlipForce() / u)
                                }
                        }
                    }
                }
            }
            ,
            I.prototype.addSpring = function(a) {
                this.springs.push(a);
                var b = this.addSpringEvent;
                b.spring = a,
                this.emit(b),
                b.spring = null
            }
            ,
            I.prototype.removeSpring = function(a) {
                var b = this.springs.indexOf(a);
                -1 !== b && E.splice(this.springs, b, 1)
            }
            ,
            I.prototype.addBody = function(a) {
                if (-1 === this.bodies.indexOf(a)) {
                    this.bodies.push(a),
                    a.world = this;
                    var b = this.addBodyEvent;
                    b.body = a,
                    this.emit(b),
                    b.body = null
                }
            }
            ,
            I.prototype.removeBody = function(a) {
                if (this.stepping)
                    this.bodiesToBeRemoved.push(a);
                else {
                    a.world = null;
                    var b = this.bodies.indexOf(a);
                    -1 !== b && (E.splice(this.bodies, b, 1),
                    this.removeBodyEvent.body = a,
                    a.resetConstraintVelocity(),
                    this.emit(this.removeBodyEvent),
                    this.removeBodyEvent.body = null)
                }
            }
            ,
            I.prototype.getBodyById = function(a) {
                for (var b = this.bodies, c = 0; c < b.length; c++) {
                    var d = b[c];
                    if (d.id === a)
                        return d
                }
                return !1
            }
            ,
            I.prototype.disableBodyCollision = function(a, b) {
                this.disabledBodyCollisionPairs.push(a, b)
            }
            ,
            I.prototype.enableBodyCollision = function(a, b) {
                for (var c = this.disabledBodyCollisionPairs, d = 0; d < c.length; d += 2)
                    if (c[d] === a && c[d + 1] === b || c[d + 1] === a && c[d] === b)
                        return void c.splice(d, 2)
            }
            ,
            I.prototype.clear = function() {
                this.time = 0,
                this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var a = this.constraints, b = a.length - 1; b >= 0; b--)
                    this.removeConstraint(a[b]);
                for (var c = this.bodies, b = c.length - 1; b >= 0; b--)
                    this.removeBody(c[b]);
                for (var d = this.springs, b = d.length - 1; b >= 0; b--)
                    this.removeSpring(d[b]);
                for (var e = this.contactMaterials, b = e.length - 1; b >= 0; b--)
                    this.removeContactMaterial(e[b]);
                I.apply(this)
            }
            ;
            var V = g.create()
              , X = (g.fromValues(0, 0),
            g.fromValues(0, 0));
            I.prototype.hitTest = function(a, b, c) {
                c = c || 0;
                var d = new o({
                    position: a
                })
                  , e = new m
                  , f = a
                  , j = 0
                  , n = V
                  , q = X;
                d.addShape(e);
                for (var r = this.narrowphase, s = [], t = 0, u = b.length; t !== u; t++)
                    for (var v = b[t], w = 0, x = v.shapes.length; w !== x; w++) {
                        var y = v.shapes[w];
                        g.rotate(n, y.position, v.angle),
                        g.add(n, n, v.position);
                        var z = y.angle + v.angle;
                        (y instanceof h && r.circleParticle(v, y, n, z, d, e, f, j, !0) || y instanceof i && r.particleConvex(d, e, f, j, v, y, n, z, !0) || y instanceof k && r.particlePlane(d, e, f, j, v, y, n, z, !0) || y instanceof l && r.particleCapsule(d, e, f, j, v, y, n, z, !0) || y instanceof m && g.squaredLength(g.sub(q, n, a)) < c * c) && s.push(v)
                    }
                return s
            }
            ,
            I.prototype.setGlobalStiffness = function(a) {
                for (var b = this.constraints, c = 0; c !== b.length; c++)
                    for (var d = b[c], e = 0; e !== d.equations.length; e++) {
                        var f = d.equations[e];
                        f.stiffness = a,
                        f.needsUpdate = !0
                    }
                for (var g = this.contactMaterials, c = 0; c !== g.length; c++) {
                    var d = g[c];
                    d.stiffness = d.frictionStiffness = a
                }
                var d = this.defaultContactMaterial;
                d.stiffness = d.frictionStiffness = a
            }
            ,
            I.prototype.setGlobalRelaxation = function(a) {
                for (var b = 0; b !== this.constraints.length; b++)
                    for (var c = this.constraints[b], d = 0; d !== c.equations.length; d++) {
                        var e = c.equations[d];
                        e.relaxation = a,
                        e.needsUpdate = !0
                    }
                for (var b = 0; b !== this.contactMaterials.length; b++) {
                    var c = this.contactMaterials[b];
                    c.relaxation = c.frictionRelaxation = a
                }
                var c = this.defaultContactMaterial;
                c.relaxation = c.frictionRelaxation = a
            }
            ;
            var Y = new B
              , Z = [];
            I.prototype.raycast = function(a, b) {
                return b.getAABB(Y),
                this.broadphase.aabbQuery(this, Y, Z),
                b.intersectBodies(a, Z),
                Z.length = 0,
                a.hasHit()
            }
        }
        , {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    }, {}, [36])(36)
}),
function() {
    var a = this
      , b = b || {};
    return b.game = null,
    b.WEBGL_RENDERER = 0,
    b.CANVAS_RENDERER = 1,
    b.VERSION = "v2.2.9",
    b._UID = 0,
    "undefined" != typeof Float32Array ? (b.Float32Array = Float32Array,
    b.Uint16Array = Uint16Array,
    b.Uint32Array = Uint32Array,
    b.ArrayBuffer = ArrayBuffer) : (b.Float32Array = Array,
    b.Uint16Array = Array),
    b.PI_2 = 2 * Math.PI,
    b.RAD_TO_DEG = 180 / Math.PI,
    b.DEG_TO_RAD = Math.PI / 180,
    b.RETINA_PREFIX = "@2x",
    b.DisplayObject = function() {
        this.position = new b.Point(0,0),
        this.scale = new b.Point(1,1),
        this.pivot = new b.Point(0,0),
        this.rotation = 0,
        this.alpha = 1,
        this.visible = !0,
        this.hitArea = null,
        this.renderable = !1,
        this.parent = null,
        this.worldAlpha = 1,
        this.worldTransform = new b.Matrix,
        this.worldPosition = new b.Point(0,0),
        this.worldScale = new b.Point(1,1),
        this.worldRotation = 0,
        this.filterArea = null,
        this._sr = 0,
        this._cr = 1,
        this._bounds = new b.Rectangle(0,0,0,0),
        this._currentBounds = null,
        this._mask = null,
        this._cacheAsBitmap = !1,
        this._cacheIsDirty = !1
    }
    ,
    b.DisplayObject.prototype.constructor = b.DisplayObject,
    b.DisplayObject.prototype = {
        destroy: function() {
            if (this.children) {
                for (var a = this.children.length; a--; )
                    this.children[a].destroy();
                this.children = []
            }
            this.hitArea = null,
            this.parent = null,
            this.worldTransform = null,
            this.filterArea = null,
            this.renderable = !1,
            this._bounds = null,
            this._currentBounds = null,
            this._mask = null,
            this._destroyCachedSprite()
        },
        updateTransform: function(a) {
            if (!a && !this.parent && !this.game)
                return this;
            var c = this.parent;
            a ? c = a : this.parent || (c = this.game.world);
            var f, g, h, i, j, k, d = c.worldTransform, e = this.worldTransform;
            return this.rotation % b.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation,
            this._sr = Math.sin(this.rotation),
            this._cr = Math.cos(this.rotation)),
            f = this._cr * this.scale.x,
            g = this._sr * this.scale.x,
            h = -this._sr * this.scale.y,
            i = this._cr * this.scale.y,
            j = this.position.x,
            k = this.position.y,
            (this.pivot.x || this.pivot.y) && (j -= this.pivot.x * f + this.pivot.y * h,
            k -= this.pivot.x * g + this.pivot.y * i),
            e.a = f * d.a + g * d.c,
            e.b = f * d.b + g * d.d,
            e.c = h * d.a + i * d.c,
            e.d = h * d.b + i * d.d,
            e.tx = j * d.a + k * d.c + d.tx,
            e.ty = j * d.b + k * d.d + d.ty) : (f = this.scale.x,
            i = this.scale.y,
            j = this.position.x - this.pivot.x * f,
            k = this.position.y - this.pivot.y * i,
            e.a = f * d.a,
            e.b = f * d.b,
            e.c = i * d.c,
            e.d = i * d.d,
            e.tx = j * d.a + k * d.c + d.tx,
            e.ty = j * d.b + k * d.d + d.ty),
            this.worldAlpha = this.alpha * c.worldAlpha,
            this.worldPosition.set(e.tx, e.ty),
            this.worldScale.set(this.scale.x * Math.sqrt(e.a * e.a + e.c * e.c), this.scale.y * Math.sqrt(e.b * e.b + e.d * e.d)),
            this.worldRotation = Math.atan2(-e.c, e.d),
            this._currentBounds = null,
            this.transformCallback && this.transformCallback.call(this.transformCallbackContext, e, d),
            this
        },
        preUpdate: function() {},
        generateTexture: function(a, c, d) {
            var e = this.getLocalBounds()
              , f = new b.RenderTexture(0 | e.width,0 | e.height,d,c,a);
            return b.DisplayObject._tempMatrix.tx = -e.x,
            b.DisplayObject._tempMatrix.ty = -e.y,
            f.render(this, b.DisplayObject._tempMatrix),
            f
        },
        updateCache: function() {
            return this._generateCachedSprite(),
            this
        },
        toGlobal: function(a) {
            return this.updateTransform(),
            this.worldTransform.apply(a)
        },
        toLocal: function(a, b) {
            return b && (a = b.toGlobal(a)),
            this.updateTransform(),
            this.worldTransform.applyInverse(a)
        },
        _renderCachedSprite: function(a) {
            this._cachedSprite.worldAlpha = this.worldAlpha,
            a.gl ? b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a) : b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a)
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var a = this.getLocalBounds();
            if (a.width = Math.max(1, Math.ceil(a.width)),
            a.height = Math.max(1, Math.ceil(a.height)),
            this.updateTransform(),
            this._cachedSprite)
                this._cachedSprite.texture.resize(a.width, a.height);
            else {
                var c = new b.RenderTexture(a.width,a.height);
                this._cachedSprite = new b.Sprite(c),
                this._cachedSprite.worldTransform = this.worldTransform
            }
            var d = this._filters;
            this._filters = null,
            this._cachedSprite.filters = d,
            b.DisplayObject._tempMatrix.tx = -a.x,
            b.DisplayObject._tempMatrix.ty = -a.y,
            this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, !0),
            this._cachedSprite.anchor.x = -a.x / a.width,
            this._cachedSprite.anchor.y = -a.y / a.height,
            this._filters = d,
            this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0),
            this._cachedSprite = null)
        }
    },
    b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform,
    Object.defineProperties(b.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x
            },
            set: function(a) {
                this.position.x = a
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(a) {
                this.position.y = a
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var a = this.parent;
                    if (!a)
                        return this.visible;
                    do {
                        if (!a.visible)
                            return !1;
                        a = a.parent
                    } while (a);
                    return !0
                }
                return !1
            }
        },
        mask: {
            get: function() {
                return this._mask
            },
            set: function(a) {
                this._mask && (this._mask.isMask = !1),
                this._mask = a,
                a && (this._mask.isMask = !0)
            }
        },
        filters: {
            get: function() {
                return this._filters
            },
            set: function(a) {
                if (Array.isArray(a)) {
                    for (var c = [], d = 0; d < a.length; d++)
                        for (var e = a[d].passes, f = 0; f < e.length; f++)
                            c.push(e[f]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: c
                    }
                }
                this._filters = a,
                this.blendMode && this.blendMode === b.blendModes.MULTIPLY && (this.blendMode = b.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(a) {
                this._cacheAsBitmap !== a && (a ? this._generateCachedSprite() : this._destroyCachedSprite(),
                this._cacheAsBitmap = a)
            }
        }
    }),
    b.DisplayObjectContainer = function() {
        b.DisplayObject.call(this),
        this.children = [],
        this.ignoreChildInput = !1
    }
    ,
    b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype),
    b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer,
    b.DisplayObjectContainer.prototype.addChild = function(a) {
        return this.addChildAt(a, this.children.length)
    }
    ,
    b.DisplayObjectContainer.prototype.addChildAt = function(a, b) {
        if (b >= 0 && b <= this.children.length)
            return a.parent && a.parent.removeChild(a),
            a.parent = this,
            this.children.splice(b, 0, a),
            a;
        throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length)
    }
    ,
    b.DisplayObjectContainer.prototype.swapChildren = function(a, b) {
        if (a !== b) {
            var c = this.getChildIndex(a)
              , d = this.getChildIndex(b);
            if (c < 0 || d < 0)
                throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[c] = b,
            this.children[d] = a
        }
    }
    ,
    b.DisplayObjectContainer.prototype.getChildIndex = function(a) {
        var b = this.children.indexOf(a);
        if (-1 === b)
            throw new Error("The supplied DisplayObject must be a child of the caller");
        return b
    }
    ,
    b.DisplayObjectContainer.prototype.setChildIndex = function(a, b) {
        if (b < 0 || b >= this.children.length)
            throw new Error("The supplied index is out of bounds");
        var c = this.getChildIndex(a);
        this.children.splice(c, 1),
        this.children.splice(b, 0, a)
    }
    ,
    b.DisplayObjectContainer.prototype.getChildAt = function(a) {
        if (a < 0 || a >= this.children.length)
            throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[a]
    }
    ,
    b.DisplayObjectContainer.prototype.removeChild = function(a) {
        var b = this.children.indexOf(a);
        if (-1 !== b)
            return this.removeChildAt(b)
    }
    ,
    b.DisplayObjectContainer.prototype.removeChildAt = function(a) {
        var b = this.getChildAt(a);
        return b && (b.parent = void 0,
        this.children.splice(a, 1)),
        b
    }
    ,
    b.DisplayObjectContainer.prototype.removeChildren = function(a, b) {
        void 0 === a && (a = 0),
        void 0 === b && (b = this.children.length);
        var c = b - a;
        if (c > 0 && c <= b) {
            for (var d = this.children.splice(begin, c), e = 0; e < d.length; e++) {
                d[e].parent = void 0
            }
            return d
        }
        if (0 === c && 0 === this.children.length)
            return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    }
    ,
    b.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(),
        !this._cacheAsBitmap))
            for (var a = 0; a < this.children.length; a++)
                this.children[a].updateTransform()
    }
    ,
    b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform,
    b.DisplayObjectContainer.prototype.getBounds = function(a) {
        var c = a && a instanceof b.DisplayObject
          , d = !0;
        c ? d = a instanceof b.DisplayObjectContainer && a.contains(this) : a = this;
        var e;
        if (c) {
            var f = a.worldTransform;
            for (a.worldTransform = b.identityMatrix,
            e = 0; e < a.children.length; e++)
                a.children[e].updateTransform()
        }
        var k, l, m, g = 1 / 0, h = 1 / 0, i = -1 / 0, j = -1 / 0, n = !1;
        for (e = 0; e < this.children.length; e++) {
            this.children[e].visible && (n = !0,
            k = this.children[e].getBounds(),
            g = g < k.x ? g : k.x,
            h = h < k.y ? h : k.y,
            l = k.width + k.x,
            m = k.height + k.y,
            i = i > l ? i : l,
            j = j > m ? j : m)
        }
        var p = this._bounds;
        if (!n) {
            p = new b.Rectangle;
            var q = p.x
              , r = p.width + p.x
              , s = p.y
              , t = p.height + p.y
              , u = this.worldTransform
              , v = u.a
              , w = u.b
              , x = u.c
              , y = u.d
              , z = u.tx
              , A = u.ty
              , B = v * r + x * t + z
              , C = y * t + w * r + A
              , D = v * q + x * t + z
              , E = y * t + w * q + A
              , F = v * q + x * s + z
              , G = y * s + w * q + A
              , H = v * r + x * s + z
              , I = y * s + w * r + A;
            i = B,
            j = C,
            g = B,
            h = C,
            g = D < g ? D : g,
            g = F < g ? F : g,
            g = H < g ? H : g,
            h = E < h ? E : h,
            h = G < h ? G : h,
            h = I < h ? I : h,
            i = D > i ? D : i,
            i = F > i ? F : i,
            i = H > i ? H : i,
            j = E > j ? E : j,
            j = G > j ? G : j,
            j = I > j ? I : j
        }
        if (p.x = g,
        p.y = h,
        p.width = i - g,
        p.height = j - h,
        c)
            for (a.worldTransform = f,
            e = 0; e < a.children.length; e++)
                a.children[e].updateTransform();
        if (!d) {
            var J = a.getBounds();
            p.x -= J.x,
            p.y -= J.y
        }
        return p
    }
    ,
    b.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this)
    }
    ,
    b.DisplayObjectContainer.prototype.contains = function(a) {
        return !!a && (a === this || this.contains(a.parent))
    }
    ,
    b.DisplayObjectContainer.prototype._renderWebGL = function(a) {
        if (this.visible && !(this.alpha <= 0)) {
            if (this._cacheAsBitmap)
                return void this._renderCachedSprite(a);
            var b;
            if (this._mask || this._filters) {
                for (this._filters && (a.spriteBatch.flush(),
                a.filterManager.pushFilter(this._filterBlock)),
                this._mask && (a.spriteBatch.stop(),
                a.maskManager.pushMask(this.mask, a),
                a.spriteBatch.start()),
                b = 0; b < this.children.length; b++)
                    this.children[b]._renderWebGL(a);
                a.spriteBatch.stop(),
                this._mask && a.maskManager.popMask(this._mask, a),
                this._filters && a.filterManager.popFilter(),
                a.spriteBatch.start()
            } else
                for (b = 0; b < this.children.length; b++)
                    this.children[b]._renderWebGL(a)
        }
    }
    ,
    b.DisplayObjectContainer.prototype._renderCanvas = function(a) {
        if (!1 !== this.visible && 0 !== this.alpha) {
            if (this._cacheAsBitmap)
                return void this._renderCachedSprite(a);
            this._mask && a.maskManager.pushMask(this._mask, a);
            for (var b = 0; b < this.children.length; b++)
                this.children[b]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a)
        }
    }
    ,
    Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x
        },
        set: function(a) {
            var b = this.getLocalBounds().width;
            this.scale.x = 0 !== b ? a / b : 1,
            this._width = a
        }
    }),
    Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y
        },
        set: function(a) {
            var b = this.getLocalBounds().height;
            this.scale.y = 0 !== b ? a / b : 1,
            this._height = a
        }
    }),
    b.Sprite = function(a) {
        b.DisplayObjectContainer.call(this),
        this.anchor = new b.Point,
        this.texture = a || b.Texture.emptyTexture,
        this._width = 0,
        this._height = 0,
        this.tint = 16777215,
        this.cachedTint = -1,
        this.tintedTexture = null,
        this.blendMode = b.blendModes.NORMAL,
        this.shader = null,
        this.exists = !0,
        this.texture.baseTexture.hasLoaded && this.onTextureUpdate(),
        this.renderable = !0
    }
    ,
    b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype),
    b.Sprite.prototype.constructor = b.Sprite,
    Object.defineProperty(b.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width,
            this._width = a
        }
    }),
    Object.defineProperty(b.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height,
            this._height = a
        }
    }),
    b.Sprite.prototype.setTexture = function(a, b) {
        void 0 !== b && this.texture.baseTexture.destroy(),
        this.texture.baseTexture.skipRender = !1,
        this.texture = a,
        this.texture.valid = !0,
        this.cachedTint = -1
    }
    ,
    b.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width),
        this._height && (this.scale.y = this._height / this.texture.frame.height)
    }
    ,
    b.Sprite.prototype.getBounds = function(a) {
        var b = this.texture.frame.width
          , c = this.texture.frame.height
          , d = b * (1 - this.anchor.x)
          , e = b * -this.anchor.x
          , f = c * (1 - this.anchor.y)
          , g = c * -this.anchor.y
          , h = a || this.worldTransform
          , i = h.a
          , j = h.b
          , k = h.c
          , l = h.d
          , m = h.tx
          , n = h.ty
          , o = -1 / 0
          , p = -1 / 0
          , q = 1 / 0
          , r = 1 / 0;
        if (0 === j && 0 === k) {
            if (i < 0) {
                i *= -1;
                var s = d;
                d = -e,
                e = -s
            }
            if (l < 0) {
                l *= -1;
                var s = f;
                f = -g,
                g = -s
            }
            q = i * e + m,
            o = i * d + m,
            r = l * g + n,
            p = l * f + n
        } else {
            var t = i * e + k * g + m
              , u = l * g + j * e + n
              , v = i * d + k * g + m
              , w = l * g + j * d + n
              , x = i * d + k * f + m
              , y = l * f + j * d + n
              , z = i * e + k * f + m
              , A = l * f + j * e + n;
            q = t < q ? t : q,
            q = v < q ? v : q,
            q = x < q ? x : q,
            q = z < q ? z : q,
            r = u < r ? u : r,
            r = w < r ? w : r,
            r = y < r ? y : r,
            r = A < r ? A : r,
            o = t > o ? t : o,
            o = v > o ? v : o,
            o = x > o ? x : o,
            o = z > o ? z : o,
            p = u > p ? u : p,
            p = w > p ? w : p,
            p = y > p ? y : p,
            p = A > p ? A : p
        }
        var B = this._bounds;
        return B.x = q,
        B.width = o - q,
        B.y = r,
        B.height = p - r,
        this._currentBounds = B,
        B
    }
    ,
    b.Sprite.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = b.identityMatrix;
        for (var c = 0; c < this.children.length; c++)
            this.children[c].updateTransform();
        var d = this.getBounds();
        for (this.worldTransform = a,
        c = 0; c < this.children.length; c++)
            this.children[c].updateTransform();
        return d
    }
    ,
    b.Sprite.prototype._renderWebGL = function(a, b) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var c = this.worldTransform;
            if (b && (c = b),
            this._mask || this._filters) {
                var d = a.spriteBatch;
                this._filters && (d.flush(),
                a.filterManager.pushFilter(this._filterBlock)),
                this._mask && (d.stop(),
                a.maskManager.pushMask(this.mask, a),
                d.start()),
                d.render(this);
                for (var e = 0; e < this.children.length; e++)
                    this.children[e]._renderWebGL(a);
                d.stop(),
                this._mask && a.maskManager.popMask(this._mask, a),
                this._filters && a.filterManager.popFilter(),
                d.start()
            } else {
                a.spriteBatch.render(this);
                for (var e = 0; e < this.children.length; e++)
                    this.children[e]._renderWebGL(a, c)
            }
        }
    }
    ,
    b.Sprite.prototype._renderCanvas = function(a, c) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var d = this.worldTransform;
            if (c && (d = c),
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode,
            a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]),
            this._mask && a.maskManager.pushMask(this._mask, a),
            this.texture.valid) {
                var e = this.texture.baseTexture.resolution / a.resolution;
                a.context.globalAlpha = this.worldAlpha,
                a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode && (a.scaleMode = this.texture.baseTexture.scaleMode,
                a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR);
                var f = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width
                  , g = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height
                  , h = d.tx * a.resolution + a.shakeX
                  , i = d.ty * a.resolution + a.shakeY;
                a.roundPixels ? (a.context.setTransform(d.a, d.b, d.c, d.d, 0 | h, 0 | i),
                f |= 0,
                g |= 0) : a.context.setTransform(d.a, d.b, d.c, d.d, h, i);
                var j = this.texture.crop.width
                  , k = this.texture.crop.height;
                if (f /= e,
                g /= e,
                16777215 !== this.tint)
                    (this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint),
                    this.cachedTint = this.tint,
                    this.texture.requiresReTint = !1),
                    a.context.drawImage(this.tintedTexture, 0, 0, j, k, f, g, j / e, k / e);
                else {
                    var l = this.texture.crop.x
                      , m = this.texture.crop.y;
                    a.context.drawImage(this.texture.baseTexture.source, l, m, j, k, f, g, j / e, k / e)
                }
            }
            for (var n = 0; n < this.children.length; n++)
                this.children[n]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a)
        }
    }
    ,
    b.SpriteBatch = function(a) {
        b.DisplayObjectContainer.call(this),
        this.textureThing = a,
        this.ready = !1
    }
    ,
    b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype),
    b.SpriteBatch.prototype.constructor = b.SpriteBatch,
    b.SpriteBatch.prototype.initWebGL = function(a) {
        this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a),
        this.ready = !0
    }
    ,
    b.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform()
    }
    ,
    b.SpriteBatch.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(a.gl),
        this.fastSpriteBatch.gl !== a.gl && this.fastSpriteBatch.setContext(a.gl),
        a.spriteBatch.stop(),
        a.shaderManager.setShader(a.shaderManager.fastShader),
        this.fastSpriteBatch.begin(this, a),
        this.fastSpriteBatch.render(this),
        a.spriteBatch.start())
    }
    ,
    b.SpriteBatch.prototype._renderCanvas = function(a) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var b = a.context;
            b.globalAlpha = this.worldAlpha,
            this.displayObjectUpdateTransform();
            for (var c = this.worldTransform, d = !0, e = 0; e < this.children.length; e++) {
                var f = this.children[e];
                if (f.visible) {
                    var g = f.texture
                      , h = g.frame;
                    if (b.globalAlpha = this.worldAlpha * f.alpha,
                    f.rotation % (2 * Math.PI) == 0)
                        d && (b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty),
                        d = !1),
                        b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * (-h.width * f.scale.x) + f.position.x + .5 + a.shakeX | 0, f.anchor.y * (-h.height * f.scale.y) + f.position.y + .5 + a.shakeY | 0, h.width * f.scale.x, h.height * f.scale.y);
                    else {
                        d || (d = !0),
                        f.displayObjectUpdateTransform();
                        var i = f.worldTransform
                          , j = i.tx * a.resolution + a.shakeX
                          , k = i.ty * a.resolution + a.shakeY;
                        a.roundPixels ? b.setTransform(i.a, i.b, i.c, i.d, 0 | j, 0 | k) : b.setTransform(i.a, i.b, i.c, i.d, j, k),
                        b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + .5 | 0, f.anchor.y * -h.height + .5 | 0, h.width, h.height)
                    }
                }
            }
        }
    }
    ,
    b.hex2rgb = function(a) {
        return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255]
    }
    ,
    b.rgb2hex = function(a) {
        return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
    }
    ,
    b.canUseNewCanvasBlendModes = function() {
        if (void 0 === document)
            return !1;
        var a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/"
          , c = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg=="
          , d = new Image;
        d.src = a + "AP804Oa6" + c;
        var e = new Image;
        e.src = a + "/wCKxvRF" + c;
        var f = b.CanvasPool.create(this, 6, 1)
          , g = f.getContext("2d");
        if (g.globalCompositeOperation = "multiply",
        g.drawImage(d, 0, 0),
        g.drawImage(e, 2, 0),
        !g.getImageData(2, 0, 1, 1))
            return !1;
        var h = g.getImageData(2, 0, 1, 1).data;
        return b.CanvasPool.remove(this),
        255 === h[0] && 0 === h[1] && 0 === h[2]
    }
    ,
    b.getNextPowerOfTwo = function(a) {
        if (a > 0 && 0 == (a & a - 1))
            return a;
        for (var b = 1; b < a; )
            b <<= 1;
        return b
    }
    ,
    b.isPowerOfTwo = function(a, b) {
        return a > 0 && 0 == (a & a - 1) && b > 0 && 0 == (b & b - 1)
    }
    ,
    b.CanvasPool = {
        create: function(a, c, d) {
            var f, e = b.CanvasPool.getFirst();
            if (-1 === e) {
                var g = {
                    parent: a,
                    canvas: document.createElement("canvas")
                };
                b.CanvasPool.pool.push(g),
                f = g.canvas
            } else
                b.CanvasPool.pool[e].parent = a,
                f = b.CanvasPool.pool[e].canvas;
            return void 0 !== c && (f.width = c,
            f.height = d),
            f
        },
        getFirst: function() {
            for (var a = b.CanvasPool.pool, c = 0; c < a.length; c++)
                if (!a[c].parent)
                    return c;
            return -1
        },
        remove: function(a) {
            for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++)
                c[d].parent === a && (c[d].parent = null,
                c[d].canvas.width = 1,
                c[d].canvas.height = 1)
        },
        removeByCanvas: function(a) {
            for (var c = b.CanvasPool.pool, d = 0; d < c.length; d++)
                c[d].canvas === a && (c[d].parent = null,
                c[d].canvas.width = 1,
                c[d].canvas.height = 1)
        },
        getTotal: function() {
            for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++)
                a[d].parent && c++;
            return c
        },
        getFree: function() {
            for (var a = b.CanvasPool.pool, c = 0, d = 0; d < a.length; d++)
                a[d].parent || c++;
            return c
        }
    },
    b.CanvasPool.pool = [],
    b.initDefaultShaders = function() {}
    ,
    b.CompileVertexShader = function(a, c) {
        return b._CompileShader(a, c, a.VERTEX_SHADER)
    }
    ,
    b.CompileFragmentShader = function(a, c) {
        return b._CompileShader(a, c, a.FRAGMENT_SHADER)
    }
    ,
    b._CompileShader = function(a, b, c) {
        var d = b;
        Array.isArray(b) && (d = b.join("\n"));
        var e = a.createShader(c);
        return a.shaderSource(e, d),
        a.compileShader(e),
        a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)),
        null)
    }
    ,
    b.compileProgram = function(a, c, d) {
        var e = b.CompileFragmentShader(a, d)
          , f = b.CompileVertexShader(a, c)
          , g = a.createProgram();
        return a.attachShader(g, f),
        a.attachShader(g, e),
        a.linkProgram(g),
        a.getProgramParameter(g, a.LINK_STATUS) || (window.console.log(a.getProgramInfoLog(g)),
        window.console.log("Could not initialise shaders")),
        g
    }
    ,
    b.PixiShader = function(a) {
        this._UID = b._UID++,
        this.gl = a,
        this.program = null,
        this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"],
        this.textureCount = 0,
        this.firstRun = !0,
        this.dirty = !0,
        this.attributes = [],
        this.init()
    }
    ,
    b.PixiShader.prototype.constructor = b.PixiShader,
    b.PixiShader.prototype.init = function() {
        var a = this.gl
          , c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
        a.useProgram(c),
        this.uSampler = a.getUniformLocation(c, "uSampler"),
        this.projectionVector = a.getUniformLocation(c, "projectionVector"),
        this.offsetVector = a.getUniformLocation(c, "offsetVector"),
        this.dimensions = a.getUniformLocation(c, "dimensions"),
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"),
        this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"),
        this.colorAttribute = a.getAttribLocation(c, "aColor"),
        -1 === this.colorAttribute && (this.colorAttribute = 2),
        this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
        for (var d in this.uniforms)
            this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
        this.initUniforms(),
        this.program = c
    }
    ,
    b.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var b, a = this.gl;
        for (var c in this.uniforms) {
            b = this.uniforms[c];
            var d = b.type;
            "sampler2D" === d ? (b._init = !1,
            null !== b.value && this.initSampler2D(b)) : "mat2" === d || "mat3" === d || "mat4" === d ? (b.glMatrix = !0,
            b.glValueLength = 1,
            "mat2" === d ? b.glFunc = a.uniformMatrix2fv : "mat3" === d ? b.glFunc = a.uniformMatrix3fv : "mat4" === d && (b.glFunc = a.uniformMatrix4fv)) : (b.glFunc = a["uniform" + d],
            b.glValueLength = "2f" === d || "2i" === d ? 2 : "3f" === d || "3i" === d ? 3 : "4f" === d || "4i" === d ? 4 : 1)
        }
    }
    ,
    b.PixiShader.prototype.initSampler2D = function(a) {
        if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
            var b = this.gl;
            if (b.activeTexture(b["TEXTURE" + this.textureCount]),
            b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]),
            a.textureData) {
                var c = a.textureData
                  , d = c.magFilter ? c.magFilter : b.LINEAR
                  , e = c.minFilter ? c.minFilter : b.LINEAR
                  , f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE
                  , g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE
                  , h = c.luminance ? b.LUMINANCE : b.RGBA;
                if (c.repeat && (f = b.REPEAT,
                g = b.REPEAT),
                b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY),
                c.width) {
                    var i = c.width ? c.width : 512
                      , j = c.height ? c.height : 2
                      , k = c.border ? c.border : 0;
                    b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null)
                } else
                    b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d),
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e),
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f),
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g)
            }
            b.uniform1i(a.uniformLocation, this.textureCount),
            a._init = !0,
            this.textureCount++
        }
    }
    ,
    b.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var a, c = this.gl;
        for (var d in this.uniforms)
            a = this.uniforms[d],
            1 === a.glValueLength ? !0 === a.glMatrix ? a.glFunc.call(c, a.uniformLocation, a.transpose, a.value) : a.glFunc.call(c, a.uniformLocation, a.value) : 2 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y) : 3 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z) : 4 === a.glValueLength ? a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w) : "sampler2D" === a.type && (a._init ? (c.activeTexture(c["TEXTURE" + this.textureCount]),
            a.value.baseTexture._dirty[c.id] ? b.instances[c.id].updateTexture(a.value.baseTexture) : c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]),
            c.uniform1i(a.uniformLocation, this.textureCount),
            this.textureCount++) : this.initSampler2D(a))
    }
    ,
    b.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attributes = null
    }
    ,
    b.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"],
    b.PixiFastShader = function(a) {
        this._UID = b._UID++,
        this.gl = a,
        this.program = null,
        this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"],
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"],
        this.textureCount = 0,
        this.init()
    }
    ,
    b.PixiFastShader.prototype.constructor = b.PixiFastShader,
    b.PixiFastShader.prototype.init = function() {
        var a = this.gl
          , c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
        this.uSampler = a.getUniformLocation(c, "uSampler"),
        this.projectionVector = a.getUniformLocation(c, "projectionVector"),
        this.offsetVector = a.getUniformLocation(c, "offsetVector"),
        this.dimensions = a.getUniformLocation(c, "dimensions"),
        this.uMatrix = a.getUniformLocation(c, "uMatrix"),
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"),
        this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord"),
        this.aScale = a.getAttribLocation(c, "aScale"),
        this.aRotation = a.getAttribLocation(c, "aRotation"),
        this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"),
        this.colorAttribute = a.getAttribLocation(c, "aColor"),
        -1 === this.colorAttribute && (this.colorAttribute = 2),
        this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute],
        this.program = c
    }
    ,
    b.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attributes = null
    }
    ,
    b.StripShader = function(a) {
        this._UID = b._UID++,
        this.gl = a,
        this.program = null,
        this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"],
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"],
        this.init()
    }
    ,
    b.StripShader.prototype.constructor = b.StripShader,
    b.StripShader.prototype.init = function() {
        var a = this.gl
          , c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
        this.uSampler = a.getUniformLocation(c, "uSampler"),
        this.projectionVector = a.getUniformLocation(c, "projectionVector"),
        this.offsetVector = a.getUniformLocation(c, "offsetVector"),
        this.colorAttribute = a.getAttribLocation(c, "aColor"),
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"),
        this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord"),
        this.attributes = [this.aVertexPosition, this.aTextureCoord],
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"),
        this.alpha = a.getUniformLocation(c, "alpha"),
        this.program = c
    }
    ,
    b.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attribute = null
    }
    ,
    b.PrimitiveShader = function(a) {
        this._UID = b._UID++,
        this.gl = a,
        this.program = null,
        this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"],
        this.init()
    }
    ,
    b.PrimitiveShader.prototype.constructor = b.PrimitiveShader,
    b.PrimitiveShader.prototype.init = function() {
        var a = this.gl
          , c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
        this.projectionVector = a.getUniformLocation(c, "projectionVector"),
        this.offsetVector = a.getUniformLocation(c, "offsetVector"),
        this.tintColor = a.getUniformLocation(c, "tint"),
        this.flipY = a.getUniformLocation(c, "flipY"),
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"),
        this.colorAttribute = a.getAttribLocation(c, "aColor"),
        this.attributes = [this.aVertexPosition, this.colorAttribute],
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"),
        this.alpha = a.getUniformLocation(c, "alpha"),
        this.program = c
    }
    ,
    b.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attributes = null
    }
    ,
    b.ComplexPrimitiveShader = function(a) {
        this._UID = b._UID++,
        this.gl = a,
        this.program = null,
        this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"],
        this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"],
        this.init()
    }
    ,
    b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader,
    b.ComplexPrimitiveShader.prototype.init = function() {
        var a = this.gl
          , c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
        a.useProgram(c),
        this.projectionVector = a.getUniformLocation(c, "projectionVector"),
        this.offsetVector = a.getUniformLocation(c, "offsetVector"),
        this.tintColor = a.getUniformLocation(c, "tint"),
        this.color = a.getUniformLocation(c, "color"),
        this.flipY = a.getUniformLocation(c, "flipY"),
        this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition"),
        this.attributes = [this.aVertexPosition, this.colorAttribute],
        this.translationMatrix = a.getUniformLocation(c, "translationMatrix"),
        this.alpha = a.getUniformLocation(c, "alpha"),
        this.program = c
    }
    ,
    b.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program),
        this.uniforms = null,
        this.gl = null,
        this.attribute = null
    }
    ,
    b.glContexts = [],
    b.instances = [],
    b.WebGLRenderer = function(a) {
        this.game = a,
        b.defaultRenderer || (b.defaultRenderer = this),
        this.type = b.WEBGL_RENDERER,
        this.resolution = a.resolution,
        this.transparent = a.transparent,
        this.autoResize = !1,
        this.preserveDrawingBuffer = a.preserveDrawingBuffer,
        this.clearBeforeRender = a.clearBeforeRender,
        this.width = a.width,
        this.height = a.height,
        this.view = a.canvas,
        this._contextOptions = {
            alpha: this.transparent,
            antialias: a.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        },
        this.projection = new b.Point,
        this.offset = new b.Point,
        this.shaderManager = new b.WebGLShaderManager,
        this.spriteBatch = new b.WebGLSpriteBatch,
        this.maskManager = new b.WebGLMaskManager,
        this.filterManager = new b.WebGLFilterManager,
        this.stencilManager = new b.WebGLStencilManager,
        this.blendModeManager = new b.WebGLBlendModeManager,
        this.renderSession = {},
        this.renderSession.game = this.game,
        this.renderSession.gl = this.gl,
        this.renderSession.drawCount = 0,
        this.renderSession.shaderManager = this.shaderManager,
        this.renderSession.maskManager = this.maskManager,
        this.renderSession.filterManager = this.filterManager,
        this.renderSession.blendModeManager = this.blendModeManager,
        this.renderSession.spriteBatch = this.spriteBatch,
        this.renderSession.stencilManager = this.stencilManager,
        this.renderSession.renderer = this,
        this.renderSession.resolution = this.resolution,
        this.initContext(),
        this.mapBlendModes()
    }
    ,
    b.WebGLRenderer.prototype.constructor = b.WebGLRenderer,
    b.WebGLRenderer.prototype.initContext = function() {
        var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = a,
        !a)
            throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = a.id = b.WebGLRenderer.glContextId++,
        b.glContexts[this.glContextId] = a,
        b.instances[this.glContextId] = this,
        a.disable(a.DEPTH_TEST),
        a.disable(a.CULL_FACE),
        a.enable(a.BLEND),
        this.shaderManager.setContext(a),
        this.spriteBatch.setContext(a),
        this.maskManager.setContext(a),
        this.filterManager.setContext(a),
        this.blendModeManager.setContext(a),
        this.stencilManager.setContext(a),
        this.renderSession.gl = this.gl,
        this.resize(this.width, this.height)
    }
    ,
    b.WebGLRenderer.prototype.render = function(a) {
        if (!this.contextLost) {
            var b = this.gl;
            b.viewport(0, 0, this.width, this.height),
            b.bindFramebuffer(b.FRAMEBUFFER, null),
            this.game.clearBeforeRender && (b.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a),
            b.clear(b.COLOR_BUFFER_BIT)),
            this.offset.x = this.game.camera._shake.x,
            this.offset.y = this.game.camera._shake.y,
            this.renderDisplayObject(a, this.projection)
        }
    }
    ,
    b.WebGLRenderer.prototype.renderDisplayObject = function(a, c, d, e) {
        this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL),
        this.renderSession.drawCount = 0,
        this.renderSession.flipY = d ? -1 : 1,
        this.renderSession.projection = c,
        this.renderSession.offset = this.offset,
        this.spriteBatch.begin(this.renderSession),
        this.filterManager.begin(this.renderSession, d),
        a._renderWebGL(this.renderSession, e),
        this.spriteBatch.end()
    }
    ,
    b.WebGLRenderer.prototype.resize = function(a, b) {
        this.width = a * this.resolution,
        this.height = b * this.resolution,
        this.view.width = this.width,
        this.view.height = this.height,
        this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
        this.view.style.height = this.height / this.resolution + "px"),
        this.gl.viewport(0, 0, this.width, this.height),
        this.projection.x = this.width / 2 / this.resolution,
        this.projection.y = -this.height / 2 / this.resolution
    }
    ,
    b.WebGLRenderer.prototype.updateTexture = function(a) {
        if (!a.hasLoaded)
            return !1;
        var c = this.gl;
        return a._glTextures[c.id] || (a._glTextures[c.id] = c.createTexture()),
        c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]),
        c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha),
        c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST),
        a.mipmap && b.isPowerOfTwo(a.width, a.height) ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST),
        c.generateMipmap(c.TEXTURE_2D)) : c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST),
        a._powerOf2 ? (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT)) : (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE),
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE)),
        a._dirty[c.id] = !1,
        !0
    }
    ,
    b.WebGLRenderer.prototype.destroy = function() {
        b.glContexts[this.glContextId] = null,
        this.projection = null,
        this.offset = null,
        this.shaderManager.destroy(),
        this.spriteBatch.destroy(),
        this.maskManager.destroy(),
        this.filterManager.destroy(),
        this.shaderManager = null,
        this.spriteBatch = null,
        this.maskManager = null,
        this.filterManager = null,
        this.gl = null,
        this.renderSession = null,
        b.CanvasPool.remove(this),
        b.instances[this.glContextId] = null,
        b.WebGLRenderer.glContextId--
    }
    ,
    b.WebGLRenderer.prototype.mapBlendModes = function() {
        var a = this.gl;
        if (!b.blendModesWebGL) {
            var c = []
              , d = b.blendModes;
            c[d.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.ADD] = [a.SRC_ALPHA, a.DST_ALPHA],
            c[d.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA],
            c[d.SCREEN] = [a.SRC_ALPHA, a.ONE],
            c[d.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            c[d.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA],
            b.blendModesWebGL = c
        }
    }
    ,
    b.WebGLRenderer.glContextId = 0,
    b.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999
    }
    ,
    b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager,
    b.WebGLBlendModeManager.prototype.setContext = function(a) {
        this.gl = a
    }
    ,
    b.WebGLBlendModeManager.prototype.setBlendMode = function(a) {
        if (this.currentBlendMode === a)
            return !1;
        this.currentBlendMode = a;
        var c = b.blendModesWebGL[this.currentBlendMode];
        return c && this.gl.blendFunc(c[0], c[1]),
        !0
    }
    ,
    b.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null
    }
    ,
    b.WebGLMaskManager = function() {}
    ,
    b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager,
    b.WebGLMaskManager.prototype.setContext = function(a) {
        this.gl = a
    }
    ,
    b.WebGLMaskManager.prototype.pushMask = function(a, c) {
        var d = c.gl;
        a.dirty && b.WebGLGraphics.updateGraphics(a, d),
        void 0 !== a._webGL[d.id] && void 0 !== a._webGL[d.id].data && 0 !== a._webGL[d.id].data.length && c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c)
    }
    ,
    b.WebGLMaskManager.prototype.popMask = function(a, b) {
        var c = this.gl;
        void 0 !== a._webGL[c.id] && void 0 !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length && b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b)
    }
    ,
    b.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null
    }
    ,
    b.WebGLStencilManager = function() {
        this.stencilStack = [],
        this.reverse = !0,
        this.count = 0
    }
    ,
    b.WebGLStencilManager.prototype.setContext = function(a) {
        this.gl = a
    }
    ,
    b.WebGLStencilManager.prototype.pushStencil = function(a, b, c) {
        var d = this.gl;
        this.bindGraphics(a, b, c),
        0 === this.stencilStack.length && (d.enable(d.STENCIL_TEST),
        d.clear(d.STENCIL_BUFFER_BIT),
        this.reverse = !0,
        this.count = 0),
        this.stencilStack.push(b);
        var e = this.count;
        d.colorMask(!1, !1, !1, !1),
        d.stencilFunc(d.ALWAYS, 0, 255),
        d.stencilOp(d.KEEP, d.KEEP, d.INVERT),
        1 === b.mode ? (d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0),
        this.reverse ? (d.stencilFunc(d.EQUAL, 255 - e, 255),
        d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, e, 255),
        d.stencilOp(d.KEEP, d.KEEP, d.INCR)),
        d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)),
        this.reverse ? d.stencilFunc(d.EQUAL, 255 - (e + 1), 255) : d.stencilFunc(d.EQUAL, e + 1, 255),
        this.reverse = !this.reverse) : (this.reverse ? (d.stencilFunc(d.EQUAL, e, 255),
        d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, 255 - e, 255),
        d.stencilOp(d.KEEP, d.KEEP, d.DECR)),
        d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0),
        this.reverse ? d.stencilFunc(d.EQUAL, e + 1, 255) : d.stencilFunc(d.EQUAL, 255 - (e + 1), 255)),
        d.colorMask(!0, !0, !0, !0),
        d.stencilOp(d.KEEP, d.KEEP, d.KEEP),
        this.count++
    }
    ,
    b.WebGLStencilManager.prototype.bindGraphics = function(a, c, d) {
        this._currentGraphics = a;
        var h, e = this.gl, f = d.projection, g = d.offset;
        1 === c.mode ? (h = d.shaderManager.complexPrimitiveShader,
        d.shaderManager.setShader(h),
        e.uniform1f(h.flipY, d.flipY),
        e.uniformMatrix3fv(h.translationMatrix, !1, a.worldTransform.toArray(!0)),
        e.uniform2f(h.projectionVector, f.x, -f.y),
        e.uniform2f(h.offsetVector, -g.x, -g.y),
        e.uniform3fv(h.tintColor, b.hex2rgb(a.tint)),
        e.uniform3fv(h.color, c.color),
        e.uniform1f(h.alpha, a.worldAlpha * c.alpha),
        e.bindBuffer(e.ARRAY_BUFFER, c.buffer),
        e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, !1, 8, 0),
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c.indexBuffer)) : (h = d.shaderManager.primitiveShader,
        d.shaderManager.setShader(h),
        e.uniformMatrix3fv(h.translationMatrix, !1, a.worldTransform.toArray(!0)),
        e.uniform1f(h.flipY, d.flipY),
        e.uniform2f(h.projectionVector, f.x, -f.y),
        e.uniform2f(h.offsetVector, -g.x, -g.y),
        e.uniform3fv(h.tintColor, b.hex2rgb(a.tint)),
        e.uniform1f(h.alpha, a.worldAlpha),
        e.bindBuffer(e.ARRAY_BUFFER, c.buffer),
        e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, !1, 24, 0),
        e.vertexAttribPointer(h.colorAttribute, 4, e.FLOAT, !1, 24, 8),
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c.indexBuffer))
    }
    ,
    b.WebGLStencilManager.prototype.popStencil = function(a, b, c) {
        var d = this.gl;
        if (this.stencilStack.pop(),
        this.count--,
        0 === this.stencilStack.length)
            d.disable(d.STENCIL_TEST);
        else {
            var e = this.count;
            this.bindGraphics(a, b, c),
            d.colorMask(!1, !1, !1, !1),
            1 === b.mode ? (this.reverse = !this.reverse,
            this.reverse ? (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255),
            d.stencilOp(d.KEEP, d.KEEP, d.INCR)) : (d.stencilFunc(d.EQUAL, e + 1, 255),
            d.stencilOp(d.KEEP, d.KEEP, d.DECR)),
            d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4)),
            d.stencilFunc(d.ALWAYS, 0, 255),
            d.stencilOp(d.KEEP, d.KEEP, d.INVERT),
            d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0),
            this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)) : (this.reverse ? (d.stencilFunc(d.EQUAL, e + 1, 255),
            d.stencilOp(d.KEEP, d.KEEP, d.DECR)) : (d.stencilFunc(d.EQUAL, 255 - (e + 1), 255),
            d.stencilOp(d.KEEP, d.KEEP, d.INCR)),
            d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0),
            this.reverse ? d.stencilFunc(d.EQUAL, e, 255) : d.stencilFunc(d.EQUAL, 255 - e, 255)),
            d.colorMask(!0, !0, !0, !0),
            d.stencilOp(d.KEEP, d.KEEP, d.KEEP)
        }
    }
    ,
    b.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null,
        this.gl = null
    }
    ,
    b.WebGLShaderManager = function() {
        this.maxAttibs = 10,
        this.attribState = [],
        this.tempAttribState = [];
        for (var a = 0; a < this.maxAttibs; a++)
            this.attribState[a] = !1;
        this.stack = []
    }
    ,
    b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager,
    b.WebGLShaderManager.prototype.setContext = function(a) {
        this.gl = a,
        this.primitiveShader = new b.PrimitiveShader(a),
        this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a),
        this.defaultShader = new b.PixiShader(a),
        this.fastShader = new b.PixiFastShader(a),
        this.stripShader = new b.StripShader(a),
        this.setShader(this.defaultShader)
    }
    ,
    b.WebGLShaderManager.prototype.setAttribs = function(a) {
        var b;
        for (b = 0; b < this.tempAttribState.length; b++)
            this.tempAttribState[b] = !1;
        for (b = 0; b < a.length; b++) {
            var c = a[b];
            this.tempAttribState[c] = !0
        }
        var d = this.gl;
        for (b = 0; b < this.attribState.length; b++)
            this.attribState[b] !== this.tempAttribState[b] && (this.attribState[b] = this.tempAttribState[b],
            this.tempAttribState[b] ? d.enableVertexAttribArray(b) : d.disableVertexAttribArray(b))
    }
    ,
    b.WebGLShaderManager.prototype.setShader = function(a) {
        return this._currentId !== a._UID && (this._currentId = a._UID,
        this.currentShader = a,
        this.gl.useProgram(a.program),
        this.setAttribs(a.attributes),
        !0)
    }
    ,
    b.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null,
        this.tempAttribState = null,
        this.primitiveShader.destroy(),
        this.complexPrimitiveShader.destroy(),
        this.defaultShader.destroy(),
        this.fastShader.destroy(),
        this.stripShader.destroy(),
        this.gl = null
    }
    ,
    b.WebGLSpriteBatch = function() {
        this.vertSize = 5,
        this.size = 2e3;
        var a = 4 * this.size * 4 * this.vertSize
          , c = 6 * this.size;
        this.vertices = new b.ArrayBuffer(a),
        this.positions = new b.Float32Array(this.vertices),
        this.colors = new b.Uint32Array(this.vertices),
        this.indices = new b.Uint16Array(c),
        this.lastIndexCount = 0;
        for (var d = 0, e = 0; d < c; d += 6,
        e += 4)
            this.indices[d + 0] = e + 0,
            this.indices[d + 1] = e + 1,
            this.indices[d + 2] = e + 2,
            this.indices[d + 3] = e + 0,
            this.indices[d + 4] = e + 2,
            this.indices[d + 5] = e + 3;
        this.drawing = !1,
        this.currentBatchSize = 0,
        this.currentBaseTexture = null,
        this.dirty = !0,
        this.textures = [],
        this.blendModes = [],
        this.shaders = [],
        this.sprites = [],
        this.defaultShader = new b.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
    }
    ,
    b.WebGLSpriteBatch.prototype.setContext = function(a) {
        this.gl = a,
        this.vertexBuffer = a.createBuffer(),
        this.indexBuffer = a.createBuffer(),
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW),
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
        a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW),
        this.currentBlendMode = 99999;
        var c = new b.PixiShader(a);
        c.fragmentSrc = this.defaultShader.fragmentSrc,
        c.uniforms = {},
        c.init(),
        this.defaultShader.shaders[a.id] = c
    }
    ,
    b.WebGLSpriteBatch.prototype.begin = function(a) {
        this.renderSession = a,
        this.shader = this.renderSession.shaderManager.defaultShader,
        this.start()
    }
    ,
    b.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    }
    ,
    b.WebGLSpriteBatch.prototype.render = function(a, b) {
        var c = a.texture
          , d = a.worldTransform;
        b && (d = b),
        this.currentBatchSize >= this.size && (this.flush(),
        this.currentBaseTexture = c.baseTexture);
        var e = c._uvs;
        if (e) {
            var h, i, j, k, f = a.anchor.x, g = a.anchor.y;
            if (c.trim) {
                var l = c.trim;
                i = l.x - f * l.width,
                h = i + c.crop.width,
                k = l.y - g * l.height,
                j = k + c.crop.height
            } else
                h = c.frame.width * (1 - f),
                i = c.frame.width * -f,
                j = c.frame.height * (1 - g),
                k = c.frame.height * -g;
            var m = 4 * this.currentBatchSize * this.vertSize
              , n = c.baseTexture.resolution
              , o = d.a / n
              , p = d.b / n
              , q = d.c / n
              , r = d.d / n
              , s = d.tx
              , t = d.ty
              , u = this.colors
              , v = this.positions;
            this.renderSession.roundPixels ? (v[m] = o * i + q * k + s | 0,
            v[m + 1] = r * k + p * i + t | 0,
            v[m + 5] = o * h + q * k + s | 0,
            v[m + 6] = r * k + p * h + t | 0,
            v[m + 10] = o * h + q * j + s | 0,
            v[m + 11] = r * j + p * h + t | 0,
            v[m + 15] = o * i + q * j + s | 0,
            v[m + 16] = r * j + p * i + t | 0) : (v[m] = o * i + q * k + s,
            v[m + 1] = r * k + p * i + t,
            v[m + 5] = o * h + q * k + s,
            v[m + 6] = r * k + p * h + t,
            v[m + 10] = o * h + q * j + s,
            v[m + 11] = r * j + p * h + t,
            v[m + 15] = o * i + q * j + s,
            v[m + 16] = r * j + p * i + t),
            v[m + 2] = e.x0,
            v[m + 3] = e.y0,
            v[m + 7] = e.x1,
            v[m + 8] = e.y1,
            v[m + 12] = e.x2,
            v[m + 13] = e.y2,
            v[m + 17] = e.x3,
            v[m + 18] = e.y3;
            var w = a.tint;
            u[m + 4] = u[m + 9] = u[m + 14] = u[m + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * a.worldAlpha << 24),
            this.sprites[this.currentBatchSize++] = a
        }
    }
    ,
    b.WebGLSpriteBatch.prototype.renderTilingSprite = function(a) {
        var c = a.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(),
        this.currentBaseTexture = c.baseTexture),
        a._uvs || (a._uvs = new b.TextureUvs);
        var d = a._uvs
          , e = c.baseTexture.width
          , f = c.baseTexture.height;
        a.tilePosition.x %= e * a.tileScaleOffset.x,
        a.tilePosition.y %= f * a.tileScaleOffset.y;
        var g = a.tilePosition.x / (e * a.tileScaleOffset.x)
          , h = a.tilePosition.y / (f * a.tileScaleOffset.y)
          , i = a.width / e / (a.tileScale.x * a.tileScaleOffset.x)
          , j = a.height / f / (a.tileScale.y * a.tileScaleOffset.y);
        d.x0 = 0 - g,
        d.y0 = 0 - h,
        d.x1 = 1 * i - g,
        d.y1 = 0 - h,
        d.x2 = 1 * i - g,
        d.y2 = 1 * j - h,
        d.x3 = 0 - g,
        d.y3 = 1 * j - h;
        var k = a.tint
          , l = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * a.worldAlpha << 24)
          , m = this.positions
          , n = this.colors
          , o = a.width
          , p = a.height
          , q = a.anchor.x
          , r = a.anchor.y
          , s = o * (1 - q)
          , t = o * -q
          , u = p * (1 - r)
          , v = p * -r
          , w = 4 * this.currentBatchSize * this.vertSize
          , x = c.baseTexture.resolution
          , y = a.worldTransform
          , z = y.a / x
          , A = y.b / x
          , B = y.c / x
          , C = y.d / x
          , D = y.tx
          , E = y.ty;
        m[w++] = z * t + B * v + D,
        m[w++] = C * v + A * t + E,
        m[w++] = d.x0,
        m[w++] = d.y0,
        n[w++] = l,
        m[w++] = z * s + B * v + D,
        m[w++] = C * v + A * s + E,
        m[w++] = d.x1,
        m[w++] = d.y1,
        n[w++] = l,
        m[w++] = z * s + B * u + D,
        m[w++] = C * u + A * s + E,
        m[w++] = d.x2,
        m[w++] = d.y2,
        n[w++] = l,
        m[w++] = z * t + B * u + D,
        m[w++] = C * u + A * t + E,
        m[w++] = d.x3,
        m[w++] = d.y3,
        n[w++] = l,
        this.sprites[this.currentBatchSize++] = a
    }
    ,
    b.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var c, a = this.gl;
            if (this.dirty) {
                this.dirty = !1,
                a.activeTexture(a.TEXTURE0),
                a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
                a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
                c = this.defaultShader.shaders[a.id];
                var d = 4 * this.vertSize;
                a.vertexAttribPointer(c.aVertexPosition, 2, a.FLOAT, !1, d, 0),
                a.vertexAttribPointer(c.aTextureCoord, 2, a.FLOAT, !1, d, 8),
                a.vertexAttribPointer(c.colorAttribute, 4, a.UNSIGNED_BYTE, !0, d, 16)
            }
            if (this.currentBatchSize > .5 * this.size)
                a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
            else {
                var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, e)
            }
            for (var f, g, h, p, i = 0, j = 0, k = null, l = this.renderSession.blendModeManager.currentBlendMode, m = null, n = !1, o = !1, q = 0, r = this.currentBatchSize; q < r; q++) {
                p = this.sprites[q],
                f = p.tilingTexture ? p.tilingTexture.baseTexture : p.texture.baseTexture,
                g = p.blendMode,
                h = p.shader || this.defaultShader,
                n = l !== g,
                o = m !== h;
                var s = f.skipRender;
                if (s && p.children.length > 0 && (s = !1),
                (k !== f && !s || n || o) && (this.renderBatch(k, i, j),
                j = q,
                i = 0,
                k = f,
                n && (l = g,
                this.renderSession.blendModeManager.setBlendMode(l)),
                o)) {
                    m = h,
                    c = m.shaders[a.id],
                    c || (c = new b.PixiShader(a),
                    c.fragmentSrc = m.fragmentSrc,
                    c.uniforms = m.uniforms,
                    c.init(),
                    m.shaders[a.id] = c),
                    this.renderSession.shaderManager.setShader(c),
                    c.dirty && c.syncUniforms();
                    var t = this.renderSession.projection;
                    a.uniform2f(c.projectionVector, t.x, t.y);
                    var u = this.renderSession.offset;
                    a.uniform2f(c.offsetVector, u.x, u.y)
                }
                i++
            }
            this.renderBatch(k, i, j),
            this.currentBatchSize = 0
        }
    }
    ,
    b.WebGLSpriteBatch.prototype.renderBatch = function(a, b, c) {
        if (0 !== b) {
            var d = this.gl;
            if (a._dirty[d.id]) {
                if (!this.renderSession.renderer.updateTexture(a))
                    return
            } else
                d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]);
            d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2),
            this.renderSession.drawCount++
        }
    }
    ,
    b.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(),
        this.dirty = !0
    }
    ,
    b.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0
    }
    ,
    b.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null,
        this.indices = null,
        this.gl.deleteBuffer(this.vertexBuffer),
        this.gl.deleteBuffer(this.indexBuffer),
        this.currentBaseTexture = null,
        this.gl = null
    }
    ,
    b.WebGLFastSpriteBatch = function(a) {
        this.vertSize = 10,
        this.maxSize = 6e3,
        this.size = this.maxSize;
        var c = 4 * this.size * this.vertSize
          , d = 6 * this.maxSize;
        this.vertices = new b.Float32Array(c),
        this.indices = new b.Uint16Array(d),
        this.vertexBuffer = null,
        this.indexBuffer = null,
        this.lastIndexCount = 0;
        for (var e = 0, f = 0; e < d; e += 6,
        f += 4)
            this.indices[e + 0] = f + 0,
            this.indices[e + 1] = f + 1,
            this.indices[e + 2] = f + 2,
            this.indices[e + 3] = f + 0,
            this.indices[e + 4] = f + 2,
            this.indices[e + 5] = f + 3;
        this.drawing = !1,
        this.currentBatchSize = 0,
        this.currentBaseTexture = null,
        this.currentBlendMode = 0,
        this.renderSession = null,
        this.shader = null,
        this.matrix = null,
        this.setContext(a)
    }
    ,
    b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch,
    b.WebGLFastSpriteBatch.prototype.setContext = function(a) {
        this.gl = a,
        this.vertexBuffer = a.createBuffer(),
        this.indexBuffer = a.createBuffer(),
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW),
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
        a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW)
    }
    ,
    b.WebGLFastSpriteBatch.prototype.begin = function(a, b) {
        this.renderSession = b,
        this.shader = this.renderSession.shaderManager.fastShader,
        this.matrix = a.worldTransform.toArray(!0),
        this.start()
    }
    ,
    b.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    }
    ,
    b.WebGLFastSpriteBatch.prototype.render = function(a) {
        var b = a.children
          , c = b[0];
        if (c.texture._uvs) {
            this.currentBaseTexture = c.texture.baseTexture,
            c.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(),
            this.renderSession.blendModeManager.setBlendMode(c.blendMode));
            for (var d = 0, e = b.length; d < e; d++)
                this.renderSprite(b[d]);
            this.flush()
        }
    }
    ,
    b.WebGLFastSpriteBatch.prototype.renderSprite = function(a) {
        if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || a.texture.baseTexture.skipRender || (this.flush(),
        this.currentBaseTexture = a.texture.baseTexture,
        a.texture._uvs))) {
            var b, f, g, h, i, j, c = this.vertices;
            if (b = a.texture._uvs,
            a.texture.frame.width,
            a.texture.frame.height,
            a.texture.trim) {
                var k = a.texture.trim;
                g = k.x - a.anchor.x * k.width,
                f = g + a.texture.crop.width,
                i = k.y - a.anchor.y * k.height,
                h = i + a.texture.crop.height
            } else
                f = a.texture.frame.width * (1 - a.anchor.x),
                g = a.texture.frame.width * -a.anchor.x,
                h = a.texture.frame.height * (1 - a.anchor.y),
                i = a.texture.frame.height * -a.anchor.y;
            j = 4 * this.currentBatchSize * this.vertSize,
            c[j++] = g,
            c[j++] = i,
            c[j++] = a.position.x,
            c[j++] = a.position.y,
            c[j++] = a.scale.x,
            c[j++] = a.scale.y,
            c[j++] = a.rotation,
            c[j++] = b.x0,
            c[j++] = b.y1,
            c[j++] = a.alpha,
            c[j++] = f,
            c[j++] = i,
            c[j++] = a.position.x,
            c[j++] = a.position.y,
            c[j++] = a.scale.x,
            c[j++] = a.scale.y,
            c[j++] = a.rotation,
            c[j++] = b.x1,
            c[j++] = b.y1,
            c[j++] = a.alpha,
            c[j++] = f,
            c[j++] = h,
            c[j++] = a.position.x,
            c[j++] = a.position.y,
            c[j++] = a.scale.x,
            c[j++] = a.scale.y,
            c[j++] = a.rotation,
            c[j++] = b.x2,
            c[j++] = b.y2,
            c[j++] = a.alpha,
            c[j++] = g,
            c[j++] = h,
            c[j++] = a.position.x,
            c[j++] = a.position.y,
            c[j++] = a.scale.x,
            c[j++] = a.scale.y,
            c[j++] = a.rotation,
            c[j++] = b.x3,
            c[j++] = b.y3,
            c[j++] = a.alpha,
            this.currentBatchSize++,
            this.currentBatchSize >= this.size && this.flush()
        }
    }
    ,
    b.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var a = this.gl;
            if (this.currentBaseTexture._glTextures[a.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, a),
            a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]),
            this.currentBatchSize > .5 * this.size)
                a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
            else {
                var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                a.bufferSubData(a.ARRAY_BUFFER, 0, b)
            }
            a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0),
            this.currentBatchSize = 0,
            this.renderSession.drawCount++
        }
    }
    ,
    b.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    }
    ,
    b.WebGLFastSpriteBatch.prototype.start = function() {
        var a = this.gl;
        a.activeTexture(a.TEXTURE0),
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = this.renderSession.projection;
        a.uniform2f(this.shader.projectionVector, b.x, b.y),
        a.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var c = 4 * this.vertSize;
        a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, !1, c, 0),
        a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, !1, c, 8),
        a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, !1, c, 16),
        a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, !1, c, 24),
        a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, !1, c, 28),
        a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, !1, c, 36)
    }
    ,
    b.WebGLFilterManager = function() {
        this.filterStack = [],
        this.offsetX = 0,
        this.offsetY = 0
    }
    ,
    b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager,
    b.WebGLFilterManager.prototype.setContext = function(a) {
        this.gl = a,
        this.texturePool = [],
        this.initShaderBuffers()
    }
    ,
    b.WebGLFilterManager.prototype.begin = function(a, b) {
        this.renderSession = a,
        this.defaultShader = a.shaderManager.defaultShader;
        var c = this.renderSession.projection;
        this.width = 2 * c.x,
        this.height = 2 * -c.y,
        this.buffer = b
    }
    ,
    b.WebGLFilterManager.prototype.pushFilter = function(a) {
        var c = this.gl
          , d = this.renderSession.projection
          , e = this.renderSession.offset;
        a._filterArea = a.target.filterArea || a.target.getBounds(),
        a._previous_stencil_mgr = this.renderSession.stencilManager,
        this.renderSession.stencilManager = new b.WebGLStencilManager,
        this.renderSession.stencilManager.setContext(c),
        c.disable(c.STENCIL_TEST),
        this.filterStack.push(a);
        var f = a.filterPasses[0];
        this.offsetX += a._filterArea.x,
        this.offsetY += a._filterArea.y;
        var g = this.texturePool.pop();
        g ? g.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : g = new b.FilterTexture(this.gl,this.width * this.renderSession.resolution,this.height * this.renderSession.resolution),
        c.bindTexture(c.TEXTURE_2D, g.texture);
        var h = a._filterArea
          , i = f.padding;
        h.x -= i,
        h.y -= i,
        h.width += 2 * i,
        h.height += 2 * i,
        h.x < 0 && (h.x = 0),
        h.width > this.width && (h.width = this.width),
        h.y < 0 && (h.y = 0),
        h.height > this.height && (h.height = this.height),
        c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer),
        c.viewport(0, 0, h.width * this.renderSession.resolution, h.height * this.renderSession.resolution),
        d.x = h.width / 2,
        d.y = -h.height / 2,
        e.x = -h.x,
        e.y = -h.y,
        c.colorMask(!0, !0, !0, !0),
        c.clearColor(0, 0, 0, 0),
        c.clear(c.COLOR_BUFFER_BIT),
        a._glFilterTexture = g
    }
    ,
    b.WebGLFilterManager.prototype.popFilter = function() {
        var a = this.gl
          , c = this.filterStack.pop()
          , d = c._filterArea
          , e = c._glFilterTexture
          , f = this.renderSession.projection
          , g = this.renderSession.offset;
        if (c.filterPasses.length > 1) {
            a.viewport(0, 0, d.width * this.renderSession.resolution, d.height * this.renderSession.resolution),
            a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
            this.vertexArray[0] = 0,
            this.vertexArray[1] = d.height,
            this.vertexArray[2] = d.width,
            this.vertexArray[3] = d.height,
            this.vertexArray[4] = 0,
            this.vertexArray[5] = 0,
            this.vertexArray[6] = d.width,
            this.vertexArray[7] = 0,
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray),
            a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer),
            this.uvArray[2] = d.width / this.width,
            this.uvArray[5] = d.height / this.height,
            this.uvArray[6] = d.width / this.width,
            this.uvArray[7] = d.height / this.height,
            a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
            var h = e
              , i = this.texturePool.pop();
            i || (i = new b.FilterTexture(this.gl,this.width * this.renderSession.resolution,this.height * this.renderSession.resolution)),
            i.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution),
            a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer),
            a.clear(a.COLOR_BUFFER_BIT),
            a.disable(a.BLEND);
            for (var j = 0; j < c.filterPasses.length - 1; j++) {
                var k = c.filterPasses[j];
                a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer),
                a.activeTexture(a.TEXTURE0),
                a.bindTexture(a.TEXTURE_2D, h.texture),
                this.applyFilterPass(k, d, d.width, d.height);
                var l = h;
                h = i,
                i = l
            }
            a.enable(a.BLEND),
            e = h,
            this.texturePool.push(i)
        }
        var m = c.filterPasses[c.filterPasses.length - 1];
        this.offsetX -= d.x,
        this.offsetY -= d.y;
        var n = this.width
          , o = this.height
          , p = 0
          , q = 0
          , r = this.buffer;
        if (0 === this.filterStack.length)
            a.colorMask(!0, !0, !0, !0);
        else {
            var s = this.filterStack[this.filterStack.length - 1];
            d = s._filterArea,
            n = d.width,
            o = d.height,
            p = d.x,
            q = d.y,
            r = s._glFilterTexture.frameBuffer
        }
        f.x = n / 2,
        f.y = -o / 2,
        g.x = p,
        g.y = q,
        d = c._filterArea;
        var t = d.x - p
          , u = d.y - q;
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
        this.vertexArray[0] = t,
        this.vertexArray[1] = u + d.height,
        this.vertexArray[2] = t + d.width,
        this.vertexArray[3] = u + d.height,
        this.vertexArray[4] = t,
        this.vertexArray[5] = u,
        this.vertexArray[6] = t + d.width,
        this.vertexArray[7] = u,
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray),
        a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer),
        this.uvArray[2] = d.width / this.width,
        this.uvArray[5] = d.height / this.height,
        this.uvArray[6] = d.width / this.width,
        this.uvArray[7] = d.height / this.height,
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray),
        a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution),
        a.bindFramebuffer(a.FRAMEBUFFER, r),
        a.activeTexture(a.TEXTURE0),
        a.bindTexture(a.TEXTURE_2D, e.texture),
        this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(),
        this.renderSession.stencilManager = c._previous_stencil_mgr,
        c._previous_stencil_mgr = null,
        this.renderSession.stencilManager.count > 0 ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST),
        this.applyFilterPass(m, d, n, o),
        this.texturePool.push(e),
        c._glFilterTexture = null
    }
    ,
    b.WebGLFilterManager.prototype.applyFilterPass = function(a, c, d, e) {
        var f = this.gl
          , g = a.shaders[f.id];
        g || (g = new b.PixiShader(f),
        g.fragmentSrc = a.fragmentSrc,
        g.uniforms = a.uniforms,
        g.init(),
        a.shaders[f.id] = g),
        this.renderSession.shaderManager.setShader(g),
        f.uniform2f(g.projectionVector, d / 2, -e / 2),
        f.uniform2f(g.offsetVector, 0, 0),
        a.uniforms.dimensions && (a.uniforms.dimensions.value[0] = this.width,
        a.uniforms.dimensions.value[1] = this.height,
        a.uniforms.dimensions.value[2] = this.vertexArray[0],
        a.uniforms.dimensions.value[3] = this.vertexArray[5]),
        g.syncUniforms(),
        f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer),
        f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, !1, 0, 0),
        f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer),
        f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, !1, 0, 0),
        f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer),
        f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, !1, 0, 0),
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0),
        this.renderSession.drawCount++
    }
    ,
    b.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var a = this.gl;
        this.vertexBuffer = a.createBuffer(),
        this.uvBuffer = a.createBuffer(),
        this.colorBuffer = a.createBuffer(),
        this.indexBuffer = a.createBuffer(),
        this.vertexArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer),
        a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW),
        this.uvArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
        a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer),
        a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW),
        this.colorArray = new b.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]),
        a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer),
        a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW),
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW)
    }
    ,
    b.WebGLFilterManager.prototype.destroy = function() {
        var a = this.gl;
        this.filterStack = null,
        this.offsetX = 0,
        this.offsetY = 0;
        for (var b = 0; b < this.texturePool.length; b++)
            this.texturePool[b].destroy();
        this.texturePool = null,
        a.deleteBuffer(this.vertexBuffer),
        a.deleteBuffer(this.uvBuffer),
        a.deleteBuffer(this.colorBuffer),
        a.deleteBuffer(this.indexBuffer)
    }
    ,
    b.FilterTexture = function(a, c, d, e) {
        this.gl = a,
        this.frameBuffer = a.createFramebuffer(),
        this.texture = a.createTexture(),
        e = e || b.scaleModes.DEFAULT,
        a.bindTexture(a.TEXTURE_2D, this.texture),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE),
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE),
        a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer),
        a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer),
        a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0),
        this.renderBuffer = a.createRenderbuffer(),
        a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer),
        a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer),
        this.resize(c, d)
    }
    ,
    b.FilterTexture.prototype.constructor = b.FilterTexture,
    b.FilterTexture.prototype.clear = function() {
        var a = this.gl;
        a.clearColor(0, 0, 0, 0),
        a.clear(a.COLOR_BUFFER_BIT)
    }
    ,
    b.FilterTexture.prototype.resize = function(a, b) {
        if (this.width !== a || this.height !== b) {
            this.width = a,
            this.height = b;
            var c = this.gl;
            c.bindTexture(c.TEXTURE_2D, this.texture),
            c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null),
            c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer),
            c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b)
        }
    }
    ,
    b.FilterTexture.prototype.destroy = function() {
        var a = this.gl;
        a.deleteFramebuffer(this.frameBuffer),
        a.deleteTexture(this.texture),
        this.frameBuffer = null,
        this.texture = null
    }
    ,
    b.CanvasBuffer = function(a, c) {
        this.width = a,
        this.height = c,
        this.canvas = b.CanvasPool.create(this, this.width, this.height),
        this.context = this.canvas.getContext("2d"),
        this.canvas.width = a,
        this.canvas.height = c
    }
    ,
    b.CanvasBuffer.prototype.constructor = b.CanvasBuffer,
    b.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0),
        this.context.clearRect(0, 0, this.width, this.height)
    }
    ,
    b.CanvasBuffer.prototype.resize = function(a, b) {
        this.width = this.canvas.width = a,
        this.height = this.canvas.height = b
    }
    ,
    b.CanvasBuffer.prototype.destroy = function() {
        b.CanvasPool.remove(this)
    }
    ,
    b.CanvasMaskManager = function() {}
    ,
    b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager,
    b.CanvasMaskManager.prototype.pushMask = function(a, c) {
        var d = c.context;
        d.save();
        var e = a.alpha
          , f = a.worldTransform
          , g = c.resolution;
        d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g),
        b.CanvasGraphics.renderGraphicsMask(a, d),
        d.clip(),
        a.worldAlpha = e
    }
    ,
    b.CanvasMaskManager.prototype.popMask = function(a) {
        a.context.restore()
    }
    ,
    b.CanvasTinter = function() {}
    ,
    b.CanvasTinter.getTintedTexture = function(a, c) {
        var d = a.tintedTexture || b.CanvasPool.create(this);
        return b.CanvasTinter.tintMethod(a.texture, c, d),
        d
    }
    ,
    b.CanvasTinter.tintWithMultiply = function(a, b, c) {
        var d = c.getContext("2d")
          , e = a.crop;
        c.width === e.width && c.height === e.height || (c.width = e.width,
        c.height = e.height),
        d.clearRect(0, 0, e.width, e.height),
        d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6),
        d.fillRect(0, 0, e.width, e.height),
        d.globalCompositeOperation = "multiply",
        d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height),
        d.globalCompositeOperation = "destination-atop",
        d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height)
    }
    ,
    b.CanvasTinter.tintWithPerPixel = function(a, c, d) {
        var e = d.getContext("2d")
          , f = a.crop;
        d.width = f.width,
        d.height = f.height,
        e.globalCompositeOperation = "copy",
        e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
        for (var g = b.hex2rgb(c), h = g[0], i = g[1], j = g[2], k = e.getImageData(0, 0, f.width, f.height), l = k.data, m = 0; m < l.length; m += 4)
            if (l[m + 0] *= h,
            l[m + 1] *= i,
            l[m + 2] *= j,
            !b.CanvasTinter.canHandleAlpha) {
                var n = l[m + 3];
                l[m + 0] /= 255 / n,
                l[m + 1] /= 255 / n,
                l[m + 2] /= 255 / n
            }
        e.putImageData(k, 0, 0)
    }
    ,
    b.CanvasTinter.checkInverseAlpha = function() {
        var a = new b.CanvasBuffer(2,1);
        a.context.fillStyle = "rgba(10, 20, 30, 0.5)",
        a.context.fillRect(0, 0, 1, 1);
        var c = a.context.getImageData(0, 0, 1, 1);
        if (null === c)
            return !1;
        a.context.putImageData(c, 1, 0);
        var d = a.context.getImageData(1, 0, 1, 1);
        return d.data[0] === c.data[0] && d.data[1] === c.data[1] && d.data[2] === c.data[2] && d.data[3] === c.data[3]
    }
    ,
    b.CanvasTinter.canHandleAlpha = b.CanvasTinter.checkInverseAlpha(),
    b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes(),
    b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel,
    b.CanvasRenderer = function(a) {
        this.game = a,
        b.defaultRenderer || (b.defaultRenderer = this),
        this.type = b.CANVAS_RENDERER,
        this.resolution = a.resolution,
        this.clearBeforeRender = a.clearBeforeRender,
        this.transparent = a.transparent,
        this.autoResize = !1,
        this.width = a.width * this.resolution,
        this.height = a.height * this.resolution,
        this.view = a.canvas,
        this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }),
        this.refresh = !0,
        this.count = 0,
        this.maskManager = new b.CanvasMaskManager,
        this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: !1
        },
        this.mapBlendModes(),
        this.resize(this.width, this.height)
    }
    ,
    b.CanvasRenderer.prototype.constructor = b.CanvasRenderer,
    b.CanvasRenderer.prototype.render = function(a) {
        this.context.setTransform(1, 0, 0, 1, 0, 0),
        this.context.globalAlpha = 1,
        this.renderSession.currentBlendMode = 0,
        this.renderSession.shakeX = this.game.camera._shake.x,
        this.renderSession.shakeY = this.game.camera._shake.y,
        this.context.globalCompositeOperation = "source-over",
        navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black",
        this.context.clear()),
        this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : a._bgColor && (this.context.fillStyle = a._bgColor.rgba,
        this.context.fillRect(0, 0, this.width, this.height))),
        this.renderDisplayObject(a)
    }
    ,
    b.CanvasRenderer.prototype.destroy = function(a) {
        void 0 === a && (a = !0),
        a && this.view.parent && this.view.parent.removeChild(this.view),
        this.view = null,
        this.context = null,
        this.maskManager = null,
        this.renderSession = null
    }
    ,
    b.CanvasRenderer.prototype.resize = function(a, c) {
        this.width = a * this.resolution,
        this.height = c * this.resolution,
        this.view.width = this.width,
        this.view.height = this.height,
        this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
        this.view.style.height = this.height / this.resolution + "px"),
        this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === b.scaleModes.LINEAR)
    }
    ,
    b.CanvasRenderer.prototype.renderDisplayObject = function(a, b, c) {
        this.renderSession.context = b || this.context,
        this.renderSession.resolution = this.resolution,
        a._renderCanvas(this.renderSession, c)
    }
    ,
    b.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!b.blendModesCanvas) {
            var a = []
              , c = b.blendModes
              , d = b.canUseNewCanvasBlendModes();
            a[c.NORMAL] = "source-over",
            a[c.ADD] = "lighter",
            a[c.MULTIPLY] = d ? "multiply" : "source-over",
            a[c.SCREEN] = d ? "screen" : "source-over",
            a[c.OVERLAY] = d ? "overlay" : "source-over",
            a[c.DARKEN] = d ? "darken" : "source-over",
            a[c.LIGHTEN] = d ? "lighten" : "source-over",
            a[c.COLOR_DODGE] = d ? "color-dodge" : "source-over",
            a[c.COLOR_BURN] = d ? "color-burn" : "source-over",
            a[c.HARD_LIGHT] = d ? "hard-light" : "source-over",
            a[c.SOFT_LIGHT] = d ? "soft-light" : "source-over",
            a[c.DIFFERENCE] = d ? "difference" : "source-over",
            a[c.EXCLUSION] = d ? "exclusion" : "source-over",
            a[c.HUE] = d ? "hue" : "source-over",
            a[c.SATURATION] = d ? "saturation" : "source-over",
            a[c.COLOR] = d ? "color" : "source-over",
            a[c.LUMINOSITY] = d ? "luminosity" : "source-over",
            b.blendModesCanvas = a
        }
    }
    ,
    b.BaseTexture = function(a, c) {
        this.resolution = 1,
        this.width = 100,
        this.height = 100,
        this.scaleMode = c || b.scaleModes.DEFAULT,
        this.hasLoaded = !1,
        this.source = a,
        this.premultipliedAlpha = !0,
        this._glTextures = [],
        this.mipmap = !1,
        this._dirty = [!0, !0, !0, !0],
        a && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0,
        this.width = this.source.naturalWidth || this.source.width,
        this.height = this.source.naturalHeight || this.source.height,
        this.dirty()),
        this.skipRender = !1,
        this._powerOf2 = !1)
    }
    ,
    b.BaseTexture.prototype.constructor = b.BaseTexture,
    b.BaseTexture.prototype.forceLoaded = function(a, b) {
        this.hasLoaded = !0,
        this.width = a,
        this.height = b,
        this.dirty()
    }
    ,
    b.BaseTexture.prototype.destroy = function() {
        this.source && b.CanvasPool.removeByCanvas(this.source),
        this.source = null,
        this.unloadFromGPU()
    }
    ,
    b.BaseTexture.prototype.updateSourceImage = function(a) {
        console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
    }
    ,
    b.BaseTexture.prototype.dirty = function() {
        for (var a = 0; a < this._glTextures.length; a++)
            this._dirty[a] = !0
    }
    ,
    b.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var a = this._glTextures.length - 1; a >= 0; a--) {
            var c = this._glTextures[a]
              , d = b.glContexts[a];
            d && c && d.deleteTexture(c)
        }
        this._glTextures.length = 0,
        this.dirty()
    }
    ,
    b.BaseTexture.fromCanvas = function(a, c) {
        return 0 === a.width && (a.width = 1),
        0 === a.height && (a.height = 1),
        new b.BaseTexture(a,c)
    }
    ,
    b.TextureSilentFail = !1,
    b.Texture = function(a, c, d, e) {
        this.noFrame = !1,
        c || (this.noFrame = !0,
        c = new b.Rectangle(0,0,1,1)),
        a instanceof b.Texture && (a = a.baseTexture),
        this.baseTexture = a,
        this.frame = c,
        this.trim = e,
        this.valid = !1,
        this.isTiling = !1,
        this.requiresUpdate = !1,
        this.requiresReTint = !1,
        this._uvs = null,
        this.width = 0,
        this.height = 0,
        this.crop = d || new b.Rectangle(0,0,1,1),
        a.hasLoaded && (this.noFrame && (c = new b.Rectangle(0,0,a.width,a.height)),
        this.setFrame(c))
    }
    ,
    b.Texture.prototype.constructor = b.Texture,
    b.Texture.prototype.onBaseTextureLoaded = function() {
        var a = this.baseTexture;
        this.noFrame && (this.frame = new b.Rectangle(0,0,a.width,a.height)),
        this.setFrame(this.frame)
    }
    ,
    b.Texture.prototype.destroy = function(a) {
        a && this.baseTexture.destroy(),
        this.valid = !1
    }
    ,
    b.Texture.prototype.setFrame = function(a) {
        if (this.noFrame = !1,
        this.frame = a,
        this.width = a.width,
        this.height = a.height,
        this.crop.x = a.x,
        this.crop.y = a.y,
        this.crop.width = a.width,
        this.crop.height = a.height,
        !this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) {
            if (!b.TextureSilentFail)
                throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            return void (this.valid = !1)
        }
        this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded,
        this.trim && (this.width = this.trim.width,
        this.height = this.trim.height,
        this.frame.width = this.trim.width,
        this.frame.height = this.trim.height),
        this.valid && this._updateUvs()
    }
    ,
    b.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new b.TextureUvs);
        var a = this.crop
          , c = this.baseTexture.width
          , d = this.baseTexture.height;
        this._uvs.x0 = a.x / c,
        this._uvs.y0 = a.y / d,
        this._uvs.x1 = (a.x + a.width) / c,
        this._uvs.y1 = a.y / d,
        this._uvs.x2 = (a.x + a.width) / c,
        this._uvs.y2 = (a.y + a.height) / d,
        this._uvs.x3 = a.x / c,
        this._uvs.y3 = (a.y + a.height) / d
    }
    ,
    b.Texture.fromCanvas = function(a, c) {
        var d = b.BaseTexture.fromCanvas(a, c);
        return new b.Texture(d)
    }
    ,
    b.TextureUvs = function() {
        this.x0 = 0,
        this.y0 = 0,
        this.x1 = 0,
        this.y1 = 0,
        this.x2 = 0,
        this.y2 = 0,
        this.x3 = 0,
        this.y3 = 0
    }
    ,
    b.RenderTexture = function(a, c, d, e, f) {
        if (this.width = a || 100,
        this.height = c || 100,
        this.resolution = f || 1,
        this.frame = new b.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution),
        this.crop = new b.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution),
        this.baseTexture = new b.BaseTexture,
        this.baseTexture.width = this.width * this.resolution,
        this.baseTexture.height = this.height * this.resolution,
        this.baseTexture._glTextures = [],
        this.baseTexture.resolution = this.resolution,
        this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT,
        this.baseTexture.hasLoaded = !0,
        b.Texture.call(this, this.baseTexture, new b.Rectangle(0,0,this.width * this.resolution,this.height * this.resolution)),
        this.renderer = d || b.defaultRenderer,
        this.renderer.type === b.WEBGL_RENDERER) {
            var g = this.renderer.gl;
            this.baseTexture._dirty[g.id] = !1,
            this.textureBuffer = new b.FilterTexture(g,this.width,this.height,this.baseTexture.scaleMode),
            this.baseTexture._glTextures[g.id] = this.textureBuffer.texture,
            this.render = this.renderWebGL,
            this.projection = new b.Point(.5 * this.width,.5 * -this.height)
        } else
            this.render = this.renderCanvas,
            this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution,this.height * this.resolution),
            this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0,
        this.tempMatrix = new Phaser.Matrix,
        this._updateUvs()
    }
    ,
    b.RenderTexture.prototype = Object.create(b.Texture.prototype),
    b.RenderTexture.prototype.constructor = b.RenderTexture,
    b.RenderTexture.prototype.resize = function(a, c, d) {
        a === this.width && c === this.height || (this.valid = a > 0 && c > 0,
        this.width = a,
        this.height = c,
        this.frame.width = this.crop.width = a * this.resolution,
        this.frame.height = this.crop.height = c * this.resolution,
        d && (this.baseTexture.width = this.width * this.resolution,
        this.baseTexture.height = this.height * this.resolution),
        this.renderer.type === b.WEBGL_RENDERER && (this.projection.x = this.width / 2,
        this.projection.y = -this.height / 2),
        this.valid && this.textureBuffer.resize(this.width, this.height))
    }
    ,
    b.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === b.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer),
        this.textureBuffer.clear())
    }
    ,
    b.RenderTexture.prototype.renderWebGL = function(a, b, c) {
        if (this.valid && 0 !== a.alpha) {
            var d = a.worldTransform;
            d.identity(),
            d.translate(0, 2 * this.projection.y),
            b && d.append(b),
            d.scale(1, -1);
            for (var e = 0; e < a.children.length; e++)
                a.children[e].updateTransform();
            var f = this.renderer.gl;
            f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution),
            f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            c && this.textureBuffer.clear(),
            this.renderer.spriteBatch.dirty = !0,
            this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b),
            this.renderer.spriteBatch.dirty = !0
        }
    }
    ,
    b.RenderTexture.prototype.renderCanvas = function(a, b, c) {
        if (this.valid && 0 !== a.alpha) {
            var d = a.worldTransform;
            d.identity(),
            b && d.append(b);
            for (var e = 0; e < a.children.length; e++)
                a.children[e].updateTransform();
            c && this.textureBuffer.clear();
            var f = this.renderer.resolution;
            this.renderer.resolution = this.resolution,
            this.renderer.renderDisplayObject(a, this.textureBuffer.context, b),
            this.renderer.resolution = f
        }
    }
    ,
    b.RenderTexture.prototype.getImage = function() {
        var a = new Image;
        return a.src = this.getBase64(),
        a
    }
    ,
    b.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL()
    }
    ,
    b.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === b.WEBGL_RENDERER) {
            var a = this.renderer.gl
              , c = this.textureBuffer.width
              , d = this.textureBuffer.height
              , e = new Uint8Array(4 * c * d);
            a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer),
            a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e),
            a.bindFramebuffer(a.FRAMEBUFFER, null);
            var f = new b.CanvasBuffer(c,d)
              , g = f.context.getImageData(0, 0, c, d);
            return g.data.set(e),
            f.context.putImageData(g, 0, 0),
            f.canvas
        }
        return this.textureBuffer.canvas
    }
    ,
    b.AbstractFilter = function(a, b) {
        this.passes = [this],
        this.shaders = [],
        this.dirty = !0,
        this.padding = 0,
        this.uniforms = b || {},
        this.fragmentSrc = a || []
    }
    ,
    b.AbstractFilter.prototype.constructor = b.AbstractFilter,
    b.AbstractFilter.prototype.syncUniforms = function() {
        for (var a = 0, b = this.shaders.length; a < b; a++)
            this.shaders[a].dirty = !0
    }
    ,
    b.Strip = function(a) {
        b.DisplayObjectContainer.call(this),
        this.texture = a,
        this.uvs = new b.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]),
        this.vertices = new b.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]),
        this.colors = new b.Float32Array([1, 1, 1, 1]),
        this.indices = new b.Uint16Array([0, 1, 2, 3]),
        this.dirty = !0,
        this.blendMode = b.blendModes.NORMAL,
        this.canvasPadding = 0,
        this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP
    }
    ,
    b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype),
    b.Strip.prototype.constructor = b.Strip,
    b.Strip.prototype._renderWebGL = function(a) {
        !this.visible || this.alpha <= 0 || (a.spriteBatch.stop(),
        this._vertexBuffer || this._initWebGL(a),
        a.shaderManager.setShader(a.shaderManager.stripShader),
        this._renderStrip(a),
        a.spriteBatch.start())
    }
    ,
    b.Strip.prototype._initWebGL = function(a) {
        var b = a.gl;
        this._vertexBuffer = b.createBuffer(),
        this._indexBuffer = b.createBuffer(),
        this._uvBuffer = b.createBuffer(),
        this._colorBuffer = b.createBuffer(),
        b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer),
        b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW),
        b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer),
        b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW),
        b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer),
        b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW),
        b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
        b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW)
    }
    ,
    b.Strip.prototype._renderStrip = function(a) {
        var c = a.gl
          , d = a.projection
          , e = a.offset
          , f = a.shaderManager.stripShader
          , g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
        a.blendModeManager.setBlendMode(this.blendMode),
        c.uniformMatrix3fv(f.translationMatrix, !1, this.worldTransform.toArray(!0)),
        c.uniform2f(f.projectionVector, d.x, -d.y),
        c.uniform2f(f.offsetVector, -e.x, -e.y),
        c.uniform1f(f.alpha, this.worldAlpha),
        this.dirty ? (this.dirty = !1,
        c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer),
        c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW),
        c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0),
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer),
        c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW),
        c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0),
        c.activeTexture(c.TEXTURE0),
        this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]),
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer),
        c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW)) : (c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer),
        c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices),
        c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 0, 0),
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer),
        c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, !1, 0, 0),
        c.activeTexture(c.TEXTURE0),
        this.texture.baseTexture._dirty[c.id] ? a.renderer.updateTexture(this.texture.baseTexture) : c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]),
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer)),
        c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0)
    }
    ,
    b.Strip.prototype._renderCanvas = function(a) {
        var c = a.context
          , d = this.worldTransform
          , e = d.tx * a.resolution + a.shakeX
          , f = d.ty * a.resolution + a.shakeY;
        a.roundPixels ? c.setTransform(d.a, d.b, d.c, d.d, 0 | e, 0 | f) : c.setTransform(d.a, d.b, d.c, d.d, e, f),
        this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(c) : this._renderCanvasTriangles(c)
    }
    ,
    b.Strip.prototype._renderCanvasTriangleStrip = function(a) {
        var b = this.vertices
          , c = this.uvs
          , d = b.length / 2;
        this.count++;
        for (var e = 0; e < d - 2; e++) {
            var f = 2 * e;
            this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4)
        }
    }
    ,
    b.Strip.prototype._renderCanvasTriangles = function(a) {
        var b = this.vertices
          , c = this.uvs
          , d = this.indices
          , e = d.length;
        this.count++;
        for (var f = 0; f < e; f += 3) {
            var g = 2 * d[f]
              , h = 2 * d[f + 1]
              , i = 2 * d[f + 2];
            this._renderCanvasDrawTriangle(a, b, c, g, h, i)
        }
    }
    ,
    b.Strip.prototype._renderCanvasDrawTriangle = function(a, b, c, d, e, f) {
        var g = this.texture.baseTexture.source
          , h = this.texture.width
          , i = this.texture.height
          , j = b[d]
          , k = b[e]
          , l = b[f]
          , m = b[d + 1]
          , n = b[e + 1]
          , o = b[f + 1]
          , p = c[d] * h
          , q = c[e] * h
          , r = c[f] * h
          , s = c[d + 1] * i
          , t = c[e + 1] * i
          , u = c[f + 1] * i;
        if (this.canvasPadding > 0) {
            var v = this.canvasPadding / this.worldTransform.a
              , w = this.canvasPadding / this.worldTransform.d
              , x = (j + k + l) / 3
              , y = (m + n + o) / 3
              , z = j - x
              , A = m - y
              , B = Math.sqrt(z * z + A * A);
            j = x + z / B * (B + v),
            m = y + A / B * (B + w),
            z = k - x,
            A = n - y,
            B = Math.sqrt(z * z + A * A),
            k = x + z / B * (B + v),
            n = y + A / B * (B + w),
            z = l - x,
            A = o - y,
            B = Math.sqrt(z * z + A * A),
            l = x + z / B * (B + v),
            o = y + A / B * (B + w)
        }
        a.save(),
        a.beginPath(),
        a.moveTo(j, m),
        a.lineTo(k, n),
        a.lineTo(l, o),
        a.closePath(),
        a.clip();
        var C = p * t + s * r + q * u - t * r - s * q - p * u
          , D = j * t + s * l + k * u - t * l - s * k - j * u
          , E = p * k + j * r + q * l - k * r - j * q - p * l
          , F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u
          , G = m * t + s * o + n * u - t * o - s * n - m * u
          , H = p * n + m * r + q * o - n * r - m * q - p * o
          , I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
        a.transform(D / C, G / C, E / C, H / C, F / C, I / C),
        a.drawImage(g, 0, 0),
        a.restore()
    }
    ,
    b.Strip.prototype.renderStripFlat = function(a) {
        var b = this.context
          , c = a.vertices
          , d = c.length / 2;
        this.count++,
        b.beginPath();
        for (var e = 1; e < d - 2; e++) {
            var f = 2 * e
              , g = c[f]
              , h = c[f + 2]
              , i = c[f + 4]
              , j = c[f + 1]
              , k = c[f + 3]
              , l = c[f + 5];
            b.moveTo(g, j),
            b.lineTo(h, k),
            b.lineTo(i, l)
        }
        b.fillStyle = "#FF0000",
        b.fill(),
        b.closePath()
    }
    ,
    b.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = !0
    }
    ,
    b.Strip.prototype.getBounds = function(a) {
        for (var c = a || this.worldTransform, d = c.a, e = c.b, f = c.c, g = c.d, h = c.tx, i = c.ty, j = -1 / 0, k = -1 / 0, l = 1 / 0, m = 1 / 0, n = this.vertices, o = 0, p = n.length; o < p; o += 2) {
            var q = n[o]
              , r = n[o + 1]
              , s = d * q + f * r + h
              , t = g * r + e * q + i;
            l = s < l ? s : l,
            m = t < m ? t : m,
            j = s > j ? s : j,
            k = t > k ? t : k
        }
        if (l === -1 / 0 || k === 1 / 0)
            return b.EmptyRectangle;
        var u = this._bounds;
        return u.x = l,
        u.width = j - l,
        u.y = m,
        u.height = k - m,
        this._currentBounds = u,
        u
    }
    ,
    b.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    },
    b.Rope = function(a, c) {
        b.Strip.call(this, a),
        this.points = c,
        this.vertices = new b.Float32Array(4 * c.length),
        this.uvs = new b.Float32Array(4 * c.length),
        this.colors = new b.Float32Array(2 * c.length),
        this.indices = new b.Uint16Array(2 * c.length),
        this.refresh()
    }
    ,
    b.Rope.prototype = Object.create(b.Strip.prototype),
    b.Rope.prototype.constructor = b.Rope,
    b.Rope.prototype.refresh = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var b = this.uvs
              , d = (a[0],
            this.indices)
              , e = this.colors;
            this.count -= .2,
            b[0] = 0,
            b[1] = 0,
            b[2] = 0,
            b[3] = 1,
            e[0] = 1,
            e[1] = 1,
            d[0] = 0,
            d[1] = 1;
            for (var g, h, i, f = a.length, j = 1; j < f; j++)
                g = a[j],
                h = 4 * j,
                i = j / (f - 1),
                b[h] = i,
                b[h + 1] = 0,
                b[h + 2] = i,
                b[h + 3] = 1,
                h = 2 * j,
                e[h] = 1,
                e[h + 1] = 1,
                h = 2 * j,
                d[h] = h,
                d[h + 1] = h + 1,
                g
        }
    }
    ,
    b.Rope.prototype.updateTransform = function() {
        var a = this.points;
        if (!(a.length < 1)) {
            var d, c = a[0], e = {
                x: 0,
                y: 0
            };
            this.count -= .2;
            for (var h, i, j, k, l, f = this.vertices, g = a.length, m = 0; m < g; m++)
                h = a[m],
                i = 4 * m,
                d = m < a.length - 1 ? a[m + 1] : h,
                e.y = -(d.x - c.x),
                e.x = d.y - c.y,
                j = 10 * (1 - m / (g - 1)),
                j > 1 && (j = 1),
                k = Math.sqrt(e.x * e.x + e.y * e.y),
                l = this.texture.height / 2,
                e.x /= k,
                e.y /= k,
                e.x *= l,
                e.y *= l,
                f[i] = h.x + e.x,
                f[i + 1] = h.y + e.y,
                f[i + 2] = h.x - e.x,
                f[i + 3] = h.y - e.y,
                c = h;
            b.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
    }
    ,
    b.Rope.prototype.setTexture = function(a) {
        this.texture = a
    }
    ,
    b.TilingSprite = function(a, c, d) {
        b.Sprite.call(this, a),
        this._width = c || 128,
        this._height = d || 128,
        this.tileScale = new b.Point(1,1),
        this.tileScaleOffset = new b.Point(1,1),
        this.tilePosition = new b.Point,
        this.renderable = !0,
        this.tint = 16777215,
        this.textureDebug = !1,
        this.blendMode = b.blendModes.NORMAL,
        this.canvasBuffer = null,
        this.tilingTexture = null,
        this.tilePattern = null,
        this.refreshTexture = !0,
        this.frameWidth = 0,
        this.frameHeight = 0
    }
    ,
    b.TilingSprite.prototype = Object.create(b.Sprite.prototype),
    b.TilingSprite.prototype.constructor = b.TilingSprite,
    b.TilingSprite.prototype.setTexture = function(a) {
        this.texture !== a && (this.texture = a,
        this.refreshTexture = !0,
        this.cachedTint = 16777215)
    }
    ,
    b.TilingSprite.prototype._renderWebGL = function(a) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (a.spriteBatch.stop(),
            a.maskManager.pushMask(this.mask, a),
            a.spriteBatch.start()),
            this._filters && (a.spriteBatch.flush(),
            a.filterManager.pushFilter(this._filterBlock)),
            this.refreshTexture) {
                if (this.generateTilingTexture(!0, a),
                !this.tilingTexture)
                    return;
                this.tilingTexture.needsUpdate && (a.renderer.updateTexture(this.tilingTexture.baseTexture),
                this.tilingTexture.needsUpdate = !1)
            }
            a.spriteBatch.renderTilingSprite(this);
            for (var b = 0; b < this.children.length; b++)
                this.children[b]._renderWebGL(a);
            a.spriteBatch.stop(),
            this._filters && a.filterManager.popFilter(),
            this._mask && a.maskManager.popMask(this._mask, a),
            a.spriteBatch.start()
        }
    }
    ,
    b.TilingSprite.prototype._renderCanvas = function(a) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var c = a.context;
            this._mask && a.maskManager.pushMask(this._mask, a),
            c.globalAlpha = this.worldAlpha;
            var d = this.worldTransform
              , e = a.resolution
              , f = d.tx * e + a.shakeX
              , g = d.ty * e + a.shakeY;
            if (c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, f, g),
            this.refreshTexture) {
                if (this.generateTilingTexture(!1, a),
                !this.tilingTexture)
                    return;
                this.tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            }
            var h = a.currentBlendMode;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode,
            c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode]);
            var i = this.tilePosition
              , j = this.tileScale;
            i.x %= this.tilingTexture.baseTexture.width,
            i.y %= this.tilingTexture.baseTexture.height,
            c.scale(j.x, j.y),
            c.translate(i.x + this.anchor.x * -this._width, i.y + this.anchor.y * -this._height),
            c.fillStyle = this.tilePattern;
            var f = -i.x
              , g = -i.y
              , k = this._width / j.x
              , l = this._height / j.y;
            a.roundPixels && (f |= 0,
            g |= 0,
            k |= 0,
            l |= 0),
            c.fillRect(f, g, k, l),
            c.scale(1 / j.x, 1 / j.y),
            c.translate(-i.x + this.anchor.x * this._width, -i.y + this.anchor.y * this._height),
            this._mask && a.maskManager.popMask(a);
            for (var m = 0; m < this.children.length; m++)
                this.children[m]._renderCanvas(a);
            h !== this.blendMode && (a.currentBlendMode = h,
            c.globalCompositeOperation = b.blendModesCanvas[h])
        }
    }
    ,
    b.TilingSprite.prototype.onTextureUpdate = function() {}
    ,
    b.TilingSprite.prototype.generateTilingTexture = function(a, c) {
        if (this.texture.baseTexture.hasLoaded) {
            var d = this.texture
              , e = d.frame
              , f = this._frame.sourceSizeW || this._frame.width
              , g = this._frame.sourceSizeH || this._frame.height
              , h = 0
              , i = 0;
            this._frame.trimmed && (h = this._frame.spriteSourceSizeX,
            i = this._frame.spriteSourceSizeY),
            a && (f = b.getNextPowerOfTwo(f),
            g = b.getNextPowerOfTwo(g)),
            this.canvasBuffer ? (this.canvasBuffer.resize(f, g),
            this.tilingTexture.baseTexture.width = f,
            this.tilingTexture.baseTexture.height = g,
            this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new b.CanvasBuffer(f,g),
            this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas),
            this.tilingTexture.isTiling = !0,
            this.tilingTexture.needsUpdate = !0),
            this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00",
            this.canvasBuffer.context.strokeRect(0, 0, f, g));
            var j = d.crop.width
              , k = d.crop.height;
            j === f && k === g || (j = f,
            k = g),
            this.canvasBuffer.context.drawImage(d.baseTexture.source, d.crop.x, d.crop.y, d.crop.width, d.crop.height, h, i, j, k),
            this.tileScaleOffset.x = e.width / f,
            this.tileScaleOffset.y = e.height / g,
            this.refreshTexture = !1,
            this.tilingTexture.baseTexture._powerOf2 = !0
        }
    }
    ,
    b.TilingSprite.prototype.getBounds = function() {
        var a = this._width
          , b = this._height
          , c = a * (1 - this.anchor.x)
          , d = a * -this.anchor.x
          , e = b * (1 - this.anchor.y)
          , f = b * -this.anchor.y
          , g = this.worldTransform
          , h = g.a
          , i = g.b
          , j = g.c
          , k = g.d
          , l = g.tx
          , m = g.ty
          , n = h * d + j * f + l
          , o = k * f + i * d + m
          , p = h * c + j * f + l
          , q = k * f + i * c + m
          , r = h * c + j * e + l
          , s = k * e + i * c + m
          , t = h * d + j * e + l
          , u = k * e + i * d + m
          , v = -1 / 0
          , w = -1 / 0
          , x = 1 / 0
          , y = 1 / 0;
        x = n < x ? n : x,
        x = p < x ? p : x,
        x = r < x ? r : x,
        x = t < x ? t : x,
        y = o < y ? o : y,
        y = q < y ? q : y,
        y = s < y ? s : y,
        y = u < y ? u : y,
        v = n > v ? n : v,
        v = p > v ? p : v,
        v = r > v ? r : v,
        v = t > v ? t : v,
        w = o > w ? o : w,
        w = q > w ? q : w,
        w = s > w ? s : w,
        w = u > w ? u : w;
        var z = this._bounds;
        return z.x = x,
        z.width = v - x,
        z.y = y,
        z.height = w - y,
        this._currentBounds = z,
        z
    }
    ,
    b.TilingSprite.prototype.destroy = function() {
        b.Sprite.prototype.destroy.call(this),
        this.canvasBuffer && (this.canvasBuffer.destroy(),
        this.canvasBuffer = null),
        this.tileScale = null,
        this.tileScaleOffset = null,
        this.tilePosition = null,
        this.tilingTexture && (this.tilingTexture.destroy(!0),
        this.tilingTexture = null)
    }
    ,
    Object.defineProperty(b.TilingSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(a) {
            this._width = a
        }
    }),
    Object.defineProperty(b.TilingSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(a) {
            this._height = a
        }
    }),
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = b),
    exports.PIXI = b) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
        return a.PIXI = b
    }()) : a.PIXI = b,
    b
}
.call(this),
function() {
    function d(a, b) {
        this._scaleFactor = a,
        this._deltaMode = b,
        this.originalEvent = null
    }
    var a = this
      , b = b || {
        VERSION: "2.6.2",
        GAMES: [],
        AUTO: 0,
        CANVAS: 1,
        WEBGL: 2,
        HEADLESS: 3,
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        UP: 3,
        DOWN: 4,
        SPRITE: 0,
        BUTTON: 1,
        IMAGE: 2,
        GRAPHICS: 3,
        TEXT: 4,
        TILESPRITE: 5,
        BITMAPTEXT: 6,
        GROUP: 7,
        RENDERTEXTURE: 8,
        TILEMAP: 9,
        TILEMAPLAYER: 10,
        EMITTER: 11,
        POLYGON: 12,
        BITMAPDATA: 13,
        CANVAS_FILTER: 14,
        WEBGL_FILTER: 15,
        ELLIPSE: 16,
        SPRITEBATCH: 17,
        RETROFONT: 18,
        POINTER: 19,
        ROPE: 20,
        CIRCLE: 21,
        RECTANGLE: 22,
        LINE: 23,
        MATRIX: 24,
        POINT: 25,
        ROUNDEDRECTANGLE: 26,
        CREATURE: 27,
        VIDEO: 28,
        PENDING_ATLAS: -1,
        HORIZONTAL: 0,
        VERTICAL: 1,
        LANDSCAPE: 0,
        PORTRAIT: 1,
        ANGLE_UP: 270,
        ANGLE_DOWN: 90,
        ANGLE_LEFT: 180,
        ANGLE_RIGHT: 0,
        ANGLE_NORTH_EAST: 315,
        ANGLE_NORTH_WEST: 225,
        ANGLE_SOUTH_EAST: 45,
        ANGLE_SOUTH_WEST: 135,
        TOP_LEFT: 0,
        TOP_CENTER: 1,
        TOP_RIGHT: 2,
        LEFT_TOP: 3,
        LEFT_CENTER: 4,
        LEFT_BOTTOM: 5,
        CENTER: 6,
        RIGHT_TOP: 7,
        RIGHT_CENTER: 8,
        RIGHT_BOTTOM: 9,
        BOTTOM_LEFT: 10,
        BOTTOM_CENTER: 11,
        BOTTOM_RIGHT: 12,
        blendModes: {
            NORMAL: 0,
            ADD: 1,
            MULTIPLY: 2,
            SCREEN: 3,
            OVERLAY: 4,
            DARKEN: 5,
            LIGHTEN: 6,
            COLOR_DODGE: 7,
            COLOR_BURN: 8,
            HARD_LIGHT: 9,
            SOFT_LIGHT: 10,
            DIFFERENCE: 11,
            EXCLUSION: 12,
            HUE: 13,
            SATURATION: 14,
            COLOR: 15,
            LUMINOSITY: 16
        },
        scaleModes: {
            DEFAULT: 0,
            LINEAR: 0,
            NEAREST: 1
        },
        PIXI: PIXI || {}
    };
    if (Math.trunc || (Math.trunc = function(b) {
        return b < 0 ? Math.ceil(b) : Math.floor(b)
    }
    ),
    Function.prototype.bind || (Function.prototype.bind = function() {
        var a = Array.prototype.slice;
        return function(b) {
            function e() {
                var f = d.concat(a.call(arguments));
                c.apply(this instanceof e ? this : b, f)
            }
            var c = this
              , d = a.call(arguments, 1);
            if ("function" != typeof c)
                throw new TypeError;
            return e.prototype = function a(b) {
                if (b && (a.prototype = b),
                !(this instanceof a))
                    return new a
            }(c.prototype),
            e
        }
    }()),
    Array.isArray || (Array.isArray = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a)
    }
    ),
    Array.prototype.forEach || (Array.prototype.forEach = function(a) {
        "use strict";
        if (void 0 === this || null === this)
            throw new TypeError;
        var b = Object(this)
          , c = b.length >>> 0;
        if ("function" != typeof a)
            throw new TypeError;
        for (var d = arguments.length >= 2 ? arguments[1] : void 0, e = 0; e < c; e++)
            e in b && a.call(d, b[e], e, b)
    }
    ),
    "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
        var c = function(a) {
            var b = new Array;
            window[a] = function(a) {
                if ("number" == typeof a) {
                    Array.call(this, a),
                    this.length = a;
                    for (var b = 0; b < this.length; b++)
                        this[b] = 0
                } else {
                    Array.call(this, a.length),
                    this.length = a.length;
                    for (var b = 0; b < this.length; b++)
                        this[b] = a[b]
                }
            }
            ,
            window[a].prototype = b,
            window[a].constructor = window[a]
        };
        c("Uint32Array"),
        c("Int16Array")
    }
    window.console || (window.console = {},
    window.console.log = window.console.assert = function() {}
    ,
    window.console.warn = window.console.assert = function() {}
    ),
    b.Utils = {
        reverseString: function(a) {
            return a.split("").reverse().join("")
        },
        getProperty: function(a, b) {
            for (var c = b.split("."), d = c.pop(), e = c.length, f = 1, g = c[0]; f < e && (a = a[g]); )
                g = c[f],
                f++;
            return a ? a[d] : null
        },
        setProperty: function(a, b, c) {
            for (var d = b.split("."), e = d.pop(), f = d.length, g = 1, h = d[0]; g < f && (a = a[h]); )
                h = d[g],
                g++;
            return a && (a[e] = c),
            a
        },
        chanceRoll: function(a) {
            return void 0 === a && (a = 50),
            a > 0 && 100 * Math.random() <= a
        },
        randomChoice: function(a, b) {
            return Math.random() < .5 ? a : b
        },
        parseDimension: function(a, b) {
            var c = 0
              , d = 0;
            return "string" == typeof a ? "%" === a.substr(-1) ? (c = parseInt(a, 10) / 100,
            d = 0 === b ? window.innerWidth * c : window.innerHeight * c) : d = parseInt(a, 10) : d = a,
            d
        },
        pad: function(a, b, c, d) {
            if (void 0 === b)
                var b = 0;
            if (void 0 === c)
                var c = " ";
            if (void 0 === d)
                var d = 3;
            a = a.toString();
            var e = 0;
            if (b + 1 >= a.length)
                switch (d) {
                case 1:
                    a = new Array(b + 1 - a.length).join(c) + a;
                    break;
                case 3:
                    var f = Math.ceil((e = b - a.length) / 2)
                      , g = e - f;
                    a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
                    break;
                default:
                    a += new Array(b + 1 - a.length).join(c)
                }
            return a
        },
        isPlainObject: function(a) {
            if ("object" != typeof a || a.nodeType || a === a.window)
                return !1;
            try {
                if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf"))
                    return !1
            } catch (a) {
                return !1
            }
            return !0
        },
        extend: function() {
            var a, c, d, e, f, g, h = arguments[0] || {}, i = 1, j = arguments.length, k = !1;
            for ("boolean" == typeof h && (k = h,
            h = arguments[1] || {},
            i = 2),
            j === i && (h = this,
            --i); i < j; i++)
                if (null != (a = arguments[i]))
                    for (c in a)
                        d = h[c],
                        e = a[c],
                        h !== e && (k && e && (b.Utils.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1,
                        g = d && Array.isArray(d) ? d : []) : g = d && b.Utils.isPlainObject(d) ? d : {},
                        h[c] = b.Utils.extend(k, g, e)) : void 0 !== e && (h[c] = e));
            return h
        },
        mixinPrototype: function(a, b, c) {
            void 0 === c && (c = !1);
            for (var d = Object.keys(b), e = 0; e < d.length; e++) {
                var f = d[e]
                  , g = b[f];
                !c && f in a || (!g || "function" != typeof g.get && "function" != typeof g.set ? a[f] = g : "function" == typeof g.clone ? a[f] = g.clone() : Object.defineProperty(a, f, g))
            }
        },
        mixin: function(a, c) {
            if (!a || "object" != typeof a)
                return c;
            for (var d in a) {
                var e = a[d];
                if (!e.childNodes && !e.cloneNode) {
                    var f = typeof a[d];
                    a[d] && "object" === f ? typeof c[d] === f ? c[d] = b.Utils.mixin(a[d], c[d]) : c[d] = b.Utils.mixin(a[d], new e.constructor) : c[d] = a[d]
                }
            }
            return c
        }
    },
    b.Circle = function(a, c, d) {
        a = a || 0,
        c = c || 0,
        d = d || 0,
        this.x = a,
        this.y = c,
        this._diameter = d,
        this._radius = 0,
        d > 0 && (this._radius = .5 * d),
        this.type = b.CIRCLE
    }
    ,
    b.Circle.prototype = {
        circumference: function() {
            return Math.PI * this._radius * 2
        },
        random: function(a) {
            void 0 === a && (a = new b.Point);
            var c = 2 * Math.PI * Math.random()
              , d = Math.random() + Math.random()
              , e = d > 1 ? 2 - d : d
              , f = e * Math.cos(c)
              , g = e * Math.sin(c);
            return a.x = this.x + f * this.radius,
            a.y = this.y + g * this.radius,
            a
        },
        getBounds: function() {
            return new b.Rectangle(this.x - this.radius,this.y - this.radius,this.diameter,this.diameter)
        },
        setTo: function(a, b, c) {
            return this.x = a,
            this.y = b,
            this._diameter = c,
            this._radius = .5 * c,
            this
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.diameter)
        },
        copyTo: function(a) {
            return a.x = this.x,
            a.y = this.y,
            a.diameter = this._diameter,
            a
        },
        distance: function(a, c) {
            var d = b.Math.distance(this.x, this.y, a.x, a.y);
            return c ? Math.round(d) : d
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new b.Circle(this.x,this.y,this.diameter) : a.setTo(this.x, this.y, this.diameter),
            a
        },
        contains: function(a, c) {
            return b.Circle.contains(this, a, c)
        },
        circumferencePoint: function(a, c, d) {
            return b.Circle.circumferencePoint(this, a, c, d)
        },
        offset: function(a, b) {
            return this.x += a,
            this.y += b,
            this
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y)
        },
        toString: function() {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
        }
    },
    b.Circle.prototype.constructor = b.Circle,
    Object.defineProperty(b.Circle.prototype, "diameter", {
        get: function() {
            return this._diameter
        },
        set: function(a) {
            a > 0 && (this._diameter = a,
            this._radius = .5 * a)
        }
    }),
    Object.defineProperty(b.Circle.prototype, "radius", {
        get: function() {
            return this._radius
        },
        set: function(a) {
            a > 0 && (this._radius = a,
            this._diameter = 2 * a)
        }
    }),
    Object.defineProperty(b.Circle.prototype, "left", {
        get: function() {
            return this.x - this._radius
        },
        set: function(a) {
            a > this.x ? (this._radius = 0,
            this._diameter = 0) : this.radius = this.x - a
        }
    }),
    Object.defineProperty(b.Circle.prototype, "right", {
        get: function() {
            return this.x + this._radius
        },
        set: function(a) {
            a < this.x ? (this._radius = 0,
            this._diameter = 0) : this.radius = a - this.x
        }
    }),
    Object.defineProperty(b.Circle.prototype, "top", {
        get: function() {
            return this.y - this._radius
        },
        set: function(a) {
            a > this.y ? (this._radius = 0,
            this._diameter = 0) : this.radius = this.y - a
        }
    }),
    Object.defineProperty(b.Circle.prototype, "bottom", {
        get: function() {
            return this.y + this._radius
        },
        set: function(a) {
            a < this.y ? (this._radius = 0,
            this._diameter = 0) : this.radius = a - this.y
        }
    }),
    Object.defineProperty(b.Circle.prototype, "area", {
        get: function() {
            return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
        }
    }),
    Object.defineProperty(b.Circle.prototype, "empty", {
        get: function() {
            return 0 === this._diameter
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0)
        }
    }),
    b.Circle.contains = function(a, b, c) {
        if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) {
            return (a.x - b) * (a.x - b) + (a.y - c) * (a.y - c) <= a.radius * a.radius
        }
        return !1
    }
    ,
    b.Circle.equals = function(a, b) {
        return a.x === b.x && a.y === b.y && a.diameter === b.diameter
    }
    ,
    b.Circle.intersects = function(a, c) {
        return b.Math.distance(a.x, a.y, c.x, c.y) <= a.radius + c.radius
    }
    ,
    b.Circle.circumferencePoint = function(a, c, d, e) {
        return void 0 === d && (d = !1),
        void 0 === e && (e = new b.Point),
        !0 === d && (c = b.Math.degToRad(c)),
        e.x = a.x + a.radius * Math.cos(c),
        e.y = a.y + a.radius * Math.sin(c),
        e
    }
    ,
    b.Circle.intersectsRectangle = function(a, b) {
        var c = Math.abs(a.x - b.x - b.halfWidth);
        if (c > b.halfWidth + a.radius)
            return !1;
        var e = Math.abs(a.y - b.y - b.halfHeight);
        if (e > b.halfHeight + a.radius)
            return !1;
        if (c <= b.halfWidth || e <= b.halfHeight)
            return !0;
        var g = c - b.halfWidth
          , h = e - b.halfHeight;
        return g * g + h * h <= a.radius * a.radius
    }
    ,
    PIXI.Circle = b.Circle,
    b.Ellipse = function(a, c, d, e) {
        a = a || 0,
        c = c || 0,
        d = d || 0,
        e = e || 0,
        this.x = a,
        this.y = c,
        this.width = d,
        this.height = e,
        this.type = b.ELLIPSE
    }
    ,
    b.Ellipse.prototype = {
        setTo: function(a, b, c, d) {
            return this.x = a,
            this.y = b,
            this.width = c,
            this.height = d,
            this
        },
        getBounds: function() {
            return new b.Rectangle(this.x - this.width,this.y - this.height,this.width,this.height)
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height)
        },
        copyTo: function(a) {
            return a.x = this.x,
            a.y = this.y,
            a.width = this.width,
            a.height = this.height,
            a
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new b.Ellipse(this.x,this.y,this.width,this.height) : a.setTo(this.x, this.y, this.width, this.height),
            a
        },
        contains: function(a, c) {
            return b.Ellipse.contains(this, a, c)
        },
        random: function(a) {
            void 0 === a && (a = new b.Point);
            var c = Math.random() * Math.PI * 2
              , d = Math.random();
            return a.x = Math.sqrt(d) * Math.cos(c),
            a.y = Math.sqrt(d) * Math.sin(c),
            a.x = this.x + a.x * this.width / 2,
            a.y = this.y + a.y * this.height / 2,
            a
        },
        toString: function() {
            return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
        }
    },
    b.Ellipse.prototype.constructor = b.Ellipse,
    Object.defineProperty(b.Ellipse.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(a) {
            this.x = a
        }
    }),
    Object.defineProperty(b.Ellipse.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(a) {
            a < this.x ? this.width = 0 : this.width = a - this.x
        }
    }),
    Object.defineProperty(b.Ellipse.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(a) {
            this.y = a
        }
    }),
    Object.defineProperty(b.Ellipse.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(a) {
            a < this.y ? this.height = 0 : this.height = a - this.y
        }
    }),
    Object.defineProperty(b.Ellipse.prototype, "empty", {
        get: function() {
            return 0 === this.width || 0 === this.height
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0, 0)
        }
    }),
    b.Ellipse.contains = function(a, b, c) {
        if (a.width <= 0 || a.height <= 0)
            return !1;
        var d = (b - a.x) / a.width - .5
          , e = (c - a.y) / a.height - .5;
        return d *= d,
        e *= e,
        d + e < .25
    }
    ,
    PIXI.Ellipse = b.Ellipse,
    b.Line = function(a, c, d, e) {
        a = a || 0,
        c = c || 0,
        d = d || 0,
        e = e || 0,
        this.start = new b.Point(a,c),
        this.end = new b.Point(d,e),
        this.type = b.LINE
    }
    ,
    b.Line.prototype = {
        setTo: function(a, b, c, d) {
            return this.start.setTo(a, b),
            this.end.setTo(c, d),
            this
        },
        fromSprite: function(a, b, c) {
            return void 0 === c && (c = !1),
            c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y)
        },
        fromAngle: function(a, b, c, d) {
            return this.start.setTo(a, b),
            this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d),
            this
        },
        rotate: function(a, b) {
            var c = (this.start.x + this.end.x) / 2
              , d = (this.start.y + this.end.y) / 2;
            return this.start.rotate(c, d, a, b),
            this.end.rotate(c, d, a, b),
            this
        },
        rotateAround: function(a, b, c, d) {
            return this.start.rotate(a, b, c, d),
            this.end.rotate(a, b, c, d),
            this
        },
        intersects: function(a, c, d) {
            return b.Line.intersectsPoints(this.start, this.end, a.start, a.end, c, d)
        },
        reflect: function(a) {
            return b.Line.reflect(this, a)
        },
        midPoint: function(a) {
            return void 0 === a && (a = new b.Point),
            a.x = (this.start.x + this.end.x) / 2,
            a.y = (this.start.y + this.end.y) / 2,
            a
        },
        centerOn: function(a, b) {
            var c = (this.start.x + this.end.x) / 2
              , d = (this.start.y + this.end.y) / 2
              , e = a - c
              , f = b - d;
            this.start.add(e, f),
            this.end.add(e, f)
        },
        pointOnLine: function(a, b) {
            return (a - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (b - this.start.y)
        },
        pointOnSegment: function(a, b) {
            var c = Math.min(this.start.x, this.end.x)
              , d = Math.max(this.start.x, this.end.x)
              , e = Math.min(this.start.y, this.end.y)
              , f = Math.max(this.start.y, this.end.y);
            return this.pointOnLine(a, b) && a >= c && a <= d && b >= e && b <= f
        },
        random: function(a) {
            void 0 === a && (a = new b.Point);
            var c = Math.random();
            return a.x = this.start.x + c * (this.end.x - this.start.x),
            a.y = this.start.y + c * (this.end.y - this.start.y),
            a
        },
        coordinatesOnLine: function(a, b) {
            void 0 === a && (a = 1),
            void 0 === b && (b = []);
            var c = Math.round(this.start.x)
              , d = Math.round(this.start.y)
              , e = Math.round(this.end.x)
              , f = Math.round(this.end.y)
              , g = Math.abs(e - c)
              , h = Math.abs(f - d)
              , i = c < e ? 1 : -1
              , j = d < f ? 1 : -1
              , k = g - h;
            b.push([c, d]);
            for (var l = 1; c !== e || d !== f; ) {
                var m = k << 1;
                m > -h && (k -= h,
                c += i),
                m < g && (k += g,
                d += j),
                l % a == 0 && b.push([c, d]),
                l++
            }
            return b
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new b.Line(this.start.x,this.start.y,this.end.x,this.end.y) : a.setTo(this.start.x, this.start.y, this.end.x, this.end.y),
            a
        }
    },
    Object.defineProperty(b.Line.prototype, "length", {
        get: function() {
            return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
        }
    }),
    Object.defineProperty(b.Line.prototype, "angle", {
        get: function() {
            return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
        }
    }),
    Object.defineProperty(b.Line.prototype, "slope", {
        get: function() {
            return (this.end.y - this.start.y) / (this.end.x - this.start.x)
        }
    }),
    Object.defineProperty(b.Line.prototype, "perpSlope", {
        get: function() {
            return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
        }
    }),
    Object.defineProperty(b.Line.prototype, "x", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    }),
    Object.defineProperty(b.Line.prototype, "y", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    }),
    Object.defineProperty(b.Line.prototype, "left", {
        get: function() {
            return Math.min(this.start.x, this.end.x)
        }
    }),
    Object.defineProperty(b.Line.prototype, "right", {
        get: function() {
            return Math.max(this.start.x, this.end.x)
        }
    }),
    Object.defineProperty(b.Line.prototype, "top", {
        get: function() {
            return Math.min(this.start.y, this.end.y)
        }
    }),
    Object.defineProperty(b.Line.prototype, "bottom", {
        get: function() {
            return Math.max(this.start.y, this.end.y)
        }
    }),
    Object.defineProperty(b.Line.prototype, "width", {
        get: function() {
            return Math.abs(this.start.x - this.end.x)
        }
    }),
    Object.defineProperty(b.Line.prototype, "height", {
        get: function() {
            return Math.abs(this.start.y - this.end.y)
        }
    }),
    Object.defineProperty(b.Line.prototype, "normalX", {
        get: function() {
            return Math.cos(this.angle - 1.5707963267948966)
        }
    }),
    Object.defineProperty(b.Line.prototype, "normalY", {
        get: function() {
            return Math.sin(this.angle - 1.5707963267948966)
        }
    }),
    Object.defineProperty(b.Line.prototype, "normalAngle", {
        get: function() {
            return b.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
        }
    }),
    b.Line.intersectsPoints = function(a, c, d, e, f, g) {
        void 0 === f && (f = !0),
        void 0 === g && (g = new b.Point);
        var h = c.y - a.y
          , i = e.y - d.y
          , j = a.x - c.x
          , k = d.x - e.x
          , l = c.x * a.y - a.x * c.y
          , m = e.x * d.y - d.x * e.y
          , n = h * k - i * j;
        if (0 === n)
            return null;
        if (g.x = (j * m - k * l) / n,
        g.y = (i * l - h * m) / n,
        f) {
            var o = (e.y - d.y) * (c.x - a.x) - (e.x - d.x) * (c.y - a.y)
              , p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o
              , q = ((c.x - a.x) * (a.y - d.y) - (c.y - a.y) * (a.x - d.x)) / o;
            return p >= 0 && p <= 1 && q >= 0 && q <= 1 ? g : null
        }
        return g
    }
    ,
    b.Line.intersects = function(a, c, d, e) {
        return b.Line.intersectsPoints(a.start, a.end, c.start, c.end, d, e)
    }
    ,
    b.Line.intersectsRectangle = function(a, c) {
        if (!b.Rectangle.intersects(a, c))
            return !1;
        var d = a.start.x
          , e = a.start.y
          , f = a.end.x
          , g = a.end.y
          , h = c.x
          , i = c.y
          , j = c.right
          , k = c.bottom
          , l = 0;
        if (d >= h && d <= j && e >= i && e <= k || f >= h && f <= j && g >= i && g <= k)
            return !0;
        if (d < h && f >= h) {
            if ((l = e + (g - e) * (h - d) / (f - d)) > i && l <= k)
                return !0
        } else if (d > j && f <= j && (l = e + (g - e) * (j - d) / (f - d)) >= i && l <= k)
            return !0;
        if (e < i && g >= i) {
            if ((l = d + (f - d) * (i - e) / (g - e)) >= h && l <= j)
                return !0
        } else if (e > k && g <= k && (l = d + (f - d) * (k - e) / (g - e)) >= h && l <= j)
            return !0;
        return !1
    }
    ,
    b.Line.reflect = function(a, b) {
        return 2 * b.normalAngle - 3.141592653589793 - a.angle
    }
    ,
    b.Matrix = function(a, c, d, e, f, g) {
        void 0 !== a && null !== a || (a = 1),
        void 0 !== c && null !== c || (c = 0),
        void 0 !== d && null !== d || (d = 0),
        void 0 !== e && null !== e || (e = 1),
        void 0 !== f && null !== f || (f = 0),
        void 0 !== g && null !== g || (g = 0),
        this.a = a,
        this.b = c,
        this.c = d,
        this.d = e,
        this.tx = f,
        this.ty = g,
        this.type = b.MATRIX
    }
    ,
    b.Matrix.prototype = {
        fromArray: function(a) {
            return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5])
        },
        setTo: function(a, b, c, d, e, f) {
            return this.a = a,
            this.b = b,
            this.c = c,
            this.d = d,
            this.tx = e,
            this.ty = f,
            this
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new b.Matrix(this.a,this.b,this.c,this.d,this.tx,this.ty) : (a.a = this.a,
            a.b = this.b,
            a.c = this.c,
            a.d = this.d,
            a.tx = this.tx,
            a.ty = this.ty),
            a
        },
        copyTo: function(a) {
            return a.copyFrom(this),
            a
        },
        copyFrom: function(a) {
            return this.a = a.a,
            this.b = a.b,
            this.c = a.c,
            this.d = a.d,
            this.tx = a.tx,
            this.ty = a.ty,
            this
        },
        toArray: function(a, b) {
            return void 0 === b && (b = new PIXI.Float32Array(9)),
            a ? (b[0] = this.a,
            b[1] = this.b,
            b[2] = 0,
            b[3] = this.c,
            b[4] = this.d,
            b[5] = 0,
            b[6] = this.tx,
            b[7] = this.ty,
            b[8] = 1) : (b[0] = this.a,
            b[1] = this.c,
            b[2] = this.tx,
            b[3] = this.b,
            b[4] = this.d,
            b[5] = this.ty,
            b[6] = 0,
            b[7] = 0,
            b[8] = 1),
            b
        },
        apply: function(a, c) {
            return void 0 === c && (c = new b.Point),
            c.x = this.a * a.x + this.c * a.y + this.tx,
            c.y = this.b * a.x + this.d * a.y + this.ty,
            c
        },
        applyInverse: function(a, c) {
            void 0 === c && (c = new b.Point);
            var d = 1 / (this.a * this.d + this.c * -this.b)
              , e = a.x
              , f = a.y;
            return c.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d,
            c.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d,
            c
        },
        translate: function(a, b) {
            return this.tx += a,
            this.ty += b,
            this
        },
        scale: function(a, b) {
            return this.a *= a,
            this.d *= b,
            this.c *= a,
            this.b *= b,
            this.tx *= a,
            this.ty *= b,
            this
        },
        rotate: function(a) {
            var b = Math.cos(a)
              , c = Math.sin(a)
              , d = this.a
              , e = this.c
              , f = this.tx;
            return this.a = d * b - this.b * c,
            this.b = d * c + this.b * b,
            this.c = e * b - this.d * c,
            this.d = e * c + this.d * b,
            this.tx = f * b - this.ty * c,
            this.ty = f * c + this.ty * b,
            this
        },
        append: function(a) {
            var b = this.a
              , c = this.b
              , d = this.c
              , e = this.d;
            return this.a = a.a * b + a.b * d,
            this.b = a.a * c + a.b * e,
            this.c = a.c * b + a.d * d,
            this.d = a.c * c + a.d * e,
            this.tx = a.tx * b + a.ty * d + this.tx,
            this.ty = a.tx * c + a.ty * e + this.ty,
            this
        },
        identity: function() {
            return this.setTo(1, 0, 0, 1, 0, 0)
        }
    },
    b.identityMatrix = new b.Matrix,
    PIXI.Matrix = b.Matrix,
    PIXI.identityMatrix = b.identityMatrix,
    b.Point = function(a, c) {
        a = a || 0,
        c = c || 0,
        this.x = a,
        this.y = c,
        this.type = b.POINT
    }
    ,
    b.Point.prototype = {
        copyFrom: function(a) {
            return this.setTo(a.x, a.y)
        },
        invert: function() {
            return this.setTo(this.y, this.x)
        },
        setTo: function(a, b) {
            return this.x = a || 0,
            this.y = b || (0 !== b ? this.x : 0),
            this
        },
        set: function(a, b) {
            return this.x = a || 0,
            this.y = b || (0 !== b ? this.x : 0),
            this
        },
        add: function(a, b) {
            return this.x += a,
            this.y += b,
            this
        },
        subtract: function(a, b) {
            return this.x -= a,
            this.y -= b,
            this
        },
        multiply: function(a, b) {
            return this.x *= a,
            this.y *= b,
            this
        },
        divide: function(a, b) {
            return this.x /= a,
            this.y /= b,
            this
        },
        clampX: function(a, c) {
            return this.x = b.Math.clamp(this.x, a, c),
            this
        },
        clampY: function(a, c) {
            return this.y = b.Math.clamp(this.y, a, c),
            this
        },
        clamp: function(a, c) {
            return this.x = b.Math.clamp(this.x, a, c),
            this.y = b.Math.clamp(this.y, a, c),
            this
        },
        clone: function(a) {
            return void 0 === a || null === a ? a = new b.Point(this.x,this.y) : a.setTo(this.x, this.y),
            a
        },
        copyTo: function(a) {
            return a.x = this.x,
            a.y = this.y,
            a
        },
        distance: function(a, c) {
            return b.Point.distance(this, a, c)
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y
        },
        angle: function(a, c) {
            return void 0 === c && (c = !1),
            c ? b.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x)
        },
        rotate: function(a, c, d, e, f) {
            return b.Point.rotate(this, a, c, d, e, f)
        },
        getMagnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        getMagnitudeSq: function() {
            return this.x * this.x + this.y * this.y
        },
        setMagnitude: function(a) {
            return this.normalize().multiply(a, a)
        },
        normalize: function() {
            if (!this.isZero()) {
                var a = this.getMagnitude();
                this.x /= a,
                this.y /= a
            }
            return this
        },
        isZero: function() {
            return 0 === this.x && 0 === this.y
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        cross: function(a) {
            return this.x * a.y - this.y * a.x
        },
        perp: function() {
            return this.setTo(-this.y, this.x)
        },
        rperp: function() {
            return this.setTo(this.y, -this.x)
        },
        normalRightHand: function() {
            return this.setTo(-1 * this.y, this.x)
        },
        floor: function() {
            return this.setTo(Math.floor(this.x), Math.floor(this.y))
        },
        ceil: function() {
            return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
        },
        toString: function() {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
        }
    },
    b.Point.prototype.constructor = b.Point,
    b.Point.add = function(a, c, d) {
        return void 0 === d && (d = new b.Point),
        d.x = a.x + c.x,
        d.y = a.y + c.y,
        d
    }
    ,
    b.Point.subtract = function(a, c, d) {
        return void 0 === d && (d = new b.Point),
        d.x = a.x - c.x,
        d.y = a.y - c.y,
        d
    }
    ,
    b.Point.multiply = function(a, c, d) {
        return void 0 === d && (d = new b.Point),
        d.x = a.x * c.x,
        d.y = a.y * c.y,
        d
    }
    ,
    b.Point.divide = function(a, c, d) {
        return void 0 === d && (d = new b.Point),
        d.x = a.x / c.x,
        d.y = a.y / c.y,
        d
    }
    ,
    b.Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y
    }
    ,
    b.Point.angle = function(a, b) {
        return Math.atan2(a.y - b.y, a.x - b.x)
    }
    ,
    b.Point.negative = function(a, c) {
        return void 0 === c && (c = new b.Point),
        c.setTo(-a.x, -a.y)
    }
    ,
    b.Point.multiplyAdd = function(a, c, d, e) {
        return void 0 === e && (e = new b.Point),
        e.setTo(a.x + c.x * d, a.y + c.y * d)
    }
    ,
    b.Point.interpolate = function(a, c, d, e) {
        return void 0 === e && (e = new b.Point),
        e.setTo(a.x + (c.x - a.x) * d, a.y + (c.y - a.y) * d)
    }
    ,
    b.Point.perp = function(a, c) {
        return void 0 === c && (c = new b.Point),
        c.setTo(-a.y, a.x)
    }
    ,
    b.Point.rperp = function(a, c) {
        return void 0 === c && (c = new b.Point),
        c.setTo(a.y, -a.x)
    }
    ,
    b.Point.distance = function(a, c, d) {
        var e = b.Math.distance(a.x, a.y, c.x, c.y);
        return d ? Math.round(e) : e
    }
    ,
    b.Point.project = function(a, c, d) {
        void 0 === d && (d = new b.Point);
        var e = a.dot(c) / c.getMagnitudeSq();
        return 0 !== e && d.setTo(e * c.x, e * c.y),
        d
    }
    ,
    b.Point.projectUnit = function(a, c, d) {
        void 0 === d && (d = new b.Point);
        var e = a.dot(c);
        return 0 !== e && d.setTo(e * c.x, e * c.y),
        d
    }
    ,
    b.Point.normalRightHand = function(a, c) {
        return void 0 === c && (c = new b.Point),
        c.setTo(-1 * a.y, a.x)
    }
    ,
    b.Point.normalize = function(a, c) {
        void 0 === c && (c = new b.Point);
        var d = a.getMagnitude();
        return 0 !== d && c.setTo(a.x / d, a.y / d),
        c
    }
    ,
    b.Point.rotate = function(a, c, d, e, f, g) {
        if (f && (e = b.Math.degToRad(e)),
        void 0 === g) {
            a.subtract(c, d);
            var h = Math.sin(e)
              , i = Math.cos(e)
              , j = i * a.x - h * a.y
              , k = h * a.x + i * a.y;
            a.x = j + c,
            a.y = k + d
        } else {
            var l = e + Math.atan2(a.y - d, a.x - c);
            a.x = c + g * Math.cos(l),
            a.y = d + g * Math.sin(l)
        }
        return a
    }
    ,
    b.Point.centroid = function(a, c) {
        if (void 0 === c && (c = new b.Point),
        "[object Array]" !== Object.prototype.toString.call(a))
            throw new Error("Phaser.Point. Parameter 'points' must be an array");
        var d = a.length;
        if (d < 1)
            throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
        if (1 === d)
            return c.copyFrom(a[0]),
            c;
        for (var e = 0; e < d; e++)
            b.Point.add(c, a[e], c);
        return c.divide(d, d),
        c
    }
    ,
    b.Point.parse = function(a, c, d) {
        c = c || "x",
        d = d || "y";
        var e = new b.Point;
        return a[c] && (e.x = parseInt(a[c], 10)),
        a[d] && (e.y = parseInt(a[d], 10)),
        e
    }
    ,
    PIXI.Point = b.Point,
    b.Polygon = function() {
        this.area = 0,
        this._points = [],
        arguments.length > 0 && this.setTo.apply(this, arguments),
        this.closed = !0,
        this.flattened = !1,
        this.type = b.POLYGON
    }
    ,
    b.Polygon.prototype = {
        toNumberArray: function(a) {
            void 0 === a && (a = []);
            for (var b = 0; b < this._points.length; b++)
                "number" == typeof this._points[b] ? (a.push(this._points[b]),
                a.push(this._points[b + 1]),
                b++) : (a.push(this._points[b].x),
                a.push(this._points[b].y));
            return a
        },
        flatten: function() {
            return this._points = this.toNumberArray(),
            this.flattened = !0,
            this
        },
        clone: function(a) {
            var c = this._points.slice();
            return void 0 === a || null === a ? a = new b.Polygon(c) : a.setTo(c),
            a
        },
        contains: function(a, b) {
            var c = !1;
            if (this.flattened)
                for (var d = -2, e = this._points.length - 2; (d += 2) < this._points.length; e = d) {
                    var f = this._points[d]
                      , g = this._points[d + 1]
                      , h = this._points[e]
                      , i = this._points[e + 1];
                    (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c)
                }
            else
                for (var d = -1, e = this._points.length - 1; ++d < this._points.length; e = d) {
                    var f = this._points[d].x
                      , g = this._points[d].y
                      , h = this._points[e].x
                      , i = this._points[e].y;
                    (g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f && (c = !c)
                }
            return c
        },
        setTo: function(a) {
            if (this.area = 0,
            this._points = [],
            arguments.length > 0) {
                Array.isArray(a) || (a = Array.prototype.slice.call(arguments));
                for (var b = Number.MAX_VALUE, c = 0, d = a.length; c < d; c++) {
                    if ("number" == typeof a[c]) {
                        var e = new PIXI.Point(a[c],a[c + 1]);
                        c++
                    } else if (Array.isArray(a[c]))
                        var e = new PIXI.Point(a[c][0],a[c][1]);
                    else
                        var e = new PIXI.Point(a[c].x,a[c].y);
                    this._points.push(e),
                    e.y < b && (b = e.y)
                }
                this.calculateArea(b)
            }
            return this
        },
        calculateArea: function(a) {
            for (var b, c, d, e, f = 0, g = this._points.length; f < g; f++)
                b = this._points[f],
                c = f === g - 1 ? this._points[0] : this._points[f + 1],
                d = (b.y - a + (c.y - a)) / 2,
                e = b.x - c.x,
                this.area += d * e;
            return this.area
        }
    },
    b.Polygon.prototype.constructor = b.Polygon,
    Object.defineProperty(b.Polygon.prototype, "points", {
        get: function() {
            return this._points
        },
        set: function(a) {
            null != a ? this.setTo(a) : this.setTo()
        }
    }),
    PIXI.Polygon = b.Polygon,
    b.Rectangle = function(a, c, d, e) {
        a = a || 0,
        c = c || 0,
        d = d || 0,
        e = e || 0,
        this.x = a,
        this.y = c,
        this.width = d,
        this.height = e,
        this.type = b.RECTANGLE
    }
    ,
    b.Rectangle.prototype = {
        offset: function(a, b) {
            return this.x += a,
            this.y += b,
            this
        },
        offsetPoint: function(a) {
            return this.offset(a.x, a.y)
        },
        setTo: function(a, b, c, d) {
            return this.x = a,
            this.y = b,
            this.width = c,
            this.height = d,
            this
        },
        scale: function(a, b) {
            return void 0 === b && (b = a),
            this.width *= a,
            this.height *= b,
            this
        },
        centerOn: function(a, b) {
            return this.centerX = a,
            this.centerY = b,
            this
        },
        floor: function() {
            this.x = Math.floor(this.x),
            this.y = Math.floor(this.y)
        },
        floorAll: function() {
            this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.width = Math.floor(this.width),
            this.height = Math.floor(this.height)
        },
        ceil: function() {
            this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y)
        },
        ceilAll: function() {
            this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.width = Math.ceil(this.width),
            this.height = Math.ceil(this.height)
        },
        copyFrom: function(a) {
            return this.setTo(a.x, a.y, a.width, a.height)
        },
        copyTo: function(a) {
            return a.x = this.x,
            a.y = this.y,
            a.width = this.width,
            a.height = this.height,
            a
        },
        inflate: function(a, c) {
            return b.Rectangle.inflate(this, a, c)
        },
        size: function(a) {
            return b.Rectangle.size(this, a)
        },
        resize: function(a, b) {
            return this.width = a,
            this.height = b,
            this
        },
        clone: function(a) {
            return b.Rectangle.clone(this, a)
        },
        contains: function(a, c) {
            return b.Rectangle.contains(this, a, c)
        },
        containsRect: function(a) {
            return b.Rectangle.containsRect(a, this)
        },
        equals: function(a) {
            return b.Rectangle.equals(this, a)
        },
        intersection: function(a, c) {
            return b.Rectangle.intersection(this, a, c)
        },
        intersects: function(a) {
            return b.Rectangle.intersects(this, a)
        },
        intersectsRaw: function(a, c, d, e, f) {
            return b.Rectangle.intersectsRaw(this, a, c, d, e, f)
        },
        union: function(a, c) {
            return b.Rectangle.union(this, a, c)
        },
        random: function(a) {
            return void 0 === a && (a = new b.Point),
            a.x = this.randomX,
            a.y = this.randomY,
            a
        },
        getPoint: function(a, c) {
            switch (void 0 === c && (c = new b.Point),
            a) {
            default:
            case b.TOP_LEFT:
                return c.set(this.x, this.y);
            case b.TOP_CENTER:
                return c.set(this.centerX, this.y);
            case b.TOP_RIGHT:
                return c.set(this.right, this.y);
            case b.LEFT_CENTER:
                return c.set(this.x, this.centerY);
            case b.CENTER:
                return c.set(this.centerX, this.centerY);
            case b.RIGHT_CENTER:
                return c.set(this.right, this.centerY);
            case b.BOTTOM_LEFT:
                return c.set(this.x, this.bottom);
            case b.BOTTOM_CENTER:
                return c.set(this.centerX, this.bottom);
            case b.BOTTOM_RIGHT:
                return c.set(this.right, this.bottom)
            }
        },
        toString: function() {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
        }
    },
    Object.defineProperty(b.Rectangle.prototype, "halfWidth", {
        get: function() {
            return Math.round(this.width / 2)
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "halfHeight", {
        get: function() {
            return Math.round(this.height / 2)
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "bottom", {
        get: function() {
            return this.y + this.height
        },
        set: function(a) {
            a <= this.y ? this.height = 0 : this.height = a - this.y
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "bottomLeft", {
        get: function() {
            return new b.Point(this.x,this.bottom)
        },
        set: function(a) {
            this.x = a.x,
            this.bottom = a.y
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "bottomRight", {
        get: function() {
            return new b.Point(this.right,this.bottom)
        },
        set: function(a) {
            this.right = a.x,
            this.bottom = a.y
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "left", {
        get: function() {
            return this.x
        },
        set: function(a) {
            a >= this.right ? this.width = 0 : this.width = this.right - a,
            this.x = a
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "right", {
        get: function() {
            return this.x + this.width
        },
        set: function(a) {
            a <= this.x ? this.width = 0 : this.width = a - this.x
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "volume", {
        get: function() {
            return this.width * this.height
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "perimeter", {
        get: function() {
            return 2 * this.width + 2 * this.height
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "centerX", {
        get: function() {
            return this.x + this.halfWidth
        },
        set: function(a) {
            this.x = a - this.halfWidth
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "centerY", {
        get: function() {
            return this.y + this.halfHeight
        },
        set: function(a) {
            this.y = a - this.halfHeight
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "randomX", {
        get: function() {
            return this.x + Math.random() * this.width
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "randomY", {
        get: function() {
            return this.y + Math.random() * this.height
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "top", {
        get: function() {
            return this.y
        },
        set: function(a) {
            a >= this.bottom ? (this.height = 0,
            this.y = a) : this.height = this.bottom - a
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "topLeft", {
        get: function() {
            return new b.Point(this.x,this.y)
        },
        set: function(a) {
            this.x = a.x,
            this.y = a.y
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "topRight", {
        get: function() {
            return new b.Point(this.x + this.width,this.y)
        },
        set: function(a) {
            this.right = a.x,
            this.y = a.y
        }
    }),
    Object.defineProperty(b.Rectangle.prototype, "empty", {
        get: function() {
            return !this.width || !this.height
        },
        set: function(a) {
            !0 === a && this.setTo(0, 0, 0, 0)
        }
    }),
    b.Rectangle.prototype.constructor = b.Rectangle,
    b.Rectangle.inflate = function(a, b, c) {
        return a.x -= b,
        a.width += 2 * b,
        a.y -= c,
        a.height += 2 * c,
        a
    }
    ,
    b.Rectangle.inflatePoint = function(a, c) {
        return b.Rectangle.inflate(a, c.x, c.y)
    }
    ,
    b.Rectangle.size = function(a, c) {
        return void 0 === c || null === c ? c = new b.Point(a.width,a.height) : c.setTo(a.width, a.height),
        c
    }
    ,
    b.Rectangle.clone = function(a, c) {
        return void 0 === c || null === c ? c = new b.Rectangle(a.x,a.y,a.width,a.height) : c.setTo(a.x, a.y, a.width, a.height),
        c
    }
    ,
    b.Rectangle.contains = function(a, b, c) {
        return !(a.width <= 0 || a.height <= 0) && (b >= a.x && b < a.right && c >= a.y && c < a.bottom)
    }
    ,
    b.Rectangle.containsRaw = function(a, b, c, d, e, f) {
        return e >= a && e < a + c && f >= b && f < b + d
    }
    ,
    b.Rectangle.containsPoint = function(a, c) {
        return b.Rectangle.contains(a, c.x, c.y)
    }
    ,
    b.Rectangle.containsRect = function(a, b) {
        return !(a.volume > b.volume) && (a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom)
    }
    ,
    b.Rectangle.equals = function(a, b) {
        return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
    }
    ,
    b.Rectangle.sameDimensions = function(a, b) {
        return a.width === b.width && a.height === b.height
    }
    ,
    b.Rectangle.intersection = function(a, c, d) {
        return void 0 === d && (d = new b.Rectangle),
        b.Rectangle.intersects(a, c) && (d.x = Math.max(a.x, c.x),
        d.y = Math.max(a.y, c.y),
        d.width = Math.min(a.right, c.right) - d.x,
        d.height = Math.min(a.bottom, c.bottom) - d.y),
        d
    }
    ,
    b.Rectangle.intersects = function(a, b) {
        return !(a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) && !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom)
    }
    ,
    b.Rectangle.intersectsRaw = function(a, b, c, d, e, f) {
        return void 0 === f && (f = 0),
        !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f)
    }
    ,
    b.Rectangle.union = function(a, c, d) {
        return void 0 === d && (d = new b.Rectangle),
        d.setTo(Math.min(a.x, c.x), Math.min(a.y, c.y), Math.max(a.right, c.right) - Math.min(a.left, c.left), Math.max(a.bottom, c.bottom) - Math.min(a.top, c.top))
    }
    ,
    b.Rectangle.aabb = function(a, c) {
        void 0 === c && (c = new b.Rectangle);
        var d = Number.NEGATIVE_INFINITY
          , e = Number.POSITIVE_INFINITY
          , f = Number.NEGATIVE_INFINITY
          , g = Number.POSITIVE_INFINITY;
        return a.forEach(function(a) {
            a.x > d && (d = a.x),
            a.x < e && (e = a.x),
            a.y > f && (f = a.y),
            a.y < g && (g = a.y)
        }),
        c.setTo(e, g, d - e, f - g),
        c
    }
    ,
    PIXI.Rectangle = b.Rectangle,
    PIXI.EmptyRectangle = new b.Rectangle(0,0,0,0),
    b.RoundedRectangle = function(a, c, d, e, f) {
        void 0 === a && (a = 0),
        void 0 === c && (c = 0),
        void 0 === d && (d = 0),
        void 0 === e && (e = 0),
        void 0 === f && (f = 20),
        this.x = a,
        this.y = c,
        this.width = d,
        this.height = e,
        this.radius = f || 20,
        this.type = b.ROUNDEDRECTANGLE
    }
    ,
    b.RoundedRectangle.prototype = {
        clone: function() {
            return new b.RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)
        },
        contains: function(a, b) {
            if (this.width <= 0 || this.height <= 0)
                return !1;
            var c = this.x;
            if (a >= c && a <= c + this.width) {
                var d = this.y;
                if (b >= d && b <= d + this.height)
                    return !0
            }
            return !1
        }
    },
    b.RoundedRectangle.prototype.constructor = b.RoundedRectangle,
    PIXI.RoundedRectangle = b.RoundedRectangle,
    b.Camera = function(a, c, d, e, f, g) {
        this.game = a,
        this.world = a.world,
        this.id = 0,
        this.view = new b.Rectangle(d,e,f,g),
        this.bounds = new b.Rectangle(d,e,f,g),
        this.deadzone = null,
        this.visible = !0,
        this.roundPx = !0,
        this.atLimit = {
            x: !1,
            y: !1
        },
        this.target = null,
        this.displayObject = null,
        this.scale = null,
        this.totalInView = 0,
        this.lerp = new b.Point(1,1),
        this.onShakeComplete = new b.Signal,
        this.onFlashComplete = new b.Signal,
        this.onFadeComplete = new b.Signal,
        this.fx = null,
        this._targetPosition = new b.Point,
        this._edge = 0,
        this._position = new b.Point,
        this._shake = {
            intensity: 0,
            duration: 0,
            horizontal: !1,
            vertical: !1,
            shakeBounds: !0,
            x: 0,
            y: 0
        },
        this._fxDuration = 0,
        this._fxType = 0
    }
    ,
    b.Camera.FOLLOW_LOCKON = 0,
    b.Camera.FOLLOW_PLATFORMER = 1,
    b.Camera.FOLLOW_TOPDOWN = 2,
    b.Camera.FOLLOW_TOPDOWN_TIGHT = 3,
    b.Camera.SHAKE_BOTH = 4,
    b.Camera.SHAKE_HORIZONTAL = 5,
    b.Camera.SHAKE_VERTICAL = 6,
    b.Camera.ENABLE_FX = !0,
    b.Camera.prototype = {
        boot: function() {
            this.displayObject = this.game.world,
            this.scale = this.game.world.scale,
            this.game.camera = this,
            b.Graphics && b.Camera.ENABLE_FX && (this.fx = new b.Graphics(this.game),
            this.game.stage.addChild(this.fx))
        },
        preUpdate: function() {
            this.totalInView = 0
        },
        follow: function(a, c, d, e) {
            void 0 === c && (c = b.Camera.FOLLOW_LOCKON),
            void 0 === d && (d = 1),
            void 0 === e && (e = 1),
            this.target = a,
            this.lerp.set(d, e);
            var f;
            switch (c) {
            case b.Camera.FOLLOW_PLATFORMER:
                var g = this.width / 8
                  , h = this.height / 3;
                this.deadzone = new b.Rectangle((this.width - g) / 2,(this.height - h) / 2 - .25 * h,g,h);
                break;
            case b.Camera.FOLLOW_TOPDOWN:
                f = Math.max(this.width, this.height) / 4,
                this.deadzone = new b.Rectangle((this.width - f) / 2,(this.height - f) / 2,f,f);
                break;
            case b.Camera.FOLLOW_TOPDOWN_TIGHT:
                f = Math.max(this.width, this.height) / 8,
                this.deadzone = new b.Rectangle((this.width - f) / 2,(this.height - f) / 2,f,f);
                break;
            case b.Camera.FOLLOW_LOCKON:
            default:
                this.deadzone = null
            }
        },
        unfollow: function() {
            this.target = null
        },
        focusOn: function(a) {
            this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight))
        },
        focusOnXY: function(a, b) {
            this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight))
        },
        shake: function(a, c, d, e, f) {
            return void 0 === a && (a = .05),
            void 0 === c && (c = 500),
            void 0 === d && (d = !0),
            void 0 === e && (e = b.Camera.SHAKE_BOTH),
            void 0 === f && (f = !0),
            !(!d && this._shake.duration > 0) && (this._shake.intensity = a,
            this._shake.duration = c,
            this._shake.shakeBounds = f,
            this._shake.x = 0,
            this._shake.y = 0,
            this._shake.horizontal = e === b.Camera.SHAKE_BOTH || e === b.Camera.SHAKE_HORIZONTAL,
            this._shake.vertical = e === b.Camera.SHAKE_BOTH || e === b.Camera.SHAKE_VERTICAL,
            !0)
        },
        flash: function(a, b, c) {
            return void 0 === a && (a = 16777215),
            void 0 === b && (b = 500),
            void 0 === c && (c = !1),
            !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(),
            this.fx.beginFill(a),
            this.fx.drawRect(0, 0, this.width, this.height),
            this.fx.endFill(),
            this.fx.alpha = 1,
            this._fxDuration = b,
            this._fxType = 0,
            !0)
        },
        fade: function(a, b, c) {
            return void 0 === a && (a = 0),
            void 0 === b && (b = 500),
            void 0 === c && (c = !1),
            !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(),
            this.fx.beginFill(a),
            this.fx.drawRect(0, 0, this.width, this.height),
            this.fx.endFill(),
            this.fx.alpha = 0,
            this._fxDuration = b,
            this._fxType = 1,
            !0)
        },
        update: function() {
            this._fxDuration > 0 && this.updateFX(),
            this._shake.duration > 0 && this.updateShake(),
            this.bounds && this.checkBounds(),
            this.roundPx && (this.view.floor(),
            this._shake.x = Math.floor(this._shake.x),
            this._shake.y = Math.floor(this._shake.y)),
            this.displayObject.position.x = -this.view.x,
            this.displayObject.position.y = -this.view.y
        },
        updateFX: function() {
            0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration,
            this.fx.alpha <= 0 && (this._fxDuration = 0,
            this.fx.alpha = 0,
            this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration,
            this.fx.alpha >= 1 && (this._fxDuration = 0,
            this.fx.alpha = 1,
            this.onFadeComplete.dispatch()))
        },
        updateShake: function() {
            this._shake.duration -= this.game.time.elapsedMS,
            this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(),
            this._shake.x = 0,
            this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width),
            this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
        },
        updateTarget: function() {
            this._targetPosition.x = this.view.x + this.target.worldPosition.x,
            this._targetPosition.y = this.view.y + this.target.worldPosition.y,
            this.deadzone ? (this._edge = this._targetPosition.x - this.view.x,
            this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)),
            this._edge = this._targetPosition.y - this.view.y,
            this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x),
            this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)),
            this.bounds && this.checkBounds(),
            this.roundPx && this.view.floor(),
            this.displayObject.position.x = -this.view.x,
            this.displayObject.position.y = -this.view.y
        },
        setBoundsToWorld: function() {
            this.bounds && this.bounds.copyFrom(this.game.world.bounds)
        },
        checkBounds: function() {
            this.atLimit.x = !1,
            this.atLimit.y = !1;
            var a = this.view.x + this._shake.x
              , b = this.view.right + this._shake.x
              , c = this.view.y + this._shake.y
              , d = this.view.bottom + this._shake.y;
            a <= this.bounds.x * this.scale.x && (this.atLimit.x = !0,
            this.view.x = this.bounds.x * this.scale.x,
            this._shake.shakeBounds || (this._shake.x = 0)),
            b >= this.bounds.right * this.scale.x && (this.atLimit.x = !0,
            this.view.x = this.bounds.right * this.scale.x - this.width,
            this._shake.shakeBounds || (this._shake.x = 0)),
            c <= this.bounds.top * this.scale.y && (this.atLimit.y = !0,
            this.view.y = this.bounds.top * this.scale.y,
            this._shake.shakeBounds || (this._shake.y = 0)),
            d >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0,
            this.view.y = this.bounds.bottom * this.scale.y - this.height,
            this._shake.shakeBounds || (this._shake.y = 0))
        },
        setPosition: function(a, b) {
            this.view.x = a,
            this.view.y = b,
            this.bounds && this.checkBounds()
        },
        setSize: function(a, b) {
            this.view.width = a,
            this.view.height = b
        },
        reset: function() {
            this.target = null,
            this.view.x = 0,
            this.view.y = 0,
            this._shake.duration = 0,
            this.resetFX()
        },
        resetFX: function() {
            this.fx.clear(),
            this.fx.alpha = 0,
            this._fxDuration = 0
        }
    },
    b.Camera.prototype.constructor = b.Camera,
    Object.defineProperty(b.Camera.prototype, "x", {
        get: function() {
            return this.view.x
        },
        set: function(a) {
            this.view.x = a,
            this.bounds && this.checkBounds()
        }
    }),
    Object.defineProperty(b.Camera.prototype, "y", {
        get: function() {
            return this.view.y
        },
        set: function(a) {
            this.view.y = a,
            this.bounds && this.checkBounds()
        }
    }),
    Object.defineProperty(b.Camera.prototype, "position", {
        get: function() {
            return this._position.set(this.view.x, this.view.y),
            this._position
        },
        set: function(a) {
            void 0 !== a.x && (this.view.x = a.x),
            void 0 !== a.y && (this.view.y = a.y),
            this.bounds && this.checkBounds()
        }
    }),
    Object.defineProperty(b.Camera.prototype, "width", {
        get: function() {
            return this.view.width
        },
        set: function(a) {
            this.view.width = a
        }
    }),
    Object.defineProperty(b.Camera.prototype, "height", {
        get: function() {
            return this.view.height
        },
        set: function(a) {
            this.view.height = a
        }
    }),
    Object.defineProperty(b.Camera.prototype, "shakeIntensity", {
        get: function() {
            return this._shake.intensity
        },
        set: function(a) {
            this._shake.intensity = a
        }
    }),
    b.State = function() {
        this.game = null,
        this.key = "",
        this.add = null,
        this.make = null,
        this.camera = null,
        this.cache = null,
        this.input = null,
        this.load = null,
        this.math = null,
        this.sound = null,
        this.scale = null,
        this.stage = null,
        this.state = null,
        this.time = null,
        this.tweens = null,
        this.world = null,
        this.particles = null,
        this.physics = null,
        this.rnd = null
    }
    ,
    b.State.prototype = {
        init: function() {},
        preload: function() {},
        loadUpdate: function() {},
        loadRender: function() {},
        create: function() {},
        update: function() {},
        preRender: function() {},
        render: function() {},
        resize: function() {},
        paused: function() {},
        resumed: function() {},
        pauseUpdate: function() {},
        shutdown: function() {}
    },
    b.State.prototype.constructor = b.State,
    b.StateManager = function(a, c) {
        this.game = a,
        this.states = {},
        this._pendingState = null,
        void 0 !== c && null !== c && (this._pendingState = c),
        this._clearWorld = !1,
        this._clearCache = !1,
        this._created = !1,
        this._args = [],
        this.current = "",
        this.onStateChange = new b.Signal,
        this.onInitCallback = null,
        this.onPreloadCallback = null,
        this.onCreateCallback = null,
        this.onUpdateCallback = null,
        this.onRenderCallback = null,
        this.onResizeCallback = null,
        this.onPreRenderCallback = null,
        this.onLoadUpdateCallback = null,
        this.onLoadRenderCallback = null,
        this.onPausedCallback = null,
        this.onResumedCallback = null,
        this.onPauseUpdateCallback = null,
        this.onShutDownCallback = null
    }
    ,
    b.StateManager.prototype = {
        boot: function() {
            this.game.onPause.add(this.pause, this),
            this.game.onResume.add(this.resume, this),
            null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
        },
        add: function(a, c, d) {
            void 0 === d && (d = !1);
            var e;
            return c instanceof b.State ? e = c : "object" == typeof c ? (e = c,
            e.game = this.game) : "function" == typeof c && (e = new c(this.game)),
            this.states[a] = e,
            d && (this.game.isBooted ? this.start(a) : this._pendingState = a),
            e
        },
        remove: function(a) {
            this.current === a && (this.callbackContext = null,
            this.onInitCallback = null,
            this.onShutDownCallback = null,
            this.onPreloadCallback = null,
            this.onLoadRenderCallback = null,
            this.onLoadUpdateCallback = null,
            this.onCreateCallback = null,
            this.onUpdateCallback = null,
            this.onPreRenderCallback = null,
            this.onRenderCallback = null,
            this.onResizeCallback = null,
            this.onPausedCallback = null,
            this.onResumedCallback = null,
            this.onPauseUpdateCallback = null),
            delete this.states[a]
        },
        start: function(a, b, c) {
            void 0 === b && (b = !0),
            void 0 === c && (c = !1),
            this.checkState(a) && (this._pendingState = a,
            this._clearWorld = b,
            this._clearCache = c,
            arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
        },
        restart: function(a, b) {
            void 0 === a && (a = !0),
            void 0 === b && (b = !1),
            this._pendingState = this.current,
            this._clearWorld = a,
            this._clearCache = b,
            arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
        },
        dummy: function() {},
        preUpdate: function() {
            if (this._pendingState && this.game.isBooted) {
                var a = this.current;
                if (this.clearCurrentState(),
                this.setCurrentState(this._pendingState),
                this.onStateChange.dispatch(this.current, a),
                this.current !== this._pendingState)
                    return;
                this._pendingState = null,
                this.onPreloadCallback ? (this.game.load.reset(!0),
                this.onPreloadCallback.call(this.callbackContext, this.game),
                0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
            }
        },
        clearCurrentState: function() {
            this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game),
            this.game.tweens.removeAll(),
            this.game.camera.reset(),
            this.game.input.reset(!0),
            this.game.physics.clear(),
            this.game.time.removeAll(),
            this.game.scale.reset(this._clearWorld),
            this.game.debug && this.game.debug.reset(),
            this._clearWorld && (this.game.world.shutdown(),
            this._clearCache && this.game.cache.destroy()))
        },
        checkState: function(a) {
            return this.states[a] ? !!(this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"),
            !1) : (console.warn("Phaser.StateManager - No state found with the key: " + a),
            !1)
        },
        link: function(a) {
            this.states[a].game = this.game,
            this.states[a].add = this.game.add,
            this.states[a].make = this.game.make,
            this.states[a].camera = this.game.camera,
            this.states[a].cache = this.game.cache,
            this.states[a].input = this.game.input,
            this.states[a].load = this.game.load,
            this.states[a].math = this.game.math,
            this.states[a].sound = this.game.sound,
            this.states[a].scale = this.game.scale,
            this.states[a].state = this,
            this.states[a].stage = this.game.stage,
            this.states[a].time = this.game.time,
            this.states[a].tweens = this.game.tweens,
            this.states[a].world = this.game.world,
            this.states[a].particles = this.game.particles,
            this.states[a].rnd = this.game.rnd,
            this.states[a].physics = this.game.physics,
            this.states[a].key = a
        },
        unlink: function(a) {
            this.states[a] && (this.states[a].game = null,
            this.states[a].add = null,
            this.states[a].make = null,
            this.states[a].camera = null,
            this.states[a].cache = null,
            this.states[a].input = null,
            this.states[a].load = null,
            this.states[a].math = null,
            this.states[a].sound = null,
            this.states[a].scale = null,
            this.states[a].state = null,
            this.states[a].stage = null,
            this.states[a].time = null,
            this.states[a].tweens = null,
            this.states[a].world = null,
            this.states[a].particles = null,
            this.states[a].rnd = null,
            this.states[a].physics = null)
        },
        setCurrentState: function(a) {
            this.callbackContext = this.states[a],
            this.link(a),
            this.onInitCallback = this.states[a].init || this.dummy,
            this.onPreloadCallback = this.states[a].preload || null,
            this.onLoadRenderCallback = this.states[a].loadRender || null,
            this.onLoadUpdateCallback = this.states[a].loadUpdate || null,
            this.onCreateCallback = this.states[a].create || null,
            this.onUpdateCallback = this.states[a].update || null,
            this.onPreRenderCallback = this.states[a].preRender || null,
            this.onRenderCallback = this.states[a].render || null,
            this.onResizeCallback = this.states[a].resize || null,
            this.onPausedCallback = this.states[a].paused || null,
            this.onResumedCallback = this.states[a].resumed || null,
            this.onPauseUpdateCallback = this.states[a].pauseUpdate || null,
            this.onShutDownCallback = this.states[a].shutdown || this.dummy,
            "" !== this.current && this.game.physics.reset(),
            this.current = a,
            this._created = !1,
            this.onInitCallback.apply(this.callbackContext, this._args),
            a === this._pendingState && (this._args = []),
            this.game._kickstart = !0
        },
        getCurrentState: function() {
            return this.states[this.current]
        },
        loadComplete: function() {
            !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game),
            !1 === this._created && this.onCreateCallback ? (this._created = !0,
            this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
        },
        pause: function() {
            this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
        },
        resume: function() {
            this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
        },
        update: function() {
            this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        pauseUpdate: function() {
            this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
        },
        preRender: function(a) {
            this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, a)
        },
        resize: function(a, b) {
            this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, a, b)
        },
        render: function() {
            this._created ? this.onRenderCallback && (this.game.renderType === b.CANVAS ? (this.game.context.save(),
            this.game.context.setTransform(1, 0, 0, 1, 0, 0),
            this.onRenderCallback.call(this.callbackContext, this.game),
            this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
        },
        destroy: function() {
            this._clearWorld = !0,
            this._clearCache = !0,
            this.clearCurrentState(),
            this.callbackContext = null,
            this.onInitCallback = null,
            this.onShutDownCallback = null,
            this.onPreloadCallback = null,
            this.onLoadRenderCallback = null,
            this.onLoadUpdateCallback = null,
            this.onCreateCallback = null,
            this.onUpdateCallback = null,
            this.onRenderCallback = null,
            this.onPausedCallback = null,
            this.onResumedCallback = null,
            this.onPauseUpdateCallback = null,
            this.game = null,
            this.states = {},
            this._pendingState = null,
            this.current = ""
        }
    },
    b.StateManager.prototype.constructor = b.StateManager,
    Object.defineProperty(b.StateManager.prototype, "created", {
        get: function() {
            return this._created
        }
    }),
    b.Signal = function() {}
    ,
    b.Signal.prototype = {
        _bindings: null,
        _prevParams: null,
        memorize: !1,
        _shouldPropagate: !0,
        active: !0,
        _boundDispatch: !1,
        validateListener: function(a, b) {
            if ("function" != typeof a)
                throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b))
        },
        _registerListener: function(a, c, d, e, f) {
            var h, g = this._indexOfListener(a, d);
            if (-1 !== g) {
                if (h = this._bindings[g],
                h.isOnce() !== c)
                    throw new Error("You cannot add" + (c ? "" : "Once") + "() then add" + (c ? "Once" : "") + "() the same listener without removing the relationship first.")
            } else
                h = new b.SignalBinding(this,a,c,d,e,f),
                this._addBinding(h);
            return this.memorize && this._prevParams && h.execute(this._prevParams),
            h
        },
        _addBinding: function(a) {
            this._bindings || (this._bindings = []);
            var b = this._bindings.length;
            do {
                b--
            } while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
            this._bindings.splice(b + 1, 0, a)
        },
        _indexOfListener: function(a, b) {
            if (!this._bindings)
                return -1;
            void 0 === b && (b = null);
            for (var d, c = this._bindings.length; c--; )
                if (d = this._bindings[c],
                d._listener === a && d.context === b)
                    return c;
            return -1
        },
        has: function(a, b) {
            return -1 !== this._indexOfListener(a, b)
        },
        add: function(a, b, c) {
            this.validateListener(a, "add");
            var d = [];
            if (arguments.length > 3)
                for (var e = 3; e < arguments.length; e++)
                    d.push(arguments[e]);
            return this._registerListener(a, !1, b, c, d)
        },
        addOnce: function(a, b, c) {
            this.validateListener(a, "addOnce");
            var d = [];
            if (arguments.length > 3)
                for (var e = 3; e < arguments.length; e++)
                    d.push(arguments[e]);
            return this._registerListener(a, !0, b, c, d)
        },
        remove: function(a, b) {
            this.validateListener(a, "remove");
            var c = this._indexOfListener(a, b);
            return -1 !== c && (this._bindings[c]._destroy(),
            this._bindings.splice(c, 1)),
            a
        },
        removeAll: function(a) {
            if (void 0 === a && (a = null),
            this._bindings) {
                for (var b = this._bindings.length; b--; )
                    a ? this._bindings[b].context === a && (this._bindings[b]._destroy(),
                    this._bindings.splice(b, 1)) : this._bindings[b]._destroy();
                a || (this._bindings.length = 0)
            }
        },
        getNumListeners: function() {
            return this._bindings ? this._bindings.length : 0
        },
        halt: function() {
            this._shouldPropagate = !1
        },
        dispatch: function() {
            if (this.active && this._bindings) {
                var c, a = Array.prototype.slice.call(arguments), b = this._bindings.length;
                if (this.memorize && (this._prevParams = a),
                b) {
                    c = this._bindings.slice(),
                    this._shouldPropagate = !0;
                    do {
                        b--
                    } while (c[b] && this._shouldPropagate && !1 !== c[b].execute(a))
                }
            }
        },
        forget: function() {
            this._prevParams && (this._prevParams = null)
        },
        dispose: function() {
            this.removeAll(),
            this._bindings = null,
            this._prevParams && (this._prevParams = null)
        },
        toString: function() {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
        }
    },
    Object.defineProperty(b.Signal.prototype, "boundDispatch", {
        get: function() {
            var a = this;
            return this._boundDispatch || (this._boundDispatch = function() {
                return a.dispatch.apply(a, arguments)
            }
            )
        }
    }),
    b.Signal.prototype.constructor = b.Signal,
    b.SignalBinding = function(a, b, c, d, e, f) {
        this._listener = b,
        c && (this._isOnce = !0),
        null != d && (this.context = d),
        this._signal = a,
        e && (this._priority = e),
        f && f.length && (this._args = f)
    }
    ,
    b.SignalBinding.prototype = {
        context: null,
        _isOnce: !1,
        _priority: 0,
        _args: null,
        callCount: 0,
        active: !0,
        params: null,
        execute: function(a) {
            var b, c;
            return this.active && this._listener && (c = this.params ? this.params.concat(a) : a,
            this._args && (c = c.concat(this._args)),
            b = this._listener.apply(this.context, c),
            this.callCount++,
            this._isOnce && this.detach()),
            b
        },
        detach: function() {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null
        },
        isBound: function() {
            return !!this._signal && !!this._listener
        },
        isOnce: function() {
            return this._isOnce
        },
        getListener: function() {
            return this._listener
        },
        getSignal: function() {
            return this._signal
        },
        _destroy: function() {
            delete this._signal,
            delete this._listener,
            delete this.context
        },
        toString: function() {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
        }
    },
    b.SignalBinding.prototype.constructor = b.SignalBinding,
    b.Filter = function(a, c, d) {
        this.game = a,
        this.type = b.WEBGL_FILTER,
        this.passes = [this],
        this.shaders = [],
        this.dirty = !0,
        this.padding = 0,
        this.prevPoint = new b.Point;
        var e = new Date;
        if (this.uniforms = {
            resolution: {
                type: "2f",
                value: {
                    x: 256,
                    y: 256
                }
            },
            time: {
                type: "1f",
                value: 0
            },
            mouse: {
                type: "2f",
                value: {
                    x: 0,
                    y: 0
                }
            },
            date: {
                type: "4fv",
                value: [e.getFullYear(), e.getMonth(), e.getDate(), 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds()]
            },
            sampleRate: {
                type: "1f",
                value: 44100
            },
            iChannel0: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel1: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel2: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            },
            iChannel3: {
                type: "sampler2D",
                value: null,
                textureData: {
                    repeat: !0
                }
            }
        },
        c)
            for (var f in c)
                this.uniforms[f] = c[f];
        this.fragmentSrc = d || ""
    }
    ,
    b.Filter.prototype = {
        init: function() {},
        setResolution: function(a, b) {
            this.uniforms.resolution.value.x = a,
            this.uniforms.resolution.value.y = b
        },
        update: function(a) {
            if (void 0 !== a) {
                var b = a.x / this.game.width
                  , c = 1 - a.y / this.game.height;
                b === this.prevPoint.x && c === this.prevPoint.y || (this.uniforms.mouse.value.x = b.toFixed(2),
                this.uniforms.mouse.value.y = c.toFixed(2),
                this.prevPoint.set(b, c))
            }
            this.uniforms.time.value = this.game.time.totalElapsedSeconds()
        },
        addToWorld: function(a, b, c, d, e, f) {
            void 0 === e && (e = 0),
            void 0 === f && (f = 0),
            void 0 !== c && null !== c ? this.width = c : c = this.width,
            void 0 !== d && null !== d ? this.height = d : d = this.height;
            var g = this.game.add.image(a, b, "__default");
            return g.width = c,
            g.height = d,
            g.anchor.set(e, f),
            g.filters = [this],
            g
        },
        destroy: function() {
            this.game = null
        }
    },
    b.Filter.prototype.constructor = b.Filter,
    Object.defineProperty(b.Filter.prototype, "width", {
        get: function() {
            return this.uniforms.resolution.value.x
        },
        set: function(a) {
            this.uniforms.resolution.value.x = a
        }
    }),
    Object.defineProperty(b.Filter.prototype, "height", {
        get: function() {
            return this.uniforms.resolution.value.y
        },
        set: function(a) {
            this.uniforms.resolution.value.y = a
        }
    }),
    b.Plugin = function(a, b) {
        void 0 === b && (b = null),
        this.game = a,
        this.parent = b,
        this.active = !1,
        this.visible = !1,
        this.hasPreUpdate = !1,
        this.hasUpdate = !1,
        this.hasPostUpdate = !1,
        this.hasRender = !1,
        this.hasPostRender = !1
    }
    ,
    b.Plugin.prototype = {
        preUpdate: function() {},
        update: function() {},
        render: function() {},
        postRender: function() {},
        destroy: function() {
            this.game = null,
            this.parent = null,
            this.active = !1,
            this.visible = !1
        }
    },
    b.Plugin.prototype.constructor = b.Plugin,
    b.PluginManager = function(a) {
        this.game = a,
        this.plugins = [],
        this._len = 0,
        this._i = 0
    }
    ,
    b.PluginManager.prototype = {
        add: function(a) {
            var b = Array.prototype.slice.call(arguments, 1)
              , c = !1;
            return "function" == typeof a ? a = new a(this.game,this) : (a.game = this.game,
            a.parent = this),
            "function" == typeof a.preUpdate && (a.hasPreUpdate = !0,
            c = !0),
            "function" == typeof a.update && (a.hasUpdate = !0,
            c = !0),
            "function" == typeof a.postUpdate && (a.hasPostUpdate = !0,
            c = !0),
            "function" == typeof a.render && (a.hasRender = !0,
            c = !0),
            "function" == typeof a.postRender && (a.hasPostRender = !0,
            c = !0),
            c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = !0),
            (a.hasRender || a.hasPostRender) && (a.visible = !0),
            this._len = this.plugins.push(a),
            "function" == typeof a.init && a.init.apply(a, b),
            a) : null
        },
        remove: function(a, b) {
            for (void 0 === b && (b = !0),
            this._i = this._len; this._i--; )
                if (this.plugins[this._i] === a)
                    return b && a.destroy(),
                    this.plugins.splice(this._i, 1),
                    void this._len--
        },
        removeAll: function() {
            for (this._i = this._len; this._i--; )
                this.plugins[this._i].destroy();
            this.plugins.length = 0,
            this._len = 0
        },
        preUpdate: function() {
            for (this._i = this._len; this._i--; )
                this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
        },
        update: function() {
            for (this._i = this._len; this._i--; )
                this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
        },
        postUpdate: function() {
            for (this._i = this._len; this._i--; )
                this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
        },
        render: function() {
            for (this._i = this._len; this._i--; )
                this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
        },
        postRender: function() {
            for (this._i = this._len; this._i--; )
                this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
        },
        destroy: function() {
            this.removeAll(),
            this.game = null
        }
    },
    b.PluginManager.prototype.constructor = b.PluginManager,
    b.Stage = function(a) {
        this.game = a,
        PIXI.DisplayObjectContainer.call(this),
        this.name = "_stage_root",
        this.disableVisibilityChange = !1,
        this.exists = !0,
        this.worldTransform = new PIXI.Matrix,
        this.stage = this,
        this.currentRenderOrderID = 0,
        this._hiddenVar = "hidden",
        this._onChange = null,
        this._bgColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            color: 0,
            rgba: "#000000"
        },
        this.game.transparent || (this._bgColor.a = 1),
        a.config && this.parseConfig(a.config)
    }
    ,
    b.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    b.Stage.prototype.constructor = b.Stage,
    b.Stage.prototype.parseConfig = function(a) {
        a.disableVisibilityChange && (this.disableVisibilityChange = a.disableVisibilityChange),
        a.backgroundColor && this.setBackgroundColor(a.backgroundColor)
    }
    ,
    b.Stage.prototype.boot = function() {
        b.DOM.getOffset(this.game.canvas, this.offset),
        b.Canvas.setUserSelect(this.game.canvas, "none"),
        b.Canvas.setTouchAction(this.game.canvas, "none"),
        this.checkVisibility()
    }
    ,
    b.Stage.prototype.preUpdate = function() {
        this.currentRenderOrderID = 0;
        for (var a = 0; a < this.children.length; a++)
            this.children[a].preUpdate()
    }
    ,
    b.Stage.prototype.update = function() {
        for (var a = this.children.length; a--; )
            this.children[a].update()
    }
    ,
    b.Stage.prototype.postUpdate = function() {
        this.game.camera.update(),
        this.game.camera.target && (this.game.camera.target.postUpdate(),
        this.updateTransform(),
        this.game.camera.updateTarget());
        for (var a = 0; a < this.children.length; a++)
            this.children[a].postUpdate();
        this.updateTransform()
    }
    ,
    b.Stage.prototype.updateTransform = function() {
        this.worldAlpha = 1;
        for (var a = 0; a < this.children.length; a++)
            this.children[a].updateTransform()
    }
    ,
    b.Stage.prototype.checkVisibility = function() {
        void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
        var a = this;
        this._onChange = function(b) {
            return a.visibilityChange(b)
        }
        ,
        this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1),
        window.onblur = this._onChange,
        window.onfocus = this._onChange,
        window.onpagehide = this._onChange,
        window.onpageshow = this._onChange,
        this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
            b.Stage.prototype.visibilityChange.call(a, {
                type: "pause"
            })
        }),
        CocoonJS.App.onActivated.addEventListener(function() {
            b.Stage.prototype.visibilityChange.call(a, {
                type: "resume"
            })
        }))
    }
    ,
    b.Stage.prototype.visibilityChange = function(a) {
        if ("pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type)
            return void ("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : "pageshow" !== a.type && "focus" !== a.type || this.game.focusGain(a));
        this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type ? this.game.gamePaused(a) : this.game.gameResumed(a))
    }
    ,
    b.Stage.prototype.setBackgroundColor = function(a) {
        this.game.transparent || (b.Color.valueToColor(a, this._bgColor),
        b.Color.updateColor(this._bgColor),
        this._bgColor.r /= 255,
        this._bgColor.g /= 255,
        this._bgColor.b /= 255,
        this._bgColor.a = 1)
    }
    ,
    b.Stage.prototype.destroy = function() {
        this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1),
        window.onpagehide = null,
        window.onpageshow = null,
        window.onblur = null,
        window.onfocus = null
    }
    ,
    Object.defineProperty(b.Stage.prototype, "backgroundColor", {
        get: function() {
            return this._bgColor.color
        },
        set: function(a) {
            this.setBackgroundColor(a)
        }
    }),
    Object.defineProperty(b.Stage.prototype, "smoothed", {
        get: function() {
            return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
        },
        set: function(a) {
            PIXI.scaleModes.DEFAULT = a ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
        }
    }),
    b.Group = function(a, c, d, e, f, g) {
        void 0 === e && (e = !1),
        void 0 === f && (f = !1),
        void 0 === g && (g = b.Physics.ARCADE),
        this.game = a,
        void 0 === c && (c = a.world),
        this.name = d || "group",
        this.z = 0,
        PIXI.DisplayObjectContainer.call(this),
        e ? (this.game.stage.addChild(this),
        this.z = this.game.stage.children.length) : c && (c.addChild(this),
        this.z = c.children.length),
        this.type = b.GROUP,
        this.physicsType = b.GROUP,
        this.alive = !0,
        this.exists = !0,
        this.ignoreDestroy = !1,
        this.pendingDestroy = !1,
        this.classType = b.Sprite,
        this.cursor = null,
        this.inputEnableChildren = !1,
        this.onChildInputDown = new b.Signal,
        this.onChildInputUp = new b.Signal,
        this.onChildInputOver = new b.Signal,
        this.onChildInputOut = new b.Signal,
        this.enableBody = f,
        this.enableBodyDebug = !1,
        this.physicsBodyType = g,
        this.physicsSortDirection = null,
        this.onDestroy = new b.Signal,
        this.cursorIndex = 0,
        this.fixedToCamera = !1,
        this.cameraOffset = new b.Point,
        this.hash = [],
        this._sortProperty = "z"
    }
    ,
    b.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    b.Group.prototype.constructor = b.Group,
    b.Group.RETURN_NONE = 0,
    b.Group.RETURN_TOTAL = 1,
    b.Group.RETURN_CHILD = 2,
    b.Group.RETURN_ALL = 3,
    b.Group.SORT_ASCENDING = -1,
    b.Group.SORT_DESCENDING = 1,
    b.Group.prototype.add = function(a, b, c) {
        return void 0 === b && (b = !1),
        a.parent === this ? a : (a.body && a.parent && a.parent.hash && a.parent.removeFromHash(a),
        void 0 === c ? (a.z = this.children.length,
        this.addChild(a)) : (this.addChildAt(a, c),
        this.updateZ()),
        this.enableBody && a.hasOwnProperty("body") && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a),
        !this.inputEnableChildren || a.input && !a.inputEnabled || (a.inputEnabled = !0),
        !b && a.events && a.events.onAddedToGroup$dispatch(a, this),
        null === this.cursor && (this.cursor = a),
        a)
    }
    ,
    b.Group.prototype.addAt = function(a, b, c) {
        this.add(a, c, b)
    }
    ,
    b.Group.prototype.addToHash = function(a) {
        if (a.parent === this) {
            if (-1 === this.hash.indexOf(a))
                return this.hash.push(a),
                !0
        }
        return !1
    }
    ,
    b.Group.prototype.removeFromHash = function(a) {
        if (a) {
            var b = this.hash.indexOf(a);
            if (-1 !== b)
                return this.hash.splice(b, 1),
                !0
        }
        return !1
    }
    ,
    b.Group.prototype.addMultiple = function(a, c) {
        if (a instanceof b.Group)
            a.moveAll(this, c);
        else if (Array.isArray(a))
            for (var d = 0; d < a.length; d++)
                this.add(a[d], c);
        return a
    }
    ,
    b.Group.prototype.getAt = function(a) {
        return a < 0 || a >= this.children.length ? -1 : this.getChildAt(a)
    }
    ,
    b.Group.prototype.create = function(a, b, c, d, e, f) {
        void 0 === e && (e = !0);
        var g = new this.classType(this.game,a,b,c,d);
        return g.exists = e,
        g.visible = e,
        g.alive = e,
        this.add(g, !1, f)
    }
    ,
    b.Group.prototype.createMultiple = function(a, b, c, d) {
        void 0 === c && (c = 0),
        void 0 === d && (d = !1),
        Array.isArray(b) || (b = [b]),
        Array.isArray(c) || (c = [c]);
        var e = this
          , f = [];
        return b.forEach(function(b) {
            c.forEach(function(c) {
                for (var g = 0; g < a; g++)
                    f.push(e.create(0, 0, b, c, d))
            })
        }),
        f
    }
    ,
    b.Group.prototype.updateZ = function() {
        for (var a = this.children.length; a--; )
            this.children[a].z = a
    }
    ,
    b.Group.prototype.align = function(a, c, d, e, f, g) {
        if (void 0 === f && (f = b.TOP_LEFT),
        void 0 === g && (g = 0),
        0 === this.children.length || g > this.children.length || -1 === a && -1 === c)
            return !1;
        for (var h = new b.Rectangle(0,0,d,e), i = a * d, j = c * e, k = g; k < this.children.length; k++) {
            var l = this.children[k];
            if (l.alignIn)
                if (l.alignIn(h, f),
                -1 === a)
                    h.y += e,
                    h.y === j && (h.x += d,
                    h.y = 0);
                else if (-1 === c)
                    h.x += d,
                    h.x === i && (h.x = 0,
                    h.y += e);
                else if (h.x += d,
                h.x === i && (h.x = 0,
                h.y += e,
                h.y === j))
                    return !0
        }
        return !0
    }
    ;
    b.Group.prototype.resetCursor = function(a) {
        if (void 0 === a && (a = 0),
        a > this.children.length - 1 && (a = 0),
        this.cursor)
            return this.cursorIndex = a,
            this.cursor = this.children[this.cursorIndex],
            this.cursor
    }
    ,
    b.Group.prototype.next = function() {
        if (this.cursor)
            return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++,
            this.cursor = this.children[this.cursorIndex],
            this.cursor
    }
    ,
    b.Group.prototype.previous = function() {
        if (this.cursor)
            return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--,
            this.cursor = this.children[this.cursorIndex],
            this.cursor
    }
    ,
    b.Group.prototype.swap = function(a, b) {
        this.swapChildren(a, b),
        this.updateZ()
    }
    ,
    b.Group.prototype.bringToTop = function(a) {
        return a.parent === this && this.getIndex(a) < this.children.length && (this.remove(a, !1, !0),
        this.add(a, !0)),
        a
    }
    ,
    b.Group.prototype.sendToBack = function(a) {
        return a.parent === this && this.getIndex(a) > 0 && (this.remove(a, !1, !0),
        this.addAt(a, 0, !0)),
        a
    }
    ,
    b.Group.prototype.moveUp = function(a) {
        if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
            var b = this.getIndex(a)
              , c = this.getAt(b + 1);
            c && this.swap(a, c)
        }
        return a
    }
    ,
    b.Group.prototype.moveDown = function(a) {
        if (a.parent === this && this.getIndex(a) > 0) {
            var b = this.getIndex(a)
              , c = this.getAt(b - 1);
            c && this.swap(a, c)
        }
        return a
    }
    ,
    b.Group.prototype.xy = function(a, b, c) {
        if (a < 0 || a > this.children.length)
            return -1;
        this.getChildAt(a).x = b,
        this.getChildAt(a).y = c
    }
    ,
    b.Group.prototype.reverse = function() {
        this.children.reverse(),
        this.updateZ()
    }
    ,
    b.Group.prototype.getIndex = function(a) {
        return this.children.indexOf(a)
    }
    ,
    b.Group.prototype.getByName = function(a) {
        for (var b = 0; b < this.children.length; b++)
            if (this.children[b].name === a)
                return this.children[b];
        return null
    }
    ,
    b.Group.prototype.replace = function(a, c) {
        var d = this.getIndex(a);
        if (-1 !== d)
            return c.parent && (c.parent instanceof b.Group ? c.parent.remove(c) : c.parent.removeChild(c)),
            this.remove(a),
            this.addAt(c, d),
            a
    }
    ,
    b.Group.prototype.hasProperty = function(a, b) {
        var c = b.length;
        return 1 === c && b[0]in a || (2 === c && b[0]in a && b[1]in a[b[0]] || (3 === c && b[0]in a && b[1]in a[b[0]] && b[2]in a[b[0]][b[1]] || 4 === c && b[0]in a && b[1]in a[b[0]] && b[2]in a[b[0]][b[1]] && b[3]in a[b[0]][b[1]][b[2]]))
    }
    ,
    b.Group.prototype.setProperty = function(a, b, c, d, e) {
        if (void 0 === e && (e = !1),
        d = d || 0,
        !this.hasProperty(a, b) && (!e || d > 0))
            return !1;
        var f = b.length;
        return 1 === f ? 0 === d ? a[b[0]] = c : 1 === d ? a[b[0]] += c : 2 === d ? a[b[0]] -= c : 3 === d ? a[b[0]] *= c : 4 === d && (a[b[0]] /= c) : 2 === f ? 0 === d ? a[b[0]][b[1]] = c : 1 === d ? a[b[0]][b[1]] += c : 2 === d ? a[b[0]][b[1]] -= c : 3 === d ? a[b[0]][b[1]] *= c : 4 === d && (a[b[0]][b[1]] /= c) : 3 === f ? 0 === d ? a[b[0]][b[1]][b[2]] = c : 1 === d ? a[b[0]][b[1]][b[2]] += c : 2 === d ? a[b[0]][b[1]][b[2]] -= c : 3 === d ? a[b[0]][b[1]][b[2]] *= c : 4 === d && (a[b[0]][b[1]][b[2]] /= c) : 4 === f && (0 === d ? a[b[0]][b[1]][b[2]][b[3]] = c : 1 === d ? a[b[0]][b[1]][b[2]][b[3]] += c : 2 === d ? a[b[0]][b[1]][b[2]][b[3]] -= c : 3 === d ? a[b[0]][b[1]][b[2]][b[3]] *= c : 4 === d && (a[b[0]][b[1]][b[2]][b[3]] /= c)),
        !0
    }
    ,
    b.Group.prototype.checkProperty = function(a, c, d, e) {
        return void 0 === e && (e = !1),
        !(!b.Utils.getProperty(a, c) && e) && b.Utils.getProperty(a, c) === d
    }
    ,
    b.Group.prototype.set = function(a, b, c, d, e, f, g) {
        if (void 0 === g && (g = !1),
        b = b.split("."),
        void 0 === d && (d = !1),
        void 0 === e && (e = !1),
        (!1 === d || d && a.alive) && (!1 === e || e && a.visible))
            return this.setProperty(a, b, c, f, g)
    }
    ,
    b.Group.prototype.setAll = function(a, b, c, d, e, f) {
        void 0 === c && (c = !1),
        void 0 === d && (d = !1),
        void 0 === f && (f = !1),
        a = a.split("."),
        e = e || 0;
        for (var g = 0; g < this.children.length; g++)
            (!c || c && this.children[g].alive) && (!d || d && this.children[g].visible) && this.setProperty(this.children[g], a, b, e, f)
    }
    ,
    b.Group.prototype.setAllChildren = function(a, c, d, e, f, g) {
        void 0 === d && (d = !1),
        void 0 === e && (e = !1),
        void 0 === g && (g = !1),
        f = f || 0;
        for (var h = 0; h < this.children.length; h++)
            (!d || d && this.children[h].alive) && (!e || e && this.children[h].visible) && (this.children[h]instanceof b.Group ? this.children[h].setAllChildren(a, c, d, e, f, g) : this.setProperty(this.children[h], a.split("."), c, f, g))
    }
    ,
    b.Group.prototype.checkAll = function(a, b, c, d, e) {
        void 0 === c && (c = !1),
        void 0 === d && (d = !1),
        void 0 === e && (e = !1);
        for (var f = 0; f < this.children.length; f++)
            if ((!c || c && this.children[f].alive) && (!d || d && this.children[f].visible) && !this.checkProperty(this.children[f], a, b, e))
                return !1;
        return !0
    }
    ,
    b.Group.prototype.addAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 1)
    }
    ,
    b.Group.prototype.subAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 2)
    }
    ,
    b.Group.prototype.multiplyAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 3)
    }
    ,
    b.Group.prototype.divideAll = function(a, b, c, d) {
        this.setAll(a, b, c, d, 4)
    }
    ,
    b.Group.prototype.callAllExists = function(a, b) {
        var c;
        if (arguments.length > 2) {
            c = [];
            for (var d = 2; d < arguments.length; d++)
                c.push(arguments[d])
        }
        for (var d = 0; d < this.children.length; d++)
            this.children[d].exists === b && this.children[d][a] && this.children[d][a].apply(this.children[d], c)
    }
    ,
    b.Group.prototype.callbackFromArray = function(a, b, c) {
        if (1 === c) {
            if (a[b[0]])
                return a[b[0]]
        } else if (2 === c) {
            if (a[b[0]][b[1]])
                return a[b[0]][b[1]]
        } else if (3 === c) {
            if (a[b[0]][b[1]][b[2]])
                return a[b[0]][b[1]][b[2]]
        } else if (4 === c) {
            if (a[b[0]][b[1]][b[2]][b[3]])
                return a[b[0]][b[1]][b[2]][b[3]]
        } else if (a[b])
            return a[b];
        return !1
    }
    ,
    b.Group.prototype.callAll = function(a, b) {
        if (void 0 !== a) {
            a = a.split(".");
            var c = a.length;
            if (void 0 === b || null === b || "" === b)
                b = null;
            else if ("string" == typeof b) {
                b = b.split(".");
                var d = b.length
            }
            var e;
            if (arguments.length > 2) {
                e = [];
                for (var f = 2; f < arguments.length; f++)
                    e.push(arguments[f])
            }
            for (var g = null, h = null, f = 0; f < this.children.length; f++)
                g = this.callbackFromArray(this.children[f], a, c),
                b && g ? (h = this.callbackFromArray(this.children[f], b, d),
                g && g.apply(h, e)) : g && g.apply(this.children[f], e)
        }
    }
    ,
    b.Group.prototype.preUpdate = function() {
        if (this.pendingDestroy)
            return this.destroy(),
            !1;
        if (!this.exists || !this.parent.exists)
            return this.renderOrderID = -1,
            !1;
        for (var a = 0; a < this.children.length; a++)
            this.children[a].preUpdate();
        return !0
    }
    ,
    b.Group.prototype.update = function() {
        for (var a = this.children.length; a--; )
            this.children[a].update()
    }
    ,
    b.Group.prototype.postUpdate = function() {
        this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x,
        this.y = this.game.camera.view.y + this.cameraOffset.y);
        for (var a = 0; a < this.children.length; a++)
            this.children[a].postUpdate()
    }
    ,
    b.Group.prototype.filter = function(a, c) {
        for (var d = -1, e = this.children.length, f = []; ++d < e; ) {
            var g = this.children[d];
            (!c || c && g.exists) && a(g, d, this.children) && f.push(g)
        }
        return new b.ArraySet(f)
    }
    ,
    b.Group.prototype.forEach = function(a, b, c) {
        if (void 0 === c && (c = !1),
        arguments.length <= 3)
            for (var d = 0; d < this.children.length; d++)
                (!c || c && this.children[d].exists) && a.call(b, this.children[d]);
        else {
            for (var e = [null], d = 3; d < arguments.length; d++)
                e.push(arguments[d]);
            for (var d = 0; d < this.children.length; d++)
                (!c || c && this.children[d].exists) && (e[0] = this.children[d],
                a.apply(b, e))
        }
    }
    ,
    b.Group.prototype.forEachExists = function(a, c) {
        var d;
        if (arguments.length > 2) {
            d = [null];
            for (var e = 2; e < arguments.length; e++)
                d.push(arguments[e])
        }
        this.iterate("exists", !0, b.Group.RETURN_TOTAL, a, c, d)
    }
    ,
    b.Group.prototype.forEachAlive = function(a, c) {
        var d;
        if (arguments.length > 2) {
            d = [null];
            for (var e = 2; e < arguments.length; e++)
                d.push(arguments[e])
        }
        this.iterate("alive", !0, b.Group.RETURN_TOTAL, a, c, d)
    }
    ,
    b.Group.prototype.forEachDead = function(a, c) {
        var d;
        if (arguments.length > 2) {
            d = [null];
            for (var e = 2; e < arguments.length; e++)
                d.push(arguments[e])
        }
        this.iterate("alive", !1, b.Group.RETURN_TOTAL, a, c, d)
    }
    ,
    b.Group.prototype.sort = function(a, c) {
        this.children.length < 2 || (void 0 === a && (a = "z"),
        void 0 === c && (c = b.Group.SORT_ASCENDING),
        this._sortProperty = a,
        c === b.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)),
        this.updateZ())
    }
    ,
    b.Group.prototype.customSort = function(a, b) {
        this.children.length < 2 || (this.children.sort(a.bind(b)),
        this.updateZ())
    }
    ,
    b.Group.prototype.ascendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1
    }
    ,
    b.Group.prototype.descendingSortHandler = function(a, b) {
        return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0
    }
    ,
    b.Group.prototype.iterate = function(a, c, d, e, f, g) {
        if (0 === this.children.length) {
            if (d === b.Group.RETURN_TOTAL)
                return 0;
            if (d === b.Group.RETURN_ALL)
                return []
        }
        var h = 0;
        if (d === b.Group.RETURN_ALL)
            var i = [];
        for (var j = 0; j < this.children.length; j++)
            if (this.children[j][a] === c) {
                if (h++,
                e && (g ? (g[0] = this.children[j],
                e.apply(f, g)) : e.call(f, this.children[j])),
                d === b.Group.RETURN_CHILD)
                    return this.children[j];
                d === b.Group.RETURN_ALL && i.push(this.children[j])
            }
        return d === b.Group.RETURN_TOTAL ? h : d === b.Group.RETURN_ALL ? i : null
    }
    ,
    b.Group.prototype.getFirstExists = function(a, c, d, e, f, g) {
        void 0 === c && (c = !1),
        "boolean" != typeof a && (a = !0);
        var h = this.iterate("exists", a, b.Group.RETURN_CHILD);
        return null === h && c ? this.create(d, e, f, g) : this.resetChild(h, d, e, f, g)
    }
    ,
    b.Group.prototype.getFirstAlive = function(a, c, d, e, f) {
        void 0 === a && (a = !1);
        var g = this.iterate("alive", !0, b.Group.RETURN_CHILD);
        return null === g && a ? this.create(c, d, e, f) : this.resetChild(g, c, d, e, f)
    }
    ,
    b.Group.prototype.getFirstDead = function(a, c, d, e, f) {
        void 0 === a && (a = !1);
        var g = this.iterate("alive", !1, b.Group.RETURN_CHILD);
        return null === g && a ? this.create(c, d, e, f) : this.resetChild(g, c, d, e, f)
    }
    ,
    b.Group.prototype.resetChild = function(a, b, c, d, e) {
        return null === a ? null : (void 0 === b && (b = null),
        void 0 === c && (c = null),
        null !== b && null !== c && a.reset(b, c),
        void 0 !== d && a.loadTexture(d, e),
        a)
    }
    ,
    b.Group.prototype.getTop = function() {
        if (this.children.length > 0)
            return this.children[this.children.length - 1]
    }
    ,
    b.Group.prototype.getBottom = function() {
        if (this.children.length > 0)
            return this.children[0]
    }
    ,
    b.Group.prototype.getClosestTo = function(a, c, d) {
        for (var e = Number.MAX_VALUE, f = 0, g = null, h = 0; h < this.children.length; h++) {
            var i = this.children[h];
            i.exists && (f = Math.abs(b.Point.distance(a, i))) < e && (!c || c.call(d, i, f)) && (e = f,
            g = i)
        }
        return g
    }
    ,
    b.Group.prototype.getFurthestFrom = function(a, c, d) {
        for (var e = 0, f = 0, g = null, h = 0; h < this.children.length; h++) {
            var i = this.children[h];
            i.exists && (f = Math.abs(b.Point.distance(a, i))) > e && (!c || c.call(d, i, f)) && (e = f,
            g = i)
        }
        return g
    }
    ,
    b.Group.prototype.countLiving = function() {
        return this.iterate("alive", !0, b.Group.RETURN_TOTAL)
    }
    ,
    b.Group.prototype.countDead = function() {
        return this.iterate("alive", !1, b.Group.RETURN_TOTAL)
    }
    ,
    b.Group.prototype.getRandom = function(a, c) {
        return void 0 === a && (a = 0),
        void 0 === c && (c = this.children.length),
        0 === c ? null : b.ArrayUtils.getRandomItem(this.children, a, c)
    }
    ,
    b.Group.prototype.getRandomExists = function(a, b) {
        var c = this.getAll("exists", !0, a, b);
        return this.game.rnd.pick(c)
    }
    ,
    b.Group.prototype.getAll = function(a, b, c, d) {
        void 0 === c && (c = 0),
        void 0 === d && (d = this.children.length);
        for (var e = [], f = c; f < d; f++) {
            var g = this.children[f];
            a && g[a] === b && e.push(g)
        }
        return e
    }
    ,
    b.Group.prototype.remove = function(a, b, c) {
        if (void 0 === b && (b = !1),
        void 0 === c && (c = !1),
        0 === this.children.length || -1 === this.children.indexOf(a))
            return !1;
        c || !a.events || a.destroyPhase || a.events.onRemovedFromGroup$dispatch(a, this);
        var d = this.removeChild(a);
        return this.removeFromHash(a),
        this.updateZ(),
        this.cursor === a && this.next(),
        b && d && d.destroy(!0),
        !0
    }
    ,
    b.Group.prototype.moveAll = function(a, c) {
        if (void 0 === c && (c = !1),
        this.children.length > 0 && a instanceof b.Group) {
            do {
                a.add(this.children[0], c)
            } while (this.children.length > 0);
            this.hash = [],
            this.cursor = null
        }
        return a
    }
    ,
    b.Group.prototype.removeAll = function(a, b, c) {
        if (void 0 === a && (a = !1),
        void 0 === b && (b = !1),
        void 0 === c && (c = !1),
        0 !== this.children.length) {
            do {
                !b && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                var d = this.removeChild(this.children[0]);
                this.removeFromHash(d),
                a && d && d.destroy(!0, c)
            } while (this.children.length > 0);
            this.hash = [],
            this.cursor = null
        }
    }
    ,
    b.Group.prototype.removeBetween = function(a, b, c, d) {
        if (void 0 === b && (b = this.children.length - 1),
        void 0 === c && (c = !1),
        void 0 === d && (d = !1),
        0 !== this.children.length) {
            if (a > b || a < 0 || b > this.children.length)
                return !1;
            for (var e = b; e >= a; ) {
                !d && this.children[e].events && this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
                var f = this.removeChild(this.children[e]);
                this.removeFromHash(f),
                c && f && f.destroy(!0),
                this.cursor === this.children[e] && (this.cursor = null),
                e--
            }
            this.updateZ()
        }
    }
    ,
    b.Group.prototype.destroy = function(a, b) {
        null === this.game || this.ignoreDestroy || (void 0 === a && (a = !0),
        void 0 === b && (b = !1),
        this.onDestroy.dispatch(this, a, b),
        this.removeAll(a),
        this.cursor = null,
        this.filters = null,
        this.pendingDestroy = !1,
        b || (this.parent && this.parent.removeChild(this),
        this.game = null,
        this.exists = !1))
    }
    ,
    Object.defineProperty(b.Group.prototype, "total", {
        get: function() {
            return this.iterate("exists", !0, b.Group.RETURN_TOTAL)
        }
    }),
    Object.defineProperty(b.Group.prototype, "length", {
        get: function() {
            return this.children.length
        }
    }),
    Object.defineProperty(b.Group.prototype, "angle", {
        get: function() {
            return b.Math.radToDeg(this.rotation)
        },
        set: function(a) {
            this.rotation = b.Math.degToRad(a)
        }
    }),
    Object.defineProperty(b.Group.prototype, "centerX", {
        get: function() {
            return this.getBounds(this.parent).centerX
        },
        set: function(a) {
            var b = this.getBounds(this.parent)
              , c = this.x - b.x;
            this.x = a + c - b.halfWidth
        }
    }),
    Object.defineProperty(b.Group.prototype, "centerY", {
        get: function() {
            return this.getBounds(this.parent).centerY
        },
        set: function(a) {
            var b = this.getBounds(this.parent)
              , c = this.y - b.y;
            this.y = a + c - b.halfHeight
        }
    }),
    Object.defineProperty(b.Group.prototype, "left", {
        get: function() {
            return this.getBounds(this.parent).left
        },
        set: function(a) {
            var b = this.getBounds(this.parent)
              , c = this.x - b.x;
            this.x = a + c
        }
    }),
    Object.defineProperty(b.Group.prototype, "right", {
        get: function() {
            return this.getBounds(this.parent).right
        },
        set: function(a) {
            var b = this.getBounds(this.parent)
              , c = this.x - b.x;
            this.x = a + c - b.width
        }
    }),
    Object.defineProperty(b.Group.prototype, "top", {
        get: function() {
            return this.getBounds(this.parent).top
        },
        set: function(a) {
            var b = this.getBounds(this.parent)
              , c = this.y - b.y;
            this.y = a + c
        }
    }),
    Object.defineProperty(b.Group.prototype, "bottom", {
        get: function() {
            return this.getBounds(this.parent).bottom
        },
        set: function(a) {
            var b = this.getBounds(this.parent)
              , c = this.y - b.y;
            this.y = a + c - b.height
        }
    }),
    b.World = function(a) {
        b.Group.call(this, a, null, "__world", !1),
        this.bounds = new b.Rectangle(0,0,a.width,a.height),
        this.camera = null,
        this._definedSize = !1,
        this._width = a.width,
        this._height = a.height,
        this.game.state.onStateChange.add(this.stateChange, this)
    }
    ,
    b.World.prototype = Object.create(b.Group.prototype),
    b.World.prototype.constructor = b.World,
    b.World.prototype.boot = function() {
        this.camera = new b.Camera(this.game,0,0,0,this.game.width,this.game.height),
        this.game.stage.addChild(this),
        this.camera.boot()
    }
    ,
    b.World.prototype.stateChange = function() {
        this.x = 0,
        this.y = 0,
        this.camera.reset()
    }
    ,
    b.World.prototype.setBounds = function(a, b, c, d) {
        this._definedSize = !0,
        this._width = c,
        this._height = d,
        this.bounds.setTo(a, b, c, d),
        this.x = a,
        this.y = b,
        this.camera.bounds && this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height)),
        this.game.physics.setBoundsToWorld()
    }
    ,
    b.World.prototype.resize = function(a, b) {
        this._definedSize && (a < this._width && (a = this._width),
        b < this._height && (b = this._height)),
        this.bounds.width = a,
        this.bounds.height = b,
        this.game.camera.setBoundsToWorld(),
        this.game.physics.setBoundsToWorld()
    }
    ,
    b.World.prototype.shutdown = function() {
        this.destroy(!0, !0)
    }
    ,
    b.World.prototype.wrap = function(a, b, c, d, e) {
        void 0 === b && (b = 0),
        void 0 === c && (c = !1),
        void 0 === d && (d = !0),
        void 0 === e && (e = !0),
        c ? (a.getBounds(),
        d && (a.x + a._currentBounds.width < this.bounds.x ? a.x = this.bounds.right : a.x > this.bounds.right && (a.x = this.bounds.left)),
        e && (a.y + a._currentBounds.height < this.bounds.top ? a.y = this.bounds.bottom : a.y > this.bounds.bottom && (a.y = this.bounds.top))) : (d && a.x + b < this.bounds.x ? a.x = this.bounds.right + b : d && a.x - b > this.bounds.right && (a.x = this.bounds.left - b),
        e && a.y + b < this.bounds.top ? a.y = this.bounds.bottom + b : e && a.y - b > this.bounds.bottom && (a.y = this.bounds.top - b))
    }
    ,
    Object.defineProperty(b.World.prototype, "width", {
        get: function() {
            return this.bounds.width
        },
        set: function(a) {
            a < this.game.width && (a = this.game.width),
            this.bounds.width = a,
            this._width = a,
            this._definedSize = !0
        }
    }),
    Object.defineProperty(b.World.prototype, "height", {
        get: function() {
            return this.bounds.height
        },
        set: function(a) {
            a < this.game.height && (a = this.game.height),
            this.bounds.height = a,
            this._height = a,
            this._definedSize = !0
        }
    }),
    Object.defineProperty(b.World.prototype, "centerX", {
        get: function() {
            return this.bounds.halfWidth + this.bounds.x
        }
    }),
    Object.defineProperty(b.World.prototype, "centerY", {
        get: function() {
            return this.bounds.halfHeight + this.bounds.y
        }
    }),
    Object.defineProperty(b.World.prototype, "randomX", {
        get: function() {
            return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
        }
    }),
    Object.defineProperty(b.World.prototype, "randomY", {
        get: function() {
            return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
        }
    }),
    b.Game = function(a, c, d, e, f, g, h, i) {
        return this.id = b.GAMES.push(this) - 1,
        this.config = null,
        this.physicsConfig = i,
        this.parent = "",
        this.width = 800,
        this.height = 600,
        this.resolution = 1,
        this._width = 800,
        this._height = 600,
        this.transparent = !1,
        this.antialias = !0,
        this.preserveDrawingBuffer = !1,
        this.clearBeforeRender = !0,
        this.renderer = null,
        this.renderType = b.AUTO,
        this.state = null,
        this.isBooted = !1,
        this.isRunning = !1,
        this.raf = null,
        this.add = null,
        this.make = null,
        this.cache = null,
        this.input = null,
        this.load = null,
        this.math = null,
        this.net = null,
        this.scale = null,
        this.sound = null,
        this.stage = null,
        this.time = null,
        this.tweens = null,
        this.world = null,
        this.physics = null,
        this.plugins = null,
        this.rnd = null,
        this.device = b.Device,
        this.camera = null,
        this.canvas = null,
        this.context = null,
        this.debug = null,
        this.particles = null,
        this.create = null,
        this.lockRender = !1,
        this.stepping = !1,
        this.pendingStep = !1,
        this.stepCount = 0,
        this.onPause = null,
        this.onResume = null,
        this.onBlur = null,
        this.onFocus = null,
        this._paused = !1,
        this._codePaused = !1,
        this.currentUpdateID = 0,
        this.updatesThisFrame = 1,
        this._deltaTime = 0,
        this._lastCount = 0,
        this._spiraling = 0,
        this._kickstart = !0,
        this.fpsProblemNotifier = new b.Signal,
        this.forceSingleUpdate = !0,
        this._nextFpsNotification = 0,
        1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
            enableDebug: !0
        },
        void 0 !== a && (this._width = a),
        void 0 !== c && (this._height = c),
        void 0 !== d && (this.renderType = d),
        void 0 !== e && (this.parent = e),
        void 0 !== g && (this.transparent = g),
        void 0 !== h && (this.antialias = h),
        this.rnd = new b.RandomDataGenerator([(Date.now() * Math.random()).toString()]),
        this.state = new b.StateManager(this,f)),
        this.device.whenReady(this.boot, this),
        this
    }
    ,
    b.Game.prototype = {
        parseConfig: function(a) {
            this.config = a,
            void 0 === a.enableDebug && (this.config.enableDebug = !0),
            a.width && (this._width = a.width),
            a.height && (this._height = a.height),
            a.renderer && (this.renderType = a.renderer),
            a.parent && (this.parent = a.parent),
            void 0 !== a.transparent && (this.transparent = a.transparent),
            void 0 !== a.antialias && (this.antialias = a.antialias),
            a.resolution && (this.resolution = a.resolution),
            void 0 !== a.preserveDrawingBuffer && (this.preserveDrawingBuffer = a.preserveDrawingBuffer),
            a.physicsConfig && (this.physicsConfig = a.physicsConfig);
            var c = [(Date.now() * Math.random()).toString()];
            a.seed && (c = a.seed),
            this.rnd = new b.RandomDataGenerator(c);
            var d = null;
            a.state && (d = a.state),
            this.state = new b.StateManager(this,d)
        },
        boot: function() {
            this.isBooted || (this.onPause = new b.Signal,
            this.onResume = new b.Signal,
            this.onBlur = new b.Signal,
            this.onFocus = new b.Signal,
            this.isBooted = !0,
            PIXI.game = this,
            this.math = b.Math,
            this.scale = new b.ScaleManager(this,this._width,this._height),
            this.stage = new b.Stage(this),
            this.setUpRenderer(),
            this.world = new b.World(this),
            this.add = new b.GameObjectFactory(this),
            this.make = new b.GameObjectCreator(this),
            this.cache = new b.Cache(this),
            this.load = new b.Loader(this),
            this.time = new b.Time(this),
            this.tweens = new b.TweenManager(this),
            this.input = new b.Input(this),
            this.sound = new b.SoundManager(this),
            this.physics = new b.Physics(this,this.physicsConfig),
            this.particles = new b.Particles(this),
            this.create = new b.Create(this),
            this.plugins = new b.PluginManager(this),
            this.net = new b.Net(this),
            this.time.boot(),
            this.stage.boot(),
            this.world.boot(),
            this.scale.boot(),
            this.input.boot(),
            this.sound.boot(),
            this.state.boot(),
            this.config.enableDebug ? (this.debug = new b.Utils.Debug(this),
            this.debug.boot()) : this.debug = {
                preUpdate: function() {},
                update: function() {},
                reset: function() {}
            },
            this.showDebugHeader(),
            this.isRunning = !0,
            this.config && this.config.forceSetTimeOut ? this.raf = new b.RequestAnimationFrame(this,this.config.forceSetTimeOut) : this.raf = new b.RequestAnimationFrame(this,!1),
            this._kickstart = !0,
            window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(),
            this.raf.start())
        },
        showDebugHeader: function() {
            if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                var a = b.VERSION
                  , c = "Canvas"
                  , d = "HTML Audio"
                  , e = 1;
                if (this.renderType === b.WEBGL ? (c = "WebGL",
                e++) : this.renderType === b.HEADLESS && (c = "Headless"),
                this.device.webAudio && (d = "WebAudio",
                e++),
                this.device.chrome) {
                    for (var f = ["%c %c %c Phaser v" + a + " | Pixi.js | " + c + " | " + d + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], g = 0; g < 3; g++)
                        g < e ? f.push("color: #ff2424; background: #fff") : f.push("color: #959595; background: #fff");
                    console.log.apply(console, f)
                } else
                    window.console && console.log("Phaser v" + a + " | Pixi.js " + PIXI.VERSION + " | " + c + " | " + d + " | http://phaser.io")
            }
        },
        setUpRenderer: function() {
            if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = b.Canvas.create(this, this.width, this.height, this.config.canvasID, !0),
            this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%",
            this.renderType === b.HEADLESS || this.renderType === b.CANVAS || this.renderType === b.AUTO && !this.device.webGL) {
                if (!this.device.canvas)
                    throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                this.renderType = b.CANVAS,
                this.renderer = new PIXI.CanvasRenderer(this),
                this.context = this.renderer.context
            } else
                this.renderType = b.WEBGL,
                this.renderer = new PIXI.WebGLRenderer(this),
                this.context = null,
                this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1),
                this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
            this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === b.CANVAS),
            this.renderType !== b.HEADLESS && (this.stage.smoothed = this.antialias,
            b.Canvas.addToDOM(this.canvas, this.parent, !1),
            b.Canvas.setTouchAction(this.canvas))
        },
        contextLost: function(a) {
            a.preventDefault(),
            this.renderer.contextLost = !0
        },
        contextRestored: function() {
            this.renderer.initContext(),
            this.cache.clearGLTextures(),
            this.renderer.contextLost = !1
        },
        update: function(a) {
            if (this.time.update(a),
            this._kickstart)
                return this.updateLogic(this.time.desiredFpsMult),
                this.updateRender(this.time.slowMotion * this.time.desiredFps),
                void (this._kickstart = !1);
            if (this._spiraling > 1 && !this.forceSingleUpdate)
                this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4,
                this.fpsProblemNotifier.dispatch()),
                this._deltaTime = 0,
                this._spiraling = 0,
                this.updateRender(this.time.slowMotion * this.time.desiredFps);
            else {
                var b = 1e3 * this.time.slowMotion / this.time.desiredFps;
                this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
                var c = 0;
                for (this.updatesThisFrame = Math.floor(this._deltaTime / b),
                this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= b && (this._deltaTime -= b,
                this.currentUpdateID = c,
                this.updateLogic(this.time.desiredFpsMult),
                c++,
                !this.forceSingleUpdate || 1 !== c); )
                    this.time.refresh();
                c > this._lastCount ? this._spiraling++ : c < this._lastCount && (this._spiraling = 0),
                this._lastCount = c,
                this.updateRender(this._deltaTime / b)
            }
        },
        updateLogic: function(a) {
            this._paused || this.pendingStep ? (this.scale.pauseUpdate(),
            this.state.pauseUpdate(),
            this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0),
            this.scale.preUpdate(),
            this.debug.preUpdate(),
            this.camera.preUpdate(),
            this.physics.preUpdate(),
            this.state.preUpdate(a),
            this.plugins.preUpdate(a),
            this.stage.preUpdate(),
            this.state.update(),
            this.stage.update(),
            this.tweens.update(),
            this.sound.update(),
            this.input.update(),
            this.physics.update(),
            this.particles.update(),
            this.plugins.update(),
            this.stage.postUpdate(),
            this.plugins.postUpdate()),
            this.stage.updateTransform()
        },
        updateRender: function(a) {
            this.lockRender || (this.state.preRender(a),
            this.renderType !== b.HEADLESS && (this.renderer.render(this.stage),
            this.plugins.render(a),
            this.state.render(a)),
            this.plugins.postRender(a))
        },
        enableStep: function() {
            this.stepping = !0,
            this.pendingStep = !1,
            this.stepCount = 0
        },
        disableStep: function() {
            this.stepping = !1,
            this.pendingStep = !1
        },
        step: function() {
            this.pendingStep = !1,
            this.stepCount++
        },
        destroy: function() {
            this.raf.stop(),
            this.state.destroy(),
            this.sound.destroy(),
            this.scale.destroy(),
            this.stage.destroy(),
            this.input.destroy(),
            this.physics.destroy(),
            this.plugins.destroy(),
            this.state = null,
            this.sound = null,
            this.scale = null,
            this.stage = null,
            this.input = null,
            this.physics = null,
            this.plugins = null,
            this.cache = null,
            this.load = null,
            this.time = null,
            this.world = null,
            this.isBooted = !1,
            this.renderer.destroy(!1),
            b.Canvas.removeFromDOM(this.canvas),
            PIXI.defaultRenderer = null,
            b.GAMES[this.id] = null
        },
        gamePaused: function(a) {
            this._paused || (this._paused = !0,
            this.time.gamePaused(),
            this.sound.muteOnPause && this.sound.setMute(),
            this.onPause.dispatch(a),
            this.device.cordova && this.device.iOS && (this.lockRender = !0))
        },
        gameResumed: function(a) {
            this._paused && !this._codePaused && (this._paused = !1,
            this.time.gameResumed(),
            this.input.reset(),
            this.sound.muteOnPause && this.sound.unsetMute(),
            this.onResume.dispatch(a),
            this.device.cordova && this.device.iOS && (this.lockRender = !1))
        },
        focusLoss: function(a) {
            this.onBlur.dispatch(a),
            this.stage.disableVisibilityChange || this.gamePaused(a)
        },
        focusGain: function(a) {
            this.onFocus.dispatch(a),
            this.stage.disableVisibilityChange || this.gameResumed(a)
        }
    },
    b.Game.prototype.constructor = b.Game,
    Object.defineProperty(b.Game.prototype, "paused", {
        get: function() {
            return this._paused
        },
        set: function(a) {
            !0 === a ? (!1 === this._paused && (this._paused = !0,
            this.sound.setMute(),
            this.time.gamePaused(),
            this.onPause.dispatch(this)),
            this._codePaused = !0) : (this._paused && (this._paused = !1,
            this.input.reset(),
            this.sound.unsetMute(),
            this.time.gameResumed(),
            this.onResume.dispatch(this)),
            this._codePaused = !1)
        }
    }),
    b.Input = function(a) {
        this.game = a,
        this.hitCanvas = null,
        this.hitContext = null,
        this.moveCallbacks = [],
        this.customCandidateHandler = null,
        this.customCandidateHandlerContext = null,
        this.pollRate = 0,
        this.enabled = !0,
        this.multiInputOverride = b.Input.MOUSE_TOUCH_COMBINE,
        this.position = null,
        this.speed = null,
        this.circle = null,
        this.scale = null,
        this.maxPointers = -1,
        this.tapRate = 200,
        this.doubleTapRate = 300,
        this.holdRate = 2e3,
        this.justPressedRate = 200,
        this.justReleasedRate = 200,
        this.recordPointerHistory = !1,
        this.recordRate = 100,
        this.recordLimit = 100,
        this.pointer1 = null,
        this.pointer2 = null,
        this.pointer3 = null,
        this.pointer4 = null,
        this.pointer5 = null,
        this.pointer6 = null,
        this.pointer7 = null,
        this.pointer8 = null,
        this.pointer9 = null,
        this.pointer10 = null,
        this.pointers = [],
        this.activePointer = null,
        this.mousePointer = null,
        this.mouse = null,
        this.keyboard = null,
        this.touch = null,
        this.mspointer = null,
        this.gamepad = null,
        this.resetLocked = !1,
        this.onDown = null,
        this.onUp = null,
        this.onTap = null,
        this.onHold = null,
        this.minPriorityID = 0,
        this.interactiveItems = new b.ArraySet,
        this._localPoint = new b.Point,
        this._pollCounter = 0,
        this._oldPosition = null,
        this._x = 0,
        this._y = 0
    }
    ,
    b.Input.MOUSE_OVERRIDES_TOUCH = 0,
    b.Input.TOUCH_OVERRIDES_MOUSE = 1,
    b.Input.MOUSE_TOUCH_COMBINE = 2,
    b.Input.MAX_POINTERS = 10,
    b.Input.prototype = {
        boot: function() {
            this.mousePointer = new b.Pointer(this.game,0,b.PointerMode.CURSOR),
            this.addPointer(),
            this.addPointer(),
            this.mouse = new b.Mouse(this.game),
            this.touch = new b.Touch(this.game),
            this.mspointer = new b.MSPointer(this.game),
            b.Keyboard && (this.keyboard = new b.Keyboard(this.game)),
            b.Gamepad && (this.gamepad = new b.Gamepad(this.game)),
            this.onDown = new b.Signal,
            this.onUp = new b.Signal,
            this.onTap = new b.Signal,
            this.onHold = new b.Signal,
            this.scale = new b.Point(1,1),
            this.speed = new b.Point,
            this.position = new b.Point,
            this._oldPosition = new b.Point,
            this.circle = new b.Circle(0,0,44),
            this.activePointer = this.mousePointer,
            this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1),
            this.hitContext = this.hitCanvas.getContext("2d"),
            this.mouse.start(),
            this.touch.start(),
            this.mspointer.start(),
            this.mousePointer.active = !0,
            this.keyboard && this.keyboard.start();
            var a = this;
            this._onClickTrampoline = function(b) {
                a.onClickTrampoline(b)
            }
            ,
            this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
        },
        destroy: function() {
            this.mouse.stop(),
            this.touch.stop(),
            this.mspointer.stop(),
            this.keyboard && this.keyboard.stop(),
            this.gamepad && this.gamepad.stop(),
            this.moveCallbacks = [],
            PIXI.CanvasPool.remove(this),
            this.game.canvas.removeEventListener("click", this._onClickTrampoline)
        },
        setInteractiveCandidateHandler: function(a, b) {
            this.customCandidateHandler = a,
            this.customCandidateHandlerContext = b
        },
        addMoveCallback: function(a, b) {
            this.moveCallbacks.push({
                callback: a,
                context: b
            })
        },
        deleteMoveCallback: function(a, b) {
            for (var c = this.moveCallbacks.length; c--; )
                if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b)
                    return void this.moveCallbacks.splice(c, 1)
        },
        addPointer: function() {
            if (this.pointers.length >= b.Input.MAX_POINTERS)
                return console.warn("Phaser.Input.addPointer: Maximum limit of " + b.Input.MAX_POINTERS + " pointers reached."),
                null;
            var a = this.pointers.length + 1
              , c = new b.Pointer(this.game,a,b.PointerMode.TOUCH);
            return this.pointers.push(c),
            this["pointer" + a] = c,
            c
        },
        update: function() {
            if (this.keyboard && this.keyboard.update(),
            this.pollRate > 0 && this._pollCounter < this.pollRate)
                return void this._pollCounter++;
            this.speed.x = this.position.x - this._oldPosition.x,
            this.speed.y = this.position.y - this._oldPosition.y,
            this._oldPosition.copyFrom(this.position),
            this.mousePointer.update(),
            this.gamepad && this.gamepad.active && this.gamepad.update();
            for (var a = 0; a < this.pointers.length; a++)
                this.pointers[a].update();
            this._pollCounter = 0
        },
        reset: function(a) {
            if (this.game.isBooted && !this.resetLocked) {
                void 0 === a && (a = !1),
                this.mousePointer.reset(),
                this.keyboard && this.keyboard.reset(a),
                this.gamepad && this.gamepad.reset();
                for (var c = 0; c < this.pointers.length; c++)
                    this.pointers[c].reset();
                "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"),
                a && (this.onDown.dispose(),
                this.onUp.dispose(),
                this.onTap.dispose(),
                this.onHold.dispose(),
                this.onDown = new b.Signal,
                this.onUp = new b.Signal,
                this.onTap = new b.Signal,
                this.onHold = new b.Signal,
                this.moveCallbacks = []),
                this._pollCounter = 0
            }
        },
        resetSpeed: function(a, b) {
            this._oldPosition.setTo(a, b),
            this.speed.setTo(0, 0)
        },
        startPointer: function(a) {
            if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers)
                return null;
            if (!this.pointer1.active)
                return this.pointer1.start(a);
            if (!this.pointer2.active)
                return this.pointer2.start(a);
            for (var b = 2; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (!c.active)
                    return c.start(a)
            }
            return null
        },
        updatePointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier === a.identifier)
                return this.pointer1.move(a);
            if (this.pointer2.active && this.pointer2.identifier === a.identifier)
                return this.pointer2.move(a);
            for (var b = 2; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.active && c.identifier === a.identifier)
                    return c.move(a)
            }
            return null
        },
        stopPointer: function(a) {
            if (this.pointer1.active && this.pointer1.identifier === a.identifier)
                return this.pointer1.stop(a);
            if (this.pointer2.active && this.pointer2.identifier === a.identifier)
                return this.pointer2.stop(a);
            for (var b = 2; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.active && c.identifier === a.identifier)
                    return c.stop(a)
            }
            return null
        },
        countActivePointers: function(a) {
            void 0 === a && (a = this.pointers.length);
            for (var b = a, c = 0; c < this.pointers.length && b > 0; c++) {
                this.pointers[c].active && b--
            }
            return a - b
        },
        getPointer: function(a) {
            void 0 === a && (a = !1);
            for (var b = 0; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.active === a)
                    return c
            }
            return null
        },
        getPointerFromIdentifier: function(a) {
            for (var b = 0; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.identifier === a)
                    return c
            }
            return null
        },
        getPointerFromId: function(a) {
            for (var b = 0; b < this.pointers.length; b++) {
                var c = this.pointers[b];
                if (c.pointerId === a)
                    return c
            }
            return null
        },
        getLocalPosition: function(a, c, d) {
            void 0 === d && (d = new b.Point);
            var e = a.worldTransform
              , f = 1 / (e.a * e.d + e.c * -e.b);
            return d.setTo(e.d * f * c.x + -e.c * f * c.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * c.y + -e.b * f * c.x + (-e.ty * e.a + e.tx * e.b) * f)
        },
        hitTest: function(a, c, d) {
            if (!a.worldVisible)
                return !1;
            if (this.getLocalPosition(a, c, this._localPoint),
            d.copyFrom(this._localPoint),
            a.hitArea && a.hitArea.contains)
                return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
            if (a instanceof b.TileSprite) {
                var e = a.width
                  , f = a.height
                  , g = -e * a.anchor.x;
                if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                    var h = -f * a.anchor.y;
                    if (this._localPoint.y >= h && this._localPoint.y < h + f)
                        return !0
                }
            } else if (a instanceof PIXI.Sprite) {
                var e = a.texture.frame.width
                  , f = a.texture.frame.height
                  , g = -e * a.anchor.x;
                if (this._localPoint.x >= g && this._localPoint.x < g + e) {
                    var h = -f * a.anchor.y;
                    if (this._localPoint.y >= h && this._localPoint.y < h + f)
                        return !0
                }
            } else if (a instanceof b.Graphics)
                for (var i = 0; i < a.graphicsData.length; i++) {
                    var j = a.graphicsData[i];
                    if (j.fill && (j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)))
                        return !0
                }
            for (var i = 0; i < a.children.length; i++)
                if (this.hitTest(a.children[i], c, d))
                    return !0;
            return !1
        },
        onClickTrampoline: function() {
            this.activePointer.processClickTrampolines()
        }
    },
    b.Input.prototype.constructor = b.Input,
    Object.defineProperty(b.Input.prototype, "x", {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = Math.floor(a)
        }
    }),
    Object.defineProperty(b.Input.prototype, "y", {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = Math.floor(a)
        }
    }),
    Object.defineProperty(b.Input.prototype, "pollLocked", {
        get: function() {
            return this.pollRate > 0 && this._pollCounter < this.pollRate
        }
    }),
    Object.defineProperty(b.Input.prototype, "totalInactivePointers", {
        get: function() {
            return this.pointers.length - this.countActivePointers()
        }
    }),
    Object.defineProperty(b.Input.prototype, "totalActivePointers", {
        get: function() {
            return this.countActivePointers()
        }
    }),
    Object.defineProperty(b.Input.prototype, "worldX", {
        get: function() {
            return this.game.camera.view.x + this.x
        }
    }),
    Object.defineProperty(b.Input.prototype, "worldY", {
        get: function() {
            return this.game.camera.view.y + this.y
        }
    }),
    b.Mouse = function(a) {
        this.game = a,
        this.input = a.input,
        this.callbackContext = this.game,
        this.mouseDownCallback = null,
        this.mouseUpCallback = null,
        this.mouseOutCallback = null,
        this.mouseOverCallback = null,
        this.mouseWheelCallback = null,
        this.capture = !1,
        this.button = -1,
        this.wheelDelta = 0,
        this.enabled = !0,
        this.locked = !1,
        this.stopOnGameOut = !1,
        this.pointerLock = new b.Signal,
        this.event = null,
        this._onMouseDown = null,
        this._onMouseMove = null,
        this._onMouseUp = null,
        this._onMouseOut = null,
        this._onMouseOver = null,
        this._onMouseWheel = null,
        this._wheelEvent = null
    }
    ,
    b.Mouse.NO_BUTTON = -1,
    b.Mouse.LEFT_BUTTON = 0,
    b.Mouse.MIDDLE_BUTTON = 1,
    b.Mouse.RIGHT_BUTTON = 2,
    b.Mouse.BACK_BUTTON = 3,
    b.Mouse.FORWARD_BUTTON = 4,
    b.Mouse.WHEEL_UP = 1,
    b.Mouse.WHEEL_DOWN = -1,
    b.Mouse.prototype = {
        start: function() {
            if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                var a = this;
                this._onMouseDown = function(b) {
                    return a.onMouseDown(b)
                }
                ,
                this._onMouseMove = function(b) {
                    return a.onMouseMove(b)
                }
                ,
                this._onMouseUp = function(b) {
                    return a.onMouseUp(b)
                }
                ,
                this._onMouseUpGlobal = function(b) {
                    return a.onMouseUpGlobal(b)
                }
                ,
                this._onMouseOutGlobal = function(b) {
                    return a.onMouseOutGlobal(b)
                }
                ,
                this._onMouseOut = function(b) {
                    return a.onMouseOut(b)
                }
                ,
                this._onMouseOver = function(b) {
                    return a.onMouseOver(b)
                }
                ,
                this._onMouseWheel = function(b) {
                    return a.onMouseWheel(b)
                }
                ;
                var b = this.game.canvas;
                b.addEventListener("mousedown", this._onMouseDown, !0),
                b.addEventListener("mousemove", this._onMouseMove, !0),
                b.addEventListener("mouseup", this._onMouseUp, !0),
                this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0),
                window.addEventListener("mouseout", this._onMouseOutGlobal, !0),
                b.addEventListener("mouseover", this._onMouseOver, !0),
                b.addEventListener("mouseout", this._onMouseOut, !0));
                var c = this.game.device.wheelEvent;
                c && (b.addEventListener(c, this._onMouseWheel, !0),
                "mousewheel" === c ? this._wheelEvent = new d(-.025,1) : "DOMMouseScroll" === c && (this._wheelEvent = new d(1,1)))
            }
        },
        onMouseDown: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && (a.identifier = 0,
            this.input.mousePointer.start(a))
        },
        onMouseMove: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && (a.identifier = 0,
            this.input.mousePointer.move(a))
        },
        onMouseUp: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && (a.identifier = 0,
            this.input.mousePointer.stop(a))
        },
        onMouseUpGlobal: function(a) {
            this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, a),
            a.identifier = 0,
            this.input.mousePointer.stop(a))
        },
        onMouseOutGlobal: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.input.mousePointer.withinGame = !1,
            this.input.enabled && this.enabled && (this.input.mousePointer.stop(a),
            this.input.mousePointer.leftButton.stop(a),
            this.input.mousePointer.rightButton.stop(a))
        },
        onMouseOut: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.input.mousePointer.withinGame = !1,
            this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && this.stopOnGameOut && (a.identifier = 0,
            this.input.mousePointer.stop(a))
        },
        onMouseOver: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.input.mousePointer.withinGame = !0,
            this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, a)
        },
        onMouseWheel: function(a) {
            this._wheelEvent && (a = this._wheelEvent.bindEvent(a)),
            this.event = a,
            this.capture && a.preventDefault(),
            this.wheelDelta = b.Math.clamp(-a.deltaY, -1, 1),
            this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, a)
        },
        requestPointerLock: function() {
            if (this.game.device.pointerLock) {
                var a = this.game.canvas;
                a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock,
                a.requestPointerLock();
                var b = this;
                this._pointerLockChange = function(a) {
                    return b.pointerLockChange(a)
                }
                ,
                document.addEventListener("pointerlockchange", this._pointerLockChange, !0),
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0),
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        },
        pointerLockChange: function(a) {
            var b = this.game.canvas;
            document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b ? (this.locked = !0,
            this.pointerLock.dispatch(!0, a)) : (this.locked = !1,
            this.pointerLock.dispatch(!1, a))
        },
        releasePointerLock: function() {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock,
            document.exitPointerLock(),
            document.removeEventListener("pointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
        },
        stop: function() {
            var a = this.game.canvas;
            a.removeEventListener("mousedown", this._onMouseDown, !0),
            a.removeEventListener("mousemove", this._onMouseMove, !0),
            a.removeEventListener("mouseup", this._onMouseUp, !0),
            a.removeEventListener("mouseover", this._onMouseOver, !0),
            a.removeEventListener("mouseout", this._onMouseOut, !0);
            var b = this.game.device.wheelEvent;
            b && a.removeEventListener(b, this._onMouseWheel, !0),
            window.removeEventListener("mouseup", this._onMouseUpGlobal, !0),
            window.removeEventListener("mouseout", this._onMouseOutGlobal, !0),
            document.removeEventListener("pointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0),
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
        }
    },
    b.Mouse.prototype.constructor = b.Mouse,
    d.prototype = {},
    d.prototype.constructor = d,
    d.prototype.bindEvent = function(a) {
        if (!d._stubsGenerated && a) {
            var b = function(a) {
                return function() {
                    var b = this.originalEvent[a];
                    return "function" != typeof b ? b : b.bind(this.originalEvent)
                }
            };
            for (var c in a)
                c in d.prototype || Object.defineProperty(d.prototype, c, {
                    get: b(c)
                });
            d._stubsGenerated = !0
        }
        return this.originalEvent = a,
        this
    }
    ,
    Object.defineProperties(d.prototype, {
        type: {
            value: "wheel"
        },
        deltaMode: {
            get: function() {
                return this._deltaMode
            }
        },
        deltaY: {
            get: function() {
                return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
            }
        },
        deltaX: {
            get: function() {
                return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
            }
        },
        deltaZ: {
            value: 0
        }
    }),
    b.MSPointer = function(a) {
        this.game = a,
        this.input = a.input,
        this.callbackContext = this.game,
        this.pointerDownCallback = null,
        this.pointerMoveCallback = null,
        this.pointerUpCallback = null,
        this.capture = !0,
        this.button = -1,
        this.event = null,
        this.enabled = !0,
        this._onMSPointerDown = null,
        this._onMSPointerMove = null,
        this._onMSPointerUp = null,
        this._onMSPointerUpGlobal = null,
        this._onMSPointerOut = null,
        this._onMSPointerOver = null
    }
    ,
    b.MSPointer.prototype = {
        start: function() {
            if (null === this._onMSPointerDown) {
                var a = this;
                if (this.game.device.mspointer) {
                    this._onMSPointerDown = function(b) {
                        return a.onPointerDown(b)
                    }
                    ,
                    this._onMSPointerMove = function(b) {
                        return a.onPointerMove(b)
                    }
                    ,
                    this._onMSPointerUp = function(b) {
                        return a.onPointerUp(b)
                    }
                    ,
                    this._onMSPointerUpGlobal = function(b) {
                        return a.onPointerUpGlobal(b)
                    }
                    ,
                    this._onMSPointerOut = function(b) {
                        return a.onPointerOut(b)
                    }
                    ,
                    this._onMSPointerOver = function(b) {
                        return a.onPointerOver(b)
                    }
                    ;
                    var b = this.game.canvas;
                    b.addEventListener("MSPointerDown", this._onMSPointerDown, !1),
                    b.addEventListener("MSPointerMove", this._onMSPointerMove, !1),
                    b.addEventListener("MSPointerUp", this._onMSPointerUp, !1),
                    b.addEventListener("pointerdown", this._onMSPointerDown, !1),
                    b.addEventListener("pointermove", this._onMSPointerMove, !1),
                    b.addEventListener("pointerup", this._onMSPointerUp, !1),
                    b.style["-ms-content-zooming"] = "none",
                    b.style["-ms-touch-action"] = "none",
                    this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
                    b.addEventListener("MSPointerOver", this._onMSPointerOver, !0),
                    b.addEventListener("MSPointerOut", this._onMSPointerOut, !0),
                    window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0),
                    b.addEventListener("pointerover", this._onMSPointerOver, !0),
                    b.addEventListener("pointerout", this._onMSPointerOut, !0))
                }
            }
        },
        onPointerDown: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && (a.identifier = a.pointerId,
            "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.start(a) : this.input.startPointer(a))
        },
        onPointerMove: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && (a.identifier = a.pointerId,
            "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.move(a) : this.input.updatePointer(a))
        },
        onPointerUp: function(a) {
            this.event = a,
            this.capture && a.preventDefault(),
            this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, a),
            this.input.enabled && this.enabled && (a.identifier = a.pointerId,
            "mouse" === a.pointerType || 4 === a.pointerType ? this.input.mousePointer.stop(a) : this.input.stopPointer(a))
        },
        onPointerUpGlobal: function(a) {
            if ("mouse" !== a.pointerType && 4 !== a.pointerType || this.input.mousePointer.withinGame) {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && b.withinGame && this.onPointerUp(a)
            } else
                this.onPointerUp(a)
        },
        onPointerOut: function(a) {
            if (this.event = a,
            this.capture && a.preventDefault(),
            "mouse" === a.pointerType || 4 === a.pointerType)
                this.input.mousePointer.withinGame = !1;
            else {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && (b.withinGame = !1)
            }
            this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a),
            this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (a.identifier = 0,
            b ? b.stop(a) : this.input.mousePointer.stop(a))
        },
        onPointerOver: function(a) {
            if (this.event = a,
            this.capture && a.preventDefault(),
            "mouse" === a.pointerType || 4 === a.pointerType)
                this.input.mousePointer.withinGame = !0;
            else {
                var b = this.input.getPointerFromIdentifier(a.identifier);
                b && (b.withinGame = !0)
            }
            this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a)
        },
        stop: function() {
            var a = this.game.canvas;
            a.removeEventListener("MSPointerDown", this._onMSPointerDown, !1),
            a.removeEventListener("MSPointerMove", this._onMSPointerMove, !1),
            a.removeEventListener("MSPointerUp", this._onMSPointerUp, !1),
            a.removeEventListener("pointerdown", this._onMSPointerDown, !1),
            a.removeEventListener("pointermove", this._onMSPointerMove, !1),
            a.removeEventListener("pointerup", this._onMSPointerUp, !1),
            window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0),
            a.removeEventListener("MSPointerOver", this._onMSPointerOver, !0),
            a.removeEventListener("MSPointerOut", this._onMSPointerOut, !0),
            window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0),
            a.removeEventListener("pointerover", this._onMSPointerOver, !0),
            a.removeEventListener("pointerout", this._onMSPointerOut, !0)
        }
    },
    b.MSPointer.prototype.constructor = b.MSPointer,
    b.DeviceButton = function(a, c) {
        this.parent = a,
        this.game = a.game,
        this.event = null,
        this.isDown = !1,
        this.isUp = !0,
        this.timeDown = 0,
        this.timeUp = 0,
        this.repeats = 0,
        this.altKey = !1,
        this.shiftKey = !1,
        this.ctrlKey = !1,
        this.value = 0,
        this.buttonCode = c,
        this.onDown = new b.Signal,
        this.onUp = new b.Signal,
        this.onFloat = new b.Signal
    }
    ,
    b.DeviceButton.prototype = {
        start: function(a, b) {
            this.isDown || (this.isDown = !0,
            this.isUp = !1,
            this.timeDown = this.game.time.time,
            this.repeats = 0,
            this.event = a,
            this.value = b,
            a && (this.altKey = a.altKey,
            this.shiftKey = a.shiftKey,
            this.ctrlKey = a.ctrlKey),
            this.onDown.dispatch(this, b))
        },
        stop: function(a, b) {
            this.isUp || (this.isDown = !1,
            this.isUp = !0,
            this.timeUp = this.game.time.time,
            this.event = a,
            this.value = b,
            a && (this.altKey = a.altKey,
            this.shiftKey = a.shiftKey,
            this.ctrlKey = a.ctrlKey),
            this.onUp.dispatch(this, b))
        },
        padFloat: function(a) {
            this.value = a,
            this.onFloat.dispatch(this, a)
        },
        justPressed: function(a) {
            return a = a || 250,
            this.isDown && this.timeDown + a > this.game.time.time
        },
        justReleased: function(a) {
            return a = a || 250,
            this.isUp && this.timeUp + a > this.game.time.time
        },
        reset: function() {
            this.isDown = !1,
            this.isUp = !0,
            this.timeDown = this.game.time.time,
            this.repeats = 0,
            this.altKey = !1,
            this.shiftKey = !1,
            this.ctrlKey = !1
        },
        destroy: function() {
            this.onDown.dispose(),
            this.onUp.dispose(),
            this.onFloat.dispose(),
            this.parent = null,
            this.game = null
        }
    },
    b.DeviceButton.prototype.constructor = b.DeviceButton,
    Object.defineProperty(b.DeviceButton.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown
        }
    }),
    b.Pointer = function(a, c, d) {
        this.game = a,
        this.id = c,
        this.type = b.POINTER,
        this.exists = !0,
        this.identifier = 0,
        this.pointerId = null,
        this.pointerMode = d || b.PointerMode.CURSOR | b.PointerMode.CONTACT,
        this.target = null,
        this.button = null,
        this.leftButton = new b.DeviceButton(this,b.Pointer.LEFT_BUTTON),
        this.middleButton = new b.DeviceButton(this,b.Pointer.MIDDLE_BUTTON),
        this.rightButton = new b.DeviceButton(this,b.Pointer.RIGHT_BUTTON),
        this.backButton = new b.DeviceButton(this,b.Pointer.BACK_BUTTON),
        this.forwardButton = new b.DeviceButton(this,b.Pointer.FORWARD_BUTTON),
        this.eraserButton = new b.DeviceButton(this,b.Pointer.ERASER_BUTTON),
        this._holdSent = !1,
        this._history = [],
        this._nextDrop = 0,
        this._stateReset = !1,
        this.withinGame = !1,
        this.clientX = -1,
        this.clientY = -1,
        this.pageX = -1,
        this.pageY = -1,
        this.screenX = -1,
        this.screenY = -1,
        this.rawMovementX = 0,
        this.rawMovementY = 0,
        this.movementX = 0,
        this.movementY = 0,
        this.x = -1,
        this.y = -1,
        this.isMouse = 0 === c,
        this.isDown = !1,
        this.isUp = !0,
        this.timeDown = 0,
        this.timeUp = 0,
        this.previousTapTime = 0,
        this.totalTouches = 0,
        this.msSinceLastClick = Number.MAX_VALUE,
        this.targetObject = null,
        this.interactiveCandidates = [],
        this.active = !1,
        this.dirty = !1,
        this.position = new b.Point,
        this.positionDown = new b.Point,
        this.positionUp = new b.Point,
        this.circle = new b.Circle(0,0,44),
        this._clickTrampolines = null,
        this._trampolineTargetObject = null
    }
    ,
    b.Pointer.NO_BUTTON = 0,
    b.Pointer.LEFT_BUTTON = 1,
    b.Pointer.RIGHT_BUTTON = 2,
    b.Pointer.MIDDLE_BUTTON = 4,
    b.Pointer.BACK_BUTTON = 8,
    b.Pointer.FORWARD_BUTTON = 16,
    b.Pointer.ERASER_BUTTON = 32,
    b.Pointer.prototype = {
        resetButtons: function() {
            this.isDown = !1,
            this.isUp = !0,
            this.isMouse && (this.leftButton.reset(),
            this.middleButton.reset(),
            this.rightButton.reset(),
            this.backButton.reset(),
            this.forwardButton.reset(),
            this.eraserButton.reset())
        },
        processButtonsDown: function(a, c) {
            b.Pointer.LEFT_BUTTON & a && this.leftButton.start(c),
            b.Pointer.RIGHT_BUTTON & a && this.rightButton.start(c),
            b.Pointer.MIDDLE_BUTTON & a && this.middleButton.start(c),
            b.Pointer.BACK_BUTTON & a && this.backButton.start(c),
            b.Pointer.FORWARD_BUTTON & a && this.forwardButton.start(c),
            b.Pointer.ERASER_BUTTON & a && this.eraserButton.start(c)
        },
        processButtonsUp: function(a, c) {
            a === b.Mouse.LEFT_BUTTON && this.leftButton.stop(c),
            a === b.Mouse.RIGHT_BUTTON && this.rightButton.stop(c),
            a === b.Mouse.MIDDLE_BUTTON && this.middleButton.stop(c),
            a === b.Mouse.BACK_BUTTON && this.backButton.stop(c),
            a === b.Mouse.FORWARD_BUTTON && this.forwardButton.stop(c),
            5 === a && this.eraserButton.stop(c)
        },
        updateButtons: function(a) {
            this.button = a.button;
            var b = "down" === a.type.toLowerCase().substr(-4);
            void 0 !== a.buttons ? b ? this.processButtonsDown(a.buttons, a) : this.processButtonsUp(a.button, a) : b ? this.leftButton.start(a) : (this.leftButton.stop(a),
            this.rightButton.stop(a)),
            1 === a.buttons && a.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(a),
            this.rightButton.start(a)),
            this.isUp = !0,
            this.isDown = !1,
            (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1,
            this.isDown = !0)
        },
        start: function(a) {
            var c = this.game.input;
            return a.pointerId && (this.pointerId = a.pointerId),
            this.identifier = a.identifier,
            this.target = a.target,
            this.isMouse ? this.updateButtons(a) : (this.isDown = !0,
            this.isUp = !1),
            this.active = !0,
            this.withinGame = !0,
            this.dirty = !1,
            this._history = [],
            this._clickTrampolines = null,
            this._trampolineTargetObject = null,
            this.msSinceLastClick = this.game.time.time - this.timeDown,
            this.timeDown = this.game.time.time,
            this._holdSent = !1,
            this.move(a, !0),
            this.positionDown.setTo(this.x, this.y),
            (c.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || c.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || c.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === c.totalActivePointers) && (c.x = this.x,
            c.y = this.y,
            c.position.setTo(this.x, this.y),
            c.onDown.dispatch(this, a),
            c.resetSpeed(this.x, this.y)),
            this._stateReset = !1,
            this.totalTouches++,
            null !== this.targetObject && this.targetObject._touchedHandler(this),
            this
        },
        update: function() {
            var a = this.game.input;
            this.active && (this.dirty && (a.interactiveItems.total > 0 && this.processInteractiveObjects(!1),
            this.dirty = !1),
            !1 === this._holdSent && this.duration >= a.holdRate && ((a.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || a.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || a.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === a.totalActivePointers) && a.onHold.dispatch(this),
            this._holdSent = !0),
            a.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + a.recordRate,
            this._history.push({
                x: this.position.x,
                y: this.position.y
            }),
            this._history.length > a.recordLimit && this._history.shift()))
        },
        move: function(a, c) {
            var d = this.game.input;
            if (!d.pollLocked) {
                if (void 0 === c && (c = !1),
                void 0 !== a.button && (this.button = a.button),
                c && this.isMouse && this.updateButtons(a),
                this.clientX = a.clientX,
                this.clientY = a.clientY,
                this.pageX = a.pageX,
                this.pageY = a.pageY,
                this.screenX = a.screenX,
                this.screenY = a.screenY,
                this.isMouse && d.mouse.locked && !c && (this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0,
                this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0,
                this.movementX += this.rawMovementX,
                this.movementY += this.rawMovementY),
                this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x,
                this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y,
                this.position.setTo(this.x, this.y),
                this.circle.x = this.x,
                this.circle.y = this.y,
                (d.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || d.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers) && (d.activePointer = this,
                d.x = this.x,
                d.y = this.y,
                d.position.setTo(d.x, d.y),
                d.circle.x = d.x,
                d.circle.y = d.y),
                this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY),
                this.game.paused)
                    return this;
                for (var e = d.moveCallbacks.length; e--; )
                    d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, c);
                return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : d.interactiveItems.total > 0 && this.processInteractiveObjects(c),
                this
            }
        },
        processInteractiveObjects: function(a) {
            var b = 0
              , c = -1
              , d = null
              , e = this.game.input.interactiveItems.first;
            for (this.interactiveCandidates = []; e; )
                e.checked = !1,
                e.validForInput(c, b, !1) && (e.checked = !0,
                (a && e.checkPointerDown(this, !0) || !a && e.checkPointerOver(this, !0)) && (b = e.sprite.renderOrderID,
                c = e.priorityID,
                d = e,
                this.interactiveCandidates.push(e))),
                e = this.game.input.interactiveItems.next;
            for (e = this.game.input.interactiveItems.first; e; )
                !e.checked && e.validForInput(c, b, !0) && (a && e.checkPointerDown(this, !1) || !a && e.checkPointerOver(this, !1)) && (b = e.sprite.renderOrderID,
                c = e.priorityID,
                d = e,
                this.interactiveCandidates.push(e)),
                e = this.game.input.interactiveItems.next;
            return this.game.input.customCandidateHandler && (d = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, d)),
            this.swapTarget(d, !1),
            null !== this.targetObject
        },
        swapTarget: function(a, b) {
            void 0 === b && (b = !1),
            null === a ? this.targetObject && (this.targetObject._pointerOutHandler(this, b),
            this.targetObject = null) : null === this.targetObject ? (this.targetObject = a,
            a._pointerOverHandler(this, b)) : this.targetObject === a ? !1 === a.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, b),
            this.targetObject = a,
            this.targetObject._pointerOverHandler(this, b))
        },
        leave: function(a) {
            this.withinGame = !1,
            this.move(a, !1)
        },
        stop: function(a) {
            var c = this.game.input;
            return this._stateReset && this.withinGame ? void a.preventDefault() : (this.timeUp = this.game.time.time,
            (c.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || c.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || c.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === c.totalActivePointers) && (c.onUp.dispatch(this, a),
            this.duration >= 0 && this.duration <= c.tapRate && (this.timeUp - this.previousTapTime < c.doubleTapRate ? c.onTap.dispatch(this, !0) : c.onTap.dispatch(this, !1),
            this.previousTapTime = this.timeUp)),
            this.isMouse ? this.updateButtons(a) : (this.isDown = !1,
            this.isUp = !0),
            this.id > 0 && (this.active = !1),
            this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY),
            this.pointerId = null,
            this.identifier = null,
            this.positionUp.setTo(this.x, this.y),
            !1 === this.isMouse && c.currentPointers--,
            c.interactiveItems.callAll("_releasedHandler", this),
            this._clickTrampolines && (this._trampolineTargetObject = this.targetObject),
            this.targetObject = null,
            this)
        },
        justPressed: function(a) {
            return a = a || this.game.input.justPressedRate,
            !0 === this.isDown && this.timeDown + a > this.game.time.time
        },
        justReleased: function(a) {
            return a = a || this.game.input.justReleasedRate,
            this.isUp && this.timeUp + a > this.game.time.time
        },
        addClickTrampoline: function(a, b, c, d) {
            if (this.isDown) {
                for (var e = this._clickTrampolines = this._clickTrampolines || [], f = 0; f < e.length; f++)
                    if (e[f].name === a) {
                        e.splice(f, 1);
                        break
                    }
                e.push({
                    name: a,
                    targetObject: this.targetObject,
                    callback: b,
                    callbackContext: c,
                    callbackArgs: d
                })
            }
        },
        processClickTrampolines: function() {
            var a = this._clickTrampolines;
            if (a) {
                for (var b = 0; b < a.length; b++) {
                    var c = a[b];
                    c.targetObject === this._trampolineTargetObject && c.callback.apply(c.callbackContext, c.callbackArgs)
                }
                this._clickTrampolines = null,
                this._trampolineTargetObject = null
            }
        },
        reset: function() {
            !1 === this.isMouse && (this.active = !1),
            this.pointerId = null,
            this.identifier = null,
            this.dirty = !1,
            this.totalTouches = 0,
            this._holdSent = !1,
            this._history.length = 0,
            this._stateReset = !0,
            this.resetButtons(),
            this.targetObject && this.targetObject._releasedHandler(this),
            this.targetObject = null
        },
        resetMovement: function() {
            this.movementX = 0,
            this.movementY = 0
        }
    },
    b.Pointer.prototype.constructor = b.Pointer,
    Object.defineProperty(b.Pointer.prototype, "duration", {
        get: function() {
            return this.isUp ? -1 : this.game.time.time - this.timeDown
        }
    }),
    Object.defineProperty(b.Pointer.prototype, "worldX", {
        get: function() {
            return this.game.world.camera.x + this.x
        }
    }),
    Object.defineProperty(b.Pointer.prototype, "worldY", {
        get: function() {
            return this.game.world.camera.y + this.y
        }
    }),
    b.PointerMode = {
        CURSOR: 1,
        CONTACT: 2
    },
    b.Touch = function(a) {
        this.game = a,
        this.enabled = !0,
        this.touchLockCallbacks = [],
        this.callbackContext = this.game,
        this.touchStartCallback = null,
        this.touchMoveCallback = null,
        this.touchEndCallback = null,
        this.touchEnterCallback = null,
        this.touchLeaveCallback = null,
        this.touchCancelCallback = null,
        this.preventDefault = !0,
        this.event = null,
        this._onTouchStart = null,
        this._onTouchMove = null,
        this._onTouchEnd = null,
        this._onTouchEnter = null,
        this._onTouchLeave = null,
        this._onTouchCancel = null,
        this._onTouchMove = null
    }
    ,
    b.Touch.prototype = {
        start: function() {
            if (null === this._onTouchStart) {
                var a = this;
                this.game.device.touch && (this._onTouchStart = function(b) {
                    return a.onTouchStart(b)
                }
                ,
                this._onTouchMove = function(b) {
                    return a.onTouchMove(b)
                }
                ,
                this._onTouchEnd = function(b) {
                    return a.onTouchEnd(b)
                }
                ,
                this._onTouchEnter = function(b) {
                    return a.onTouchEnter(b)
                }
                ,
                this._onTouchLeave = function(b) {
                    return a.onTouchLeave(b)
                }
                ,
                this._onTouchCancel = function(b) {
                    return a.onTouchCancel(b)
                }
                ,
                this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1),
                this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1),
                this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1),
                this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1),
                this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1),
                this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
            }
        },
        consumeDocumentTouches: function() {
            this._documentTouchMove = function(a) {
                a.preventDefault()
            }
            ,
            document.addEventListener("touchmove", this._documentTouchMove, !1)
        },
        addTouchLockCallback: function(a, b, c) {
            void 0 === c && (c = !1),
            this.touchLockCallbacks.push({
                callback: a,
                context: b,
                onEnd: c
            })
        },
        removeTouchLockCallback: function(a, b) {
            for (var c = this.touchLockCallbacks.length; c--; )
                if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b)
                    return this.touchLockCallbacks.splice(c, 1),
                    !0;
            return !1
        },
        onTouchStart: function(a) {
            for (var b = this.touchLockCallbacks.length; b--; ) {
                var c = this.touchLockCallbacks[b];
                !c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1)
            }
            if (this.event = a,
            this.game.input.enabled && this.enabled) {
                this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, a),
                this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++)
                    this.game.input.startPointer(a.changedTouches[b])
            }
        },
        onTouchCancel: function(a) {
            if (this.event = a,
            this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, a),
            this.game.input.enabled && this.enabled) {
                this.preventDefault && a.preventDefault();
                for (var b = 0; b < a.changedTouches.length; b++)
                    this.game.input.stopPointer(a.changedTouches[b])
            }
        },
        onTouchEnter: function(a) {
            this.event = a,
            this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, a),
            this.game.input.enabled && this.enabled && this.preventDefault && a.preventDefault()
        },
        onTouchLeave: function(a) {
            this.event = a,
            this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, a),
            this.preventDefault && a.preventDefault()
        },
        onTouchMove: function(a) {
            this.event = a,
            this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, a),
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++)
                this.game.input.updatePointer(a.changedTouches[b])
        },
        onTouchEnd: function(a) {
            for (var b = this.touchLockCallbacks.length; b--; ) {
                var c = this.touchLockCallbacks[b];
                c.onEnd && c.callback.call(c.context, this, a) && this.touchLockCallbacks.splice(b, 1)
            }
            this.event = a,
            this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, a),
            this.preventDefault && a.preventDefault();
            for (var b = 0; b < a.changedTouches.length; b++)
                this.game.input.stopPointer(a.changedTouches[b])
        },
        stop: function() {
            this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart),
            this.game.canvas.removeEventListener("touchmove", this._onTouchMove),
            this.game.canvas.removeEventListener("touchend", this._onTouchEnd),
            this.game.canvas.removeEventListener("touchenter", this._onTouchEnter),
            this.game.canvas.removeEventListener("touchleave", this._onTouchLeave),
            this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
        }
    },
    b.Touch.prototype.constructor = b.Touch,
    b.InputHandler = function(a) {
        this.sprite = a,
        this.game = a.game,
        this.enabled = !1,
        this.checked = !1,
        this.priorityID = 0,
        this.useHandCursor = !1,
        this._setHandCursor = !1,
        this.isDragged = !1,
        this.allowHorizontalDrag = !0,
        this.allowVerticalDrag = !0,
        this.bringToTop = !1,
        this.snapOffset = null,
        this.snapOnDrag = !1,
        this.snapOnRelease = !1,
        this.snapX = 0,
        this.snapY = 0,
        this.snapOffsetX = 0,
        this.snapOffsetY = 0,
        this.pixelPerfectOver = !1,
        this.pixelPerfectClick = !1,
        this.pixelPerfectAlpha = 255,
        this.draggable = !1,
        this.boundsRect = null,
        this.boundsSprite = null,
        this.scaleLayer = !1,
        this.dragOffset = new b.Point,
        this.dragFromCenter = !1,
        this.dragStopBlocksInputUp = !1,
        this.dragStartPoint = new b.Point,
        this.dragDistanceThreshold = 0,
        this.dragTimeThreshold = 0,
        this.downPoint = new b.Point,
        this.snapPoint = new b.Point,
        this._dragPoint = new b.Point,
        this._dragPhase = !1,
        this._pendingDrag = !1,
        this._dragTimePass = !1,
        this._dragDistancePass = !1,
        this._wasEnabled = !1,
        this._tempPoint = new b.Point,
        this._pointerData = [],
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            camX: 0,
            camY: 0,
            isDown: !1,
            isUp: !1,
            isOver: !1,
            isOut: !1,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: !1
        })
    }
    ,
    b.InputHandler.prototype = {
        start: function(a, c) {
            if (a = a || 0,
            void 0 === c && (c = !1),
            !1 === this.enabled) {
                this.game.input.interactiveItems.add(this),
                this.useHandCursor = c,
                this.priorityID = a;
                for (var d = 0; d < 10; d++)
                    this._pointerData[d] = {
                        id: d,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    };
                this.snapOffset = new b.Point,
                this.enabled = !0,
                this._wasEnabled = !0
            }
            return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this),
            this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this),
            this.sprite
        },
        addedToGroup: function() {
            this._dragPhase || this._wasEnabled && !this.enabled && this.start()
        },
        removedFromGroup: function() {
            this._dragPhase || (this.enabled ? (this._wasEnabled = !0,
            this.stop()) : this._wasEnabled = !1)
        },
        reset: function() {
            this.enabled = !1;
            for (var a = 0; a < 10; a++)
                this._pointerData[a] = {
                    id: a,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                }
        },
        stop: function() {
            !1 !== this.enabled && (this.enabled = !1,
            this.game.input.interactiveItems.remove(this))
        },
        destroy: function() {
            this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default",
            this._setHandCursor = !1),
            this.enabled = !1,
            this.game.input.interactiveItems.remove(this),
            this._pointerData.length = 0,
            this.boundsRect = null,
            this.boundsSprite = null,
            this.sprite = null)
        },
        validForInput: function(a, b, c) {
            return void 0 === c && (c = !0),
            !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!c && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > a || this.priorityID === a && this.sprite.renderOrderID > b))
        },
        isPixelPerfect: function() {
            return this.pixelPerfectClick || this.pixelPerfectOver
        },
        pointerX: function(a) {
            return a = a || 0,
            this._pointerData[a].x
        },
        pointerY: function(a) {
            return a = a || 0,
            this._pointerData[a].y
        },
        pointerDown: function(a) {
            return a = a || 0,
            this._pointerData[a].isDown
        },
        pointerUp: function(a) {
            return a = a || 0,
            this._pointerData[a].isUp
        },
        pointerTimeDown: function(a) {
            return a = a || 0,
            this._pointerData[a].timeDown
        },
        pointerTimeUp: function(a) {
            return a = a || 0,
            this._pointerData[a].timeUp
        },
        pointerOver: function(a) {
            if (!this.enabled)
                return !1;
            if (void 0 === a) {
                for (var b = 0; b < 10; b++)
                    if (this._pointerData[b].isOver)
                        return !0;
                return !1
            }
            return this._pointerData[a].isOver
        },
        pointerOut: function(a) {
            if (!this.enabled)
                return !1;
            if (void 0 !== a)
                return this._pointerData[a].isOut;
            for (var b = 0; b < 10; b++)
                if (this._pointerData[b].isOut)
                    return !0
        },
        pointerTimeOver: function(a) {
            return a = a || 0,
            this._pointerData[a].timeOver
        },
        pointerTimeOut: function(a) {
            return a = a || 0,
            this._pointerData[a].timeOut
        },
        pointerDragged: function(a) {
            return a = a || 0,
            this._pointerData[a].isDragged
        },
        checkPointerDown: function(a, b) {
            return !!(a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1),
            !(!b && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
        },
        checkPointerOver: function(a, b) {
            return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (void 0 === b && (b = !1),
            !(!b && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
        },
        checkPixel: function(a, b, c) {
            if (this.sprite.texture.baseTexture.source) {
                if (null === a && null === b) {
                    this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
                    var a = this._tempPoint.x
                      , b = this._tempPoint.y
                }
                if (0 !== this.sprite.anchor.x && (a -= -this.sprite.texture.frame.width * this.sprite.anchor.x),
                0 !== this.sprite.anchor.y && (b -= -this.sprite.texture.frame.height * this.sprite.anchor.y),
                a += this.sprite.texture.frame.x,
                b += this.sprite.texture.frame.y,
                this.sprite.texture.trim && (a -= this.sprite.texture.trim.x,
                b -= this.sprite.texture.trim.y,
                a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom))
                    return this._dx = a,
                    this._dy = b,
                    !1;
                this._dx = a,
                this._dy = b,
                this.game.input.hitContext.clearRect(0, 0, 1, 1),
                this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
                if (this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha)
                    return !0
            }
            return !1
        },
        update: function(a) {
            if (null !== this.sprite && void 0 !== this.sprite.parent)
                return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = b.Math.distance(a.x, a.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold),
                this._dragDistancePass && this._dragTimePass && this.startDrag(a),
                !0) : this.draggable && this._draggedPointerID === a.id ? this.updateDrag(a, !1) : this._pointerData[a.id].isOver ? this.checkPointerOver(a) ? (this._pointerData[a.id].x = a.x - this.sprite.x,
                this._pointerData[a.id].y = a.y - this.sprite.y,
                !0) : (this._pointerOutHandler(a),
                !1) : void 0 : (this._pointerOutHandler(a),
                !1)
        },
        _pointerOverHandler: function(a, c) {
            if (null !== this.sprite) {
                var d = this._pointerData[a.id];
                if (!1 === d.isOver || a.dirty) {
                    var e = !1 === d.isOver;
                    d.isOver = !0,
                    d.isOut = !1,
                    d.timeOver = this.game.time.time,
                    d.x = a.x - this.sprite.x,
                    d.y = a.y - this.sprite.y,
                    this.useHandCursor && !1 === d.isDragged && (this.game.canvas.style.cursor = "pointer",
                    this._setHandCursor = !0),
                    !c && e && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, a),
                    this.sprite.parent && this.sprite.parent.type === b.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, a)
                }
            }
        },
        _pointerOutHandler: function(a, c) {
            if (null !== this.sprite) {
                var d = this._pointerData[a.id];
                d.isOver = !1,
                d.isOut = !0,
                d.timeOut = this.game.time.time,
                this.useHandCursor && !1 === d.isDragged && (this.game.canvas.style.cursor = "default",
                this._setHandCursor = !1),
                !c && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, a),
                this.sprite && this.sprite.parent && this.sprite.parent.type === b.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, a))
            }
        },
        _touchedHandler: function(a) {
            if (null !== this.sprite) {
                var c = this._pointerData[a.id];
                if (!c.isDown && c.isOver) {
                    if (this.pixelPerfectClick && !this.checkPixel(null, null, a))
                        return;
                    if (c.isDown = !0,
                    c.isUp = !1,
                    c.timeDown = this.game.time.time,
                    this.downPoint.set(a.x, a.y),
                    a.dirty = !0,
                    this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, a),
                    this.sprite && this.sprite.parent && this.sprite.parent.type === b.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, a),
                    null === this.sprite))
                        return;
                    this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(a) : (this._pendingDrag = !0,
                    this._dragDistancePass = 0 === this.dragDistanceThreshold,
                    this.dragTimeThreshold > 0 ? (this._dragTimePass = !1,
                    this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, a)) : this._dragTimePass = !0)),
                    this.bringToTop && this.sprite.bringToTop()
                }
            }
        },
        dragTimeElapsed: function(a) {
            this._dragTimePass = !0,
            this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(a)
        },
        _releasedHandler: function(a) {
            if (null !== this.sprite) {
                var c = this._pointerData[a.id];
                if (c.isDown && a.isUp) {
                    c.isDown = !1,
                    c.isUp = !0,
                    c.timeUp = this.game.time.time,
                    c.downDuration = c.timeUp - c.timeDown;
                    var d = this.checkPointerOver(a);
                    this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === a.id) || this.sprite.events.onInputUp$dispatch(this.sprite, a, d),
                    this.sprite && this.sprite.parent && this.sprite.parent.type === b.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, a, d),
                    d && (d = this.checkPointerOver(a))),
                    c.isOver = d,
                    !d && this.useHandCursor && (this.game.canvas.style.cursor = "default",
                    this._setHandCursor = !1),
                    a.dirty = !0,
                    this._pendingDrag = !1,
                    this.draggable && this.isDragged && this._draggedPointerID === a.id && this.stopDrag(a)
                }
            }
        },
        updateDrag: function(a, b) {
            if (void 0 === b && (b = !1),
            a.isUp)
                return this.stopDrag(a),
                !1;
            var c = this.globalToLocalX(a.x) + this._dragPoint.x + this.dragOffset.x
              , d = this.globalToLocalY(a.y) + this._dragPoint.y + this.dragOffset.y;
            if (this.sprite.fixedToCamera)
                this.allowHorizontalDrag && (this.sprite.cameraOffset.x = c),
                this.allowVerticalDrag && (this.sprite.cameraOffset.y = d),
                this.boundsRect && this.checkBoundsRect(),
                this.boundsSprite && this.checkBoundsSprite(),
                this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
                this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY,
                this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
            else {
                var e = this.game.camera.x - this._pointerData[a.id].camX
                  , f = this.game.camera.y - this._pointerData[a.id].camY;
                this.allowHorizontalDrag && (this.sprite.x = c + e),
                this.allowVerticalDrag && (this.sprite.y = d + f),
                this.boundsRect && this.checkBoundsRect(),
                this.boundsSprite && this.checkBoundsSprite(),
                this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
                this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY,
                this.snapPoint.set(this.sprite.x, this.sprite.y))
            }
            return this.sprite.events.onDragUpdate.dispatch(this.sprite, a, c, d, this.snapPoint, b),
            !0
        },
        justOver: function(a, b) {
            return a = a || 0,
            b = b || 500,
            this._pointerData[a].isOver && this.overDuration(a) < b
        },
        justOut: function(a, b) {
            return a = a || 0,
            b = b || 500,
            this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b
        },
        justPressed: function(a, b) {
            return a = a || 0,
            b = b || 500,
            this._pointerData[a].isDown && this.downDuration(a) < b
        },
        justReleased: function(a, b) {
            return a = a || 0,
            b = b || 500,
            this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b
        },
        overDuration: function(a) {
            return a = a || 0,
            this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1
        },
        downDuration: function(a) {
            return a = a || 0,
            this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1
        },
        enableDrag: function(a, c, d, e, f, g) {
            void 0 === a && (a = !1),
            void 0 === c && (c = !1),
            void 0 === d && (d = !1),
            void 0 === e && (e = 255),
            void 0 === f && (f = null),
            void 0 === g && (g = null),
            this._dragPoint = new b.Point,
            this.draggable = !0,
            this.bringToTop = c,
            this.dragOffset = new b.Point,
            this.dragFromCenter = a,
            this.pixelPerfectClick = d,
            this.pixelPerfectAlpha = e,
            f && (this.boundsRect = f),
            g && (this.boundsSprite = g)
        },
        disableDrag: function() {
            if (this._pointerData)
                for (var a = 0; a < 10; a++)
                    this._pointerData[a].isDragged = !1;
            this.draggable = !1,
            this.isDragged = !1,
            this._draggedPointerID = -1,
            this._pendingDrag = !1
        },
        startDrag: function(a) {
            var b = this.sprite.x
              , c = this.sprite.y;
            if (this.isDragged = !0,
            this._draggedPointerID = a.id,
            this._pointerData[a.id].camX = this.game.camera.x,
            this._pointerData[a.id].camY = this.game.camera.y,
            this._pointerData[a.id].isDragged = !0,
            this.sprite.fixedToCamera) {
                if (this.dragFromCenter) {
                    var d = this.sprite.getBounds();
                    this.sprite.cameraOffset.x = this.globalToLocalX(a.x) + (this.sprite.cameraOffset.x - d.centerX),
                    this.sprite.cameraOffset.y = this.globalToLocalY(a.y) + (this.sprite.cameraOffset.y - d.centerY)
                }
                this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y)
            } else {
                if (this.dragFromCenter) {
                    var d = this.sprite.getBounds();
                    this.sprite.x = this.globalToLocalX(a.x) + (this.sprite.x - d.centerX),
                    this.sprite.y = this.globalToLocalY(a.y) + (this.sprite.y - d.centerY)
                }
                this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(a.x), this.sprite.y - this.globalToLocalY(a.y))
            }
            this.updateDrag(a, !0),
            this.bringToTop && (this._dragPhase = !0,
            this.sprite.bringToTop()),
            this.dragStartPoint.set(b, c),
            this.sprite.events.onDragStart$dispatch(this.sprite, a, b, c),
            this._pendingDrag = !1
        },
        globalToLocalX: function(a) {
            return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.x,
            a *= this.game.scale.grid.scaleFluidInversed.x),
            a
        },
        globalToLocalY: function(a) {
            return this.scaleLayer && (a -= this.game.scale.grid.boundsFluid.y,
            a *= this.game.scale.grid.scaleFluidInversed.y),
            a
        },
        stopDrag: function(a) {
            this.isDragged = !1,
            this._draggedPointerID = -1,
            this._pointerData[a.id].isDragged = !1,
            this._dragPhase = !1,
            this._pendingDrag = !1,
            this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX,
            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)),
            this.sprite.events.onDragStop$dispatch(this.sprite, a),
            !1 === this.checkPointerOver(a) && this._pointerOutHandler(a)
        },
        setDragLock: function(a, b) {
            void 0 === a && (a = !0),
            void 0 === b && (b = !0),
            this.allowHorizontalDrag = a,
            this.allowVerticalDrag = b
        },
        enableSnap: function(a, b, c, d, e, f) {
            void 0 === c && (c = !0),
            void 0 === d && (d = !1),
            void 0 === e && (e = 0),
            void 0 === f && (f = 0),
            this.snapX = a,
            this.snapY = b,
            this.snapOffsetX = e,
            this.snapOffsetY = f,
            this.snapOnDrag = c,
            this.snapOnRelease = d
        },
        disableSnap: function() {
            this.snapOnDrag = !1,
            this.snapOnRelease = !1
        },
        checkBoundsRect: function() {
            this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width),
            this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)),
            this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
        },
        checkBoundsSprite: function() {
            this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width),
            this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)),
            this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
        }
    },
    b.InputHandler.prototype.constructor = b.InputHandler,
    b.Gamepad = function(a) {
        this.game = a,
        this._gamepadIndexMap = {},
        this._rawPads = [],
        this._active = !1,
        this.enabled = !0,
        this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads,
        this._prevRawGamepadTypes = [],
        this._prevTimestamps = [],
        this.callbackContext = this,
        this.onConnectCallback = null,
        this.onDisconnectCallback = null,
        this.onDownCallback = null,
        this.onUpCallback = null,
        this.onAxisCallback = null,
        this.onFloatCallback = null,
        this._ongamepadconnected = null,
        this._gamepaddisconnected = null,
        this._gamepads = [new b.SinglePad(a,this), new b.SinglePad(a,this), new b.SinglePad(a,this), new b.SinglePad(a,this)]
    }
    ,
    b.Gamepad.prototype = {
        addCallbacks: function(a, b) {
            void 0 !== b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback,
            this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback,
            this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback,
            this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback,
            this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback,
            this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback,
            this.callbackContext = a)
        },
        start: function() {
            if (!this._active) {
                this._active = !0;
                var a = this;
                this._onGamepadConnected = function(b) {
                    return a.onGamepadConnected(b)
                }
                ,
                this._onGamepadDisconnected = function(b) {
                    return a.onGamepadDisconnected(b)
                }
                ,
                window.addEventListener("gamepadconnected", this._onGamepadConnected, !1),
                window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
            }
        },
        onGamepadConnected: function(a) {
            var b = a.gamepad;
            this._rawPads.push(b),
            this._gamepads[b.index].connect(b)
        },
        onGamepadDisconnected: function(a) {
            var b = a.gamepad;
            for (var c in this._rawPads)
                this._rawPads[c].index === b.index && this._rawPads.splice(c, 1);
            this._gamepads[b.index].disconnect()
        },
        update: function() {
            this._pollGamepads(),
            this.pad1.pollStatus(),
            this.pad2.pollStatus(),
            this.pad3.pollStatus(),
            this.pad4.pollStatus()
        },
        _pollGamepads: function() {
            if (this._active) {
                if (navigator.getGamepads)
                    var a = navigator.getGamepads();
                else if (navigator.webkitGetGamepads)
                    var a = navigator.webkitGetGamepads();
                else if (navigator.webkitGamepads)
                    var a = navigator.webkitGamepads();
                if (a) {
                    this._rawPads = [];
                    for (var b = !1, c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && (b = !0,
                    this._prevRawGamepadTypes[c] = typeof a[c]),
                    a[c] && this._rawPads.push(a[c]),
                    3 !== c); c++)
                        ;
                    for (var d = 0; d < this._gamepads.length; d++)
                        this._gamepads[d]._rawPad = this._rawPads[d];
                    if (b) {
                        for (var f, e = {
                            rawIndices: {},
                            padIndices: {}
                        }, g = 0; g < this._gamepads.length; g++)
                            if (f = this._gamepads[g],
                            f.connected)
                                for (var h = 0; h < this._rawPads.length; h++)
                                    this._rawPads[h].index === f.index && (e.rawIndices[f.index] = !0,
                                    e.padIndices[g] = !0);
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (f = this._gamepads[i],
                            !e.padIndices[i]) {
                                this._rawPads.length < 1 && f.disconnect();
                                for (var j = 0; j < this._rawPads.length && !e.padIndices[i]; j++) {
                                    var k = this._rawPads[j];
                                    if (k) {
                                        if (e.rawIndices[k.index]) {
                                            f.disconnect();
                                            continue
                                        }
                                        f.connect(k),
                                        e.rawIndices[k.index] = !0,
                                        e.padIndices[i] = !0
                                    } else
                                        f.disconnect()
                                }
                            }
                    }
                }
            }
        },
        setDeadZones: function(a) {
            for (var b = 0; b < this._gamepads.length; b++)
                this._gamepads[b].deadZone = a
        },
        stop: function() {
            this._active = !1,
            window.removeEventListener("gamepadconnected", this._onGamepadConnected),
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
        },
        reset: function() {
            this.update();
            for (var a = 0; a < this._gamepads.length; a++)
                this._gamepads[a].reset()
        },
        justPressed: function(a, b) {
            for (var c = 0; c < this._gamepads.length; c++)
                if (!0 === this._gamepads[c].justPressed(a, b))
                    return !0;
            return !1
        },
        justReleased: function(a, b) {
            for (var c = 0; c < this._gamepads.length; c++)
                if (!0 === this._gamepads[c].justReleased(a, b))
                    return !0;
            return !1
        },
        isDown: function(a) {
            for (var b = 0; b < this._gamepads.length; b++)
                if (!0 === this._gamepads[b].isDown(a))
                    return !0;
            return !1
        },
        destroy: function() {
            this.stop();
            for (var a = 0; a < this._gamepads.length; a++)
                this._gamepads[a].destroy()
        }
    },
    b.Gamepad.prototype.constructor = b.Gamepad,
    Object.defineProperty(b.Gamepad.prototype, "active", {
        get: function() {
            return this._active
        }
    }),
    Object.defineProperty(b.Gamepad.prototype, "supported", {
        get: function() {
            return this._gamepadSupportAvailable
        }
    }),
    Object.defineProperty(b.Gamepad.prototype, "padsConnected", {
        get: function() {
            return this._rawPads.length
        }
    }),
    Object.defineProperty(b.Gamepad.prototype, "pad1", {
        get: function() {
            return this._gamepads[0]
        }
    }),
    Object.defineProperty(b.Gamepad.prototype, "pad2", {
        get: function() {
            return this._gamepads[1]
        }
    }),
    Object.defineProperty(b.Gamepad.prototype, "pad3", {
        get: function() {
            return this._gamepads[2]
        }
    }),
    Object.defineProperty(b.Gamepad.prototype, "pad4", {
        get: function() {
            return this._gamepads[3]
        }
    }),
    b.Gamepad.BUTTON_0 = 0,
    b.Gamepad.BUTTON_1 = 1,
    b.Gamepad.BUTTON_2 = 2,
    b.Gamepad.BUTTON_3 = 3,
    b.Gamepad.BUTTON_4 = 4,
    b.Gamepad.BUTTON_5 = 5,
    b.Gamepad.BUTTON_6 = 6,
    b.Gamepad.BUTTON_7 = 7,
    b.Gamepad.BUTTON_8 = 8,
    b.Gamepad.BUTTON_9 = 9,
    b.Gamepad.BUTTON_10 = 10,
    b.Gamepad.BUTTON_11 = 11,
    b.Gamepad.BUTTON_12 = 12,
    b.Gamepad.BUTTON_13 = 13,
    b.Gamepad.BUTTON_14 = 14,
    b.Gamepad.BUTTON_15 = 15,
    b.Gamepad.AXIS_0 = 0,
    b.Gamepad.AXIS_1 = 1,
    b.Gamepad.AXIS_2 = 2,
    b.Gamepad.AXIS_3 = 3,
    b.Gamepad.AXIS_4 = 4,
    b.Gamepad.AXIS_5 = 5,
    b.Gamepad.AXIS_6 = 6,
    b.Gamepad.AXIS_7 = 7,
    b.Gamepad.AXIS_8 = 8,
    b.Gamepad.AXIS_9 = 9,
    b.Gamepad.XBOX360_A = 0,
    b.Gamepad.XBOX360_B = 1,
    b.Gamepad.XBOX360_X = 2,
    b.Gamepad.XBOX360_Y = 3,
    b.Gamepad.XBOX360_LEFT_BUMPER = 4,
    b.Gamepad.XBOX360_RIGHT_BUMPER = 5,
    b.Gamepad.XBOX360_LEFT_TRIGGER = 6,
    b.Gamepad.XBOX360_RIGHT_TRIGGER = 7,
    b.Gamepad.XBOX360_BACK = 8,
    b.Gamepad.XBOX360_START = 9,
    b.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10,
    b.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11,
    b.Gamepad.XBOX360_DPAD_LEFT = 14,
    b.Gamepad.XBOX360_DPAD_RIGHT = 15,
    b.Gamepad.XBOX360_DPAD_UP = 12,
    b.Gamepad.XBOX360_DPAD_DOWN = 13,
    b.Gamepad.XBOX360_STICK_LEFT_X = 0,
    b.Gamepad.XBOX360_STICK_LEFT_Y = 1,
    b.Gamepad.XBOX360_STICK_RIGHT_X = 2,
    b.Gamepad.XBOX360_STICK_RIGHT_Y = 3,
    b.Gamepad.PS3XC_X = 0,
    b.Gamepad.PS3XC_CIRCLE = 1;
    b.Gamepad.PS3XC_SQUARE = 2,
    b.Gamepad.PS3XC_TRIANGLE = 3,
    b.Gamepad.PS3XC_L1 = 4,
    b.Gamepad.PS3XC_R1 = 5,
    b.Gamepad.PS3XC_L2 = 6,
    b.Gamepad.PS3XC_R2 = 7,
    b.Gamepad.PS3XC_SELECT = 8,
    b.Gamepad.PS3XC_START = 9,
    b.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10,
    b.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11,
    b.Gamepad.PS3XC_DPAD_UP = 12,
    b.Gamepad.PS3XC_DPAD_DOWN = 13,
    b.Gamepad.PS3XC_DPAD_LEFT = 14,
    b.Gamepad.PS3XC_DPAD_RIGHT = 15,
    b.Gamepad.PS3XC_STICK_LEFT_X = 0,
    b.Gamepad.PS3XC_STICK_LEFT_Y = 1,
    b.Gamepad.PS3XC_STICK_RIGHT_X = 2,
    b.Gamepad.PS3XC_STICK_RIGHT_Y = 3,
    b.SinglePad = function(a, b) {
        this.game = a,
        this.index = null,
        this.connected = !1,
        this.callbackContext = this,
        this.onConnectCallback = null,
        this.onDisconnectCallback = null,
        this.onDownCallback = null,
        this.onUpCallback = null,
        this.onAxisCallback = null,
        this.onFloatCallback = null,
        this.deadZone = .26,
        this._padParent = b,
        this._rawPad = null,
        this._prevTimestamp = null,
        this._buttons = [],
        this._buttonsLen = 0,
        this._axes = [],
        this._axesLen = 0
    }
    ,
    b.SinglePad.prototype = {
        addCallbacks: function(a, b) {
            void 0 !== b && (this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback,
            this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback,
            this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback,
            this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback,
            this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback,
            this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback,
            this.callbackContext = a)
        },
        getButton: function(a) {
            return this._buttons[a] ? this._buttons[a] : null
        },
        pollStatus: function() {
            if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                for (var a = 0; a < this._buttonsLen; a++) {
                    var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
                    b !== this._buttons[a].value && (1 === b ? this.processButtonDown(a, b) : 0 === b ? this.processButtonUp(a, b) : this.processButtonFloat(a, b))
                }
                for (var c = 0; c < this._axesLen; c++) {
                    var d = this._rawPad.axes[c];
                    d > 0 && d > this.deadZone || d < 0 && d < -this.deadZone ? this.processAxisChange(c, d) : this.processAxisChange(c, 0)
                }
                this._prevTimestamp = this._rawPad.timestamp
            }
        },
        connect: function(a) {
            var c = !this.connected;
            this.connected = !0,
            this.index = a.index,
            this._rawPad = a,
            this._buttons = [],
            this._buttonsLen = a.buttons.length,
            this._axes = [],
            this._axesLen = a.axes.length;
            for (var d = 0; d < this._axesLen; d++)
                this._axes[d] = a.axes[d];
            for (var e in a.buttons)
                e = parseInt(e, 10),
                this._buttons[e] = new b.DeviceButton(this,e);
            c && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index),
            c && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
        },
        disconnect: function() {
            var a = this.connected
              , b = this.index;
            this.connected = !1,
            this.index = null,
            this._rawPad = void 0;
            for (var c = 0; c < this._buttonsLen; c++)
                this._buttons[c].destroy();
            this._buttons = [],
            this._buttonsLen = 0,
            this._axes = [],
            this._axesLen = 0,
            a && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b),
            a && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
        },
        destroy: function() {
            this._rawPad = void 0;
            for (var a = 0; a < this._buttonsLen; a++)
                this._buttons[a].destroy();
            this._buttons = [],
            this._buttonsLen = 0,
            this._axes = [],
            this._axesLen = 0,
            this.onConnectCallback = null,
            this.onDisconnectCallback = null,
            this.onDownCallback = null,
            this.onUpCallback = null,
            this.onAxisCallback = null,
            this.onFloatCallback = null
        },
        processAxisChange: function(a, b) {
            this._axes[a] !== b && (this._axes[a] = b,
            this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b),
            this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, a, b))
        },
        processButtonDown: function(a, b) {
            this._buttons[a] && this._buttons[a].start(null, b),
            this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index),
            this.onDownCallback && this.onDownCallback.call(this.callbackContext, a, b)
        },
        processButtonUp: function(a, b) {
            this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index),
            this.onUpCallback && this.onUpCallback.call(this.callbackContext, a, b),
            this._buttons[a] && this._buttons[a].stop(null, b)
        },
        processButtonFloat: function(a, b) {
            this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index),
            this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, a, b),
            this._buttons[a] && this._buttons[a].padFloat(b)
        },
        axis: function(a) {
            return !!this._axes[a] && this._axes[a]
        },
        isDown: function(a) {
            return !!this._buttons[a] && this._buttons[a].isDown
        },
        isUp: function(a) {
            return !!this._buttons[a] && this._buttons[a].isUp
        },
        justReleased: function(a, b) {
            if (this._buttons[a])
                return this._buttons[a].justReleased(b)
        },
        justPressed: function(a, b) {
            if (this._buttons[a])
                return this._buttons[a].justPressed(b)
        },
        buttonValue: function(a) {
            return this._buttons[a] ? this._buttons[a].value : null
        },
        reset: function() {
            for (var a = 0; a < this._axes.length; a++)
                this._axes[a] = 0
        }
    },
    b.SinglePad.prototype.constructor = b.SinglePad,
    b.Key = function(a, c) {
        this.game = a,
        this._enabled = !0,
        this.event = null,
        this.isDown = !1,
        this.isUp = !0,
        this.altKey = !1,
        this.ctrlKey = !1,
        this.shiftKey = !1,
        this.timeDown = 0,
        this.duration = 0,
        this.timeUp = -2500,
        this.repeats = 0,
        this.keyCode = c,
        this.onDown = new b.Signal,
        this.onHoldCallback = null,
        this.onHoldContext = null,
        this.onUp = new b.Signal,
        this._justDown = !1,
        this._justUp = !1
    }
    ,
    b.Key.prototype = {
        update: function() {
            this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown,
            this.repeats++,
            this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
        },
        processKeyDown: function(a) {
            this._enabled && (this.event = a,
            this.isDown || (this.altKey = a.altKey,
            this.ctrlKey = a.ctrlKey,
            this.shiftKey = a.shiftKey,
            this.isDown = !0,
            this.isUp = !1,
            this.timeDown = this.game.time.time,
            this.duration = 0,
            this.repeats = 0,
            this._justDown = !0,
            this.onDown.dispatch(this)))
        },
        processKeyUp: function(a) {
            this._enabled && (this.event = a,
            this.isUp || (this.isDown = !1,
            this.isUp = !0,
            this.timeUp = this.game.time.time,
            this.duration = this.game.time.time - this.timeDown,
            this._justUp = !0,
            this.onUp.dispatch(this)))
        },
        reset: function(a) {
            void 0 === a && (a = !0),
            this.isDown = !1,
            this.isUp = !0,
            this.timeUp = this.game.time.time,
            this.duration = 0,
            this._enabled = !0,
            this._justDown = !1,
            this._justUp = !1,
            a && (this.onDown.removeAll(),
            this.onUp.removeAll(),
            this.onHoldCallback = null,
            this.onHoldContext = null)
        },
        downDuration: function(a) {
            return void 0 === a && (a = 50),
            this.isDown && this.duration < a
        },
        upDuration: function(a) {
            return void 0 === a && (a = 50),
            !this.isDown && this.game.time.time - this.timeUp < a
        }
    },
    Object.defineProperty(b.Key.prototype, "justDown", {
        get: function() {
            var a = this._justDown;
            return this._justDown = !1,
            a
        }
    }),
    Object.defineProperty(b.Key.prototype, "justUp", {
        get: function() {
            var a = this._justUp;
            return this._justUp = !1,
            a
        }
    }),
    Object.defineProperty(b.Key.prototype, "enabled", {
        get: function() {
            return this._enabled
        },
        set: function(a) {
            (a = !!a) !== this._enabled && (a || this.reset(!1),
            this._enabled = a)
        }
    }),
    b.Key.prototype.constructor = b.Key,
    b.Keyboard = function(a) {
        this.game = a,
        this.enabled = !0,
        this.event = null,
        this.pressEvent = null,
        this.callbackContext = this,
        this.onDownCallback = null,
        this.onPressCallback = null,
        this.onUpCallback = null,
        this._keys = [],
        this._capture = [],
        this._onKeyDown = null,
        this._onKeyPress = null,
        this._onKeyUp = null,
        this._i = 0,
        this._k = 0
    }
    ,
    b.Keyboard.prototype = {
        addCallbacks: function(a, b, c, d) {
            this.callbackContext = a,
            void 0 !== b && null !== b && (this.onDownCallback = b),
            void 0 !== c && null !== c && (this.onUpCallback = c),
            void 0 !== d && null !== d && (this.onPressCallback = d)
        },
        addKey: function(a) {
            return this._keys[a] || (this._keys[a] = new b.Key(this.game,a),
            this.addKeyCapture(a)),
            this._keys[a]
        },
        addKeys: function(a) {
            var b = {};
            for (var c in a)
                b[c] = this.addKey(a[c]);
            return b
        },
        removeKey: function(a) {
            this._keys[a] && (this._keys[a] = null,
            this.removeKeyCapture(a))
        },
        createCursorKeys: function() {
            return this.addKeys({
                up: b.KeyCode.UP,
                down: b.KeyCode.DOWN,
                left: b.KeyCode.LEFT,
                right: b.KeyCode.RIGHT
            })
        },
        start: function() {
            if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                var a = this;
                this._onKeyDown = function(b) {
                    return a.processKeyDown(b)
                }
                ,
                this._onKeyUp = function(b) {
                    return a.processKeyUp(b)
                }
                ,
                this._onKeyPress = function(b) {
                    return a.processKeyPress(b)
                }
                ,
                window.addEventListener("keydown", this._onKeyDown, !1),
                window.addEventListener("keyup", this._onKeyUp, !1),
                window.addEventListener("keypress", this._onKeyPress, !1)
            }
        },
        stop: function() {
            window.removeEventListener("keydown", this._onKeyDown),
            window.removeEventListener("keyup", this._onKeyUp),
            window.removeEventListener("keypress", this._onKeyPress),
            this._onKeyDown = null,
            this._onKeyUp = null,
            this._onKeyPress = null
        },
        destroy: function() {
            this.stop(),
            this.clearCaptures(),
            this._keys.length = 0,
            this._i = 0
        },
        addKeyCapture: function(a) {
            if ("object" == typeof a)
                for (var b in a)
                    this._capture[a[b]] = !0;
            else
                this._capture[a] = !0
        },
        removeKeyCapture: function(a) {
            delete this._capture[a]
        },
        clearCaptures: function() {
            this._capture = {}
        },
        update: function() {
            for (this._i = this._keys.length; this._i--; )
                this._keys[this._i] && this._keys[this._i].update()
        },
        processKeyDown: function(a) {
            if (this.event = a,
            this.game.input.enabled && this.enabled) {
                var c = a.keyCode;
                this._capture[c] && a.preventDefault(),
                this._keys[c] || (this._keys[c] = new b.Key(this.game,c)),
                this._keys[c].processKeyDown(a),
                this._k = c,
                this.onDownCallback && this.onDownCallback.call(this.callbackContext, a)
            }
        },
        processKeyPress: function(a) {
            this.pressEvent = a,
            this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a)
        },
        processKeyUp: function(a) {
            if (this.event = a,
            this.game.input.enabled && this.enabled) {
                var c = a.keyCode;
                this._capture[c] && a.preventDefault(),
                this._keys[c] || (this._keys[c] = new b.Key(this.game,c)),
                this._keys[c].processKeyUp(a),
                this.onUpCallback && this.onUpCallback.call(this.callbackContext, a)
            }
        },
        reset: function(a) {
            void 0 === a && (a = !0),
            this.event = null;
            for (var b = this._keys.length; b--; )
                this._keys[b] && this._keys[b].reset(a)
        },
        downDuration: function(a, b) {
            return this._keys[a] ? this._keys[a].downDuration(b) : null
        },
        upDuration: function(a, b) {
            return this._keys[a] ? this._keys[a].upDuration(b) : null
        },
        isDown: function(a) {
            return this._keys[a] ? this._keys[a].isDown : null
        }
    },
    Object.defineProperty(b.Keyboard.prototype, "lastChar", {
        get: function() {
            return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
        }
    }),
    Object.defineProperty(b.Keyboard.prototype, "lastKey", {
        get: function() {
            return this._keys[this._k]
        }
    }),
    b.Keyboard.prototype.constructor = b.Keyboard,
    b.KeyCode = {
        A: "A".charCodeAt(0),
        B: "B".charCodeAt(0),
        C: "C".charCodeAt(0),
        D: "D".charCodeAt(0),
        E: "E".charCodeAt(0),
        F: "F".charCodeAt(0),
        G: "G".charCodeAt(0),
        H: "H".charCodeAt(0),
        I: "I".charCodeAt(0),
        J: "J".charCodeAt(0),
        K: "K".charCodeAt(0),
        L: "L".charCodeAt(0),
        M: "M".charCodeAt(0),
        N: "N".charCodeAt(0),
        O: "O".charCodeAt(0),
        P: "P".charCodeAt(0),
        Q: "Q".charCodeAt(0),
        R: "R".charCodeAt(0),
        S: "S".charCodeAt(0),
        T: "T".charCodeAt(0),
        U: "U".charCodeAt(0),
        V: "V".charCodeAt(0),
        W: "W".charCodeAt(0),
        X: "X".charCodeAt(0),
        Y: "Y".charCodeAt(0),
        Z: "Z".charCodeAt(0),
        ZERO: "0".charCodeAt(0),
        ONE: "1".charCodeAt(0),
        TWO: "2".charCodeAt(0),
        THREE: "3".charCodeAt(0),
        FOUR: "4".charCodeAt(0),
        FIVE: "5".charCodeAt(0),
        SIX: "6".charCodeAt(0),
        SEVEN: "7".charCodeAt(0),
        EIGHT: "8".charCodeAt(0),
        NINE: "9".charCodeAt(0),
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_ADD: 107,
        NUMPAD_ENTER: 108,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        F13: 124,
        F14: 125,
        F15: 126,
        COLON: 186,
        EQUALS: 187,
        COMMA: 188,
        UNDERSCORE: 189,
        PERIOD: 190,
        QUESTION_MARK: 191,
        TILDE: 192,
        OPEN_BRACKET: 219,
        BACKWARD_SLASH: 220,
        CLOSED_BRACKET: 221,
        QUOTES: 222,
        BACKSPACE: 8,
        TAB: 9,
        CLEAR: 12,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        CAPS_LOCK: 20,
        ESC: 27,
        SPACEBAR: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        PLUS: 43,
        MINUS: 44,
        INSERT: 45,
        DELETE: 46,
        HELP: 47,
        NUM_LOCK: 144
    };
    for (var e in b.KeyCode)
        b.KeyCode.hasOwnProperty(e) && !e.match(/[a-z]/) && (b.Keyboard[e] = b.KeyCode[e]);
    b.Component = function() {}
    ,
    b.Component.Angle = function() {}
    ,
    b.Component.Angle.prototype = {
        angle: {
            get: function() {
                return b.Math.wrapAngle(b.Math.radToDeg(this.rotation))
            },
            set: function(a) {
                this.rotation = b.Math.degToRad(b.Math.wrapAngle(a))
            }
        }
    },
    b.Component.Animation = function() {}
    ,
    b.Component.Animation.prototype = {
        play: function(a, b, c, d) {
            if (this.animations)
                return this.animations.play(a, b, c, d)
        }
    },
    b.Component.AutoCull = function() {}
    ,
    b.Component.AutoCull.prototype = {
        autoCull: !1,
        inCamera: {
            get: function() {
                return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()),
                this._bounds.x += this.game.camera.view.x,
                this._bounds.y += this.game.camera.view.y),
                this.game.world.camera.view.intersects(this._bounds)
            }
        }
    },
    b.Component.Bounds = function() {}
    ,
    b.Component.Bounds.prototype = {
        offsetX: {
            get: function() {
                return this.anchor.x * this.width
            }
        },
        offsetY: {
            get: function() {
                return this.anchor.y * this.height
            }
        },
        centerX: {
            get: function() {
                return this.x - this.offsetX + .5 * this.width
            },
            set: function(a) {
                this.x = a + this.offsetX - .5 * this.width
            }
        },
        centerY: {
            get: function() {
                return this.y - this.offsetY + .5 * this.height
            },
            set: function(a) {
                this.y = a + this.offsetY - .5 * this.height
            }
        },
        left: {
            get: function() {
                return this.x - this.offsetX
            },
            set: function(a) {
                this.x = a + this.offsetX
            }
        },
        right: {
            get: function() {
                return this.x + this.width - this.offsetX
            },
            set: function(a) {
                this.x = a - this.width + this.offsetX
            }
        },
        top: {
            get: function() {
                return this.y - this.offsetY
            },
            set: function(a) {
                this.y = a + this.offsetY
            }
        },
        bottom: {
            get: function() {
                return this.y + this.height - this.offsetY
            },
            set: function(a) {
                this.y = a - this.height + this.offsetY
            }
        },
        alignIn: function(a, c, d, e) {
            switch (void 0 === d && (d = 0),
            void 0 === e && (e = 0),
            c) {
            default:
            case b.TOP_LEFT:
                this.left = a.left - d,
                this.top = a.top - e;
                break;
            case b.TOP_CENTER:
                this.centerX = a.centerX + d,
                this.top = a.top - e;
                break;
            case b.TOP_RIGHT:
                this.right = a.right + d,
                this.top = a.top - e;
                break;
            case b.LEFT_CENTER:
                this.left = a.left - d,
                this.centerY = a.centerY + e;
                break;
            case b.CENTER:
                this.centerX = a.centerX + d,
                this.centerY = a.centerY + e;
                break;
            case b.RIGHT_CENTER:
                this.right = a.right + d,
                this.centerY = a.centerY + e;
                break;
            case b.BOTTOM_LEFT:
                this.left = a.left - d,
                this.bottom = a.bottom + e;
                break;
            case b.BOTTOM_CENTER:
                this.centerX = a.centerX + d,
                this.bottom = a.bottom + e;
                break;
            case b.BOTTOM_RIGHT:
                this.right = a.right + d,
                this.bottom = a.bottom + e
            }
            return this
        },
        alignTo: function(a, c, d, e) {
            switch (void 0 === d && (d = 0),
            void 0 === e && (e = 0),
            c) {
            default:
            case b.TOP_LEFT:
                this.left = a.left - d,
                this.bottom = a.top - e;
                break;
            case b.TOP_CENTER:
                this.centerX = a.centerX + d,
                this.bottom = a.top - e;
                break;
            case b.TOP_RIGHT:
                this.right = a.right + d,
                this.bottom = a.top - e;
                break;
            case b.LEFT_TOP:
                this.right = a.left - d,
                this.top = a.top - e;
                break;
            case b.LEFT_CENTER:
                this.right = a.left - d,
                this.centerY = a.centerY + e;
                break;
            case b.LEFT_BOTTOM:
                this.right = a.left - d,
                this.bottom = a.bottom + e;
                break;
            case b.RIGHT_TOP:
                this.left = a.right + d,
                this.top = a.top - e;
                break;
            case b.RIGHT_CENTER:
                this.left = a.right + d,
                this.centerY = a.centerY + e;
                break;
            case b.RIGHT_BOTTOM:
                this.left = a.right + d,
                this.bottom = a.bottom + e;
                break;
            case b.BOTTOM_LEFT:
                this.left = a.left - d,
                this.top = a.bottom + e;
                break;
            case b.BOTTOM_CENTER:
                this.centerX = a.centerX + d,
                this.top = a.bottom + e;
                break;
            case b.BOTTOM_RIGHT:
                this.right = a.right + d,
                this.top = a.bottom + e
            }
            return this
        }
    },
    b.Group.prototype.alignIn = b.Component.Bounds.prototype.alignIn,
    b.Group.prototype.alignTo = b.Component.Bounds.prototype.alignTo,
    b.Component.BringToTop = function() {}
    ,
    b.Component.BringToTop.prototype.bringToTop = function() {
        return this.parent && this.parent.bringToTop(this),
        this
    }
    ,
    b.Component.BringToTop.prototype.sendToBack = function() {
        return this.parent && this.parent.sendToBack(this),
        this
    }
    ,
    b.Component.BringToTop.prototype.moveUp = function() {
        return this.parent && this.parent.moveUp(this),
        this
    }
    ,
    b.Component.BringToTop.prototype.moveDown = function() {
        return this.parent && this.parent.moveDown(this),
        this
    }
    ,
    b.Component.Core = function() {}
    ,
    b.Component.Core.install = function(a) {
        b.Utils.mixinPrototype(this, b.Component.Core.prototype),
        this.components = {};
        for (var c = 0; c < a.length; c++) {
            var d = a[c]
              , e = !1;
            "Destroy" === d && (e = !0),
            b.Utils.mixinPrototype(this, b.Component[d].prototype, e),
            this.components[d] = !0
        }
    }
    ,
    b.Component.Core.init = function(a, c, d, e, f) {
        this.game = a,
        this.key = e,
        this.data = {},
        this.position.set(c, d),
        this.world = new b.Point(c,d),
        this.previousPosition = new b.Point(c,d),
        this.events = new b.Events(this),
        this._bounds = new b.Rectangle,
        this.components.PhysicsBody && (this.body = this.body),
        this.components.Animation && (this.animations = new b.AnimationManager(this)),
        this.components.LoadTexture && null !== e && this.loadTexture(e, f),
        this.components.FixedToCamera && (this.cameraOffset = new b.Point(c,d))
    }
    ,
    b.Component.Core.preUpdate = function() {
        if (this.pendingDestroy)
            return void this.destroy();
        if (this.previousPosition.set(this.world.x, this.world.y),
        this.previousRotation = this.rotation,
        !this.exists || !this.parent.exists)
            return this.renderOrderID = -1,
            !1;
        this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty),
        this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++),
        this.animations && this.animations.update(),
        this.body && this.body.preUpdate();
        for (var a = 0; a < this.children.length; a++)
            this.children[a].preUpdate();
        return !0
    }
    ,
    b.Component.Core.prototype = {
        game: null,
        name: "",
        data: {},
        components: {},
        z: 0,
        events: void 0,
        animations: void 0,
        key: "",
        world: null,
        debug: !1,
        previousPosition: null,
        previousRotation: 0,
        renderOrderID: 0,
        fresh: !0,
        pendingDestroy: !1,
        _bounds: null,
        _exists: !0,
        exists: {
            get: function() {
                return this._exists
            },
            set: function(a) {
                a ? (this._exists = !0,
                this.body && this.body.type === b.Physics.P2JS && this.body.addToWorld(),
                this.visible = !0) : (this._exists = !1,
                this.body && this.body.type === b.Physics.P2JS && this.body.removeFromWorld(),
                this.visible = !1)
            }
        },
        update: function() {},
        postUpdate: function() {
            this.customRender && this.key.render(),
            this.components.PhysicsBody && b.Component.PhysicsBody.postUpdate.call(this),
            this.components.FixedToCamera && b.Component.FixedToCamera.postUpdate.call(this);
            for (var a = 0; a < this.children.length; a++)
                this.children[a].postUpdate()
        }
    },
    b.Component.Crop = function() {}
    ,
    b.Component.Crop.prototype = {
        cropRect: null,
        _crop: null,
        crop: function(a, c) {
            void 0 === c && (c = !1),
            a ? (c && null !== this.cropRect ? this.cropRect.setTo(a.x, a.y, a.width, a.height) : c && null === this.cropRect ? this.cropRect = new b.Rectangle(a.x,a.y,a.width,a.height) : this.cropRect = a,
            this.updateCrop()) : (this._crop = null,
            this.cropRect = null,
            this.resetFrame())
        },
        updateCrop: function() {
            if (this.cropRect) {
                var a = this.texture.crop.x
                  , c = this.texture.crop.y
                  , d = this.texture.crop.width
                  , e = this.texture.crop.height;
                this._crop = b.Rectangle.clone(this.cropRect, this._crop),
                this._crop.x += this._frame.x,
                this._crop.y += this._frame.y;
                var f = Math.max(this._frame.x, this._crop.x)
                  , g = Math.max(this._frame.y, this._crop.y)
                  , h = Math.min(this._frame.right, this._crop.right) - f
                  , i = Math.min(this._frame.bottom, this._crop.bottom) - g;
                this.texture.crop.x = f,
                this.texture.crop.y = g,
                this.texture.crop.width = h,
                this.texture.crop.height = i,
                this.texture.frame.width = Math.min(h, this.cropRect.width),
                this.texture.frame.height = Math.min(i, this.cropRect.height),
                this.texture.width = this.texture.frame.width,
                this.texture.height = this.texture.frame.height,
                this.texture._updateUvs(),
                16777215 === this.tint || a === f && c === g && d === h && e === i || (this.texture.requiresReTint = !0)
            }
        }
    },
    b.Component.Delta = function() {}
    ,
    b.Component.Delta.prototype = {
        deltaX: {
            get: function() {
                return this.world.x - this.previousPosition.x
            }
        },
        deltaY: {
            get: function() {
                return this.world.y - this.previousPosition.y
            }
        },
        deltaZ: {
            get: function() {
                return this.rotation - this.previousRotation
            }
        }
    },
    b.Component.Destroy = function() {}
    ,
    b.Component.Destroy.prototype = {
        destroyPhase: !1,
        destroy: function(a, c) {
            if (null !== this.game && !this.destroyPhase) {
                void 0 === a && (a = !0),
                void 0 === c && (c = !1),
                this.destroyPhase = !0,
                this.events && this.events.onDestroy$dispatch(this),
                this.parent && (this.parent instanceof b.Group ? this.parent.remove(this) : this.parent.removeChild(this)),
                this.input && this.input.destroy(),
                this.animations && this.animations.destroy(),
                this.body && this.body.destroy(),
                this.events && this.events.destroy(),
                this.game.tweens.removeFrom(this);
                var d = this.children.length;
                if (a)
                    for (; d--; )
                        this.children[d].destroy(a);
                else
                    for (; d--; )
                        this.removeChild(this.children[d]);
                this._crop && (this._crop = null,
                this.cropRect = null),
                this._frame && (this._frame = null),
                b.Video && this.key instanceof b.Video && this.key.onChangeSource.remove(this.resizeFrame, this),
                b.BitmapText && this._glyphs && (this._glyphs = []),
                this.alive = !1,
                this.exists = !1,
                this.visible = !1,
                this.filters = null,
                this.mask = null,
                this.game = null,
                this.data = {},
                this.renderable = !1,
                this.transformCallback && (this.transformCallback = null,
                this.transformCallbackContext = null),
                this.hitArea = null,
                this.parent = null,
                this.stage = null,
                this.worldTransform = null,
                this.filterArea = null,
                this._bounds = null,
                this._currentBounds = null,
                this._mask = null,
                this._destroyCachedSprite(),
                c && this.texture.destroy(!0),
                this.destroyPhase = !1,
                this.pendingDestroy = !1
            }
        }
    },
    b.Events = function(a) {
        this.parent = a
    }
    ,
    b.Events.prototype = {
        destroy: function() {
            this._parent = null,
            this._onDestroy && this._onDestroy.dispose(),
            this._onAddedToGroup && this._onAddedToGroup.dispose(),
            this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(),
            this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(),
            this._onKilled && this._onKilled.dispose(),
            this._onRevived && this._onRevived.dispose(),
            this._onEnterBounds && this._onEnterBounds.dispose(),
            this._onOutOfBounds && this._onOutOfBounds.dispose(),
            this._onInputOver && this._onInputOver.dispose(),
            this._onInputOut && this._onInputOut.dispose(),
            this._onInputDown && this._onInputDown.dispose(),
            this._onInputUp && this._onInputUp.dispose(),
            this._onDragStart && this._onDragStart.dispose(),
            this._onDragUpdate && this._onDragUpdate.dispose(),
            this._onDragStop && this._onDragStop.dispose(),
            this._onAnimationStart && this._onAnimationStart.dispose(),
            this._onAnimationComplete && this._onAnimationComplete.dispose(),
            this._onAnimationLoop && this._onAnimationLoop.dispose()
        },
        onAddedToGroup: null,
        onRemovedFromGroup: null,
        onRemovedFromWorld: null,
        onDestroy: null,
        onKilled: null,
        onRevived: null,
        onOutOfBounds: null,
        onEnterBounds: null,
        onInputOver: null,
        onInputOut: null,
        onInputDown: null,
        onInputUp: null,
        onDragStart: null,
        onDragUpdate: null,
        onDragStop: null,
        onAnimationStart: null,
        onAnimationComplete: null,
        onAnimationLoop: null
    },
    b.Events.prototype.constructor = b.Events;
    for (var f in b.Events.prototype)
        b.Events.prototype.hasOwnProperty(f) && 0 === f.indexOf("on") && null === b.Events.prototype[f] && function(a, c) {
            "use strict";
            Object.defineProperty(b.Events.prototype, a, {
                get: function() {
                    return this[c] || (this[c] = new b.Signal)
                }
            }),
            b.Events.prototype[a + "$dispatch"] = function() {
                return this[c] ? this[c].dispatch.apply(this[c], arguments) : null
            }
        }(f, "_" + f);
    b.Component.FixedToCamera = function() {}
    ,
    b.Component.FixedToCamera.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
    }
    ,
    b.Component.FixedToCamera.prototype = {
        _fixedToCamera: !1,
        fixedToCamera: {
            get: function() {
                return this._fixedToCamera
            },
            set: function(a) {
                a ? (this._fixedToCamera = !0,
                this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
            }
        },
        cameraOffset: new b.Point
    },
    b.Component.Health = function() {}
    ,
    b.Component.Health.prototype = {
        health: 1,
        maxHealth: 100,
        damage: function(a) {
            return this.alive && (this.health -= a,
            this.health <= 0 && this.kill()),
            this
        },
        setHealth: function(a) {
            return this.health = a,
            this.health > this.maxHealth && (this.health = this.maxHealth),
            this
        },
        heal: function(a) {
            return this.alive && (this.health += a,
            this.health > this.maxHealth && (this.health = this.maxHealth)),
            this
        }
    },
    b.Component.InCamera = function() {}
    ,
    b.Component.InCamera.prototype = {
        inCamera: {
            get: function() {
                return this.game.world.camera.view.intersects(this._bounds)
            }
        }
    },
    b.Component.InputEnabled = function() {}
    ,
    b.Component.InputEnabled.prototype = {
        input: null,
        inputEnabled: {
            get: function() {
                return this.input && this.input.enabled
            },
            set: function(a) {
                a ? null === this.input ? (this.input = new b.InputHandler(this),
                this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
            }
        }
    },
    b.Component.InWorld = function() {}
    ,
    b.Component.InWorld.preUpdate = function() {
        if (this.autoCull || this.checkWorldBounds) {
            if (this._bounds.copyFrom(this.getBounds()),
            this._bounds.x += this.game.camera.view.x,
            this._bounds.y += this.game.camera.view.y,
            this.autoCull)
                if (this.game.world.camera.view.intersects(this._bounds))
                    this.renderable = !0,
                    this.game.world.camera.totalInView++;
                else if (this.renderable = !1,
                this.outOfCameraBoundsKill)
                    return this.kill(),
                    !1;
            if (this.checkWorldBounds)
                if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds))
                    this._outOfBoundsFired = !1,
                    this.events.onEnterBounds$dispatch(this);
                else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0,
                this.events.onOutOfBounds$dispatch(this),
                this.outOfBoundsKill))
                    return this.kill(),
                    !1
        }
        return !0
    }
    ,
    b.Component.InWorld.prototype = {
        checkWorldBounds: !1,
        outOfBoundsKill: !1,
        outOfCameraBoundsKill: !1,
        _outOfBoundsFired: !1,
        inWorld: {
            get: function() {
                return this.game.world.bounds.intersects(this.getBounds())
            }
        }
    },
    b.Component.LifeSpan = function() {}
    ,
    b.Component.LifeSpan.preUpdate = function() {
        return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS,
        this.lifespan <= 0)) || (this.kill(),
        !1)
    }
    ,
    b.Component.LifeSpan.prototype = {
        alive: !0,
        lifespan: 0,
        revive: function(a) {
            return void 0 === a && (a = 100),
            this.alive = !0,
            this.exists = !0,
            this.visible = !0,
            "function" == typeof this.setHealth && this.setHealth(a),
            this.events && this.events.onRevived$dispatch(this),
            this
        },
        kill: function() {
            return this.alive = !1,
            this.exists = !1,
            this.visible = !1,
            this.events && this.events.onKilled$dispatch(this),
            this
        }
    },
    b.Component.LoadTexture = function() {}
    ,
    b.Component.LoadTexture.prototype = {
        customRender: !1,
        _frame: null,
        loadTexture: function(a, c, d) {
            a === b.PENDING_ATLAS ? (a = c,
            c = 0) : c = c || 0,
            (d || void 0 === d) && this.animations && this.animations.stop(),
            this.key = a,
            this.customRender = !1;
            var e = this.game.cache
              , f = !0
              , g = !this.texture.baseTexture.scaleMode;
            if (b.RenderTexture && a instanceof b.RenderTexture)
                this.key = a.key,
                this.setTexture(a);
            else if (b.BitmapData && a instanceof b.BitmapData)
                this.customRender = !0,
                this.setTexture(a.texture),
                f = e.hasFrameData(a.key, b.Cache.BITMAPDATA) ? !this.animations.loadFrameData(e.getFrameData(a.key, b.Cache.BITMAPDATA), c) : !this.animations.loadFrameData(a.frameData, 0);
            else if (b.Video && a instanceof b.Video) {
                this.customRender = !0;
                var h = a.texture.valid;
                this.setTexture(a.texture),
                this.setFrame(a.texture.frame.clone()),
                a.onChangeSource.add(this.resizeFrame, this),
                this.texture.valid = h
            } else if (b.Tilemap && a instanceof b.TilemapLayer)
                this.setTexture(PIXI.Texture.fromCanvas(a.canvas));
            else if (a instanceof PIXI.Texture)
                this.setTexture(a);
            else {
                var i = e.getImage(a, !0);
                this.key = i.key,
                this.setTexture(new PIXI.Texture(i.base)),
                this.texture.baseTexture.skipRender = "__default" === a,
                f = !this.animations.loadFrameData(i.frameData, c)
            }
            f && (this._frame = b.Rectangle.clone(this.texture.frame)),
            g || (this.texture.baseTexture.scaleMode = 1)
        },
        setFrame: function(a) {
            this._frame = a,
            this.texture.frame.x = a.x,
            this.texture.frame.y = a.y,
            this.texture.frame.width = a.width,
            this.texture.frame.height = a.height,
            this.texture.crop.x = a.x,
            this.texture.crop.y = a.y,
            this.texture.crop.width = a.width,
            this.texture.crop.height = a.height,
            a.trimmed ? (this.texture.trim ? (this.texture.trim.x = a.spriteSourceSizeX,
            this.texture.trim.y = a.spriteSourceSizeY,
            this.texture.trim.width = a.sourceSizeW,
            this.texture.trim.height = a.sourceSizeH) : this.texture.trim = {
                x: a.spriteSourceSizeX,
                y: a.spriteSourceSizeY,
                width: a.sourceSizeW,
                height: a.sourceSizeH
            },
            this.texture.width = a.sourceSizeW,
            this.texture.height = a.sourceSizeH,
            this.texture.frame.width = a.sourceSizeW,
            this.texture.frame.height = a.sourceSizeH) : !a.trimmed && this.texture.trim && (this.texture.trim = null),
            this.cropRect && this.updateCrop(),
            this.texture.requiresReTint = !0,
            this.texture._updateUvs(),
            this.tilingTexture && (this.refreshTexture = !0)
        },
        resizeFrame: function(a, b, c) {
            this.texture.frame.resize(b, c),
            this.texture.setFrame(this.texture.frame)
        },
        resetFrame: function() {
            this._frame && this.setFrame(this._frame)
        },
        frame: {
            get: function() {
                return this.animations.frame
            },
            set: function(a) {
                this.animations.frame = a
            }
        },
        frameName: {
            get: function() {
                return this.animations.frameName
            },
            set: function(a) {
                this.animations.frameName = a
            }
        }
    },
    b.Component.Overlap = function() {}
    ,
    b.Component.Overlap.prototype = {
        overlap: function(a) {
            return b.Rectangle.intersects(this.getBounds(), a.getBounds())
        }
    },
    b.Component.PhysicsBody = function() {}
    ,
    b.Component.PhysicsBody.preUpdate = function() {
        return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y),
        this.worldTransform.tx = this.world.x,
        this.worldTransform.ty = this.world.y,
        this.previousPosition.set(this.world.x, this.world.y),
        this.previousRotation = this.rotation,
        this.body && this.body.preUpdate(),
        this.fresh = !1,
        !1) : (this.previousPosition.set(this.world.x, this.world.y),
        this.previousRotation = this.rotation,
        !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1,
        !1))
    }
    ,
    b.Component.PhysicsBody.postUpdate = function() {
        this.exists && this.body && this.body.postUpdate()
    }
    ,
    b.Component.PhysicsBody.prototype = {
        body: null,
        x: {
            get: function() {
                return this.position.x
            },
            set: function(a) {
                this.position.x = a,
                this.body && !this.body.dirty && (this.body._reset = !0)
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(a) {
                this.position.y = a,
                this.body && !this.body.dirty && (this.body._reset = !0)
            }
        }
    },
    b.Component.Reset = function() {}
    ,
    b.Component.Reset.prototype.reset = function(a, b, c) {
        return void 0 === c && (c = 1),
        this.world.set(a, b),
        this.position.set(a, b),
        this.fresh = !0,
        this.exists = !0,
        this.visible = !0,
        this.renderable = !0,
        this.components.InWorld && (this._outOfBoundsFired = !1),
        this.components.LifeSpan && (this.alive = !0,
        this.health = c),
        this.components.PhysicsBody && this.body && this.body.reset(a, b, !1, !1),
        this
    }
    ,
    b.Component.ScaleMinMax = function() {}
    ,
    b.Component.ScaleMinMax.prototype = {
        transformCallback: null,
        transformCallbackContext: this,
        scaleMin: null,
        scaleMax: null,
        checkTransform: function(a) {
            this.scaleMin && (a.a < this.scaleMin.x && (a.a = this.scaleMin.x),
            a.d < this.scaleMin.y && (a.d = this.scaleMin.y)),
            this.scaleMax && (a.a > this.scaleMax.x && (a.a = this.scaleMax.x),
            a.d > this.scaleMax.y && (a.d = this.scaleMax.y))
        },
        setScaleMinMax: function(a, c, d, e) {
            void 0 === c ? c = d = e = a : void 0 === d && (d = e = c,
            c = a),
            null === a ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(a, c) : this.scaleMin = new b.Point(a,c),
            null === d ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(d, e) : this.scaleMax = new b.Point(d,e),
            null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform,
            this.transformCallbackContext = this)
        }
    },
    b.Component.Smoothed = function() {}
    ,
    b.Component.Smoothed.prototype = {
        smoothed: {
            get: function() {
                return !this.texture.baseTexture.scaleMode
            },
            set: function(a) {
                a ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
            }
        }
    },
    b.GameObjectFactory = function(a) {
        this.game = a,
        this.world = this.game.world
    }
    ,
    b.GameObjectFactory.prototype = {
        existing: function(a) {
            return this.world.add(a)
        },
        weapon: function(a, c, d, e) {
            var f = this.game.plugins.add(b.Weapon);
            return f.createBullets(a, c, d, e),
            f
        },
        image: function(a, c, d, e, f) {
            return void 0 === f && (f = this.world),
            f.add(new b.Image(this.game,a,c,d,e))
        },
        sprite: function(a, b, c, d, e) {
            return void 0 === e && (e = this.world),
            e.create(a, b, c, d)
        },
        creature: function(a, c, d, e, f) {
            void 0 === f && (f = this.world);
            var g = new b.Creature(this.game,a,c,d,e);
            return f.add(g),
            g
        },
        tween: function(a) {
            return this.game.tweens.create(a)
        },
        group: function(a, c, d, e, f) {
            return new b.Group(this.game,a,c,d,e,f)
        },
        physicsGroup: function(a, c, d, e) {
            return new b.Group(this.game,c,d,e,!0,a)
        },
        spriteBatch: function(a, c, d) {
            return void 0 === a && (a = null),
            void 0 === c && (c = "group"),
            void 0 === d && (d = !1),
            new b.SpriteBatch(this.game,a,c,d)
        },
        audio: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d)
        },
        sound: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d)
        },
        audioSprite: function(a) {
            return this.game.sound.addSprite(a)
        },
        tileSprite: function(a, c, d, e, f, g, h) {
            return void 0 === h && (h = this.world),
            h.add(new b.TileSprite(this.game,a,c,d,e,f,g))
        },
        rope: function(a, c, d, e, f, g) {
            return void 0 === g && (g = this.world),
            g.add(new b.Rope(this.game,a,c,d,e,f))
        },
        text: function(a, c, d, e, f) {
            return void 0 === f && (f = this.world),
            f.add(new b.Text(this.game,a,c,d,e))
        },
        button: function(a, c, d, e, f, g, h, i, j, k) {
            return void 0 === k && (k = this.world),
            k.add(new b.Button(this.game,a,c,d,e,f,g,h,i,j))
        },
        graphics: function(a, c, d) {
            return void 0 === d && (d = this.world),
            d.add(new b.Graphics(this.game,a,c))
        },
        emitter: function(a, c, d) {
            return this.game.particles.add(new b.Particles.Arcade.Emitter(this.game,a,c,d))
        },
        retroFont: function(a, c, d, e, f, g, h, i, j) {
            return new b.RetroFont(this.game,a,c,d,e,f,g,h,i,j)
        },
        bitmapText: function(a, c, d, e, f, g) {
            return void 0 === g && (g = this.world),
            g.add(new b.BitmapText(this.game,a,c,d,e,f))
        },
        tilemap: function(a, c, d, e, f) {
            return new b.Tilemap(this.game,a,c,d,e,f)
        },
        renderTexture: function(a, c, d, e) {
            void 0 !== d && "" !== d || (d = this.game.rnd.uuid()),
            void 0 === e && (e = !1);
            var f = new b.RenderTexture(this.game,a,c,d);
            return e && this.game.cache.addRenderTexture(d, f),
            f
        },
        video: function(a, c) {
            return new b.Video(this.game,a,c)
        },
        bitmapData: function(a, c, d, e) {
            void 0 === e && (e = !1),
            void 0 !== d && "" !== d || (d = this.game.rnd.uuid());
            var f = new b.BitmapData(this.game,d,a,c);
            return e && this.game.cache.addBitmapData(d, f),
            f
        },
        filter: function(a) {
            var c = Array.prototype.slice.call(arguments, 1)
              , a = new b.Filter[a](this.game);
            return a.init.apply(a, c),
            a
        },
        plugin: function(a) {
            return this.game.plugins.add(a)
        }
    },
    b.GameObjectFactory.prototype.constructor = b.GameObjectFactory,
    b.GameObjectCreator = function(a) {
        this.game = a,
        this.world = this.game.world
    }
    ,
    b.GameObjectCreator.prototype = {
        image: function(a, c, d, e) {
            return new b.Image(this.game,a,c,d,e)
        },
        sprite: function(a, c, d, e) {
            return new b.Sprite(this.game,a,c,d,e)
        },
        tween: function(a) {
            return new b.Tween(a,this.game,this.game.tweens)
        },
        group: function(a, c, d, e, f) {
            return new b.Group(this.game,a,c,d,e,f)
        },
        spriteBatch: function(a, c, d) {
            return void 0 === c && (c = "group"),
            void 0 === d && (d = !1),
            new b.SpriteBatch(this.game,a,c,d)
        },
        audio: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d)
        },
        audioSprite: function(a) {
            return this.game.sound.addSprite(a)
        },
        sound: function(a, b, c, d) {
            return this.game.sound.add(a, b, c, d)
        },
        tileSprite: function(a, c, d, e, f, g) {
            return new b.TileSprite(this.game,a,c,d,e,f,g)
        },
        rope: function(a, c, d, e, f) {
            return new b.Rope(this.game,a,c,d,e,f)
        },
        text: function(a, c, d, e) {
            return new b.Text(this.game,a,c,d,e)
        },
        button: function(a, c, d, e, f, g, h, i, j) {
            return new b.Button(this.game,a,c,d,e,f,g,h,i,j)
        },
        graphics: function(a, c) {
            return new b.Graphics(this.game,a,c)
        },
        emitter: function(a, c, d) {
            return new b.Particles.Arcade.Emitter(this.game,a,c,d)
        },
        retroFont: function(a, c, d, e, f, g, h, i, j) {
            return new b.RetroFont(this.game,a,c,d,e,f,g,h,i,j)
        },
        bitmapText: function(a, c, d, e, f, g) {
            return new b.BitmapText(this.game,a,c,d,e,f,g)
        },
        tilemap: function(a, c, d, e, f) {
            return new b.Tilemap(this.game,a,c,d,e,f)
        },
        renderTexture: function(a, c, d, e) {
            void 0 !== d && "" !== d || (d = this.game.rnd.uuid()),
            void 0 === e && (e = !1);
            var f = new b.RenderTexture(this.game,a,c,d);
            return e && this.game.cache.addRenderTexture(d, f),
            f
        },
        bitmapData: function(a, c, d, e) {
            void 0 === e && (e = !1),
            void 0 !== d && "" !== d || (d = this.game.rnd.uuid());
            var f = new b.BitmapData(this.game,d,a,c);
            return e && this.game.cache.addBitmapData(d, f),
            f
        },
        filter: function(a) {
            var c = Array.prototype.slice.call(arguments, 1)
              , a = new b.Filter[a](this.game);
            return a.init.apply(a, c),
            a
        }
    },
    b.GameObjectCreator.prototype.constructor = b.GameObjectCreator,
    b.Sprite = function(a, c, d, e, f) {
        c = c || 0,
        d = d || 0,
        e = e || null,
        f = f || null,
        this.type = b.SPRITE,
        this.physicsType = b.SPRITE,
        PIXI.Sprite.call(this, b.Cache.DEFAULT),
        b.Component.Core.init.call(this, a, c, d, e, f)
    }
    ,
    b.Sprite.prototype = Object.create(PIXI.Sprite.prototype),
    b.Sprite.prototype.constructor = b.Sprite,
    b.Component.Core.install.call(b.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]),
    b.Sprite.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate,
    b.Sprite.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate,
    b.Sprite.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate,
    b.Sprite.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.Sprite.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }
    ,
    b.Image = function(a, c, d, e, f) {
        c = c || 0,
        d = d || 0,
        e = e || null,
        f = f || null,
        this.type = b.IMAGE,
        PIXI.Sprite.call(this, b.Cache.DEFAULT),
        b.Component.Core.init.call(this, a, c, d, e, f)
    }
    ,
    b.Image.prototype = Object.create(PIXI.Sprite.prototype),
    b.Image.prototype.constructor = b.Image,
    b.Component.Core.install.call(b.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]),
    b.Image.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate,
    b.Image.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.Image.prototype.preUpdate = function() {
        return !!this.preUpdateInWorld() && this.preUpdateCore()
    }
    ,
    b.Button = function(a, c, d, e, f, g, h, i, j, k) {
        c = c || 0,
        d = d || 0,
        e = e || null,
        f = f || null,
        g = g || this,
        b.Image.call(this, a, c, d, e, i),
        this.type = b.BUTTON,
        this.physicsType = b.SPRITE,
        this._onOverFrame = null,
        this._onOutFrame = null,
        this._onDownFrame = null,
        this._onUpFrame = null,
        this.onOverSound = null,
        this.onOutSound = null,
        this.onDownSound = null,
        this.onUpSound = null,
        this.onOverSoundMarker = "",
        this.onOutSoundMarker = "",
        this.onDownSoundMarker = "",
        this.onUpSoundMarker = "",
        this.onInputOver = new b.Signal,
        this.onInputOut = new b.Signal,
        this.onInputDown = new b.Signal,
        this.onInputUp = new b.Signal,
        this.onOverMouseOnly = !0,
        this.justReleasedPreventsOver = b.PointerMode.TOUCH,
        this.freezeFrames = !1,
        this.forceOut = !1,
        this.inputEnabled = !0,
        this.input.start(0, !0),
        this.input.useHandCursor = !0,
        this.setFrames(h, i, j, k),
        null !== f && this.onInputUp.add(f, g),
        this.events.onInputOver.add(this.onInputOverHandler, this),
        this.events.onInputOut.add(this.onInputOutHandler, this),
        this.events.onInputDown.add(this.onInputDownHandler, this),
        this.events.onInputUp.add(this.onInputUpHandler, this),
        this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
    }
    ,
    b.Button.prototype = Object.create(b.Image.prototype),
    b.Button.prototype.constructor = b.Button;
    var g = "Over"
      , h = "Out"
      , i = "Down"
      , j = "Up";
    b.Button.prototype.clearFrames = function() {
        this.setFrames(null, null, null, null)
    }
    ,
    b.Button.prototype.removedFromWorld = function() {
        this.inputEnabled = !1
    }
    ,
    b.Button.prototype.setStateFrame = function(a, b, c) {
        var d = "_on" + a + "Frame";
        null !== b ? (this[d] = b,
        c && this.changeStateFrame(a)) : this[d] = null
    }
    ,
    b.Button.prototype.changeStateFrame = function(a) {
        if (this.freezeFrames)
            return !1;
        var b = "_on" + a + "Frame"
          , c = this[b];
        return "string" == typeof c ? (this.frameName = c,
        !0) : "number" == typeof c && (this.frame = c,
        !0)
    }
    ,
    b.Button.prototype.setFrames = function(a, b, c, d) {
        this.setStateFrame(g, a, this.input.pointerOver()),
        this.setStateFrame(h, b, !this.input.pointerOver()),
        this.setStateFrame(i, c, this.input.pointerDown()),
        this.setStateFrame(j, d, this.input.pointerUp())
    }
    ,
    b.Button.prototype.setStateSound = function(a, c, d) {
        var e = "on" + a + "Sound"
          , f = "on" + a + "SoundMarker";
        c instanceof b.Sound || c instanceof b.AudioSprite ? (this[e] = c,
        this[f] = "string" == typeof d ? d : "") : (this[e] = null,
        this[f] = "")
    }
    ,
    b.Button.prototype.playStateSound = function(a) {
        var b = "on" + a + "Sound"
          , c = this[b];
        if (c) {
            var d = "on" + a + "SoundMarker"
              , e = this[d];
            return c.play(e),
            !0
        }
        return !1
    }
    ,
    b.Button.prototype.setSounds = function(a, b, c, d, e, f, k, l) {
        this.setStateSound(g, a, b),
        this.setStateSound(h, e, f),
        this.setStateSound(i, c, d),
        this.setStateSound(j, k, l)
    }
    ,
    b.Button.prototype.setOverSound = function(a, b) {
        this.setStateSound(g, a, b)
    }
    ,
    b.Button.prototype.setOutSound = function(a, b) {
        this.setStateSound(h, a, b)
    }
    ,
    b.Button.prototype.setDownSound = function(a, b) {
        this.setStateSound(i, a, b)
    }
    ,
    b.Button.prototype.setUpSound = function(a, b) {
        this.setStateSound(j, a, b)
    }
    ,
    b.Button.prototype.onInputOverHandler = function(a, b) {
        b.justReleased() && (this.justReleasedPreventsOver & b.pointerMode) === b.pointerMode || (this.changeStateFrame(g),
        this.onOverMouseOnly && !b.isMouse || (this.playStateSound(g),
        this.onInputOver && this.onInputOver.dispatch(this, b)))
    }
    ,
    b.Button.prototype.onInputOutHandler = function(a, b) {
        this.changeStateFrame(h),
        this.playStateSound(h),
        this.onInputOut && this.onInputOut.dispatch(this, b)
    }
    ,
    b.Button.prototype.onInputDownHandler = function(a, b) {
        this.changeStateFrame(i),
        this.playStateSound(i),
        this.onInputDown && this.onInputDown.dispatch(this, b)
    }
    ,
    b.Button.prototype.onInputUpHandler = function(a, b, c) {
        if (this.playStateSound(j),
        this.onInputUp && this.onInputUp.dispatch(this, b, c),
        !this.freezeFrames)
            if (!0 === this.forceOut || (this.forceOut & b.pointerMode) === b.pointerMode)
                this.changeStateFrame(h);
            else {
                var d = this.changeStateFrame(j);
                d || (c ? this.changeStateFrame(g) : this.changeStateFrame(h))
            }
    }
    ,
    b.SpriteBatch = function(a, c, d, e) {
        void 0 !== c && null !== c || (c = a.world),
        PIXI.SpriteBatch.call(this),
        b.Group.call(this, a, c, d, e),
        this.type = b.SPRITEBATCH
    }
    ,
    b.SpriteBatch.prototype = b.Utils.extend(!0, b.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, b.Group.prototype),
    b.SpriteBatch.prototype.constructor = b.SpriteBatch,
    b.BitmapData = function(a, c, d, e, f) {
        void 0 !== d && 0 !== d || (d = 256),
        void 0 !== e && 0 !== e || (e = 256),
        void 0 === f && (f = !1),
        this.game = a,
        this.key = c,
        this.width = d,
        this.height = e,
        this.canvas = b.Canvas.create(this, d, e, null, f),
        this.context = this.canvas.getContext("2d", {
            alpha: !0
        }),
        this.ctx = this.context,
        this.smoothProperty = a.renderType === b.CANVAS ? a.renderer.renderSession.smoothProperty : b.Canvas.getSmoothingPrefix(this.context),
        this.imageData = this.context.getImageData(0, 0, d, e),
        this.data = null,
        this.imageData && (this.data = this.imageData.data),
        this.pixels = null,
        this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
        this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length),
        this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data),
        this.baseTexture = new PIXI.BaseTexture(this.canvas),
        this.texture = new PIXI.Texture(this.baseTexture),
        this.frameData = new b.FrameData,
        this.textureFrame = this.frameData.addFrame(new b.Frame(0,0,0,d,e,"bitmapData")),
        this.texture.frame = this.textureFrame,
        this.type = b.BITMAPDATA,
        this.disableTextureUpload = !1,
        this.dirty = !1,
        this.cls = this.clear,
        this._image = null,
        this._pos = new b.Point,
        this._size = new b.Point,
        this._scale = new b.Point,
        this._rotate = 0,
        this._alpha = {
            prev: 1,
            current: 1
        },
        this._anchor = new b.Point,
        this._tempR = 0,
        this._tempG = 0,
        this._tempB = 0,
        this._circle = new b.Circle,
        this._swapCanvas = void 0
    }
    ,
    b.BitmapData.prototype = {
        move: function(a, b, c) {
            return 0 !== a && this.moveH(a, c),
            0 !== b && this.moveV(b, c),
            this
        },
        moveH: function(a, b) {
            void 0 === b && (b = !0),
            void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
            var c = this._swapCanvas
              , d = c.getContext("2d")
              , e = this.height
              , f = this.canvas;
            if (d.clearRect(0, 0, this.width, this.height),
            a < 0) {
                a = Math.abs(a);
                var g = this.width - a;
                b && d.drawImage(f, 0, 0, a, e, g, 0, a, e),
                d.drawImage(f, a, 0, g, e, 0, 0, g, e)
            } else {
                var g = this.width - a;
                b && d.drawImage(f, g, 0, a, e, 0, 0, a, e),
                d.drawImage(f, 0, 0, g, e, a, 0, g, e)
            }
            return this.clear(),
            this.copy(this._swapCanvas)
        },
        moveV: function(a, b) {
            void 0 === b && (b = !0),
            void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
            var c = this._swapCanvas
              , d = c.getContext("2d")
              , e = this.width
              , f = this.canvas;
            if (d.clearRect(0, 0, this.width, this.height),
            a < 0) {
                a = Math.abs(a);
                var g = this.height - a;
                b && d.drawImage(f, 0, 0, e, a, 0, g, e, a),
                d.drawImage(f, 0, a, e, g, 0, 0, e, g)
            } else {
                var g = this.height - a;
                b && d.drawImage(f, 0, g, e, a, 0, 0, e, a),
                d.drawImage(f, 0, 0, e, g, 0, a, e, g)
            }
            return this.clear(),
            this.copy(this._swapCanvas)
        },
        add: function(a) {
            if (Array.isArray(a))
                for (var b = 0; b < a.length; b++)
                    a[b].loadTexture && a[b].loadTexture(this);
            else
                a.loadTexture(this);
            return this
        },
        load: function(a) {
            if ("string" == typeof a && (a = this.game.cache.getImage(a)),
            a)
                return this.resize(a.width, a.height),
                this.cls(),
                this.draw(a),
                this.update(),
                this
        },
        clear: function(a, b, c, d) {
            return void 0 === a && (a = 0),
            void 0 === b && (b = 0),
            void 0 === c && (c = this.width),
            void 0 === d && (d = this.height),
            this.context.clearRect(a, b, c, d),
            this.dirty = !0,
            this
        },
        fill: function(a, b, c, d) {
            return void 0 === d && (d = 1),
            this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")",
            this.context.fillRect(0, 0, this.width, this.height),
            this.dirty = !0,
            this
        },
        generateTexture: function(a) {
            var b = new Image;
            b.src = this.canvas.toDataURL("image/png");
            var c = this.game.cache.addImage(a, "", b);
            return new PIXI.Texture(c.base)
        },
        resize: function(a, b) {
            return a === this.width && b === this.height || (this.width = a,
            this.height = b,
            this.canvas.width = a,
            this.canvas.height = b,
            void 0 !== this._swapCanvas && (this._swapCanvas.width = a,
            this._swapCanvas.height = b),
            this.baseTexture.width = a,
            this.baseTexture.height = b,
            this.textureFrame.width = a,
            this.textureFrame.height = b,
            this.texture.width = a,
            this.texture.height = b,
            this.texture.crop.width = a,
            this.texture.crop.height = b,
            this.update(),
            this.dirty = !0),
            this
        },
        update: function(a, b, c, d) {
            return void 0 === a && (a = 0),
            void 0 === b && (b = 0),
            void 0 === c && (c = Math.max(1, this.width)),
            void 0 === d && (d = Math.max(1, this.height)),
            this.imageData = this.context.getImageData(a, b, c, d),
            this.data = this.imageData.data,
            this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
            this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length),
            this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data,
            this
        },
        processPixelRGB: function(a, c, d, e, f, g) {
            void 0 === d && (d = 0),
            void 0 === e && (e = 0),
            void 0 === f && (f = this.width),
            void 0 === g && (g = this.height);
            for (var h = d + f, i = e + g, j = b.Color.createColor(), k = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, l = !1, m = e; m < i; m++)
                for (var n = d; n < h; n++)
                    b.Color.unpackPixel(this.getPixel32(n, m), j),
                    !1 !== (k = a.call(c, j, n, m)) && null !== k && void 0 !== k && (this.setPixel32(n, m, k.r, k.g, k.b, k.a, !1),
                    l = !0);
            return l && (this.context.putImageData(this.imageData, 0, 0),
            this.dirty = !0),
            this
        },
        processPixel: function(a, b, c, d, e, f) {
            void 0 === c && (c = 0),
            void 0 === d && (d = 0),
            void 0 === e && (e = this.width),
            void 0 === f && (f = this.height);
            for (var g = c + e, h = d + f, i = 0, j = 0, k = !1, l = d; l < h; l++)
                for (var m = c; m < g; m++)
                    i = this.getPixel32(m, l),
                    (j = a.call(b, i, m, l)) !== i && (this.pixels[l * this.width + m] = j,
                    k = !0);
            return k && (this.context.putImageData(this.imageData, 0, 0),
            this.dirty = !0),
            this
        },
        replaceRGB: function(a, c, d, e, f, g, h, i, j) {
            var k = 0
              , l = 0
              , m = this.width
              , n = this.height
              , o = b.Color.packPixel(a, c, d, e);
            void 0 !== j && j instanceof b.Rectangle && (k = j.x,
            l = j.y,
            m = j.width,
            n = j.height);
            for (var p = 0; p < n; p++)
                for (var q = 0; q < m; q++)
                    this.getPixel32(k + q, l + p) === o && this.setPixel32(k + q, l + p, f, g, h, i, !1);
            return this.context.putImageData(this.imageData, 0, 0),
            this.dirty = !0,
            this
        },
        setHSL: function(a, c, d, e) {
            var f = a || 0 === a
              , g = c || 0 === c
              , h = d || 0 === d;
            if (f || g || h) {
                void 0 === e && (e = new b.Rectangle(0,0,this.width,this.height));
                for (var i = b.Color.createColor(), j = e.y; j < e.bottom; j++)
                    for (var k = e.x; k < e.right; k++)
                        b.Color.unpackPixel(this.getPixel32(k, j), i, !0),
                        f && (i.h = a),
                        g && (i.s = c),
                        h && (i.l = d),
                        b.Color.HSLtoRGB(i.h, i.s, i.l, i),
                        this.setPixel32(k, j, i.r, i.g, i.b, i.a, !1);
                return this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0,
                this
            }
        },
        shiftHSL: function(a, c, d, e) {
            if (void 0 !== a && null !== a || (a = !1),
            void 0 !== c && null !== c || (c = !1),
            void 0 !== d && null !== d || (d = !1),
            a || c || d) {
                void 0 === e && (e = new b.Rectangle(0,0,this.width,this.height));
                for (var f = b.Color.createColor(), g = e.y; g < e.bottom; g++)
                    for (var h = e.x; h < e.right; h++)
                        b.Color.unpackPixel(this.getPixel32(h, g), f, !0),
                        a && (f.h = this.game.math.wrap(f.h + a, 0, 1)),
                        c && (f.s = this.game.math.clamp(f.s + c, 0, 1)),
                        d && (f.l = this.game.math.clamp(f.l + d, 0, 1)),
                        b.Color.HSLtoRGB(f.h, f.s, f.l, f),
                        this.setPixel32(h, g, f.r, f.g, f.b, f.a, !1);
                return this.context.putImageData(this.imageData, 0, 0),
                this.dirty = !0,
                this
            }
        },
        setPixel32: function(a, c, d, e, f, g, h) {
            return void 0 === h && (h = !0),
            a >= 0 && a <= this.width && c >= 0 && c <= this.height && (b.Device.LITTLE_ENDIAN ? this.pixels[c * this.width + a] = g << 24 | f << 16 | e << 8 | d : this.pixels[c * this.width + a] = d << 24 | e << 16 | f << 8 | g,
            h && (this.context.putImageData(this.imageData, 0, 0),
            this.dirty = !0)),
            this
        },
        setPixel: function(a, b, c, d, e, f) {
            return this.setPixel32(a, b, c, d, e, 255, f)
        },
        getPixel: function(a, c, d) {
            d || (d = b.Color.createColor());
            var e = ~~(a + c * this.width);
            return e *= 4,
            d.r = this.data[e],
            d.g = this.data[++e],
            d.b = this.data[++e],
            d.a = this.data[++e],
            d
        },
        getPixel32: function(a, b) {
            if (a >= 0 && a <= this.width && b >= 0 && b <= this.height)
                return this.pixels[b * this.width + a]
        },
        getPixelRGB: function(a, c, d, e, f) {
            return b.Color.unpackPixel(this.getPixel32(a, c), d, e, f)
        },
        getPixels: function(a) {
            return this.context.getImageData(a.x, a.y, a.width, a.height)
        },
        getFirstPixel: function(a) {
            void 0 === a && (a = 0);
            var c = b.Color.createColor()
              , d = 0
              , e = 0
              , f = 1
              , g = !1;
            1 === a ? (f = -1,
            e = this.height) : 3 === a && (f = -1,
            d = this.width);
            do {
                b.Color.unpackPixel(this.getPixel32(d, e), c),
                0 === a || 1 === a ? ++d === this.width && (d = 0,
                ((e += f) >= this.height || e <= 0) && (g = !0)) : 2 !== a && 3 !== a || ++e === this.height && (e = 0,
                ((d += f) >= this.width || d <= 0) && (g = !0))
            } while (0 === c.a && !g);
            return c.x = d,
            c.y = e,
            c
        },
        getBounds: function(a) {
            return void 0 === a && (a = new b.Rectangle),
            a.x = this.getFirstPixel(2).x,
            a.x === this.width ? a.setTo(0, 0, 0, 0) : (a.y = this.getFirstPixel(0).y,
            a.width = this.getFirstPixel(3).x - a.x + 1,
            a.height = this.getFirstPixel(1).y - a.y + 1,
            a)
        },
        addToWorld: function(a, b, c, d, e, f) {
            e = e || 1,
            f = f || 1;
            var g = this.game.add.image(a, b, this);
            return g.anchor.set(c, d),
            g.scale.set(e, f),
            g
        },
        copy: function(a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
            if (void 0 !== a && null !== a || (a = this),
            (a instanceof b.RenderTexture || a instanceof PIXI.RenderTexture) && (a = a.getCanvas()),
            this._image = a,
            a instanceof b.Sprite || a instanceof b.Image || a instanceof b.Text || a instanceof PIXI.Sprite)
                this._pos.set(a.texture.crop.x, a.texture.crop.y),
                this._size.set(a.texture.crop.width, a.texture.crop.height),
                this._scale.set(a.scale.x, a.scale.y),
                this._anchor.set(a.anchor.x, a.anchor.y),
                this._rotate = a.rotation,
                this._alpha.current = a.alpha,
                a.texture instanceof b.RenderTexture || a.texture instanceof PIXI.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source,
                void 0 !== g && null !== g || (g = a.x),
                void 0 !== h && null !== h || (h = a.y),
                a.texture.trim && (g += a.texture.trim.x - a.anchor.x * a.texture.trim.width,
                h += a.texture.trim.y - a.anchor.y * a.texture.trim.height),
                16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint,
                a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)),
                this._image = a.tintedTexture,
                this._pos.set(0));
            else {
                if (this._pos.set(0),
                this._scale.set(1),
                this._anchor.set(0),
                this._rotate = 0,
                this._alpha.current = 1,
                a instanceof b.BitmapData)
                    this._image = a.canvas;
                else if ("string" == typeof a) {
                    if (null === (a = this.game.cache.getImage(a)))
                        return;
                    this._image = a
                }
                this._size.set(this._image.width, this._image.height)
            }
            if (void 0 !== c && null !== c || (c = 0),
            void 0 !== d && null !== d || (d = 0),
            e && (this._size.x = e),
            f && (this._size.y = f),
            void 0 !== g && null !== g || (g = c),
            void 0 !== h && null !== h || (h = d),
            void 0 !== i && null !== i || (i = this._size.x),
            void 0 !== j && null !== j || (j = this._size.y),
            "number" == typeof k && (this._rotate = k),
            "number" == typeof l && (this._anchor.x = l),
            "number" == typeof m && (this._anchor.y = m),
            "number" == typeof n && (this._scale.x = n),
            "number" == typeof o && (this._scale.y = o),
            "number" == typeof p && (this._alpha.current = p),
            void 0 === q && (q = null),
            void 0 === r && (r = !1),
            !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                var s = this.context;
                return this._alpha.prev = s.globalAlpha,
                s.save(),
                s.globalAlpha = this._alpha.current,
                q && (this.op = q),
                r && (g |= 0,
                h |= 0),
                s.translate(g, h),
                s.scale(this._scale.x, this._scale.y),
                s.rotate(this._rotate),
                s.drawImage(this._image, this._pos.x + c, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j),
                s.restore(),
                s.globalAlpha = this._alpha.prev,
                this.dirty = !0,
                this
            }
        },
        copyTransform: function(a, c, d) {
            if (void 0 === c && (c = null),
            void 0 === d && (d = !1),
            !a.hasOwnProperty("worldTransform") || !a.worldVisible || 0 === a.worldAlpha)
                return this;
            var e = a.worldTransform;
            if (this._pos.set(a.texture.crop.x, a.texture.crop.y),
            this._size.set(a.texture.crop.width, a.texture.crop.height),
            0 === e.a || 0 === e.d || 0 === this._size.x || 0 === this._size.y)
                return this;
            a.texture instanceof b.RenderTexture || a.texture instanceof PIXI.RenderTexture ? this._image = a.texture.getCanvas() : this._image = a.texture.baseTexture.source;
            var f = e.tx
              , g = e.ty;
            a.texture.trim && (f += a.texture.trim.x - a.anchor.x * a.texture.trim.width,
            g += a.texture.trim.y - a.anchor.y * a.texture.trim.height),
            16777215 !== a.tint && (a.cachedTint !== a.tint && (a.cachedTint = a.tint,
            a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint)),
            this._image = a.tintedTexture,
            this._pos.set(0)),
            d && (f |= 0,
            g |= 0);
            var h = this.context;
            return this._alpha.prev = h.globalAlpha,
            h.save(),
            h.globalAlpha = this._alpha.current,
            c && (this.op = c),
            h[this.smoothProperty] = a.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR,
            h.setTransform(e.a, e.b, e.c, e.d, f, g),
            h.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * a.anchor.x, -this._size.y * a.anchor.y, this._size.x, this._size.y),
            h.restore(),
            h.globalAlpha = this._alpha.prev,
            this.dirty = !0,
            this
        },
        copyRect: function(a, b, c, d, e, f, g) {
            return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g)
        },
        draw: function(a, b, c, d, e, f, g) {
            return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g)
        },
        drawGroup: function(a, b, c) {
            return a.total > 0 && a.forEachExists(this.drawGroupProxy, this, b, c),
            this
        },
        drawGroupProxy: function(a, c, d) {
            if (a.hasOwnProperty("texture") && this.copyTransform(a, c, d),
            a.type === b.GROUP && a.exists)
                this.drawGroup(a, c, d);
            else if (a.hasOwnProperty("children") && a.children.length > 0)
                for (var e = 0; e < a.children.length; e++)
                    a.children[e].exists && this.copyTransform(a.children[e], c, d)
        },
        drawFull: function(a, c, d) {
            if (!1 === a.worldVisible || 0 === a.worldAlpha || a.hasOwnProperty("exists") && !1 === a.exists)
                return this;
            if (a.type !== b.GROUP && a.type !== b.EMITTER && a.type !== b.BITMAPTEXT)
                if (a.type === b.GRAPHICS) {
                    var e = a.getBounds();
                    this.ctx.save(),
                    this.ctx.translate(e.x, e.y),
                    PIXI.CanvasGraphics.renderGraphics(a, this.ctx),
                    this.ctx.restore()
                } else
                    this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, c, d);
            if (a.children)
                for (var f = 0; f < a.children.length; f++)
                    this.drawFull(a.children[f], c, d);
            return this
        },
        shadow: function(a, b, c, d) {
            var e = this.context;
            return void 0 === a || null === a ? e.shadowColor = "rgba(0,0,0,0)" : (e.shadowColor = a,
            e.shadowBlur = b || 5,
            e.shadowOffsetX = c || 10,
            e.shadowOffsetY = d || 10),
            this
        },
        alphaMask: function(a, b, c, d) {
            return void 0 === d || null === d ? this.draw(b).blendSourceAtop() : this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop(),
            void 0 === c || null === c ? this.draw(a).blendReset() : this.draw(a, c.x, c.y, c.width, c.height).blendReset(),
            this
        },
        extract: function(a, b, c, d, e, f, g, h, i) {
            return void 0 === e && (e = 255),
            void 0 === f && (f = !1),
            void 0 === g && (g = b),
            void 0 === h && (h = c),
            void 0 === i && (i = d),
            f && a.resize(this.width, this.height),
            this.processPixelRGB(function(f, j, k) {
                return f.r === b && f.g === c && f.b === d && a.setPixel32(j, k, g, h, i, e, !1),
                !1
            }, this),
            a.context.putImageData(a.imageData, 0, 0),
            a.dirty = !0,
            a
        },
        rect: function(a, b, c, d, e) {
            return void 0 !== e && (this.context.fillStyle = e),
            this.context.fillRect(a, b, c, d),
            this
        },
        text: function(a, b, c, d, e, f) {
            void 0 === b && (b = 0),
            void 0 === c && (c = 0),
            void 0 === d && (d = "14px Courier"),
            void 0 === e && (e = "rgb(255,255,255)"),
            void 0 === f && (f = !0);
            var g = this.context
              , h = g.font;
            return g.font = d,
            f && (g.fillStyle = "rgb(0,0,0)",
            g.fillText(a, b + 1, c + 1)),
            g.fillStyle = e,
            g.fillText(a, b, c),
            g.font = h,
            this
        },
        circle: function(a, b, c, d) {
            var e = this.context;
            return void 0 !== d && (e.fillStyle = d),
            e.beginPath(),
            e.arc(a, b, c, 0, 2 * Math.PI, !1),
            e.closePath(),
            e.fill(),
            this
        },
        line: function(a, b, c, d, e, f) {
            void 0 === e && (e = "#fff"),
            void 0 === f && (f = 1);
            var g = this.context;
            return g.beginPath(),
            g.moveTo(a, b),
            g.lineTo(c, d),
            g.lineWidth = f,
            g.strokeStyle = e,
            g.stroke(),
            g.closePath(),
            this
        },
        textureLine: function(a, c, d) {
            if (void 0 === d && (d = "repeat-x"),
            "string" != typeof c || (c = this.game.cache.getImage(c))) {
                var e = a.length;
                "no-repeat" === d && e > c.width && (e = c.width);
                var f = this.context;
                return f.fillStyle = f.createPattern(c, d),
                this._circle = new b.Circle(a.start.x,a.start.y,c.height),
                this._circle.circumferencePoint(a.angle - 1.5707963267948966, !1, this._pos),
                f.save(),
                f.translate(this._pos.x, this._pos.y),
                f.rotate(a.angle),
                f.fillRect(0, 0, e, c.height),
                f.restore(),
                this.dirty = !0,
                this
            }
        },
        render: function() {
            return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(),
            this.dirty = !1),
            this
        },
        destroy: function() {
            this.frameData.destroy(),
            this.texture.destroy(!0),
            PIXI.CanvasPool.remove(this)
        },
        blendReset: function() {
            return this.op = "source-over",
            this
        },
        blendSourceOver: function() {
            return this.op = "source-over",
            this
        },
        blendSourceIn: function() {
            return this.op = "source-in",
            this
        },
        blendSourceOut: function() {
            return this.op = "source-out",
            this
        },
        blendSourceAtop: function() {
            return this.op = "source-atop",
            this
        },
        blendDestinationOver: function() {
            return this.op = "destination-over",
            this
        },
        blendDestinationIn: function() {
            return this.op = "destination-in",
            this
        },
        blendDestinationOut: function() {
            return this.op = "destination-out",
            this
        },
        blendDestinationAtop: function() {
            return this.op = "destination-atop",
            this
        },
        blendXor: function() {
            return this.op = "xor",
            this
        },
        blendAdd: function() {
            return this.op = "lighter",
            this
        },
        blendMultiply: function() {
            return this.op = "multiply",
            this
        },
        blendScreen: function() {
            return this.op = "screen",
            this
        },
        blendOverlay: function() {
            return this.op = "overlay",
            this
        },
        blendDarken: function() {
            return this.op = "darken",
            this
        },
        blendLighten: function() {
            return this.op = "lighten",
            this
        },
        blendColorDodge: function() {
            return this.op = "color-dodge",
            this
        },
        blendColorBurn: function() {
            return this.op = "color-burn",
            this
        },
        blendHardLight: function() {
            return this.op = "hard-light",
            this
        },
        blendSoftLight: function() {
            return this.op = "soft-light",
            this
        },
        blendDifference: function() {
            return this.op = "difference",
            this
        },
        blendExclusion: function() {
            return this.op = "exclusion",
            this
        },
        blendHue: function() {
            return this.op = "hue",
            this
        },
        blendSaturation: function() {
            return this.op = "saturation",
            this
        },
        blendColor: function() {
            return this.op = "color",
            this
        },
        blendLuminosity: function() {
            return this.op = "luminosity",
            this
        }
    },
    Object.defineProperty(b.BitmapData.prototype, "smoothed", {
        get: function() {
            b.Canvas.getSmoothingEnabled(this.context)
        },
        set: function(a) {
            b.Canvas.setSmoothingEnabled(this.context, a)
        }
    }),
    Object.defineProperty(b.BitmapData.prototype, "op", {
        get: function() {
            return this.context.globalCompositeOperation
        },
        set: function(a) {
            this.context.globalCompositeOperation = a
        }
    }),
    b.BitmapData.getTransform = function(a, b, c, d, e, f) {
        return "number" != typeof a && (a = 0),
        "number" != typeof b && (b = 0),
        "number" != typeof c && (c = 1),
        "number" != typeof d && (d = 1),
        "number" != typeof e && (e = 0),
        "number" != typeof f && (f = 0),
        {
            sx: c,
            sy: d,
            scaleX: c,
            scaleY: d,
            skewX: e,
            skewY: f,
            translateX: a,
            translateY: b,
            tx: a,
            ty: b
        }
    }
    ,
    b.BitmapData.prototype.constructor = b.BitmapData,
    PIXI.Graphics = function() {
        PIXI.DisplayObjectContainer.call(this),
        this.renderable = !0,
        this.fillAlpha = 1,
        this.lineWidth = 0,
        this.lineColor = 0,
        this.graphicsData = [],
        this.tint = 16777215,
        this.blendMode = PIXI.blendModes.NORMAL,
        this.currentPath = null,
        this._webGL = [],
        this.isMask = !1,
        this.boundsPadding = 0,
        this._localBounds = new PIXI.Rectangle(0,0,1,1),
        this.dirty = !0,
        this._boundsDirty = !1,
        this.webGLDirty = !1,
        this.cachedSpriteDirty = !1
    }
    ,
    PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    PIXI.Graphics.prototype.constructor = PIXI.Graphics,
    PIXI.Graphics.prototype.lineStyle = function(a, b, c) {
        return this.lineWidth = a || 0,
        this.lineColor = b || 0,
        this.lineAlpha = void 0 === c ? 1 : c,
        this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth,
        this.currentPath.lineColor = this.lineColor,
        this.currentPath.lineAlpha = this.lineAlpha)),
        this
    }
    ,
    PIXI.Graphics.prototype.moveTo = function(a, b) {
        return this.drawShape(new PIXI.Polygon([a, b])),
        this
    }
    ,
    PIXI.Graphics.prototype.lineTo = function(a, b) {
        return this.currentPath || this.moveTo(0, 0),
        this.currentPath.shape.points.push(a, b),
        this.dirty = !0,
        this._boundsDirty = !0,
        this
    }
    ,
    PIXI.Graphics.prototype.quadraticCurveTo = function(a, b, c, d) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        var e, f, g = 20, h = this.currentPath.shape.points;
        0 === h.length && this.moveTo(0, 0);
        for (var i = h[h.length - 2], j = h[h.length - 1], k = 0, l = 1; l <= g; ++l)
            k = l / g,
            e = i + (a - i) * k,
            f = j + (b - j) * k,
            h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    }
    ,
    PIXI.Graphics.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
        for (var h, i, j, k, l, g = 20, m = this.currentPath.shape.points, n = m[m.length - 2], o = m[m.length - 1], p = 0, q = 1; q <= g; ++q)
            p = q / g,
            h = 1 - p,
            i = h * h,
            j = i * h,
            k = p * p,
            l = k * p,
            m.push(j * n + 3 * i * p * a + 3 * h * k * c + l * e, j * o + 3 * i * p * b + 3 * h * k * d + l * f);
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    }
    ,
    PIXI.Graphics.prototype.arcTo = function(a, b, c, d, e) {
        this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(a, b) : this.moveTo(a, b);
        var f = this.currentPath.shape.points
          , g = f[f.length - 2]
          , h = f[f.length - 1]
          , i = h - b
          , j = g - a
          , k = d - b
          , l = c - a
          , m = Math.abs(i * l - j * k);
        if (m < 1e-8 || 0 === e)
            f[f.length - 2] === a && f[f.length - 1] === b || f.push(a, b);
        else {
            var n = i * i + j * j
              , o = k * k + l * l
              , p = i * k + j * l
              , q = e * Math.sqrt(n) / m
              , r = e * Math.sqrt(o) / m
              , s = q * p / n
              , t = r * p / o
              , u = q * l + r * j
              , v = q * k + r * i
              , w = j * (r + s)
              , x = i * (r + s)
              , y = l * (q + t)
              , z = k * (q + t)
              , A = Math.atan2(x - v, w - u)
              , B = Math.atan2(z - v, y - u);
            this.arc(u + a, v + b, e, A, B, j * k > l * i)
        }
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    }
    ,
    PIXI.Graphics.prototype.arc = function(a, b, c, d, e, f, g) {
        if (d === e)
            return this;
        void 0 === f && (f = !1),
        void 0 === g && (g = 40),
        !f && e <= d ? e += 2 * Math.PI : f && d <= e && (d += 2 * Math.PI);
        var h = f ? -1 * (d - e) : e - d
          , i = Math.ceil(Math.abs(h) / (2 * Math.PI)) * g;
        if (0 === h)
            return this;
        var j = a + Math.cos(d) * c
          , k = b + Math.sin(d) * c;
        f && this.filling ? this.moveTo(a, b) : this.moveTo(j, k);
        for (var l = this.currentPath.shape.points, m = h / (2 * i), n = 2 * m, o = Math.cos(m), p = Math.sin(m), q = i - 1, r = q % 1 / q, s = 0; s <= q; s++) {
            var t = s + r * s
              , u = m + d + n * t
              , v = Math.cos(u)
              , w = -Math.sin(u);
            l.push((o * v + p * w) * c + a, (o * -w + p * v) * c + b)
        }
        return this.dirty = !0,
        this._boundsDirty = !0,
        this
    }
    ,
    PIXI.Graphics.prototype.beginFill = function(a, b) {
        return this.filling = !0,
        this.fillColor = a || 0,
        this.fillAlpha = void 0 === b ? 1 : b,
        this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling,
        this.currentPath.fillColor = this.fillColor,
        this.currentPath.fillAlpha = this.fillAlpha),
        this
    }
    ,
    PIXI.Graphics.prototype.endFill = function() {
        return this.filling = !1,
        this.fillColor = null,
        this.fillAlpha = 1,
        this
    }
    ,
    PIXI.Graphics.prototype.drawRect = function(a, b, c, d) {
        return this.drawShape(new PIXI.Rectangle(a,b,c,d)),
        this
    }
    ,
    PIXI.Graphics.prototype.drawRoundedRect = function(a, b, c, d, e) {
        return this.drawShape(new PIXI.RoundedRectangle(a,b,c,d,e)),
        this
    }
    ,
    PIXI.Graphics.prototype.drawCircle = function(a, b, c) {
        return this.drawShape(new PIXI.Circle(a,b,c)),
        this
    }
    ,
    PIXI.Graphics.prototype.drawEllipse = function(a, b, c, d) {
        return this.drawShape(new PIXI.Ellipse(a,b,c,d)),
        this
    }
    ,
    PIXI.Graphics.prototype.drawPolygon = function(a) {
        (a instanceof b.Polygon || a instanceof PIXI.Polygon) && (a = a.points);
        var c = a;
        if (!Array.isArray(c)) {
            c = new Array(arguments.length);
            for (var d = 0; d < c.length; ++d)
                c[d] = arguments[d]
        }
        return this.drawShape(new b.Polygon(c)),
        this
    }
    ,
    PIXI.Graphics.prototype.clear = function() {
        return this.lineWidth = 0,
        this.filling = !1,
        this.dirty = !0,
        this._boundsDirty = !0,
        this.clearDirty = !0,
        this.graphicsData = [],
        this.updateLocalBounds(),
        this
    }
    ,
    PIXI.Graphics.prototype.generateTexture = function(a, b, c) {
        void 0 === a && (a = 1),
        void 0 === b && (b = PIXI.scaleModes.DEFAULT),
        void 0 === c && (c = 0);
        var d = this.getBounds();
        d.width += c,
        d.height += c;
        var e = new PIXI.CanvasBuffer(d.width * a,d.height * a)
          , f = PIXI.Texture.fromCanvas(e.canvas, b);
        return f.baseTexture.resolution = a,
        e.context.scale(a, a),
        e.context.translate(-d.x, -d.y),
        PIXI.CanvasGraphics.renderGraphics(this, e.context),
        f
    }
    ,
    PIXI.Graphics.prototype._renderWebGL = function(a) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._cacheAsBitmap)
                return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(),
                this.updateCachedSpriteTexture(),
                this.cachedSpriteDirty = !1,
                this.dirty = !1),
                this._cachedSprite.worldAlpha = this.worldAlpha,
                void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
            if (a.spriteBatch.stop(),
            a.blendModeManager.setBlendMode(this.blendMode),
            this._mask && a.maskManager.pushMask(this._mask, a),
            this._filters && a.filterManager.pushFilter(this._filterBlock),
            this.blendMode !== a.spriteBatch.currentBlendMode) {
                a.spriteBatch.currentBlendMode = this.blendMode;
                var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
                a.spriteBatch.gl.blendFunc(b[0], b[1])
            }
            if (this.webGLDirty && (this.dirty = !0,
            this.webGLDirty = !1),
            PIXI.WebGLGraphics.renderGraphics(this, a),
            this.children.length) {
                a.spriteBatch.start();
                for (var c = 0; c < this.children.length; c++)
                    this.children[c]._renderWebGL(a);
                a.spriteBatch.stop()
            }
            this._filters && a.filterManager.popFilter(),
            this._mask && a.maskManager.popMask(this.mask, a),
            a.drawCount++,
            a.spriteBatch.start()
        }
    }
    ,
    PIXI.Graphics.prototype._renderCanvas = function(a) {
        if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
            if (this._prevTint !== this.tint && (this.dirty = !0,
            this._prevTint = this.tint),
            this._cacheAsBitmap)
                return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(),
                this.updateCachedSpriteTexture(),
                this.cachedSpriteDirty = !1,
                this.dirty = !1),
                this._cachedSprite.alpha = this.alpha,
                void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
            var b = a.context
              , c = this.worldTransform;
            this.blendMode !== a.currentBlendMode && (a.currentBlendMode = this.blendMode,
            b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode]),
            this._mask && a.maskManager.pushMask(this._mask, a);
            var d = a.resolution
              , e = c.tx * a.resolution + a.shakeX
              , f = c.ty * a.resolution + a.shakeY;
            b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f),
            PIXI.CanvasGraphics.renderGraphics(this, b);
            for (var g = 0; g < this.children.length; g++)
                this.children[g]._renderCanvas(a);
            this._mask && a.maskManager.popMask(a)
        }
    }
    ,
    PIXI.Graphics.prototype.getBounds = function(a) {
        if (!this._currentBounds) {
            if (!this.renderable)
                return PIXI.EmptyRectangle;
            this.dirty && (this.updateLocalBounds(),
            this.webGLDirty = !0,
            this.cachedSpriteDirty = !0,
            this.dirty = !1);
            var b = this._localBounds
              , c = b.x
              , d = b.width + b.x
              , e = b.y
              , f = b.height + b.y
              , g = a || this.worldTransform
              , h = g.a
              , i = g.b
              , j = g.c
              , k = g.d
              , l = g.tx
              , m = g.ty
              , n = h * d + j * f + l
              , o = k * f + i * d + m
              , p = h * c + j * f + l
              , q = k * f + i * c + m
              , r = h * c + j * e + l
              , s = k * e + i * c + m
              , t = h * d + j * e + l
              , u = k * e + i * d + m
              , v = n
              , w = o
              , x = n
              , y = o;
            x = p < x ? p : x,
            x = r < x ? r : x,
            x = t < x ? t : x,
            y = q < y ? q : y,
            y = s < y ? s : y,
            y = u < y ? u : y,
            v = p > v ? p : v,
            v = r > v ? r : v,
            v = t > v ? t : v,
            w = q > w ? q : w,
            w = s > w ? s : w,
            w = u > w ? u : w,
            this._bounds.x = x,
            this._bounds.width = v - x,
            this._bounds.y = y,
            this._bounds.height = w - y,
            this._currentBounds = this._bounds
        }
        return this._currentBounds
    }
    ,
    PIXI.Graphics.prototype.getLocalBounds = function() {
        var a = this.worldTransform;
        this.worldTransform = PIXI.identityMatrix;
        for (var b = 0; b < this.children.length; b++)
            this.children[b].updateTransform();
        var c = this.getBounds();
        for (this.worldTransform = a,
        b = 0; b < this.children.length; b++)
            this.children[b].updateTransform();
        return c
    }
    ,
    PIXI.Graphics.prototype.containsPoint = function(a) {
        this.worldTransform.applyInverse(a, tempPoint);
        for (var b = this.graphicsData, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d.fill && (d.shape && d.shape.contains(tempPoint.x, tempPoint.y)))
                return !0
        }
        return !1
    }
    ,
    PIXI.Graphics.prototype.updateLocalBounds = function() {
        var a = 1 / 0
          , c = -1 / 0
          , d = 1 / 0
          , e = -1 / 0;
        if (this.graphicsData.length)
            for (var f, g, h, i, j, k, l = 0; l < this.graphicsData.length; l++) {
                var m = this.graphicsData[l]
                  , n = m.type
                  , o = m.lineWidth;
                if (f = m.shape,
                n === PIXI.Graphics.RECT || n === PIXI.Graphics.RREC)
                    h = f.x - o / 2,
                    i = f.y - o / 2,
                    j = f.width + o,
                    k = f.height + o,
                    a = h < a ? h : a,
                    c = h + j > c ? h + j : c,
                    d = i < d ? i : d,
                    e = i + k > e ? i + k : e;
                else if (n === PIXI.Graphics.CIRC)
                    h = f.x,
                    i = f.y,
                    j = f.radius + o / 2,
                    k = f.radius + o / 2,
                    a = h - j < a ? h - j : a,
                    c = h + j > c ? h + j : c,
                    d = i - k < d ? i - k : d,
                    e = i + k > e ? i + k : e;
                else if (n === PIXI.Graphics.ELIP)
                    h = f.x,
                    i = f.y,
                    j = f.width + o / 2,
                    k = f.height + o / 2,
                    a = h - j < a ? h - j : a,
                    c = h + j > c ? h + j : c,
                    d = i - k < d ? i - k : d,
                    e = i + k > e ? i + k : e;
                else {
                    g = f.points;
                    for (var p = 0; p < g.length; p++)
                        g[p]instanceof b.Point ? (h = g[p].x,
                        i = g[p].y) : (h = g[p],
                        i = g[p + 1],
                        p < g.length - 1 && p++),
                        a = h - o < a ? h - o : a,
                        c = h + o > c ? h + o : c,
                        d = i - o < d ? i - o : d,
                        e = i + o > e ? i + o : e
                }
            }
        else
            a = 0,
            c = 0,
            d = 0,
            e = 0;
        var q = this.boundsPadding;
        this._localBounds.x = a - q,
        this._localBounds.width = c - a + 2 * q,
        this._localBounds.y = d - q,
        this._localBounds.height = e - d + 2 * q
    }
    ,
    PIXI.Graphics.prototype._generateCachedSprite = function() {
        var a = this.getLocalBounds();
        if (this._cachedSprite)
            this._cachedSprite.buffer.resize(a.width, a.height);
        else {
            var b = new PIXI.CanvasBuffer(a.width,a.height)
              , c = PIXI.Texture.fromCanvas(b.canvas);
            this._cachedSprite = new PIXI.Sprite(c),
            this._cachedSprite.buffer = b,
            this._cachedSprite.worldTransform = this.worldTransform
        }
        this._cachedSprite.anchor.x = -a.x / a.width,
        this._cachedSprite.anchor.y = -a.y / a.height,
        this._cachedSprite.buffer.context.translate(-a.x, -a.y),
        this.worldAlpha = 1,
        PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context),
        this._cachedSprite.alpha = this.alpha
    }
    ,
    PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
        var a = this._cachedSprite
          , b = a.texture
          , c = a.buffer.canvas;
        b.baseTexture.width = c.width,
        b.baseTexture.height = c.height,
        b.crop.width = b.frame.width = c.width,
        b.crop.height = b.frame.height = c.height,
        a._width = c.width,
        a._height = c.height,
        b.baseTexture.dirty()
    }
    ,
    PIXI.Graphics.prototype.destroyCachedSprite = function() {
        this._cachedSprite.texture.destroy(!0),
        this._cachedSprite = null
    }
    ,
    PIXI.Graphics.prototype.drawShape = function(a) {
        this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(),
        this.currentPath = null,
        a instanceof b.Polygon && (a = a.clone(),
        a.flatten());
        var c = new PIXI.GraphicsData(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.filling,a);
        return this.graphicsData.push(c),
        c.type === PIXI.Graphics.POLY && (c.shape.closed = this.filling,
        this.currentPath = c),
        this.dirty = !0,
        this._boundsDirty = !0,
        c
    }
    ,
    Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
        get: function() {
            return this._cacheAsBitmap
        },
        set: function(a) {
            this._cacheAsBitmap = a,
            this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(),
            this.dirty = !0,
            this.webGLDirty = !0
        }
    }),
    PIXI.GraphicsData = function(a, b, c, d, e, f, g) {
        this.lineWidth = a,
        this.lineColor = b,
        this.lineAlpha = c,
        this._lineTint = b,
        this.fillColor = d,
        this.fillAlpha = e,
        this._fillTint = d,
        this.fill = f,
        this.shape = g,
        this.type = g.type
    }
    ,
    PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData,
    PIXI.GraphicsData.prototype.clone = function() {
        return new GraphicsData(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.fill,this.shape)
    }
    ,
    PIXI.EarCut = {},
    PIXI.EarCut.Triangulate = function(a, b, c) {
        c = c || 2;
        var d = b && b.length
          , e = d ? b[0] * c : a.length
          , f = PIXI.EarCut.linkedList(a, 0, e, c, !0)
          , g = [];
        if (!f)
            return g;
        var h, i, j, k, l, m, n;
        if (d && (f = PIXI.EarCut.eliminateHoles(a, b, f, c)),
        a.length > 80 * c) {
            h = j = a[0],
            i = k = a[1];
            for (var o = c; o < e; o += c)
                l = a[o],
                m = a[o + 1],
                l < h && (h = l),
                m < i && (i = m),
                l > j && (j = l),
                m > k && (k = m);
            n = Math.max(j - h, k - i)
        }
        return PIXI.EarCut.earcutLinked(f, g, c, h, i, n),
        g
    }
    ,
    PIXI.EarCut.linkedList = function(a, b, c, d, e) {
        var g, h, i, f = 0;
        for (g = b,
        h = c - d; g < c; g += d)
            f += (a[h] - a[g]) * (a[g + 1] + a[h + 1]),
            h = g;
        if (e === f > 0)
            for (g = b; g < c; g += d)
                i = PIXI.EarCut.insertNode(g, a[g], a[g + 1], i);
        else
            for (g = c - d; g >= b; g -= d)
                i = PIXI.EarCut.insertNode(g, a[g], a[g + 1], i);
        return i
    }
    ,
    PIXI.EarCut.filterPoints = function(a, b) {
        if (!a)
            return a;
        b || (b = a);
        var d, c = a;
        do {
            if (d = !1,
            c.steiner || !PIXI.EarCut.equals(c, c.next) && 0 !== PIXI.EarCut.area(c.prev, c, c.next))
                c = c.next;
            else {
                if (PIXI.EarCut.removeNode(c),
                (c = b = c.prev) === c.next)
                    return null;
                d = !0
            }
        } while (d || c !== b);
        return b
    }
    ,
    PIXI.EarCut.earcutLinked = function(a, b, c, d, e, f, g) {
        if (a) {
            !g && f && PIXI.EarCut.indexCurve(a, d, e, f);
            for (var i, j, h = a; a.prev !== a.next; )
                if (i = a.prev,
                j = a.next,
                f ? PIXI.EarCut.isEarHashed(a, d, e, f) : PIXI.EarCut.isEar(a))
                    b.push(i.i / c),
                    b.push(a.i / c),
                    b.push(j.i / c),
                    PIXI.EarCut.removeNode(a),
                    a = j.next,
                    h = j.next;
                else if ((a = j) === h) {
                    g ? 1 === g ? (a = PIXI.EarCut.cureLocalIntersections(a, b, c),
                    PIXI.EarCut.earcutLinked(a, b, c, d, e, f, 2)) : 2 === g && PIXI.EarCut.splitEarcut(a, b, c, d, e, f) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(a), b, c, d, e, f, 1);
                    break
                }
        }
    }
    ,
    PIXI.EarCut.isEar = function(a) {
        var b = a.prev
          , c = a
          , d = a.next;
        if (PIXI.EarCut.area(b, c, d) >= 0)
            return !1;
        for (var e = a.next.next; e !== a.prev; ) {
            if (PIXI.EarCut.pointInTriangle(b.x, b.y, c.x, c.y, d.x, d.y, e.x, e.y) && PIXI.EarCut.area(e.prev, e, e.next) >= 0)
                return !1;
            e = e.next
        }
        return !0
    }
    ,
    PIXI.EarCut.isEarHashed = function(a, b, c, d) {
        var e = a.prev
          , f = a
          , g = a.next;
        if (PIXI.EarCut.area(e, f, g) >= 0)
            return !1;
        for (var h = e.x < f.x ? e.x < g.x ? e.x : g.x : f.x < g.x ? f.x : g.x, i = e.y < f.y ? e.y < g.y ? e.y : g.y : f.y < g.y ? f.y : g.y, j = e.x > f.x ? e.x > g.x ? e.x : g.x : f.x > g.x ? f.x : g.x, k = e.y > f.y ? e.y > g.y ? e.y : g.y : f.y > g.y ? f.y : g.y, l = PIXI.EarCut.zOrder(h, i, b, c, d), m = PIXI.EarCut.zOrder(j, k, b, c, d), n = a.nextZ; n && n.z <= m; ) {
            if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0)
                return !1;
            n = n.nextZ
        }
        for (n = a.prevZ; n && n.z >= l; ) {
            if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, f.x, f.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0)
                return !1;
            n = n.prevZ
        }
        return !0
    }
    ,
    PIXI.EarCut.cureLocalIntersections = function(a, b, c) {
        var d = a;
        do {
            var e = d.prev
              , f = d.next.next;
            PIXI.EarCut.intersects(e, d, d.next, f) && PIXI.EarCut.locallyInside(e, f) && PIXI.EarCut.locallyInside(f, e) && (b.push(e.i / c),
            b.push(d.i / c),
            b.push(f.i / c),
            PIXI.EarCut.removeNode(d),
            PIXI.EarCut.removeNode(d.next),
            d = a = f),
            d = d.next
        } while (d !== a);
        return d
    }
    ,
    PIXI.EarCut.splitEarcut = function(a, b, c, d, e, f) {
        var g = a;
        do {
            for (var h = g.next.next; h !== g.prev; ) {
                if (g.i !== h.i && PIXI.EarCut.isValidDiagonal(g, h)) {
                    var i = PIXI.EarCut.splitPolygon(g, h);
                    return g = PIXI.EarCut.filterPoints(g, g.next),
                    i = PIXI.EarCut.filterPoints(i, i.next),
                    PIXI.EarCut.earcutLinked(g, b, c, d, e, f),
                    void PIXI.EarCut.earcutLinked(i, b, c, d, e, f)
                }
                h = h.next
            }
            g = g.next
        } while (g !== a)
    }
    ,
    PIXI.EarCut.eliminateHoles = function(a, b, c, d) {
        var f, g, h, i, j, e = [];
        for (f = 0,
        g = b.length; f < g; f++)
            h = b[f] * d,
            i = f < g - 1 ? b[f + 1] * d : a.length,
            j = PIXI.EarCut.linkedList(a, h, i, d, !1),
            j === j.next && (j.steiner = !0),
            e.push(PIXI.EarCut.getLeftmost(j));
        for (e.sort(compareX),
        f = 0; f < e.length; f++)
            PIXI.EarCut.eliminateHole(e[f], c),
            c = PIXI.EarCut.filterPoints(c, c.next);
        return c
    }
    ,
    PIXI.EarCut.compareX = function(a, b) {
        return a.x - b.x
    }
    ,
    PIXI.EarCut.eliminateHole = function(a, b) {
        if (b = PIXI.EarCut.findHoleBridge(a, b)) {
            var c = PIXI.EarCut.splitPolygon(b, a);
            PIXI.EarCut.filterPoints(c, c.next)
        }
    }
    ,
    PIXI.EarCut.findHoleBridge = function(a, b) {
        var g, c = b, d = a.x, e = a.y, f = -1 / 0;
        do {
            if (e <= c.y && e >= c.next.y) {
                var h = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
                h <= d && h > f && (f = h,
                g = c.x < c.next.x ? c : c.next)
            }
            c = c.next
        } while (c !== b);
        if (!g)
            return null;
        if (a.x === g.x)
            return g.prev;
        var k, i = g, j = 1 / 0;
        for (c = g.next; c !== i; )
            d >= c.x && c.x >= g.x && PIXI.EarCut.pointInTriangle(e < g.y ? d : f, e, g.x, g.y, e < g.y ? f : d, e, c.x, c.y) && ((k = Math.abs(e - c.y) / (d - c.x)) < j || k === j && c.x > g.x) && PIXI.EarCut.locallyInside(c, a) && (g = c,
            j = k),
            c = c.next;
        return g
    }
    ,
    PIXI.EarCut.indexCurve = function(a, b, c, d) {
        var e = a;
        do {
            null === e.z && (e.z = PIXI.EarCut.zOrder(e.x, e.y, b, c, d)),
            e.prevZ = e.prev,
            e.nextZ = e.next,
            e = e.next
        } while (e !== a);
        e.prevZ.nextZ = null,
        e.prevZ = null,
        PIXI.EarCut.sortLinked(e)
    }
    ,
    PIXI.EarCut.sortLinked = function(a) {
        var b, c, d, e, f, g, h, i, j = 1;
        do {
            for (c = a,
            a = null,
            f = null,
            g = 0; c; ) {
                for (g++,
                d = c,
                h = 0,
                b = 0; b < j && (h++,
                d = d.nextZ); b++)
                    ;
                for (i = j; h > 0 || i > 0 && d; )
                    0 === h ? (e = d,
                    d = d.nextZ,
                    i--) : 0 !== i && d ? c.z <= d.z ? (e = c,
                    c = c.nextZ,
                    h--) : (e = d,
                    d = d.nextZ,
                    i--) : (e = c,
                    c = c.nextZ,
                    h--),
                    f ? f.nextZ = e : a = e,
                    e.prevZ = f,
                    f = e;
                c = d
            }
            f.nextZ = null,
            j *= 2
        } while (g > 1);
        return a
    }
    ,
    PIXI.EarCut.zOrder = function(a, b, c, d, e) {
        return a = 32767 * (a - c) / e,
        b = 32767 * (b - d) / e,
        a = 16711935 & (a | a << 8),
        a = 252645135 & (a | a << 4),
        a = 858993459 & (a | a << 2),
        a = 1431655765 & (a | a << 1),
        b = 16711935 & (b | b << 8),
        b = 252645135 & (b | b << 4),
        b = 858993459 & (b | b << 2),
        b = 1431655765 & (b | b << 1),
        a | b << 1
    }
    ,
    PIXI.EarCut.getLeftmost = function(a) {
        var b = a
          , c = a;
        do {
            b.x < c.x && (c = b),
            b = b.next
        } while (b !== a);
        return c
    }
    ,
    PIXI.EarCut.pointInTriangle = function(a, b, c, d, e, f, g, h) {
        return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0
    }
    ,
    PIXI.EarCut.isValidDiagonal = function(a, b) {
        return PIXI.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b)
    }
    ,
    PIXI.EarCut.area = function(a, b, c) {
        return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)
    }
    ,
    PIXI.EarCut.equals = function(a, b) {
        return a.x === b.x && a.y === b.y
    }
    ,
    PIXI.EarCut.intersects = function(a, b, c, d) {
        return PIXI.EarCut.area(a, b, c) > 0 != PIXI.EarCut.area(a, b, d) > 0 && PIXI.EarCut.area(c, d, a) > 0 != PIXI.EarCut.area(c, d, b) > 0
    }
    ,
    PIXI.EarCut.intersectsPolygon = function(a, b) {
        var c = a;
        do {
            if (c.i !== a.i && c.next.i !== a.i && c.i !== b.i && c.next.i !== b.i && PIXI.EarCut.intersects(c, c.next, a, b))
                return !0;
            c = c.next
        } while (c !== a);
        return !1
    }
    ,
    PIXI.EarCut.locallyInside = function(a, b) {
        return PIXI.EarCut.area(a.prev, a, a.next) < 0 ? PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 : PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0
    }
    ,
    PIXI.EarCut.middleInside = function(a, b) {
        var c = a
          , d = !1
          , e = (a.x + b.x) / 2
          , f = (a.y + b.y) / 2;
        do {
            c.y > f != c.next.y > f && e < (c.next.x - c.x) * (f - c.y) / (c.next.y - c.y) + c.x && (d = !d),
            c = c.next
        } while (c !== a);
        return d
    }
    ,
    PIXI.EarCut.splitPolygon = function(a, b) {
        var c = new PIXI.EarCut.Node(a.i,a.x,a.y)
          , d = new PIXI.EarCut.Node(b.i,b.x,b.y)
          , e = a.next
          , f = b.prev;
        return a.next = b,
        b.prev = a,
        c.next = e,
        e.prev = c,
        d.next = c,
        c.prev = d,
        f.next = d,
        d.prev = f,
        d
    }
    ,
    PIXI.EarCut.insertNode = function(a, b, c, d) {
        var e = new PIXI.EarCut.Node(a,b,c);
        return d ? (e.next = d.next,
        e.prev = d,
        d.next.prev = e,
        d.next = e) : (e.prev = e,
        e.next = e),
        e
    }
    ,
    PIXI.EarCut.removeNode = function(a) {
        a.next.prev = a.prev,
        a.prev.next = a.next,
        a.prevZ && (a.prevZ.nextZ = a.nextZ),
        a.nextZ && (a.nextZ.prevZ = a.prevZ)
    }
    ,
    PIXI.EarCut.Node = function(a, b, c) {
        this.i = a,
        this.x = b,
        this.y = c,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    ,
    PIXI.WebGLGraphics = function() {}
    ,
    PIXI.WebGLGraphics.stencilBufferLimit = 6,
    PIXI.WebGLGraphics.renderGraphics = function(a, b) {
        var g, c = b.gl, d = b.projection, e = b.offset, f = b.shaderManager.primitiveShader;
        a.dirty && PIXI.WebGLGraphics.updateGraphics(a, c);
        for (var h = a._webGL[c.id], i = 0; i < h.data.length; i++)
            1 === h.data[i].mode ? (g = h.data[i],
            b.stencilManager.pushStencil(a, g, b),
            c.drawElements(c.TRIANGLE_FAN, 4, c.UNSIGNED_SHORT, 2 * (g.indices.length - 4)),
            b.stencilManager.popStencil(a, g, b)) : (g = h.data[i],
            b.shaderManager.setShader(f),
            f = b.shaderManager.primitiveShader,
            c.uniformMatrix3fv(f.translationMatrix, !1, a.worldTransform.toArray(!0)),
            c.uniform1f(f.flipY, 1),
            c.uniform2f(f.projectionVector, d.x, -d.y),
            c.uniform2f(f.offsetVector, -e.x, -e.y),
            c.uniform3fv(f.tintColor, PIXI.hex2rgb(a.tint)),
            c.uniform1f(f.alpha, a.worldAlpha),
            c.bindBuffer(c.ARRAY_BUFFER, g.buffer),
            c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, !1, 24, 0),
            c.vertexAttribPointer(f.colorAttribute, 4, c.FLOAT, !1, 24, 8),
            c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, g.indexBuffer),
            c.drawElements(c.TRIANGLE_STRIP, g.indices.length, c.UNSIGNED_SHORT, 0))
    }
    ,
    PIXI.WebGLGraphics.updateGraphics = function(a, b) {
        var c = a._webGL[b.id];
        c || (c = a._webGL[b.id] = {
            lastIndex: 0,
            data: [],
            gl: b
        }),
        a.dirty = !1;
        var d;
        if (a.clearDirty) {
            for (a.clearDirty = !1,
            d = 0; d < c.data.length; d++) {
                var e = c.data[d];
                e.reset(),
                PIXI.WebGLGraphics.graphicsDataPool.push(e)
            }
            c.data = [],
            c.lastIndex = 0
        }
        var f;
        for (d = c.lastIndex; d < a.graphicsData.length; d++) {
            var g = a.graphicsData[d];
            if (g.type === PIXI.Graphics.POLY) {
                if (g.points = g.shape.points.slice(),
                g.shape.closed && (g.points[0] === g.points[g.points.length - 2] && g.points[1] === g.points[g.points.length - 1] || g.points.push(g.points[0], g.points[1])),
                g.fill && g.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                    if (g.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                        f = PIXI.WebGLGraphics.switchMode(c, 0);
                        var h = PIXI.WebGLGraphics.buildPoly(g, f);
                        h || (f = PIXI.WebGLGraphics.switchMode(c, 1),
                        PIXI.WebGLGraphics.buildComplexPoly(g, f))
                    } else
                        f = PIXI.WebGLGraphics.switchMode(c, 1),
                        PIXI.WebGLGraphics.buildComplexPoly(g, f);
                g.lineWidth > 0 && (f = PIXI.WebGLGraphics.switchMode(c, 0),
                PIXI.WebGLGraphics.buildLine(g, f))
            } else
                f = PIXI.WebGLGraphics.switchMode(c, 0),
                g.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(g, f) : g.type === PIXI.Graphics.CIRC || g.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(g, f) : g.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(g, f);
            c.lastIndex++
        }
        for (d = 0; d < c.data.length; d++)
            f = c.data[d],
            f.dirty && f.upload()
    }
    ,
    PIXI.WebGLGraphics.switchMode = function(a, b) {
        var c;
        return a.data.length ? (c = a.data[a.data.length - 1],
        c.mode === b && 1 !== b || (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl),
        c.mode = b,
        a.data.push(c))) : (c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl),
        c.mode = b,
        a.data.push(c)),
        c.dirty = !0,
        c
    }
    ,
    PIXI.WebGLGraphics.buildRectangle = function(a, b) {
        var c = a.shape
          , d = c.x
          , e = c.y
          , f = c.width
          , g = c.height;
        if (a.fill) {
            var h = PIXI.hex2rgb(a.fillColor)
              , i = a.fillAlpha
              , j = h[0] * i
              , k = h[1] * i
              , l = h[2] * i
              , m = b.points
              , n = b.indices
              , o = m.length / 6;
            m.push(d, e),
            m.push(j, k, l, i),
            m.push(d + f, e),
            m.push(j, k, l, i),
            m.push(d, e + g),
            m.push(j, k, l, i),
            m.push(d + f, e + g),
            m.push(j, k, l, i),
            n.push(o, o, o + 1, o + 2, o + 3, o + 3)
        }
        if (a.lineWidth) {
            var p = a.points;
            a.points = [d, e, d + f, e, d + f, e + g, d, e + g, d, e],
            PIXI.WebGLGraphics.buildLine(a, b),
            a.points = p
        }
    }
    ,
    PIXI.WebGLGraphics.buildRoundedRectangle = function(a, b) {
        var c = a.shape
          , d = c.x
          , e = c.y
          , f = c.width
          , g = c.height
          , h = c.radius
          , i = [];
        if (i.push(d, e + h),
        i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d, e + g - h, d, e + g, d + h, e + g)),
        i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f - h, e + g, d + f, e + g, d + f, e + g - h)),
        i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f, e + h, d + f, e, d + f - h, e)),
        i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + h, e, d, e, d, e + h)),
        a.fill) {
            var j = PIXI.hex2rgb(a.fillColor)
              , k = a.fillAlpha
              , l = j[0] * k
              , m = j[1] * k
              , n = j[2] * k
              , o = b.points
              , p = b.indices
              , q = o.length / 6
              , r = PIXI.EarCut.Triangulate(i, null, 2)
              , s = 0;
            for (s = 0; s < r.length; s += 3)
                p.push(r[s] + q),
                p.push(r[s] + q),
                p.push(r[s + 1] + q),
                p.push(r[s + 2] + q),
                p.push(r[s + 2] + q);
            for (s = 0; s < i.length; s++)
                o.push(i[s], i[++s], l, m, n, k)
        }
        if (a.lineWidth) {
            var t = a.points;
            a.points = i,
            PIXI.WebGLGraphics.buildLine(a, b),
            a.points = t
        }
    }
    ,
    PIXI.WebGLGraphics.quadraticBezierCurve = function(a, b, c, d, e, f) {
        function o(a, b, c) {
            return a + (b - a) * c
        }
        for (var g, h, i, j, k, l, m = 20, n = [], p = 0, q = 0; q <= m; q++)
            p = q / m,
            g = o(a, c, p),
            h = o(b, d, p),
            i = o(c, e, p),
            j = o(d, f, p),
            k = o(g, i, p),
            l = o(h, j, p),
            n.push(k, l);
        return n
    }
    ,
    PIXI.WebGLGraphics.buildCircle = function(a, b) {
        var f, g, c = a.shape, d = c.x, e = c.y;
        a.type === PIXI.Graphics.CIRC ? (f = c.radius,
        g = c.radius) : (f = c.width,
        g = c.height);
        var h = 40
          , i = 2 * Math.PI / h
          , j = 0;
        if (a.fill) {
            var k = PIXI.hex2rgb(a.fillColor)
              , l = a.fillAlpha
              , m = k[0] * l
              , n = k[1] * l
              , o = k[2] * l
              , p = b.points
              , q = b.indices
              , r = p.length / 6;
            for (q.push(r),
            j = 0; j < h + 1; j++)
                p.push(d, e, m, n, o, l),
                p.push(d + Math.sin(i * j) * f, e + Math.cos(i * j) * g, m, n, o, l),
                q.push(r++, r++);
            q.push(r - 1)
        }
        if (a.lineWidth) {
            var s = a.points;
            for (a.points = [],
            j = 0; j < h + 1; j++)
                a.points.push(d + Math.sin(i * j) * f, e + Math.cos(i * j) * g);
            PIXI.WebGLGraphics.buildLine(a, b),
            a.points = s
        }
    }
    ,
    PIXI.WebGLGraphics.buildLine = function(a, b) {
        var c = 0
          , d = a.points;
        if (0 !== d.length) {
            if (a.lineWidth % 2)
                for (c = 0; c < d.length; c++)
                    d[c] += .5;
            var e = new PIXI.Point(d[0],d[1])
              , f = new PIXI.Point(d[d.length - 2],d[d.length - 1]);
            if (e.x === f.x && e.y === f.y) {
                d = d.slice(),
                d.pop(),
                d.pop(),
                f = new PIXI.Point(d[d.length - 2],d[d.length - 1]);
                var g = f.x + .5 * (e.x - f.x)
                  , h = f.y + .5 * (e.y - f.y);
                d.unshift(g, h),
                d.push(g, h)
            }
            var t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, i = b.points, j = b.indices, k = d.length / 2, l = d.length, m = i.length / 6, n = a.lineWidth / 2, o = PIXI.hex2rgb(a.lineColor), p = a.lineAlpha, q = o[0] * p, r = o[1] * p, s = o[2] * p;
            for (v = d[0],
            w = d[1],
            x = d[2],
            y = d[3],
            B = -(w - y),
            C = v - x,
            P = Math.sqrt(B * B + C * C),
            B /= P,
            C /= P,
            B *= n,
            C *= n,
            i.push(v - B, w - C, q, r, s, p),
            i.push(v + B, w + C, q, r, s, p),
            c = 1; c < k - 1; c++)
                v = d[2 * (c - 1)],
                w = d[2 * (c - 1) + 1],
                x = d[2 * c],
                y = d[2 * c + 1],
                z = d[2 * (c + 1)],
                A = d[2 * (c + 1) + 1],
                B = -(w - y),
                C = v - x,
                P = Math.sqrt(B * B + C * C),
                B /= P,
                C /= P,
                B *= n,
                C *= n,
                D = -(y - A),
                E = x - z,
                P = Math.sqrt(D * D + E * E),
                D /= P,
                E /= P,
                D *= n,
                E *= n,
                H = -C + w - (-C + y),
                I = -B + x - (-B + v),
                J = (-B + v) * (-C + y) - (-B + x) * (-C + w),
                K = -E + A - (-E + y),
                L = -D + x - (-D + z),
                M = (-D + z) * (-E + y) - (-D + x) * (-E + A),
                N = H * L - K * I,
                Math.abs(N) < .1 ? (N += 10.1,
                i.push(x - B, y - C, q, r, s, p),
                i.push(x + B, y + C, q, r, s, p)) : (t = (I * M - L * J) / N,
                u = (K * J - H * M) / N,
                O = (t - x) * (t - x) + (u - y) + (u - y),
                O > 19600 ? (F = B - D,
                G = C - E,
                P = Math.sqrt(F * F + G * G),
                F /= P,
                G /= P,
                F *= n,
                G *= n,
                i.push(x - F, y - G),
                i.push(q, r, s, p),
                i.push(x + F, y + G),
                i.push(q, r, s, p),
                i.push(x - F, y - G),
                i.push(q, r, s, p),
                l++) : (i.push(t, u),
                i.push(q, r, s, p),
                i.push(x - (t - x), y - (u - y)),
                i.push(q, r, s, p)));
            for (v = d[2 * (k - 2)],
            w = d[2 * (k - 2) + 1],
            x = d[2 * (k - 1)],
            y = d[2 * (k - 1) + 1],
            B = -(w - y),
            C = v - x,
            P = Math.sqrt(B * B + C * C),
            B /= P,
            C /= P,
            B *= n,
            C *= n,
            i.push(x - B, y - C),
            i.push(q, r, s, p),
            i.push(x + B, y + C),
            i.push(q, r, s, p),
            j.push(m),
            c = 0; c < l; c++)
                j.push(m++);
            j.push(m - 1)
        }
    }
    ,
    PIXI.WebGLGraphics.buildComplexPoly = function(a, b) {
        var c = a.points.slice();
        if (!(c.length < 6)) {
            var d = b.indices;
            b.points = c,
            b.alpha = a.fillAlpha,
            b.color = PIXI.hex2rgb(a.fillColor);
            for (var i, j, e = 1 / 0, f = -1 / 0, g = 1 / 0, h = -1 / 0, k = 0; k < c.length; k += 2)
                i = c[k],
                j = c[k + 1],
                e = i < e ? i : e,
                f = i > f ? i : f,
                g = j < g ? j : g,
                h = j > h ? j : h;
            c.push(e, g, f, g, f, h, e, h);
            var l = c.length / 2;
            for (k = 0; k < l; k++)
                d.push(k)
        }
    }
    ,
    PIXI.WebGLGraphics.buildPoly = function(a, b) {
        var c = a.points;
        if (!(c.length < 6)) {
            var d = b.points
              , e = b.indices
              , f = c.length / 2
              , g = PIXI.hex2rgb(a.fillColor)
              , h = a.fillAlpha
              , i = g[0] * h
              , j = g[1] * h
              , k = g[2] * h
              , l = PIXI.EarCut.Triangulate(c, null, 2);
            if (!l)
                return !1;
            var m = d.length / 6
              , n = 0;
            for (n = 0; n < l.length; n += 3)
                e.push(l[n] + m),
                e.push(l[n] + m),
                e.push(l[n + 1] + m),
                e.push(l[n + 2] + m),
                e.push(l[n + 2] + m);
            for (n = 0; n < f; n++)
                d.push(c[2 * n], c[2 * n + 1], i, j, k, h);
            return !0
        }
    }
    ,
    PIXI.WebGLGraphics.graphicsDataPool = [],
    PIXI.WebGLGraphicsData = function(a) {
        this.gl = a,
        this.color = [0, 0, 0],
        this.points = [],
        this.indices = [],
        this.buffer = a.createBuffer(),
        this.indexBuffer = a.createBuffer(),
        this.mode = 1,
        this.alpha = 1,
        this.dirty = !0
    }
    ,
    PIXI.WebGLGraphicsData.prototype.reset = function() {
        this.points = [],
        this.indices = []
    }
    ,
    PIXI.WebGLGraphicsData.prototype.upload = function() {
        var a = this.gl;
        this.glPoints = new PIXI.Float32Array(this.points),
        a.bindBuffer(a.ARRAY_BUFFER, this.buffer),
        a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW),
        this.glIndicies = new PIXI.Uint16Array(this.indices),
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW),
        this.dirty = !1
    }
    ,
    PIXI.CanvasGraphics = function() {}
    ,
    PIXI.CanvasGraphics.renderGraphics = function(a, b) {
        var c = a.worldAlpha;
        a.dirty && (this.updateGraphicsTint(a),
        a.dirty = !1);
        for (var d = 0; d < a.graphicsData.length; d++) {
            var e = a.graphicsData[d]
              , f = e.shape
              , g = e._fillTint
              , h = e._lineTint;
            if (b.lineWidth = e.lineWidth,
            e.type === PIXI.Graphics.POLY) {
                b.beginPath();
                var i = f.points;
                b.moveTo(i[0], i[1]);
                for (var j = 1; j < i.length / 2; j++)
                    b.lineTo(i[2 * j], i[2 * j + 1]);
                f.closed && b.lineTo(i[0], i[1]),
                i[0] === i[i.length - 2] && i[1] === i[i.length - 1] && b.closePath(),
                e.fill && (b.globalAlpha = e.fillAlpha * c,
                b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6),
                b.fill()),
                e.lineWidth && (b.globalAlpha = e.lineAlpha * c,
                b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                b.stroke())
            } else if (e.type === PIXI.Graphics.RECT)
                (e.fillColor || 0 === e.fillColor) && (b.globalAlpha = e.fillAlpha * c,
                b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6),
                b.fillRect(f.x, f.y, f.width, f.height)),
                e.lineWidth && (b.globalAlpha = e.lineAlpha * c,
                b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                b.strokeRect(f.x, f.y, f.width, f.height));
            else if (e.type === PIXI.Graphics.CIRC)
                b.beginPath(),
                b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI),
                b.closePath(),
                e.fill && (b.globalAlpha = e.fillAlpha * c,
                b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6),
                b.fill()),
                e.lineWidth && (b.globalAlpha = e.lineAlpha * c,
                b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                b.stroke());
            else if (e.type === PIXI.Graphics.ELIP) {
                var k = 2 * f.width
                  , l = 2 * f.height
                  , m = f.x - k / 2
                  , n = f.y - l / 2;
                b.beginPath();
                var o = .5522848
                  , p = k / 2 * o
                  , q = l / 2 * o
                  , r = m + k
                  , s = n + l
                  , t = m + k / 2
                  , u = n + l / 2;
                b.moveTo(m, u),
                b.bezierCurveTo(m, u - q, t - p, n, t, n),
                b.bezierCurveTo(t + p, n, r, u - q, r, u),
                b.bezierCurveTo(r, u + q, t + p, s, t, s),
                b.bezierCurveTo(t - p, s, m, u + q, m, u),
                b.closePath(),
                e.fill && (b.globalAlpha = e.fillAlpha * c,
                b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6),
                b.fill()),
                e.lineWidth && (b.globalAlpha = e.lineAlpha * c,
                b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                b.stroke())
            } else if (e.type === PIXI.Graphics.RREC) {
                var v = f.x
                  , w = f.y
                  , x = f.width
                  , y = f.height
                  , z = f.radius
                  , A = Math.min(x, y) / 2 | 0;
                z = z > A ? A : z,
                b.beginPath(),
                b.moveTo(v, w + z),
                b.lineTo(v, w + y - z),
                b.quadraticCurveTo(v, w + y, v + z, w + y),
                b.lineTo(v + x - z, w + y),
                b.quadraticCurveTo(v + x, w + y, v + x, w + y - z),
                b.lineTo(v + x, w + z),
                b.quadraticCurveTo(v + x, w, v + x - z, w),
                b.lineTo(v + z, w),
                b.quadraticCurveTo(v, w, v, w + z),
                b.closePath(),
                (e.fillColor || 0 === e.fillColor) && (b.globalAlpha = e.fillAlpha * c,
                b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6),
                b.fill()),
                e.lineWidth && (b.globalAlpha = e.lineAlpha * c,
                b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                b.stroke())
            }
        }
    }
    ,
    PIXI.CanvasGraphics.renderGraphicsMask = function(a, b) {
        var c = a.graphicsData.length;
        if (0 !== c) {
            b.beginPath();
            for (var d = 0; d < c; d++) {
                var e = a.graphicsData[d]
                  , f = e.shape;
                if (e.type === PIXI.Graphics.POLY) {
                    var g = f.points;
                    b.moveTo(g[0], g[1]);
                    for (var h = 1; h < g.length / 2; h++)
                        b.lineTo(g[2 * h], g[2 * h + 1]);
                    g[0] === g[g.length - 2] && g[1] === g[g.length - 1] && b.closePath()
                } else if (e.type === PIXI.Graphics.RECT)
                    b.rect(f.x, f.y, f.width, f.height),
                    b.closePath();
                else if (e.type === PIXI.Graphics.CIRC)
                    b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI),
                    b.closePath();
                else if (e.type === PIXI.Graphics.ELIP) {
                    var i = 2 * f.width
                      , j = 2 * f.height
                      , k = f.x - i / 2
                      , l = f.y - j / 2
                      , m = .5522848
                      , n = i / 2 * m
                      , o = j / 2 * m
                      , p = k + i
                      , q = l + j
                      , r = k + i / 2
                      , s = l + j / 2;
                    b.moveTo(k, s),
                    b.bezierCurveTo(k, s - o, r - n, l, r, l),
                    b.bezierCurveTo(r + n, l, p, s - o, p, s),
                    b.bezierCurveTo(p, s + o, r + n, q, r, q),
                    b.bezierCurveTo(r - n, q, k, s + o, k, s),
                    b.closePath()
                } else if (e.type === PIXI.Graphics.RREC) {
                    var t = f.x
                      , u = f.y
                      , v = f.width
                      , w = f.height
                      , x = f.radius
                      , y = Math.min(v, w) / 2 | 0;
                    x = x > y ? y : x,
                    b.moveTo(t, u + x),
                    b.lineTo(t, u + w - x),
                    b.quadraticCurveTo(t, u + w, t + x, u + w),
                    b.lineTo(t + v - x, u + w),
                    b.quadraticCurveTo(t + v, u + w, t + v, u + w - x),
                    b.lineTo(t + v, u + x),
                    b.quadraticCurveTo(t + v, u, t + v - x, u),
                    b.lineTo(t + x, u),
                    b.quadraticCurveTo(t, u, t, u + x),
                    b.closePath()
                }
            }
        }
    }
    ,
    PIXI.CanvasGraphics.updateGraphicsTint = function(a) {
        if (16777215 !== a.tint)
            for (var b = (a.tint >> 16 & 255) / 255, c = (a.tint >> 8 & 255) / 255, d = (255 & a.tint) / 255, e = 0; e < a.graphicsData.length; e++) {
                var f = a.graphicsData[e]
                  , g = 0 | f.fillColor
                  , h = 0 | f.lineColor;
                f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255,
                f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255
            }
    }
    ,
    b.Graphics = function(a, c, d) {
        void 0 === c && (c = 0),
        void 0 === d && (d = 0),
        this.type = b.GRAPHICS,
        this.physicsType = b.SPRITE,
        this.anchor = new b.Point,
        PIXI.Graphics.call(this),
        b.Component.Core.init.call(this, a, c, d, "", null)
    }
    ,
    b.Graphics.prototype = Object.create(PIXI.Graphics.prototype),
    b.Graphics.prototype.constructor = b.Graphics,
    b.Component.Core.install.call(b.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
    b.Graphics.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate,
    b.Graphics.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate,
    b.Graphics.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate,
    b.Graphics.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.Graphics.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }
    ,
    b.Graphics.prototype.postUpdate = function() {
        b.Component.PhysicsBody.postUpdate.call(this),
        b.Component.FixedToCamera.postUpdate.call(this),
        this._boundsDirty && (this.updateLocalBounds(),
        this._boundsDirty = !1);
        for (var a = 0; a < this.children.length; a++)
            this.children[a].postUpdate()
    }
    ,
    b.Graphics.prototype.destroy = function(a) {
        this.clear(),
        b.Component.Destroy.prototype.destroy.call(this, a)
    }
    ,
    b.Graphics.prototype.drawTriangle = function(a, c) {
        void 0 === c && (c = !1);
        var d = new b.Polygon(a);
        if (c) {
            var e = new b.Point(this.game.camera.x - a[0].x,this.game.camera.y - a[0].y)
              , f = new b.Point(a[1].x - a[0].x,a[1].y - a[0].y)
              , g = new b.Point(a[1].x - a[2].x,a[1].y - a[2].y)
              , h = g.cross(f);
            e.dot(h) > 0 && this.drawPolygon(d)
        } else
            this.drawPolygon(d)
    }
    ,
    b.Graphics.prototype.drawTriangles = function(a, c, d) {
        void 0 === d && (d = !1);
        var i, e = new b.Point, f = new b.Point, g = new b.Point, h = [];
        if (c)
            if (a[0]instanceof b.Point)
                for (i = 0; i < c.length / 3; i++)
                    h.push(a[c[3 * i]]),
                    h.push(a[c[3 * i + 1]]),
                    h.push(a[c[3 * i + 2]]),
                    3 === h.length && (this.drawTriangle(h, d),
                    h = []);
            else
                for (i = 0; i < c.length; i++)
                    e.x = a[2 * c[i]],
                    e.y = a[2 * c[i] + 1],
                    h.push(e.copyTo({})),
                    3 === h.length && (this.drawTriangle(h, d),
                    h = []);
        else if (a[0]instanceof b.Point)
            for (i = 0; i < a.length / 3; i++)
                this.drawTriangle([a[3 * i], a[3 * i + 1], a[3 * i + 2]], d);
        else
            for (i = 0; i < a.length / 6; i++)
                e.x = a[6 * i + 0],
                e.y = a[6 * i + 1],
                f.x = a[6 * i + 2],
                f.y = a[6 * i + 3],
                g.x = a[6 * i + 4],
                g.y = a[6 * i + 5],
                this.drawTriangle([e, f, g], d)
    }
    ,
    b.RenderTexture = function(a, c, d, e, f, g) {
        void 0 === e && (e = ""),
        void 0 === f && (f = b.scaleModes.DEFAULT),
        void 0 === g && (g = 1),
        this.game = a,
        this.key = e,
        this.type = b.RENDERTEXTURE,
        this._tempMatrix = new PIXI.Matrix,
        PIXI.RenderTexture.call(this, c, d, this.game.renderer, f, g),
        this.render = b.RenderTexture.prototype.render
    }
    ,
    b.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype),
    b.RenderTexture.prototype.constructor = b.RenderTexture,
    b.RenderTexture.prototype.renderXY = function(a, b, c, d) {
        a.updateTransform(),
        this._tempMatrix.copyFrom(a.worldTransform),
        this._tempMatrix.tx = b,
        this._tempMatrix.ty = c,
        this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d)
    }
    ,
    b.RenderTexture.prototype.renderRawXY = function(a, b, c, d) {
        this._tempMatrix.identity().translate(b, c),
        this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, d) : this.renderCanvas(a, this._tempMatrix, d)
    }
    ,
    b.RenderTexture.prototype.render = function(a, b, c) {
        void 0 === b || null === b ? this._tempMatrix.copyFrom(a.worldTransform) : this._tempMatrix.copyFrom(b),
        this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(a, this._tempMatrix, c) : this.renderCanvas(a, this._tempMatrix, c)
    }
    ,
    b.Text = function(a, c, d, e, f) {
        c = c || 0,
        d = d || 0,
        e = void 0 === e || null === e ? "" : e.toString(),
        f = b.Utils.extend({}, f),
        this.type = b.TEXT,
        this.physicsType = b.SPRITE,
        this.padding = new b.Point,
        this.textBounds = null,
        this.canvas = PIXI.CanvasPool.create(this),
        this.context = this.canvas.getContext("2d"),
        this.colors = [],
        this.strokeColors = [],
        this.fontStyles = [],
        this.fontWeights = [],
        this.autoRound = !1,
        this.useAdvancedWrap = !1,
        this._res = a.renderer.resolution,
        this._text = e,
        this._fontComponents = null,
        this._lineSpacing = 0,
        this._charCount = 0,
        this._width = 0,
        this._height = 0,
        b.Sprite.call(this, a, c, d, PIXI.Texture.fromCanvas(this.canvas)),
        this.setStyle(f),
        "" !== e && this.updateText()
    }
    ,
    b.Text.prototype = Object.create(b.Sprite.prototype),
    b.Text.prototype.constructor = b.Text,
    b.Text.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }
    ,
    b.Text.prototype.update = function() {}
    ,
    b.Text.prototype.destroy = function(a) {
        this.texture.destroy(!0),
        b.Component.Destroy.prototype.destroy.call(this, a)
    }
    ,
    b.Text.prototype.setShadow = function(a, b, c, d, e, f) {
        return void 0 === a && (a = 0),
        void 0 === b && (b = 0),
        void 0 === c && (c = "rgba(0, 0, 0, 1)"),
        void 0 === d && (d = 0),
        void 0 === e && (e = !0),
        void 0 === f && (f = !0),
        this.style.shadowOffsetX = a,
        this.style.shadowOffsetY = b,
        this.style.shadowColor = c,
        this.style.shadowBlur = d,
        this.style.shadowStroke = e,
        this.style.shadowFill = f,
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.setStyle = function(a, b) {
        void 0 === b && (b = !1),
        a = a || {},
        a.font = a.font || "bold 20pt Arial",
        a.backgroundColor = a.backgroundColor || null,
        a.fill = a.fill || "black",
        a.align = a.align || "left",
        a.boundsAlignH = a.boundsAlignH || "left",
        a.boundsAlignV = a.boundsAlignV || "top",
        a.stroke = a.stroke || "black",
        a.strokeThickness = a.strokeThickness || 0,
        a.wordWrap = a.wordWrap || !1,
        a.wordWrapWidth = a.wordWrapWidth || 100,
        a.maxLines = a.maxLines || 0,
        a.shadowOffsetX = a.shadowOffsetX || 0,
        a.shadowOffsetY = a.shadowOffsetY || 0,
        a.shadowColor = a.shadowColor || "rgba(0,0,0,0)",
        a.shadowBlur = a.shadowBlur || 0,
        a.tabs = a.tabs || 0;
        var c = this.fontToComponents(a.font);
        return a.fontStyle && (c.fontStyle = a.fontStyle),
        a.fontVariant && (c.fontVariant = a.fontVariant),
        a.fontWeight && (c.fontWeight = a.fontWeight),
        a.fontSize && ("number" == typeof a.fontSize && (a.fontSize = a.fontSize + "px"),
        c.fontSize = a.fontSize),
        this._fontComponents = c,
        a.font = this.componentsToFont(this._fontComponents),
        this.style = a,
        this.dirty = !0,
        b && this.updateText(),
        this
    }
    ,
    b.Text.prototype.updateText = function() {
        this.texture.baseTexture.resolution = this._res,
        this.context.font = this.style.font;
        var a = this.text;
        this.style.wordWrap && (a = this.runWordWrap(this.text));
        var b = a.split(/(?:\r\n|\r|\n)/)
          , c = this.style.tabs
          , d = []
          , e = 0
          , f = this.determineFontProperties(this.style.font)
          , g = b.length;
        this.style.maxLines > 0 && this.style.maxLines < b.length && (g = this.style.maxLines),
        this._charCount = 0;
        for (var h = 0; h < g; h++) {
            if (0 === c) {
                var i = this.style.strokeThickness + this.padding.x;
                this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? i += this.measureLine(b[h]) : i += this.context.measureText(b[h]).width,
                this.style.wordWrap && (i -= this.context.measureText(" ").width)
            } else {
                var j = b[h].split(/(?:\t)/)
                  , i = this.padding.x + this.style.strokeThickness;
                if (Array.isArray(c))
                    for (var k = 0, l = 0; l < j.length; l++) {
                        var m = 0;
                        m = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width),
                        l > 0 && (k += c[l - 1]),
                        i = k + m
                    }
                else
                    for (var l = 0; l < j.length; l++) {
                        this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? i += this.measureLine(j[l]) : i += Math.ceil(this.context.measureText(j[l]).width);
                        var n = this.game.math.snapToCeil(i, c) - i;
                        i += n
                    }
            }
            d[h] = Math.ceil(i),
            e = Math.max(e, d[h])
        }
        this.canvas.width = e * this._res;
        var o = f.fontSize + this.style.strokeThickness + this.padding.y
          , p = o * g
          , q = this._lineSpacing;
        q < 0 && Math.abs(q) > o && (q = -o),
        0 !== q && (p += q > 0 ? q * b.length : q * (b.length - 1)),
        this.canvas.height = p * this._res,
        this.context.scale(this._res, this._res),
        navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height),
        this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor,
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)),
        this.context.fillStyle = this.style.fill,
        this.context.font = this.style.font,
        this.context.strokeStyle = this.style.stroke,
        this.context.textBaseline = "alphabetic",
        this.context.lineWidth = this.style.strokeThickness,
        this.context.lineCap = "round",
        this.context.lineJoin = "round";
        var r, s;
        for (this._charCount = 0,
        h = 0; h < g; h++)
            r = this.style.strokeThickness / 2,
            s = this.style.strokeThickness / 2 + h * o + f.ascent,
            h > 0 && (s += q * h),
            "right" === this.style.align ? r += e - d[h] : "center" === this.style.align && (r += (e - d[h]) / 2),
            this.autoRound && (r = Math.round(r),
            s = Math.round(s)),
            this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(b[h], r, s) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke),
            0 === c ? this.context.strokeText(b[h], r, s) : this.renderTabLine(b[h], r, s, !1)),
            this.style.fill && (this.updateShadow(this.style.shadowFill),
            0 === c ? this.context.fillText(b[h], r, s) : this.renderTabLine(b[h], r, s, !0)));
        this.updateTexture(),
        this.dirty = !1
    }
    ,
    b.Text.prototype.renderTabLine = function(a, b, c, d) {
        var e = a.split(/(?:\t)/)
          , f = this.style.tabs
          , g = 0;
        if (Array.isArray(f))
            for (var h = 0, i = 0; i < e.length; i++)
                i > 0 && (h += f[i - 1]),
                g = b + h,
                d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c);
        else
            for (var i = 0; i < e.length; i++) {
                var j = Math.ceil(this.context.measureText(e[i]).width);
                g = this.game.math.snapToCeil(b, f),
                d ? this.context.fillText(e[i], g, c) : this.context.strokeText(e[i], g, c),
                b = g + j
            }
    }
    ,
    b.Text.prototype.updateShadow = function(a) {
        a ? (this.context.shadowOffsetX = this.style.shadowOffsetX,
        this.context.shadowOffsetY = this.style.shadowOffsetY,
        this.context.shadowColor = this.style.shadowColor,
        this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0,
        this.context.shadowOffsetY = 0,
        this.context.shadowColor = 0,
        this.context.shadowBlur = 0)
    }
    ,
    b.Text.prototype.measureLine = function(a) {
        for (var b = 0, c = 0; c < a.length; c++) {
            var d = a[c];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var e = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (e.fontStyle = this.fontStyles[this._charCount]),
                this.fontWeights[this._charCount] && (e.fontWeight = this.fontWeights[this._charCount]),
                this.context.font = this.componentsToFont(e)
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]),
            this.updateShadow(this.style.shadowStroke)),
            this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]),
            this.updateShadow(this.style.shadowFill)),
            b += this.context.measureText(d).width,
            this._charCount++
        }
        return Math.ceil(b)
    }
    ,
    b.Text.prototype.updateLine = function(a, b, c) {
        for (var d = 0; d < a.length; d++) {
            var e = a[d];
            if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                var f = this.fontToComponents(this.context.font);
                this.fontStyles[this._charCount] && (f.fontStyle = this.fontStyles[this._charCount]),
                this.fontWeights[this._charCount] && (f.fontWeight = this.fontWeights[this._charCount]),
                this.context.font = this.componentsToFont(f)
            }
            this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]),
            this.updateShadow(this.style.shadowStroke),
            this.context.strokeText(e, b, c)),
            this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]),
            this.updateShadow(this.style.shadowFill),
            this.context.fillText(e, b, c)),
            b += this.context.measureText(e).width,
            this._charCount++
        }
    }
    ,
    b.Text.prototype.clearColors = function() {
        return this.colors = [],
        this.strokeColors = [],
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.clearFontValues = function() {
        return this.fontStyles = [],
        this.fontWeights = [],
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.addColor = function(a, b) {
        return this.colors[b] = a,
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.addStrokeColor = function(a, b) {
        return this.strokeColors[b] = a,
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.addFontStyle = function(a, b) {
        return this.fontStyles[b] = a,
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.addFontWeight = function(a, b) {
        return this.fontWeights[b] = a,
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.precalculateWordWrap = function(a) {
        return this.texture.baseTexture.resolution = this._res,
        this.context.font = this.style.font,
        this.runWordWrap(a).split(/(?:\r\n|\r|\n)/)
    }
    ,
    b.Text.prototype.runWordWrap = function(a) {
        return this.useAdvancedWrap ? this.advancedWordWrap(a) : this.basicWordWrap(a)
    }
    ,
    b.Text.prototype.advancedWordWrap = function(a) {
        for (var b = this.context, c = this.style.wordWrapWidth, d = "", e = a.replace(/ +/gi, " ").split(/\r?\n/gi), f = e.length, g = 0; g < f; g++) {
            var h = e[g]
              , i = "";
            h = h.replace(/^ *|\s*$/gi, "");
            if (b.measureText(h).width < c)
                d += h + "\n";
            else {
                for (var k = c, l = h.split(" "), m = 0; m < l.length; m++) {
                    var n = l[m]
                      , o = n + " "
                      , p = b.measureText(o).width;
                    if (p > k) {
                        if (0 === m) {
                            for (var q = o; q.length && (q = q.slice(0, -1),
                            !((p = b.measureText(q).width) <= k)); )
                                ;
                            if (!q.length)
                                throw new Error("This text's wordWrapWidth setting is less than a single character!");
                            var r = n.substr(q.length);
                            l[m] = r,
                            i += q
                        }
                        var s = l[m].length ? m : m + 1
                          , t = l.slice(s).join(" ").replace(/[ \n]*$/gi, "");
                        e[g + 1] = t + " " + (e[g + 1] || ""),
                        f = e.length;
                        break
                    }
                    i += o,
                    k -= p
                }
                d += i.replace(/[ \n]*$/gi, "") + "\n"
            }
        }
        return d = d.replace(/[\s|\n]*$/gi, "")
    }
    ,
    b.Text.prototype.basicWordWrap = function(a) {
        for (var b = "", c = a.split("\n"), d = 0; d < c.length; d++) {
            for (var e = this.style.wordWrapWidth, f = c[d].split(" "), g = 0; g < f.length; g++) {
                var h = this.context.measureText(f[g]).width
                  , i = h + this.context.measureText(" ").width;
                i > e ? (g > 0 && (b += "\n"),
                b += f[g] + " ",
                e = this.style.wordWrapWidth - h) : (e -= i,
                b += f[g] + " ")
            }
            d < c.length - 1 && (b += "\n")
        }
        return b
    }
    ,
    b.Text.prototype.updateFont = function(a) {
        var b = this.componentsToFont(a);
        this.style.font !== b && (this.style.font = b,
        this.dirty = !0,
        this.parent && this.updateTransform())
    }
    ,
    b.Text.prototype.fontToComponents = function(a) {
        var b = a.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
        if (b) {
            var c = b[5].trim();
            return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(c) || /['",]/.exec(c) || (c = "'" + c + "'"),
            {
                font: a,
                fontStyle: b[1] || "normal",
                fontVariant: b[2] || "normal",
                fontWeight: b[3] || "normal",
                fontSize: b[4] || "medium",
                fontFamily: c
            }
        }
        return console.warn("Phaser.Text - unparsable CSS font: " + a),
        {
            font: a
        }
    }
    ,
    b.Text.prototype.componentsToFont = function(a) {
        var c, b = [];
        return c = a.fontStyle,
        c && "normal" !== c && b.push(c),
        c = a.fontVariant,
        c && "normal" !== c && b.push(c),
        c = a.fontWeight,
        c && "normal" !== c && b.push(c),
        c = a.fontSize,
        c && "medium" !== c && b.push(c),
        c = a.fontFamily,
        c && b.push(c),
        b.length || b.push(a.font),
        b.join(" ")
    }
    ,
    b.Text.prototype.setText = function(a, b) {
        return void 0 === b && (b = !1),
        this.text = a.toString() || "",
        b ? this.updateText() : this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.parseList = function(a) {
        if (!Array.isArray(a))
            return this;
        for (var b = "", c = 0; c < a.length; c++)
            Array.isArray(a[c]) ? (b += a[c].join("\t"),
            c < a.length - 1 && (b += "\n")) : (b += a[c],
            c < a.length - 1 && (b += "\t"));
        return this.text = b,
        this.dirty = !0,
        this
    }
    ,
    b.Text.prototype.setTextBounds = function(a, c, d, e) {
        return void 0 === a ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(a, c, d, e) : this.textBounds = new b.Rectangle(a,c,d,e),
        this.style.wordWrapWidth > d && (this.style.wordWrapWidth = d)),
        this.updateTexture(),
        this
    }
    ,
    b.Text.prototype.updateTexture = function() {
        var a = this.texture.baseTexture
          , b = this.texture.crop
          , c = this.texture.frame
          , d = this.canvas.width
          , e = this.canvas.height;
        if (a.width = d,
        a.height = e,
        b.width = d,
        b.height = e,
        c.width = d,
        c.height = e,
        this.texture.width = d,
        this.texture.height = e,
        this._width = d,
        this._height = e,
        this.textBounds) {
            var f = this.textBounds.x
              , g = this.textBounds.y;
            "right" === this.style.boundsAlignH ? f += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (f += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2),
            "bottom" === this.style.boundsAlignV ? g += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (g += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2),
            this.pivot.x = -f,
            this.pivot.y = -g
        }
        this.renderable = 0 !== d && 0 !== e,
        this.texture.requiresReTint = !0,
        this.texture.baseTexture.dirty()
    }
    ,
    b.Text.prototype._renderWebGL = function(a) {
        this.dirty && (this.updateText(),
        this.dirty = !1),
        PIXI.Sprite.prototype._renderWebGL.call(this, a)
    }
    ,
    b.Text.prototype._renderCanvas = function(a) {
        this.dirty && (this.updateText(),
        this.dirty = !1),
        PIXI.Sprite.prototype._renderCanvas.call(this, a)
    }
    ,
    b.Text.prototype.determineFontProperties = function(a) {
        var c = b.Text.fontPropertiesCache[a];
        if (!c) {
            c = {};
            var d = b.Text.fontPropertiesCanvas
              , e = b.Text.fontPropertiesContext;
            e.font = a;
            var f = Math.ceil(e.measureText("|MÉq").width)
              , g = Math.ceil(e.measureText("|MÉq").width)
              , h = 2 * g;
            if (g = 1.4 * g | 0,
            d.width = f,
            d.height = h,
            e.fillStyle = "#f00",
            e.fillRect(0, 0, f, h),
            e.font = a,
            e.textBaseline = "alphabetic",
            e.fillStyle = "#000",
            e.fillText("|MÉq", 0, g),
            !e.getImageData(0, 0, f, h))
                return c.ascent = g,
                c.descent = g + 6,
                c.fontSize = c.ascent + c.descent,
                b.Text.fontPropertiesCache[a] = c,
                c;
            var l, m, i = e.getImageData(0, 0, f, h).data, j = i.length, k = 4 * f, n = 0, o = !1;
            for (l = 0; l < g; l++) {
                for (m = 0; m < k; m += 4)
                    if (255 !== i[n + m]) {
                        o = !0;
                        break
                    }
                if (o)
                    break;
                n += k
            }
            for (c.ascent = g - l,
            n = j - k,
            o = !1,
            l = h; l > g; l--) {
                for (m = 0; m < k; m += 4)
                    if (255 !== i[n + m]) {
                        o = !0;
                        break
                    }
                if (o)
                    break;
                n -= k
            }
            c.descent = l - g,
            c.descent += 6,
            c.fontSize = c.ascent + c.descent,
            b.Text.fontPropertiesCache[a] = c
        }
        return c
    }
    ,
    b.Text.prototype.getBounds = function(a) {
        return this.dirty && (this.updateText(),
        this.dirty = !1),
        PIXI.Sprite.prototype.getBounds.call(this, a)
    }
    ,
    Object.defineProperty(b.Text.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || "",
            this.dirty = !0,
            this.parent && this.updateTransform())
        }
    }),
    Object.defineProperty(b.Text.prototype, "cssFont", {
        get: function() {
            return this.componentsToFont(this._fontComponents)
        },
        set: function(a) {
            a = a || "bold 20pt Arial",
            this._fontComponents = this.fontToComponents(a),
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(b.Text.prototype, "font", {
        get: function() {
            return this._fontComponents.fontFamily
        },
        set: function(a) {
            a = a || "Arial",
            a = a.trim(),
            /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a) || (a = "'" + a + "'"),
            this._fontComponents.fontFamily = a,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(b.Text.prototype, "fontSize", {
        get: function() {
            var a = this._fontComponents.fontSize;
            return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a
        },
        set: function(a) {
            a = a || "0",
            "number" == typeof a && (a += "px"),
            this._fontComponents.fontSize = a,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(b.Text.prototype, "fontWeight", {
        get: function() {
            return this._fontComponents.fontWeight || "normal"
        },
        set: function(a) {
            a = a || "normal",
            this._fontComponents.fontWeight = a,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(b.Text.prototype, "fontStyle", {
        get: function() {
            return this._fontComponents.fontStyle || "normal"
        },
        set: function(a) {
            a = a || "normal",
            this._fontComponents.fontStyle = a,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(b.Text.prototype, "fontVariant", {
        get: function() {
            return this._fontComponents.fontVariant || "normal"
        },
        set: function(a) {
            a = a || "normal",
            this._fontComponents.fontVariant = a,
            this.updateFont(this._fontComponents)
        }
    }),
    Object.defineProperty(b.Text.prototype, "fill", {
        get: function() {
            return this.style.fill
        },
        set: function(a) {
            a !== this.style.fill && (this.style.fill = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "align", {
        get: function() {
            return this.style.align
        },
        set: function(a) {
            a !== this.style.align && (this.style.align = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "resolution", {
        get: function() {
            return this._res
        },
        set: function(a) {
            a !== this._res && (this._res = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "tabs", {
        get: function() {
            return this.style.tabs
        },
        set: function(a) {
            a !== this.style.tabs && (this.style.tabs = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "boundsAlignH", {
        get: function() {
            return this.style.boundsAlignH
        },
        set: function(a) {
            a !== this.style.boundsAlignH && (this.style.boundsAlignH = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "boundsAlignV", {
        get: function() {
            return this.style.boundsAlignV
        },
        set: function(a) {
            a !== this.style.boundsAlignV && (this.style.boundsAlignV = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "stroke", {
        get: function() {
            return this.style.stroke
        },
        set: function(a) {
            a !== this.style.stroke && (this.style.stroke = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "strokeThickness", {
        get: function() {
            return this.style.strokeThickness
        },
        set: function(a) {
            a !== this.style.strokeThickness && (this.style.strokeThickness = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "wordWrap", {
        get: function() {
            return this.style.wordWrap
        },
        set: function(a) {
            a !== this.style.wordWrap && (this.style.wordWrap = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "wordWrapWidth", {
        get: function() {
            return this.style.wordWrapWidth
        },
        set: function(a) {
            a !== this.style.wordWrapWidth && (this.style.wordWrapWidth = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "lineSpacing", {
        get: function() {
            return this._lineSpacing
        },
        set: function(a) {
            a !== this._lineSpacing && (this._lineSpacing = parseFloat(a),
            this.dirty = !0,
            this.parent && this.updateTransform())
        }
    }),
    Object.defineProperty(b.Text.prototype, "shadowOffsetX", {
        get: function() {
            return this.style.shadowOffsetX
        },
        set: function(a) {
            a !== this.style.shadowOffsetX && (this.style.shadowOffsetX = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "shadowOffsetY", {
        get: function() {
            return this.style.shadowOffsetY
        },
        set: function(a) {
            a !== this.style.shadowOffsetY && (this.style.shadowOffsetY = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "shadowColor", {
        get: function() {
            return this.style.shadowColor
        },
        set: function(a) {
            a !== this.style.shadowColor && (this.style.shadowColor = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "shadowBlur", {
        get: function() {
            return this.style.shadowBlur
        },
        set: function(a) {
            a !== this.style.shadowBlur && (this.style.shadowBlur = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "shadowStroke", {
        get: function() {
            return this.style.shadowStroke
        },
        set: function(a) {
            a !== this.style.shadowStroke && (this.style.shadowStroke = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "shadowFill", {
        get: function() {
            return this.style.shadowFill
        },
        set: function(a) {
            a !== this.style.shadowFill && (this.style.shadowFill = a,
            this.dirty = !0)
        }
    }),
    Object.defineProperty(b.Text.prototype, "width", {
        get: function() {
            return this.dirty && (this.updateText(),
            this.dirty = !1),
            this.scale.x * this.texture.frame.width
        },
        set: function(a) {
            this.scale.x = a / this.texture.frame.width,
            this._width = a
        }
    }),
    Object.defineProperty(b.Text.prototype, "height", {
        get: function() {
            return this.dirty && (this.updateText(),
            this.dirty = !1),
            this.scale.y * this.texture.frame.height
        },
        set: function(a) {
            this.scale.y = a / this.texture.frame.height,
            this._height = a
        }
    }),
    b.Text.fontPropertiesCache = {},
    b.Text.fontPropertiesCanvas = document.createElement("canvas"),
    b.Text.fontPropertiesContext = b.Text.fontPropertiesCanvas.getContext("2d"),
    b.BitmapText = function(a, c, d, e, f, g, h) {
        c = c || 0,
        d = d || 0,
        e = e || "",
        f = f || "",
        g = g || 32,
        h = h || "left",
        PIXI.DisplayObjectContainer.call(this),
        this.type = b.BITMAPTEXT,
        this.physicsType = b.SPRITE,
        this.textWidth = 0,
        this.textHeight = 0,
        this.anchor = new b.Point,
        this._prevAnchor = new b.Point,
        this._glyphs = [],
        this._maxWidth = 0,
        this._text = f.toString() || "",
        this._data = a.cache.getBitmapFont(e),
        this._font = e,
        this._fontSize = g,
        this._align = h,
        this._tint = 16777215,
        this.updateText(),
        this.dirty = !1,
        b.Component.Core.init.call(this, a, c, d, "", null)
    }
    ,
    b.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),
    b.BitmapText.prototype.constructor = b.BitmapText,
    b.Component.Core.install.call(b.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]),
    b.BitmapText.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate,
    b.BitmapText.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate,
    b.BitmapText.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate,
    b.BitmapText.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.BitmapText.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }
    ,
    b.BitmapText.prototype.postUpdate = function() {
        b.Component.PhysicsBody.postUpdate.call(this),
        b.Component.FixedToCamera.postUpdate.call(this),
        this.body && this.body.type === b.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
    }
    ,
    b.BitmapText.prototype.setText = function(a) {
        this.text = a
    }
    ;
    b.BitmapText.prototype.scanLine = function(a, b, c) {
        for (var d = 0, e = 0, f = -1, g = 0, h = null, i = this._maxWidth > 0 ? this._maxWidth : null, j = [], k = 0; k < c.length; k++) {
            var l = k === c.length - 1;
            if (/(?:\r\n|\r|\n)/.test(c.charAt(k)))
                return {
                    width: e,
                    text: c.substr(0, k),
                    end: l,
                    chars: j
                };
            var m = c.charCodeAt(k)
              , n = a.chars[m]
              , o = 0;
            void 0 === n && (m = 32,
            n = a.chars[m]);
            var p = h && n.kerning[h] ? n.kerning[h] : 0;
            if (/(\s)/.test(c.charAt(k)) && (f = k,
            g = e),
            o = (p + n.texture.width + n.xOffset) * b,
            i && e + o >= i && f > -1)
                return {
                    width: g || e,
                    text: c.substr(0, k - (k - f)),
                    end: l,
                    chars: j
                };
            e += (n.xAdvance + p) * b,
            j.push(d + (n.xOffset + p) * b),
            d += (n.xAdvance + p) * b,
            h = m
        }
        return {
            width: e,
            text: c,
            end: l,
            chars: j
        }
    }
    ,
    b.BitmapText.prototype.cleanText = function(a, b) {
        void 0 === b && (b = "");
        var c = this._data.font;
        if (!c)
            return "";
        for (var d = /\r\n|\n\r|\n|\r/g, e = a.replace(d, "\n").split("\n"), f = 0; f < e.length; f++) {
            for (var g = "", h = e[f], i = 0; i < h.length; i++)
                g = c.chars[h.charCodeAt(i)] ? g.concat(h[i]) : g.concat(b);
            e[f] = g
        }
        return e.join("\n")
    }
    ,
    b.BitmapText.prototype.updateText = function() {
        var a = this._data.font;
        if (a) {
            var b = this.text
              , c = this._fontSize / a.size
              , d = []
              , e = 0;
            this.textWidth = 0;
            do {
                var f = this.scanLine(a, c, b);
                f.y = e,
                d.push(f),
                f.width > this.textWidth && (this.textWidth = f.width),
                e += a.lineHeight * c,
                b = b.substr(f.text.length + 1)
            } while (!1 === f.end);
            this.textHeight = e;
            for (var g = 0, h = 0, i = this.textWidth * this.anchor.x, j = this.textHeight * this.anchor.y, k = 0; k < d.length; k++) {
                var f = d[k];
                "right" === this._align ? h = this.textWidth - f.width : "center" === this._align && (h = (this.textWidth - f.width) / 2);
                for (var l = 0; l < f.text.length; l++) {
                    var m = f.text.charCodeAt(l)
                      , n = a.chars[m];
                    void 0 === n && (m = 32,
                    n = a.chars[m]);
                    var o = this._glyphs[g];
                    o ? o.texture = n.texture : (o = new PIXI.Sprite(n.texture),
                    o.name = f.text[l],
                    this._glyphs.push(o)),
                    o.position.x = f.chars[l] + h - i,
                    o.position.y = f.y + n.yOffset * c - j,
                    o.scale.set(c),
                    o.tint = this.tint,
                    o.texture.requiresReTint = !0,
                    o.parent || this.addChild(o),
                    g++
                }
            }
            for (k = g; k < this._glyphs.length; k++)
                this.removeChild(this._glyphs[k])
        }
    }
    ,
    b.BitmapText.prototype.purgeGlyphs = function() {
        for (var a = this._glyphs.length, b = [], c = 0; c < this._glyphs.length; c++)
            this._glyphs[c].parent !== this ? this._glyphs[c].destroy() : b.push(this._glyphs[c]);
        return this._glyphs = [],
        this._glyphs = b,
        this.updateText(),
        a - b.length
    }
    ,
    b.BitmapText.prototype.updateTransform = function() {
        !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(),
        this.dirty = !1,
        this._prevAnchor.copyFrom(this.anchor)),
        PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
    }
    ,
    Object.defineProperty(b.BitmapText.prototype, "align", {
        get: function() {
            return this._align
        },
        set: function(a) {
            a === this._align || "left" !== a && "center" !== a && "right" !== a || (this._align = a,
            this.updateText())
        }
    }),
    Object.defineProperty(b.BitmapText.prototype, "tint", {
        get: function() {
            return this._tint
        },
        set: function(a) {
            a !== this._tint && (this._tint = a,
            this.updateText())
        }
    }),
    Object.defineProperty(b.BitmapText.prototype, "font", {
        get: function() {
            return this._font
        },
        set: function(a) {
            a !== this._font && (this._font = a.trim(),
            this._data = this.game.cache.getBitmapFont(this._font),
            this.updateText())
        }
    }),
    Object.defineProperty(b.BitmapText.prototype, "fontSize", {
        get: function() {
            return this._fontSize
        },
        set: function(a) {
            (a = parseInt(a, 10)) !== this._fontSize && a > 0 && (this._fontSize = a,
            this.updateText())
        }
    }),
    Object.defineProperty(b.BitmapText.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            a !== this._text && (this._text = a.toString() || "",
            this.updateText())
        }
    }),
    Object.defineProperty(b.BitmapText.prototype, "maxWidth", {
        get: function() {
            return this._maxWidth
        },
        set: function(a) {
            a !== this._maxWidth && (this._maxWidth = a,
            this.updateText())
        }
    }),
    Object.defineProperty(b.BitmapText.prototype, "smoothed", {
        get: function() {
            return !this._data.base.scaleMode
        },
        set: function(a) {
            this._data.base.scaleMode = a ? 0 : 1
        }
    }),
    b.RetroFont = function(a, c, d, e, f, g, h, i, j, k) {
        if (!a.cache.checkImageKey(c))
            return !1;
        void 0 !== g && null !== g || (g = a.cache.getImage(c).width / d),
        this.characterWidth = d,
        this.characterHeight = e,
        this.characterSpacingX = h || 0,
        this.characterSpacingY = i || 0,
        this.characterPerRow = g,
        this.offsetX = j || 0,
        this.offsetY = k || 0,
        this.align = "left",
        this.multiLine = !1,
        this.autoUpperCase = !0,
        this.customSpacingX = 0,
        this.customSpacingY = 0,
        this.fixedWidth = 0,
        this.fontSet = a.cache.getImage(c),
        this._text = "",
        this.grabData = [],
        this.frameData = new b.FrameData;
        for (var l = this.offsetX, m = this.offsetY, n = 0, o = 0; o < f.length; o++) {
            var p = this.frameData.addFrame(new b.Frame(o,l,m,this.characterWidth,this.characterHeight));
            this.grabData[f.charCodeAt(o)] = p.index,
            n++,
            n === this.characterPerRow ? (n = 0,
            l = this.offsetX,
            m += this.characterHeight + this.characterSpacingY) : l += this.characterWidth + this.characterSpacingX
        }
        a.cache.updateFrameData(c, this.frameData),
        this.stamp = new b.Image(a,0,0,c,0),
        b.RenderTexture.call(this, a, 100, 100, "", b.scaleModes.NEAREST),
        this.type = b.RETROFONT
    }
    ,
    b.RetroFont.prototype = Object.create(b.RenderTexture.prototype),
    b.RetroFont.prototype.constructor = b.RetroFont,
    b.RetroFont.ALIGN_LEFT = "left",
    b.RetroFont.ALIGN_RIGHT = "right",
    b.RetroFont.ALIGN_CENTER = "center",
    b.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
    b.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    b.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ",
    b.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789",
    b.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789",
    b.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ",
    b.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39",
    b.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    b.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!",
    b.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    b.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
    b.RetroFont.prototype.setFixedWidth = function(a, b) {
        void 0 === b && (b = "left"),
        this.fixedWidth = a,
        this.align = b
    }
    ,
    b.RetroFont.prototype.setText = function(a, b, c, d, e, f) {
        this.multiLine = b || !1,
        this.customSpacingX = c || 0,
        this.customSpacingY = d || 0,
        this.align = e || "left",
        this.autoUpperCase = !f,
        a.length > 0 && (this.text = a)
    }
    ,
    b.RetroFont.prototype.buildRetroFontText = function() {
        var a = 0
          , c = 0;
        if (this.clear(),
        this.multiLine) {
            var d = this._text.split("\n");
            this.fixedWidth > 0 ? this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
            for (var e = 0; e < d.length; e++)
                a = 0,
                this.align === b.RetroFont.ALIGN_RIGHT ? a = this.width - d[e].length * (this.characterWidth + this.customSpacingX) : this.align === b.RetroFont.ALIGN_CENTER && (a = this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2,
                a += this.customSpacingX / 2),
                a < 0 && (a = 0),
                this.pasteLine(d[e], a, c, this.customSpacingX),
                c += this.characterHeight + this.customSpacingY
        } else
            this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0),
            a = 0,
            this.align === b.RetroFont.ALIGN_RIGHT ? a = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === b.RetroFont.ALIGN_CENTER && (a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2,
            a += this.customSpacingX / 2),
            a < 0 && (a = 0),
            this.pasteLine(this._text, a, 0, this.customSpacingX);
        this.requiresReTint = !0
    }
    ,
    b.RetroFont.prototype.pasteLine = function(a, b, c, d) {
        for (var e = 0; e < a.length; e++)
            if (" " === a.charAt(e))
                b += this.characterWidth + d;
            else if (this.grabData[a.charCodeAt(e)] >= 0 && (this.stamp.frame = this.grabData[a.charCodeAt(e)],
            this.renderXY(this.stamp, b, c, !1),
            (b += this.characterWidth + d) > this.width))
                break
    }
    ,
    b.RetroFont.prototype.getLongestLine = function() {
        var a = 0;
        if (this._text.length > 0)
            for (var b = this._text.split("\n"), c = 0; c < b.length; c++)
                b[c].length > a && (a = b[c].length);
        return a
    }
    ,
    b.RetroFont.prototype.removeUnsupportedCharacters = function(a) {
        for (var b = "", c = 0; c < this._text.length; c++) {
            var d = this._text[c]
              , e = d.charCodeAt(0);
            (this.grabData[e] >= 0 || !a && "\n" === d) && (b = b.concat(d))
        }
        return b
    }
    ,
    b.RetroFont.prototype.updateOffset = function(a, b) {
        if (this.offsetX !== a || this.offsetY !== b) {
            for (var c = a - this.offsetX, d = b - this.offsetY, e = this.game.cache.getFrameData(this.stamp.key).getFrames(), f = e.length; f--; )
                e[f].x += c,
                e[f].y += d;
            this.buildRetroFontText()
        }
    }
    ,
    Object.defineProperty(b.RetroFont.prototype, "text", {
        get: function() {
            return this._text
        },
        set: function(a) {
            var b;
            (b = this.autoUpperCase ? a.toUpperCase() : a) !== this._text && (this._text = b,
            this.removeUnsupportedCharacters(this.multiLine),
            this.buildRetroFontText())
        }
    }),
    Object.defineProperty(b.RetroFont.prototype, "smoothed", {
        get: function() {
            return this.stamp.smoothed
        },
        set: function(a) {
            this.stamp.smoothed = a,
            this.buildRetroFontText()
        }
    }),
    b.Rope = function(a, c, d, e, f, g) {
        this.points = [],
        this.points = g,
        this._hasUpdateAnimation = !1,
        this._updateAnimationCallback = null,
        c = c || 0,
        d = d || 0,
        e = e || null,
        f = f || null,
        this.type = b.ROPE,
        PIXI.Rope.call(this, b.Cache.DEFAULT, this.points),
        b.Component.Core.init.call(this, a, c, d, e, f)
    }
    ,
    b.Rope.prototype = Object.create(PIXI.Rope.prototype),
    b.Rope.prototype.constructor = b.Rope,
    b.Component.Core.install.call(b.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]),
    b.Rope.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate,
    b.Rope.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate,
    b.Rope.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate,
    b.Rope.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.Rope.prototype.preUpdate = function() {
        return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }
    ,
    b.Rope.prototype.update = function() {
        this._hasUpdateAnimation && this.updateAnimation.call(this)
    }
    ,
    b.Rope.prototype.reset = function(a, c) {
        return b.Component.Reset.prototype.reset.call(this, a, c),
        this
    }
    ,
    Object.defineProperty(b.Rope.prototype, "updateAnimation", {
        get: function() {
            return this._updateAnimation
        },
        set: function(a) {
            a && "function" == typeof a ? (this._hasUpdateAnimation = !0,
            this._updateAnimation = a) : (this._hasUpdateAnimation = !1,
            this._updateAnimation = null)
        }
    }),
    Object.defineProperty(b.Rope.prototype, "segments", {
        get: function() {
            for (var c, d, e, f, g, h, i, j, a = [], k = 0; k < this.points.length; k++)
                c = 4 * k,
                d = this.vertices[c] * this.scale.x,
                e = this.vertices[c + 1] * this.scale.y,
                f = this.vertices[c + 4] * this.scale.x,
                g = this.vertices[c + 3] * this.scale.y,
                h = b.Math.difference(d, f),
                i = b.Math.difference(e, g),
                d += this.world.x,
                e += this.world.y,
                j = new b.Rectangle(d,e,h,i),
                a.push(j);
            return a
        }
    }),
    b.TileSprite = function(a, c, d, e, f, g, h) {
        c = c || 0,
        d = d || 0,
        e = e || 256,
        f = f || 256,
        g = g || null,
        h = h || null,
        this.type = b.TILESPRITE,
        this.physicsType = b.SPRITE,
        this._scroll = new b.Point;
        var i = a.cache.getImage("__default", !0);
        PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f),
        b.Component.Core.init.call(this, a, c, d, g, h)
    }
    ,
    b.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype),
    b.TileSprite.prototype.constructor = b.TileSprite,
    b.Component.Core.install.call(b.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]),
    b.TileSprite.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate,
    b.TileSprite.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate,
    b.TileSprite.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate,
    b.TileSprite.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.TileSprite.prototype.preUpdate = function() {
        return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed),
        0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed),
        !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
    }
    ,
    b.TileSprite.prototype.autoScroll = function(a, b) {
        this._scroll.set(a, b)
    }
    ,
    b.TileSprite.prototype.stopScroll = function() {
        this._scroll.set(0, 0)
    }
    ,
    b.TileSprite.prototype.destroy = function(a) {
        b.Component.Destroy.prototype.destroy.call(this, a),
        PIXI.TilingSprite.prototype.destroy.call(this)
    }
    ,
    b.TileSprite.prototype.reset = function(a, c) {
        return b.Component.Reset.prototype.reset.call(this, a, c),
        this.tilePosition.x = 0,
        this.tilePosition.y = 0,
        this
    }
    ,
    b.Device = function() {
        this.deviceReadyAt = 0,
        this.initialized = !1,
        this.desktop = !1,
        this.iOS = !1,
        this.iOSVersion = 0,
        this.cocoonJS = !1,
        this.cocoonJSApp = !1,
        this.cordova = !1,
        this.node = !1,
        this.nodeWebkit = !1,
        this.electron = !1,
        this.ejecta = !1,
        this.crosswalk = !1,
        this.android = !1,
        this.chromeOS = !1,
        this.linux = !1,
        this.macOS = !1,
        this.windows = !1,
        this.windowsPhone = !1,
        this.canvas = !1,
        this.canvasBitBltShift = null,
        this.webGL = !1,
        this.file = !1,
        this.fileSystem = !1,
        this.localStorage = !1,
        this.worker = !1,
        this.css3D = !1,
        this.pointerLock = !1,
        this.typedArray = !1,
        this.vibration = !1,
        this.getUserMedia = !0,
        this.quirksMode = !1,
        this.touch = !1,
        this.mspointer = !1,
        this.wheelEvent = null,
        this.arora = !1,
        this.chrome = !1,
        this.chromeVersion = 0,
        this.epiphany = !1,
        this.firefox = !1,
        this.firefoxVersion = 0,
        this.ie = !1,
        this.ieVersion = 0,
        this.trident = !1,
        this.tridentVersion = 0,
        this.edge = !1,
        this.mobileSafari = !1,
        this.midori = !1,
        this.opera = !1,
        this.safari = !1,
        this.safariVersion = 0,
        this.webApp = !1,
        this.silk = !1,
        this.audioData = !1,
        this.webAudio = !1,
        this.ogg = !1,
        this.opus = !1,
        this.mp3 = !1,
        this.wav = !1,
        this.m4a = !1,
        this.webm = !1,
        this.dolby = !1,
        this.oggVideo = !1,
        this.h264Video = !1,
        this.mp4Video = !1,
        this.webmVideo = !1,
        this.vp9Video = !1,
        this.hlsVideo = !1,
        this.iPhone = !1,
        this.iPhone4 = !1,
        this.iPad = !1,
        this.pixelRatio = 0,
        this.littleEndian = !1,
        this.LITTLE_ENDIAN = !1,
        this.support32bit = !1,
        this.fullscreen = !1,
        this.requestFullscreen = "",
        this.cancelFullscreen = "",
        this.fullscreenKeyboard = !1
    }
    ,
    b.Device = new b.Device,
    b.Device.onInitialized = new b.Signal,
    b.Device.whenReady = function(a, b, c) {
        var d = this._readyCheck;
        if (this.deviceReadyAt || !d)
            a.call(b, this);
        else if (d._monitor || c)
            d._queue = d._queue || [],
            d._queue.push([a, b]);
        else {
            d._monitor = d.bind(this),
            d._queue = d._queue || [],
            d._queue.push([a, b]);
            var e = void 0 !== window.cordova
              , f = navigator.isCocoonJS;
            "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(d._monitor, 0) : e && !f ? document.addEventListener("deviceready", d._monitor, !1) : (document.addEventListener("DOMContentLoaded", d._monitor, !1),
            window.addEventListener("load", d._monitor, !1))
        }
    }
    ,
    b.Device._readyCheck = function() {
        var a = this._readyCheck;
        if (document.body) {
            if (!this.deviceReadyAt) {
                this.deviceReadyAt = Date.now(),
                document.removeEventListener("deviceready", a._monitor),
                document.removeEventListener("DOMContentLoaded", a._monitor),
                window.removeEventListener("load", a._monitor),
                this._initialize(),
                this.initialized = !0,
                this.onInitialized.dispatch(this);
                for (var b; b = a._queue.shift(); ) {
                    var c = b[0]
                      , d = b[1];
                    c.call(d, this)
                }
                this._readyCheck = null,
                this._initialize = null,
                this.onInitialized = null
            }
        } else
            window.setTimeout(a._monitor, 20)
    }
    ,
    b.Device._initialize = function() {
        function b() {
            var b = navigator.userAgent;
            /Playstation Vita/.test(b) ? a.vita = !0 : /Kindle/.test(b) || /\bKF[A-Z][A-Z]+/.test(b) || /Silk.*Mobile Safari/.test(b) ? a.kindle = !0 : /Android/.test(b) ? a.android = !0 : /CrOS/.test(b) ? a.chromeOS = !0 : /iP[ao]d|iPhone/i.test(b) ? (a.iOS = !0,
            navigator.appVersion.match(/OS (\d+)/),
            a.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(b) ? a.linux = !0 : /Mac OS/.test(b) ? a.macOS = !0 : /Windows/.test(b) && (a.windows = !0),
            (/Windows Phone/i.test(b) || /IEMobile/i.test(b)) && (a.android = !1,
            a.iOS = !1,
            a.macOS = !1,
            a.windows = !0,
            a.windowsPhone = !0);
            var c = /Silk/.test(b);
            (a.windows || a.macOS || a.linux && !c || a.chromeOS) && (a.desktop = !0),
            (a.windowsPhone || /Windows NT/i.test(b) && /Touch/i.test(b)) && (a.desktop = !1)
        }
        function c() {
            a.canvas = !!window.CanvasRenderingContext2D || a.cocoonJS;
            try {
                a.localStorage = !!localStorage.getItem
            } catch (b) {
                a.localStorage = !1
            }
            a.file = !!(window.File && window.FileReader && window.FileList && window.Blob),
            a.fileSystem = !!window.requestFileSystem,
            a.webGL = function() {
                try {
                    var a = document.createElement("canvas");
                    return a.screencanvas = !1,
                    !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"))
                } catch (a) {
                    return !1
                }
            }(),
            a.webGL = !!a.webGL,
            a.worker = !!window.Worker,
            a.pointerLock = "pointerLockElement"in document || "mozPointerLockElement"in document || "webkitPointerLockElement"in document,
            a.quirksMode = "CSS1Compat" !== document.compatMode,
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia,
            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL,
            a.getUserMedia = a.getUserMedia && !!navigator.getUserMedia && !!window.URL,
            a.firefox && a.firefoxVersion < 21 && (a.getUserMedia = !1),
            !a.iOS && (a.ie || a.firefox || a.chrome) && (a.canvasBitBltShift = !0),
            (a.safari || a.mobileSafari) && (a.canvasBitBltShift = !1)
        }
        function d() {
            ("ontouchstart"in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (a.touch = !0),
            (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (a.mspointer = !0),
            a.cocoonJS || ("onwheel"in window || a.ie && "WheelEvent"in window ? a.wheelEvent = "wheel" : "onmousewheel"in window ? a.wheelEvent = "mousewheel" : a.firefox && "MouseScrollEvent"in window && (a.wheelEvent = "DOMMouseScroll"))
        }
        function e() {
            for (var b = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], c = document.createElement("div"), d = 0; d < b.length; d++)
                if (c[b[d]]) {
                    a.fullscreen = !0,
                    a.requestFullscreen = b[d];
                    break
                }
            var e = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
            if (a.fullscreen)
                for (var d = 0; d < e.length; d++)
                    if (document[e[d]]) {
                        a.cancelFullscreen = e[d];
                        break
                    }
            window.Element && Element.ALLOW_KEYBOARD_INPUT && (a.fullscreenKeyboard = !0)
        }
        function f() {
            var b = navigator.userAgent;
            if (/Arora/.test(b) ? a.arora = !0 : /Edge\/\d+/.test(b) ? a.edge = !0 : /Chrome\/(\d+)/.test(b) && !a.windowsPhone ? (a.chrome = !0,
            a.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(b) ? a.epiphany = !0 : /Firefox\D+(\d+)/.test(b) ? (a.firefox = !0,
            a.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(b) && a.iOS ? a.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(b) ? (a.ie = !0,
            a.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(b) ? a.midori = !0 : /Opera/.test(b) ? a.opera = !0 : /Safari\/(\d+)/.test(b) && !a.windowsPhone ? (a.safari = !0,
            /Version\/(\d+)\./.test(b) && (a.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(b) && (a.ie = !0,
            a.trident = !0,
            a.tridentVersion = parseInt(RegExp.$1, 10),
            a.ieVersion = parseInt(RegExp.$3, 10)),
            /Silk/.test(b) && (a.silk = !0),
            navigator.standalone && (a.webApp = !0),
            void 0 !== window.cordova && (a.cordova = !0),
            "undefined" != typeof process && "undefined" != typeof require && (a.node = !0),
            a.node && "object" == typeof process.versions && (a.nodeWebkit = !!process.versions["node-webkit"],
            a.electron = !!process.versions.electron),
            navigator.isCocoonJS && (a.cocoonJS = !0),
            a.cocoonJS)
                try {
                    a.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (b) {
                    a.cocoonJSApp = !1
                }
            void 0 !== window.ejecta && (a.ejecta = !0),
            /Crosswalk/.test(b) && (a.crosswalk = !0)
        }
        function g() {
            var b = document.createElement("video");
            try {
                !!b.canPlayType && (b.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (a.oggVideo = !0),
                b.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (a.h264Video = !0,
                a.mp4Video = !0),
                b.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (a.webmVideo = !0),
                b.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (a.vp9Video = !0),
                b.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (a.hlsVideo = !0))
            } catch (a) {}
        }
        function h() {
            a.audioData = !!window.Audio,
            a.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
            var b = document.createElement("audio");
            try {
                if (!!b.canPlayType && (b.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (a.ogg = !0),
                (b.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || b.canPlayType("audio/opus;").replace(/^no$/, "")) && (a.opus = !0),
                b.canPlayType("audio/mpeg;").replace(/^no$/, "") && (a.mp3 = !0),
                b.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (a.wav = !0),
                (b.canPlayType("audio/x-m4a;") || b.canPlayType("audio/aac;").replace(/^no$/, "")) && (a.m4a = !0),
                b.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (a.webm = !0),
                "" !== b.canPlayType('audio/mp4;codecs="ec-3"')))
                    if (a.edge)
                        a.dolby = !0;
                    else if (a.safari && a.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var d = parseInt(RegExp.$1, 10)
                          , e = parseInt(RegExp.$2, 10);
                        (10 === d && e >= 11 || d > 10) && (a.dolby = !0)
                    }
            } catch (a) {}
        }
        function i() {
            var a = new ArrayBuffer(4)
              , b = new Uint8Array(a)
              , c = new Uint32Array(a);
            return b[0] = 161,
            b[1] = 178,
            b[2] = 195,
            b[3] = 212,
            3569595041 === c[0] || 2712847316 !== c[0] && null
        }
        function j() {
            if (void 0 === Uint8ClampedArray)
                return !1;
            var a = PIXI.CanvasPool.create(this, 1, 1)
              , b = a.getContext("2d");
            if (!b)
                return !1;
            var c = b.createImageData(1, 1);
            return PIXI.CanvasPool.remove(this),
            c.data instanceof Uint8ClampedArray
        }
        function k() {
            a.pixelRatio = window.devicePixelRatio || 1,
            a.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"),
            a.iPhone4 = 2 === a.pixelRatio && a.iPhone,
            a.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"),
            "undefined" != typeof Int8Array ? a.typedArray = !0 : a.typedArray = !1,
            "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (a.littleEndian = i(),
            a.LITTLE_ENDIAN = a.littleEndian),
            a.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== a.littleEndian && j(),
            navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate,
            navigator.vibrate && (a.vibration = !0)
        }
        function l() {
            var c, b = document.createElement("p"), d = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(b, null);
            for (var e in d)
                void 0 !== b.style[e] && (b.style[e] = "translate3d(1px,1px,1px)",
                c = window.getComputedStyle(b).getPropertyValue(d[e]));
            document.body.removeChild(b),
            a.css3D = void 0 !== c && c.length > 0 && "none" !== c
        }
        var a = this;
        b(),
        f(),
        h(),
        g(),
        l(),
        k(),
        c(),
        e(),
        d()
    }
    ,
    b.Device.canPlayAudio = function(a) {
        return !("mp3" !== a || !this.mp3) || (!("ogg" !== a || !this.ogg && !this.opus) || (!("m4a" !== a || !this.m4a) || (!("opus" !== a || !this.opus) || (!("wav" !== a || !this.wav) || (!("webm" !== a || !this.webm) || !("mp4" !== a || !this.dolby))))))
    }
    ,
    b.Device.canPlayVideo = function(a) {
        return !("webm" !== a || !this.webmVideo && !this.vp9Video) || (!("mp4" !== a || !this.mp4Video && !this.h264Video) || (!("ogg" !== a && "ogv" !== a || !this.oggVideo) || !("mpeg" !== a || !this.hlsVideo)))
    }
    ,
    b.Device.isConsoleOpen = function() {
        return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(),
        console.profileEnd(),
        console.clear && console.clear(),
        !console.profiles)) && console.profiles.length > 0
    }
    ,
    b.Device.isAndroidStockBrowser = function() {
        var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
        return a && a[1] < 537
    }
    ,
    b.Canvas = {
        create: function(a, b, c, d, e) {
            b = b || 256,
            c = c || 256;
            var f = e ? document.createElement("canvas") : PIXI.CanvasPool.create(a, b, c);
            return "string" == typeof d && "" !== d && (f.id = d),
            f.width = b,
            f.height = c,
            f.style.display = "block",
            f
        },
        setBackgroundColor: function(a, b) {
            return b = b || "rgb(0,0,0)",
            a.style.backgroundColor = b,
            a
        },
        setTouchAction: function(a, b) {
            return b = b || "none",
            a.style.msTouchAction = b,
            a.style["ms-touch-action"] = b,
            a.style["touch-action"] = b,
            a
        },
        setUserSelect: function(a, b) {
            return b = b || "none",
            a.style["-webkit-touch-callout"] = b,
            a.style["-webkit-user-select"] = b,
            a.style["-khtml-user-select"] = b,
            a.style["-moz-user-select"] = b,
            a.style["-ms-user-select"] = b,
            a.style["user-select"] = b,
            a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)",
            a
        },
        addToDOM: function(a, b, c) {
            var d;
            return void 0 === c && (c = !0),
            b && ("string" == typeof b ? d = document.getElementById(b) : "object" == typeof b && 1 === b.nodeType && (d = b)),
            d || (d = document.body),
            c && d.style && (d.style.overflow = "hidden"),
            d.appendChild(a),
            a
        },
        removeFromDOM: function(a) {
            a.parentNode && a.parentNode.removeChild(a)
        },
        setTransform: function(a, b, c, d, e, f, g) {
            return a.setTransform(d, f, g, e, b, c),
            a
        },
        setSmoothingEnabled: function(a, c) {
            var d = b.Canvas.getSmoothingPrefix(a);
            return d && (a[d] = c),
            a
        },
        getSmoothingPrefix: function(a) {
            var b = ["i", "webkitI", "msI", "mozI", "oI"];
            for (var c in b) {
                var d = b[c] + "mageSmoothingEnabled";
                if (d in a)
                    return d
            }
            return null
        },
        getSmoothingEnabled: function(a) {
            var c = b.Canvas.getSmoothingPrefix(a);
            if (c)
                return a[c]
        },
        setImageRenderingCrisp: function(a) {
            for (var b = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], c = 0; c < b.length; c++)
                a.style["image-rendering"] = b[c];
            return a.style.msInterpolationMode = "nearest-neighbor",
            a
        },
        setImageRenderingBicubic: function(a) {
            return a.style["image-rendering"] = "auto",
            a.style.msInterpolationMode = "bicubic",
            a
        }
    },
    b.RequestAnimationFrame = function(a, b) {
        void 0 === b && (b = !1),
        this.game = a,
        this.isRunning = !1,
        this.forceSetTimeOut = b;
        for (var c = ["ms", "moz", "webkit", "o"], d = 0; d < c.length && !window.requestAnimationFrame; d++)
            window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"],
            window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"];
        this._isSetTimeOut = !1,
        this._onLoop = null,
        this._timeOutID = null
    }
    ,
    b.RequestAnimationFrame.prototype = {
        start: function() {
            this.isRunning = !0;
            var a = this;
            !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0,
            this._onLoop = function() {
                return a.updateSetTimeout()
            }
            ,
            this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1,
            this._onLoop = function(b) {
                return a.updateRAF(b)
            }
            ,
            this._timeOutID = window.requestAnimationFrame(this._onLoop))
        },
        updateRAF: function(a) {
            this.isRunning && (this.game.update(Math.floor(a)),
            this._timeOutID = window.requestAnimationFrame(this._onLoop))
        },
        updateSetTimeout: function() {
            this.isRunning && (this.game.update(Date.now()),
            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
        },
        stop: function() {
            this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID),
            this.isRunning = !1
        },
        isSetTimeOut: function() {
            return this._isSetTimeOut
        },
        isRAF: function() {
            return !1 === this._isSetTimeOut
        }
    },
    b.RequestAnimationFrame.prototype.constructor = b.RequestAnimationFrame,
    b.Math = {
        PI2: 2 * Math.PI,
        between: function(a, b) {
            return Math.floor(Math.random() * (b - a + 1) + a)
        },
        fuzzyEqual: function(a, b, c) {
            return void 0 === c && (c = 1e-4),
            Math.abs(a - b) < c
        },
        fuzzyLessThan: function(a, b, c) {
            return void 0 === c && (c = 1e-4),
            a < b + c
        },
        fuzzyGreaterThan: function(a, b, c) {
            return void 0 === c && (c = 1e-4),
            a > b - c
        },
        fuzzyCeil: function(a, b) {
            return void 0 === b && (b = 1e-4),
            Math.ceil(a - b)
        },
        fuzzyFloor: function(a, b) {
            return void 0 === b && (b = 1e-4),
            Math.floor(a + b)
        },
        average: function() {
            for (var a = 0, b = arguments.length, c = 0; c < b; c++)
                a += +arguments[c];
            return a / b
        },
        shear: function(a) {
            return a % 1
        },
        snapTo: function(a, b, c) {
            return void 0 === c && (c = 0),
            0 === b ? a : (a -= c,
            a = b * Math.round(a / b),
            c + a)
        },
        snapToFloor: function(a, b, c) {
            return void 0 === c && (c = 0),
            0 === b ? a : (a -= c,
            a = b * Math.floor(a / b),
            c + a)
        },
        snapToCeil: function(a, b, c) {
            return void 0 === c && (c = 0),
            0 === b ? a : (a -= c,
            a = b * Math.ceil(a / b),
            c + a)
        },
        roundTo: function(a, b, c) {
            void 0 === b && (b = 0),
            void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.round(a * d) / d
        },
        floorTo: function(a, b, c) {
            void 0 === b && (b = 0),
            void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.floor(a * d) / d
        },
        ceilTo: function(a, b, c) {
            void 0 === b && (b = 0),
            void 0 === c && (c = 10);
            var d = Math.pow(c, -b);
            return Math.ceil(a * d) / d
        },
        rotateToAngle: function(a, c, d) {
            return void 0 === d && (d = .05),
            a === c ? a : (Math.abs(c - a) <= d || Math.abs(c - a) >= b.Math.PI2 - d ? a = c : (Math.abs(c - a) > Math.PI && (c < a ? c += b.Math.PI2 : c -= b.Math.PI2),
            c > a ? a += d : c < a && (a -= d)),
            a)
        },
        getShortestAngle: function(a, b) {
            var c = b - a;
            return 0 === c ? 0 : c - 360 * Math.floor((c - -180) / 360)
        },
        angleBetween: function(a, b, c, d) {
            return Math.atan2(d - b, c - a)
        },
        angleBetweenY: function(a, b, c, d) {
            return Math.atan2(c - a, d - b)
        },
        angleBetweenPoints: function(a, b) {
            return Math.atan2(b.y - a.y, b.x - a.x)
        },
        angleBetweenPointsY: function(a, b) {
            return Math.atan2(b.x - a.x, b.y - a.y)
        },
        reverseAngle: function(a) {
            return this.normalizeAngle(a + Math.PI, !0)
        },
        normalizeAngle: function(a) {
            return a %= 2 * Math.PI,
            a >= 0 ? a : a + 2 * Math.PI
        },
        maxAdd: function(a, b, c) {
            return Math.min(a + b, c)
        },
        minSub: function(a, b, c) {
            return Math.max(a - b, c)
        },
        wrap: function(a, b, c) {
            var d = c - b;
            if (d <= 0)
                return 0;
            var e = (a - b) % d;
            return e < 0 && (e += d),
            e + b
        },
        wrapValue: function(a, b, c) {
            return a = Math.abs(a),
            b = Math.abs(b),
            c = Math.abs(c),
            (a + b) % c
        },
        isOdd: function(a) {
            return !!(1 & a)
        },
        isEven: function(a) {
            return !(1 & a)
        },
        min: function() {
            if (1 === arguments.length && "object" == typeof arguments[0])
                var a = arguments[0];
            else
                var a = arguments;
            for (var b = 1, c = 0, d = a.length; b < d; b++)
                a[b] < a[c] && (c = b);
            return a[c]
        },
        max: function() {
            if (1 === arguments.length && "object" == typeof arguments[0])
                var a = arguments[0];
            else
                var a = arguments;
            for (var b = 1, c = 0, d = a.length; b < d; b++)
                a[b] > a[c] && (c = b);
            return a[c]
        },
        minProperty: function(a) {
            if (2 === arguments.length && "object" == typeof arguments[1])
                var b = arguments[1];
            else
                var b = arguments.slice(1);
            for (var c = 1, d = 0, e = b.length; c < e; c++)
                b[c][a] < b[d][a] && (d = c);
            return b[d][a]
        },
        maxProperty: function(a) {
            if (2 === arguments.length && "object" == typeof arguments[1])
                var b = arguments[1];
            else
                var b = arguments.slice(1);
            for (var c = 1, d = 0, e = b.length; c < e; c++)
                b[c][a] > b[d][a] && (d = c);
            return b[d][a]
        },
        wrapAngle: function(a, b) {
            return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180)
        },
        linearInterpolation: function(a, b) {
            var c = a.length - 1
              , d = c * b
              , e = Math.floor(d);
            return b < 0 ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e)
        },
        bezierInterpolation: function(a, b) {
            for (var c = 0, d = a.length - 1, e = 0; e <= d; e++)
                c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e);
            return c
        },
        catmullRomInterpolation: function(a, b) {
            var c = a.length - 1
              , d = c * b
              , e = Math.floor(d);
            return a[0] === a[c] ? (b < 0 && (e = Math.floor(d = c * (1 + b))),
            this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : b < 0 ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e)
        },
        linear: function(a, b, c) {
            return (b - a) * c + a
        },
        bernstein: function(a, b) {
            return this.factorial(a) / this.factorial(b) / this.factorial(a - b)
        },
        factorial: function(a) {
            if (0 === a)
                return 1;
            for (var b = a; --a; )
                b *= a;
            return b
        },
        catmullRom: function(a, b, c, d, e) {
            var f = .5 * (c - a)
              , g = .5 * (d - b)
              , h = e * e;
            return (2 * b - 2 * c + f + g) * (e * h) + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b
        },
        difference: function(a, b) {
            return Math.abs(a - b)
        },
        roundAwayFromZero: function(a) {
            return a > 0 ? Math.ceil(a) : Math.floor(a)
        },
        sinCosGenerator: function(a, b, c, d) {
            void 0 === b && (b = 1),
            void 0 === c && (c = 1),
            void 0 === d && (d = 1);
            for (var e = b, f = c, g = d * Math.PI / a, h = [], i = [], j = 0; j < a; j++)
                f -= e * g,
                e += f * g,
                h[j] = f,
                i[j] = e;
            return {
                sin: i,
                cos: h,
                length: a
            }
        },
        distance: function(a, b, c, d) {
            var e = a - c
              , f = b - d;
            return Math.sqrt(e * e + f * f)
        },
        distanceSq: function(a, b, c, d) {
            var e = a - c
              , f = b - d;
            return e * e + f * f
        },
        distancePow: function(a, b, c, d, e) {
            return void 0 === e && (e = 2),
            Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e))
        },
        clamp: function(a, b, c) {
            return a < b ? b : c < a ? c : a
        },
        clampBottom: function(a, b) {
            return a < b ? b : a
        },
        within: function(a, b, c) {
            return Math.abs(a - b) <= c
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b)
        },
        smoothstep: function(a, b, c) {
            return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))) * a * (3 - 2 * a)
        },
        smootherstep: function(a, b, c) {
            return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))) * a * a * (a * (6 * a - 15) + 10)
        },
        sign: function(a) {
            return a < 0 ? -1 : a > 0 ? 1 : 0
        },
        percent: function(a, b, c) {
            return void 0 === c && (c = 0),
            a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b
        }
    };
    var k = Math.PI / 180
      , l = 180 / Math.PI;
    return b.Math.degToRad = function(b) {
        return b * k
    }
    ,
    b.Math.radToDeg = function(b) {
        return b * l
    }
    ,
    b.RandomDataGenerator = function(a) {
        void 0 === a && (a = []),
        this.c = 1,
        this.s0 = 0,
        this.s1 = 0,
        this.s2 = 0,
        "string" == typeof a ? this.state(a) : this.sow(a)
    }
    ,
    b.RandomDataGenerator.prototype = {
        rnd: function() {
            var a = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
            return this.c = 0 | a,
            this.s0 = this.s1,
            this.s1 = this.s2,
            this.s2 = a - this.c,
            this.s2
        },
        sow: function(a) {
            if (this.s0 = this.hash(" "),
            this.s1 = this.hash(this.s0),
            this.s2 = this.hash(this.s1),
            this.c = 1,
            a)
                for (var b = 0; b < a.length && null != a[b]; b++) {
                    var c = a[b];
                    this.s0 -= this.hash(c),
                    this.s0 += ~~(this.s0 < 0),
                    this.s1 -= this.hash(c),
                    this.s1 += ~~(this.s1 < 0),
                    this.s2 -= this.hash(c),
                    this.s2 += ~~(this.s2 < 0)
                }
        },
        hash: function(a) {
            var b, c, d;
            for (d = 4022871197,
            a = a.toString(),
            c = 0; c < a.length; c++)
                d += a.charCodeAt(c),
                b = .02519603282416938 * d,
                d = b >>> 0,
                b -= d,
                b *= d,
                d = b >>> 0,
                b -= d,
                d += 4294967296 * b;
            return 2.3283064365386963e-10 * (d >>> 0)
        },
        integer: function() {
            return 4294967296 * this.rnd.apply(this)
        },
        frac: function() {
            return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
        },
        real: function() {
            return this.integer() + this.frac()
        },
        integerInRange: function(a, b) {
            return Math.floor(this.realInRange(0, b - a + 1) + a)
        },
        between: function(a, b) {
            return this.integerInRange(a, b)
        },
        realInRange: function(a, b) {
            return this.frac() * (b - a) + a
        },
        normal: function() {
            return 1 - 2 * this.frac()
        },
        uuid: function() {
            var a = ""
              , b = "";
            for (b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-")
                ;
            return b
        },
        pick: function(a) {
            return a[this.integerInRange(0, a.length - 1)]
        },
        sign: function() {
            return this.pick([-1, 1])
        },
        weightedPick: function(a) {
            return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + .5)]
        },
        timestamp: function(a, b) {
            return this.realInRange(a || 9466848e5, b || 1577862e6)
        },
        angle: function() {
            return this.integerInRange(-180, 180)
        },
        state: function(a) {
            return "string" == typeof a && a.match(/^!rnd/) && (a = a.split(","),
            this.c = parseFloat(a[1]),
            this.s0 = parseFloat(a[2]),
            this.s1 = parseFloat(a[3]),
            this.s2 = parseFloat(a[4])),
            ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
        }
    },
    b.RandomDataGenerator.prototype.constructor = b.RandomDataGenerator,
    b.QuadTree = function(a, b, c, d, e, f, g) {
        this.maxObjects = 10,
        this.maxLevels = 4,
        this.level = 0,
        this.bounds = {},
        this.objects = [],
        this.nodes = [],
        this._empty = [],
        this.reset(a, b, c, d, e, f, g)
    }
    ,
    b.QuadTree.prototype = {
        reset: function(a, b, c, d, e, f, g) {
            this.maxObjects = e || 10,
            this.maxLevels = f || 4,
            this.level = g || 0,
            this.bounds = {
                x: Math.round(a),
                y: Math.round(b),
                width: c,
                height: d,
                subWidth: Math.floor(c / 2),
                subHeight: Math.floor(d / 2),
                right: Math.round(a) + Math.floor(c / 2),
                bottom: Math.round(b) + Math.floor(d / 2)
            },
            this.objects.length = 0,
            this.nodes.length = 0
        },
        populate: function(a) {
            a.forEach(this.populateHandler, this, !0)
        },
        populateHandler: function(a) {
            a.body && a.exists && this.insert(a.body)
        },
        split: function() {
            this.nodes[0] = new b.QuadTree(this.bounds.right,this.bounds.y,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1),
            this.nodes[1] = new b.QuadTree(this.bounds.x,this.bounds.y,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1),
            this.nodes[2] = new b.QuadTree(this.bounds.x,this.bounds.bottom,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1),
            this.nodes[3] = new b.QuadTree(this.bounds.right,this.bounds.bottom,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level + 1)
        },
        insert: function(a) {
            var c, b = 0;
            if (null != this.nodes[0] && -1 !== (c = this.getIndex(a)))
                return void this.nodes[c].insert(a);
            if (this.objects.push(a),
            this.objects.length > this.maxObjects && this.level < this.maxLevels)
                for (null == this.nodes[0] && this.split(); b < this.objects.length; )
                    c = this.getIndex(this.objects[b]),
                    -1 !== c ? this.nodes[c].insert(this.objects.splice(b, 1)[0]) : b++
        },
        getIndex: function(a) {
            var b = -1;
            return a.x < this.bounds.right && a.right < this.bounds.right ? a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 1 : a.y > this.bounds.bottom && (b = 2) : a.x > this.bounds.right && (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom ? b = 0 : a.y > this.bounds.bottom && (b = 3)),
            b
        },
        retrieve: function(a) {
            if (a instanceof b.Rectangle)
                var c = this.objects
                  , d = this.getIndex(a);
            else {
                if (!a.body)
                    return this._empty;
                var c = this.objects
                  , d = this.getIndex(a.body)
            }
            return this.nodes[0] && (-1 !== d ? c = c.concat(this.nodes[d].retrieve(a)) : (c = c.concat(this.nodes[0].retrieve(a)),
            c = c.concat(this.nodes[1].retrieve(a)),
            c = c.concat(this.nodes[2].retrieve(a)),
            c = c.concat(this.nodes[3].retrieve(a)))),
            c
        },
        clear: function() {
            this.objects.length = 0;
            for (var a = this.nodes.length; a--; )
                this.nodes[a].clear(),
                this.nodes.splice(a, 1);
            this.nodes.length = 0
        }
    },
    b.QuadTree.prototype.constructor = b.QuadTree,
    b.Net = function(a) {
        this.game = a
    }
    ,
    b.Net.prototype = {
        getHostName: function() {
            return window.location && window.location.hostname ? window.location.hostname : null
        },
        checkDomainName: function(a) {
            return -1 !== window.location.hostname.indexOf(a)
        },
        updateQueryString: function(a, b, c, d) {
            void 0 === c && (c = !1),
            void 0 !== d && "" !== d || (d = window.location.href);
            var e = ""
              , f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)","gi");
            if (f.test(d))
                e = void 0 !== b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, "");
            else if (void 0 !== b && null !== b) {
                var g = -1 !== d.indexOf("?") ? "&" : "?"
                  , h = d.split("#");
                d = h[0] + g + a + "=" + b,
                h[1] && (d += "#" + h[1]),
                e = d
            } else
                e = d;
            if (!c)
                return e;
            window.location.href = e
        },
        getQueryString: function(a) {
            void 0 === a && (a = "");
            var b = {}
              , c = location.search.substring(1).split("&");
            for (var d in c) {
                var e = c[d].split("=");
                if (e.length > 1) {
                    if (a && a === this.decodeURI(e[0]))
                        return this.decodeURI(e[1]);
                    b[this.decodeURI(e[0])] = this.decodeURI(e[1])
                }
            }
            return b
        },
        decodeURI: function(a) {
            return decodeURIComponent(a.replace(/\+/g, " "))
        }
    },
    b.Net.prototype.constructor = b.Net,
    b.TweenManager = function(a) {
        this.game = a,
        this.frameBased = !1,
        this._tweens = [],
        this._add = [],
        this.easeMap = {
            Power0: b.Easing.Power0,
            Power1: b.Easing.Power1,
            Power2: b.Easing.Power2,
            Power3: b.Easing.Power3,
            Power4: b.Easing.Power4,
            Linear: b.Easing.Linear.None,
            Quad: b.Easing.Quadratic.Out,
            Cubic: b.Easing.Cubic.Out,
            Quart: b.Easing.Quartic.Out,
            Quint: b.Easing.Quintic.Out,
            Sine: b.Easing.Sinusoidal.Out,
            Expo: b.Easing.Exponential.Out,
            Circ: b.Easing.Circular.Out,
            Elastic: b.Easing.Elastic.Out,
            Back: b.Easing.Back.Out,
            Bounce: b.Easing.Bounce.Out,
            "Quad.easeIn": b.Easing.Quadratic.In,
            "Cubic.easeIn": b.Easing.Cubic.In,
            "Quart.easeIn": b.Easing.Quartic.In,
            "Quint.easeIn": b.Easing.Quintic.In,
            "Sine.easeIn": b.Easing.Sinusoidal.In,
            "Expo.easeIn": b.Easing.Exponential.In,
            "Circ.easeIn": b.Easing.Circular.In,
            "Elastic.easeIn": b.Easing.Elastic.In,
            "Back.easeIn": b.Easing.Back.In,
            "Bounce.easeIn": b.Easing.Bounce.In,
            "Quad.easeOut": b.Easing.Quadratic.Out,
            "Cubic.easeOut": b.Easing.Cubic.Out,
            "Quart.easeOut": b.Easing.Quartic.Out,
            "Quint.easeOut": b.Easing.Quintic.Out,
            "Sine.easeOut": b.Easing.Sinusoidal.Out,
            "Expo.easeOut": b.Easing.Exponential.Out,
            "Circ.easeOut": b.Easing.Circular.Out,
            "Elastic.easeOut": b.Easing.Elastic.Out,
            "Back.easeOut": b.Easing.Back.Out,
            "Bounce.easeOut": b.Easing.Bounce.Out,
            "Quad.easeInOut": b.Easing.Quadratic.InOut,
            "Cubic.easeInOut": b.Easing.Cubic.InOut,
            "Quart.easeInOut": b.Easing.Quartic.InOut,
            "Quint.easeInOut": b.Easing.Quintic.InOut,
            "Sine.easeInOut": b.Easing.Sinusoidal.InOut,
            "Expo.easeInOut": b.Easing.Exponential.InOut,
            "Circ.easeInOut": b.Easing.Circular.InOut,
            "Elastic.easeInOut": b.Easing.Elastic.InOut,
            "Back.easeInOut": b.Easing.Back.InOut,
            "Bounce.easeInOut": b.Easing.Bounce.InOut
        },
        this.game.onPause.add(this._pauseAll, this),
        this.game.onResume.add(this._resumeAll, this)
    }
    ,
    b.TweenManager.prototype = {
        getAll: function() {
            return this._tweens
        },
        removeAll: function() {
            for (var a = 0; a < this._tweens.length; a++)
                this._tweens[a].pendingDelete = !0;
            this._add = []
        },
        removeFrom: function(a, c) {
            void 0 === c && (c = !0);
            var d, e;
            if (Array.isArray(a))
                for (d = 0,
                e = a.length; d < e; d++)
                    this.removeFrom(a[d]);
            else if (a.type === b.GROUP && c)
                for (var d = 0, e = a.children.length; d < e; d++)
                    this.removeFrom(a.children[d]);
            else {
                for (d = 0,
                e = this._tweens.length; d < e; d++)
                    a === this._tweens[d].target && this.remove(this._tweens[d]);
                for (d = 0,
                e = this._add.length; d < e; d++)
                    a === this._add[d].target && this.remove(this._add[d])
            }
        },
        add: function(a) {
            a._manager = this,
            this._add.push(a)
        },
        create: function(a) {
            return new b.Tween(a,this.game,this)
        },
        remove: function(a) {
            var b = this._tweens.indexOf(a);
            -1 !== b ? this._tweens[b].pendingDelete = !0 : -1 !== (b = this._add.indexOf(a)) && (this._add[b].pendingDelete = !0)
        },
        update: function() {
            var a = this._add.length
              , b = this._tweens.length;
            if (0 === b && 0 === a)
                return !1;
            for (var c = 0; c < b; )
                this._tweens[c].update(this.game.time.time) ? c++ : (this._tweens.splice(c, 1),
                b--);
            return a > 0 && (this._tweens = this._tweens.concat(this._add),
            this._add.length = 0),
            !0
        },
        isTweening: function(a) {
            return this._tweens.some(function(b) {
                return b.target === a
            })
        },
        _pauseAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--)
                this._tweens[a]._pause()
        },
        _resumeAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--)
                this._tweens[a]._resume()
        },
        pauseAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--)
                this._tweens[a].pause()
        },
        resumeAll: function() {
            for (var a = this._tweens.length - 1; a >= 0; a--)
                this._tweens[a].resume(!0)
        }
    },
    b.TweenManager.prototype.constructor = b.TweenManager,
    b.Tween = function(a, c, d) {
        this.game = c,
        this.target = a,
        this.manager = d,
        this.timeline = [],
        this.reverse = !1,
        this.timeScale = 1,
        this.repeatCounter = 0,
        this.pendingDelete = !1,
        this.onStart = new b.Signal,
        this.onLoop = new b.Signal,
        this.onRepeat = new b.Signal,
        this.onChildComplete = new b.Signal,
        this.onComplete = new b.Signal,
        this.isRunning = !1,
        this.current = 0,
        this.properties = {},
        this.chainedTween = null,
        this.isPaused = !1,
        this.frameBased = d.frameBased,
        this._onUpdateCallback = null,
        this._onUpdateCallbackContext = null,
        this._pausedTime = 0,
        this._codePaused = !1,
        this._hasStarted = !1
    }
    ,
    b.Tween.prototype = {
        to: function(a, c, d, e, f, g, h) {
            return (void 0 === c || c <= 0) && (c = 1e3),
            void 0 !== d && null !== d || (d = b.Easing.Default),
            void 0 === e && (e = !1),
            void 0 === f && (f = 0),
            void 0 === g && (g = 0),
            void 0 === h && (h = !1),
            "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]),
            this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"),
            this) : (this.timeline.push(new b.TweenData(this).to(a, c, d, f, g, h)),
            e && this.start(),
            this)
        },
        from: function(a, c, d, e, f, g, h) {
            return void 0 === c && (c = 1e3),
            void 0 !== d && null !== d || (d = b.Easing.Default),
            void 0 === e && (e = !1),
            void 0 === f && (f = 0),
            void 0 === g && (g = 0),
            void 0 === h && (h = !1),
            "string" == typeof d && this.manager.easeMap[d] && (d = this.manager.easeMap[d]),
            this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"),
            this) : (this.timeline.push(new b.TweenData(this).from(a, c, d, f, g, h)),
            e && this.start(),
            this)
        },
        start: function(a) {
            if (void 0 === a && (a = 0),
            null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning)
                return this;
            for (var b = 0; b < this.timeline.length; b++)
                for (var c in this.timeline[b].vEnd)
                    this.properties[c] = this.target[c] || 0,
                    Array.isArray(this.properties[c]) || (this.properties[c] *= 1);
            for (var b = 0; b < this.timeline.length; b++)
                this.timeline[b].loadValues();
            return this.manager.add(this),
            this.isRunning = !0,
            (a < 0 || a > this.timeline.length - 1) && (a = 0),
            this.current = a,
            this.timeline[this.current].start(),
            this
        },
        stop: function(a) {
            return void 0 === a && (a = !1),
            this.isRunning = !1,
            this._onUpdateCallback = null,
            this._onUpdateCallbackContext = null,
            a && (this.onComplete.dispatch(this.target, this),
            this._hasStarted = !1,
            this.chainedTween && this.chainedTween.start()),
            this.manager.remove(this),
            this
        },
        updateTweenData: function(a, b, c) {
            if (0 === this.timeline.length)
                return this;
            if (void 0 === c && (c = 0),
            -1 === c)
                for (var d = 0; d < this.timeline.length; d++)
                    this.timeline[d][a] = b;
            else
                this.timeline[c][a] = b;
            return this
        },
        delay: function(a, b) {
            return this.updateTweenData("delay", a, b)
        },
        repeat: function(a, b, c) {
            return void 0 === b && (b = 0),
            this.updateTweenData("repeatCounter", a, c),
            this.updateTweenData("repeatDelay", b, c)
        },
        repeatDelay: function(a, b) {
            return this.updateTweenData("repeatDelay", a, b)
        },
        yoyo: function(a, b, c) {
            return void 0 === b && (b = 0),
            this.updateTweenData("yoyo", a, c),
            this.updateTweenData("yoyoDelay", b, c)
        },
        yoyoDelay: function(a, b) {
            return this.updateTweenData("yoyoDelay", a, b)
        },
        easing: function(a, b) {
            return "string" == typeof a && this.manager.easeMap[a] && (a = this.manager.easeMap[a]),
            this.updateTweenData("easingFunction", a, b)
        },
        interpolation: function(a, c, d) {
            return void 0 === c && (c = b.Math),
            this.updateTweenData("interpolationFunction", a, d),
            this.updateTweenData("interpolationContext", c, d)
        },
        repeatAll: function(a) {
            return void 0 === a && (a = 0),
            this.repeatCounter = a,
            this
        },
        chain: function() {
            for (var a = arguments.length; a--; )
                a > 0 ? arguments[a - 1].chainedTween = arguments[a] : this.chainedTween = arguments[a];
            return this
        },
        loop: function(a) {
            return void 0 === a && (a = !0),
            this.repeatCounter = a ? -1 : 0,
            this
        },
        onUpdateCallback: function(a, b) {
            return this._onUpdateCallback = a,
            this._onUpdateCallbackContext = b,
            this
        },
        pause: function() {
            this.isPaused = !0,
            this._codePaused = !0,
            this._pausedTime = this.game.time.time
        },
        _pause: function() {
            this._codePaused || (this.isPaused = !0,
            this._pausedTime = this.game.time.time)
        },
        resume: function() {
            if (this.isPaused) {
                this.isPaused = !1,
                this._codePaused = !1;
                for (var a = 0; a < this.timeline.length; a++)
                    this.timeline[a].isRunning || (this.timeline[a].startTime += this.game.time.time - this._pausedTime)
            }
        },
        _resume: function() {
            this._codePaused || this.resume()
        },
        update: function(a) {
            if (this.pendingDelete || !this.target)
                return !1;
            if (this.isPaused)
                return !0;
            var c = this.timeline[this.current].update(a);
            if (c === b.TweenData.PENDING)
                return !0;
            if (c === b.TweenData.RUNNING)
                return this._hasStarted || (this.onStart.dispatch(this.target, this),
                this._hasStarted = !0),
                null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]),
                this.isRunning;
            if (c === b.TweenData.LOOPED)
                return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this),
                !0;
            if (c === b.TweenData.COMPLETE) {
                var d = !1;
                return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1,
                d = !0) : ++this.current === this.timeline.length && (this.current = 0,
                d = !0),
                d ? -1 === this.repeatCounter ? (this.timeline[this.current].start(),
                this.onLoop.dispatch(this.target, this),
                !0) : this.repeatCounter > 0 ? (this.repeatCounter--,
                this.timeline[this.current].start(),
                this.onRepeat.dispatch(this.target, this),
                !0) : (this.isRunning = !1,
                this.onComplete.dispatch(this.target, this),
                this._hasStarted = !1,
                this.chainedTween && this.chainedTween.start(),
                !1) : (this.onChildComplete.dispatch(this.target, this),
                this.timeline[this.current].start(),
                !0)
            }
        },
        generateData: function(a, b) {
            if (null === this.game || null === this.target)
                return null;
            void 0 === a && (a = 60),
            void 0 === b && (b = []);
            for (var c = 0; c < this.timeline.length; c++)
                for (var d in this.timeline[c].vEnd)
                    this.properties[d] = this.target[d] || 0,
                    Array.isArray(this.properties[d]) || (this.properties[d] *= 1);
            for (var c = 0; c < this.timeline.length; c++)
                this.timeline[c].loadValues();
            for (var c = 0; c < this.timeline.length; c++)
                b = b.concat(this.timeline[c].generateData(a));
            return b
        }
    },
    Object.defineProperty(b.Tween.prototype, "totalDuration", {
        get: function() {
            for (var a = 0, b = 0; b < this.timeline.length; b++)
                a += this.timeline[b].duration;
            return a
        }
    }),
    b.Tween.prototype.constructor = b.Tween,
    b.TweenData = function(a) {
        this.parent = a,
        this.game = a.game,
        this.vStart = {},
        this.vStartCache = {},
        this.vEnd = {},
        this.vEndCache = {},
        this.duration = 1e3,
        this.percent = 0,
        this.value = 0,
        this.repeatCounter = 0,
        this.repeatDelay = 0,
        this.repeatTotal = 0,
        this.interpolate = !1,
        this.yoyo = !1,
        this.yoyoDelay = 0,
        this.inReverse = !1,
        this.delay = 0,
        this.dt = 0,
        this.startTime = null,
        this.easingFunction = b.Easing.Default,
        this.interpolationFunction = b.Math.linearInterpolation,
        this.interpolationContext = b.Math,
        this.isRunning = !1,
        this.isFrom = !1
    }
    ,
    b.TweenData.PENDING = 0,
    b.TweenData.RUNNING = 1,
    b.TweenData.LOOPED = 2,
    b.TweenData.COMPLETE = 3,
    b.TweenData.prototype = {
        to: function(a, b, c, d, e, f) {
            return this.vEnd = a,
            this.duration = b,
            this.easingFunction = c,
            this.delay = d,
            this.repeatTotal = e,
            this.yoyo = f,
            this.isFrom = !1,
            this
        },
        from: function(a, b, c, d, e, f) {
            return this.vEnd = a,
            this.duration = b,
            this.easingFunction = c,
            this.delay = d,
            this.repeatTotal = e,
            this.yoyo = f,
            this.isFrom = !0,
            this
        },
        start: function() {
            if (this.startTime = this.game.time.time + this.delay,
            this.parent.reverse ? this.dt = this.duration : this.dt = 0,
            this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0,
            this.isFrom)
                for (var a in this.vStartCache)
                    this.vStart[a] = this.vEndCache[a],
                    this.vEnd[a] = this.vStartCache[a],
                    this.parent.target[a] = this.vStart[a];
            return this.value = 0,
            this.yoyoCounter = 0,
            this.repeatCounter = this.repeatTotal,
            this
        },
        loadValues: function() {
            for (var a in this.parent.properties) {
                if (this.vStart[a] = this.parent.properties[a],
                Array.isArray(this.vEnd[a])) {
                    if (0 === this.vEnd[a].length)
                        continue;
                    0 === this.percent && (this.vEnd[a] = [this.vStart[a]].concat(this.vEnd[a]))
                }
                void 0 !== this.vEnd[a] ? ("string" == typeof this.vEnd[a] && (this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10)),
                this.parent.properties[a] = this.vEnd[a]) : this.vEnd[a] = this.vStart[a],
                this.vStartCache[a] = this.vStart[a],
                this.vEndCache[a] = this.vEnd[a]
            }
            return this
        },
        update: function(a) {
            if (this.isRunning) {
                if (a < this.startTime)
                    return b.TweenData.RUNNING
            } else {
                if (!(a >= this.startTime))
                    return b.TweenData.PENDING;
                this.isRunning = !0
            }
            var c = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
            this.parent.reverse ? (this.dt -= c * this.parent.timeScale,
            this.dt = Math.max(this.dt, 0)) : (this.dt += c * this.parent.timeScale,
            this.dt = Math.min(this.dt, this.duration)),
            this.percent = this.dt / this.duration,
            this.value = this.easingFunction(this.percent);
            for (var d in this.vEnd) {
                var e = this.vStart[d]
                  , f = this.vEnd[d];
                Array.isArray(f) ? this.parent.target[d] = this.interpolationFunction.call(this.interpolationContext, f, this.value) : this.parent.target[d] = e + (f - e) * this.value
            }
            return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : b.TweenData.RUNNING
        },
        generateData: function(a) {
            this.parent.reverse ? this.dt = this.duration : this.dt = 0;
            var b = []
              , c = !1
              , d = 1 / a * 1e3;
            do {
                this.parent.reverse ? (this.dt -= d,
                this.dt = Math.max(this.dt, 0)) : (this.dt += d,
                this.dt = Math.min(this.dt, this.duration)),
                this.percent = this.dt / this.duration,
                this.value = this.easingFunction(this.percent);
                var e = {};
                for (var f in this.vEnd) {
                    var g = this.vStart[f]
                      , h = this.vEnd[f];
                    Array.isArray(h) ? e[f] = this.interpolationFunction(h, this.value) : e[f] = g + (h - g) * this.value
                }
                b.push(e),
                (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (c = !0)
            } while (!c);
            if (this.yoyo) {
                var i = b.slice();
                i.reverse(),
                b = b.concat(i)
            }
            return b
        },
        repeat: function() {
            if (this.yoyo) {
                if (this.inReverse && 0 === this.repeatCounter) {
                    for (var a in this.vStartCache)
                        this.vStart[a] = this.vStartCache[a],
                        this.vEnd[a] = this.vEndCache[a];
                    return this.inReverse = !1,
                    b.TweenData.COMPLETE
                }
                this.inReverse = !this.inReverse
            } else if (0 === this.repeatCounter)
                return b.TweenData.COMPLETE;
            if (this.inReverse)
                for (var a in this.vStartCache)
                    this.vStart[a] = this.vEndCache[a],
                    this.vEnd[a] = this.vStartCache[a];
            else {
                for (var a in this.vStartCache)
                    this.vStart[a] = this.vStartCache[a],
                    this.vEnd[a] = this.vEndCache[a];
                this.repeatCounter > 0 && this.repeatCounter--
            }
            return this.startTime = this.game.time.time,
            this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay),
            this.parent.reverse ? this.dt = this.duration : this.dt = 0,
            b.TweenData.LOOPED
        }
    },
    b.TweenData.prototype.constructor = b.TweenData,
    b.Easing = {
        Linear: {
            None: function(a) {
                return a
            }
        },
        Quadratic: {
            In: function(a) {
                return a * a
            },
            Out: function(a) {
                return a * (2 - a)
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
            }
        },
        Cubic: {
            In: function(a) {
                return a * a * a
            },
            Out: function(a) {
                return --a * a * a + 1
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
            }
        },
        Quartic: {
            In: function(a) {
                return a * a * a * a
            },
            Out: function(a) {
                return 1 - --a * a * a * a
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2)
            }
        },
        Quintic: {
            In: function(a) {
                return a * a * a * a * a
            },
            Out: function(a) {
                return --a * a * a * a * a + 1
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
            }
        },
        Sinusoidal: {
            In: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos(a * Math.PI / 2)
            },
            Out: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : Math.sin(a * Math.PI / 2)
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : .5 * (1 - Math.cos(Math.PI * a))
            }
        },
        Exponential: {
            In: function(a) {
                return 0 === a ? 0 : Math.pow(1024, a - 1)
            },
            Out: function(a) {
                return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
            },
            InOut: function(a) {
                return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(1024, a - 1) : .5 * (2 - Math.pow(2, -10 * (a - 1)))
            }
        },
        Circular: {
            In: function(a) {
                return 1 - Math.sqrt(1 - a * a)
            },
            Out: function(a) {
                return Math.sqrt(1 - --a * a)
            },
            InOut: function(a) {
                return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
            }
        },
        Elastic: {
            In: function(a) {
                var b, c = .1, d = .4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1,
                b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI),
                -c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d))
            },
            Out: function(a) {
                var b, c = .1, d = .4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1,
                b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI),
                c * Math.pow(2, -10 * a) * Math.sin((a - b) * (2 * Math.PI) / d) + 1)
            },
            InOut: function(a) {
                var b, c = .1, d = .4;
                return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1,
                b = d / 4) : b = d * Math.asin(1 / c) / (2 * Math.PI),
                (a *= 2) < 1 ? c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d) * -.5 : c * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / d) * .5 + 1)
            }
        },
        Back: {
            In: function(a) {
                var b = 1.70158;
                return a * a * ((b + 1) * a - b)
            },
            Out: function(a) {
                var b = 1.70158;
                return --a * a * ((b + 1) * a + b) + 1
            },
            InOut: function(a) {
                var b = 2.5949095;
                return (a *= 2) < 1 ? a * a * ((b + 1) * a - b) * .5 : .5 * ((a -= 2) * a * ((b + 1) * a + b) + 2)
            }
        },
        Bounce: {
            In: function(a) {
                return 1 - b.Easing.Bounce.Out(1 - a)
            },
            Out: function(a) {
                return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
            },
            InOut: function(a) {
                return a < .5 ? .5 * b.Easing.Bounce.In(2 * a) : .5 * b.Easing.Bounce.Out(2 * a - 1) + .5
            }
        }
    },
    b.Easing.Default = b.Easing.Linear.None,
    b.Easing.Power0 = b.Easing.Linear.None,
    b.Easing.Power1 = b.Easing.Quadratic.Out,
    b.Easing.Power2 = b.Easing.Cubic.Out,
    b.Easing.Power3 = b.Easing.Quartic.Out,
    b.Easing.Power4 = b.Easing.Quintic.Out,
    b.Time = function(a) {
        this.game = a,
        this.time = 0,
        this.prevTime = 0,
        this.now = 0,
        this.elapsed = 0,
        this.elapsedMS = 0,
        this.physicsElapsed = 1 / 60,
        this.physicsElapsedMS = 1 / 60 * 1e3,
        this.desiredFpsMult = 1 / 60,
        this._desiredFps = 60,
        this.suggestedFps = this.desiredFps,
        this.slowMotion = 1,
        this.advancedTiming = !1,
        this.frames = 0,
        this.fps = 0,
        this.fpsMin = 1e3,
        this.fpsMax = 0,
        this.msMin = 1e3,
        this.msMax = 0,
        this.pauseDuration = 0,
        this.timeToCall = 0,
        this.timeExpected = 0,
        this.events = new b.Timer(this.game,!1),
        this._frameCount = 0,
        this._elapsedAccumulator = 0,
        this._started = 0,
        this._timeLastSecond = 0,
        this._pauseStarted = 0,
        this._justResumed = !1,
        this._timers = []
    }
    ,
    b.Time.prototype = {
        boot: function() {
            this._started = Date.now(),
            this.time = Date.now(),
            this.events.start(),
            this.timeExpected = this.time
        },
        add: function(a) {
            return this._timers.push(a),
            a
        },
        create: function(a) {
            void 0 === a && (a = !0);
            var c = new b.Timer(this.game,a);
            return this._timers.push(c),
            c
        },
        removeAll: function() {
            for (var a = 0; a < this._timers.length; a++)
                this._timers[a].destroy();
            this._timers = [],
            this.events.removeAll()
        },
        refresh: function() {
            var a = this.time;
            this.time = Date.now(),
            this.elapsedMS = this.time - a
        },
        update: function(a) {
            var b = this.time;
            this.time = Date.now(),
            this.elapsedMS = this.time - b,
            this.prevTime = this.now,
            this.now = a,
            this.elapsed = this.now - this.prevTime,
            this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - a))),
            this.timeExpected = a + this.timeToCall),
            this.advancedTiming && this.updateAdvancedTiming(),
            this.game.paused || (this.events.update(this.time),
            this._timers.length && this.updateTimers())
        },
        updateTimers: function() {
            for (var a = 0, b = this._timers.length; a < b; )
                this._timers[a].update(this.time) ? a++ : (this._timers.splice(a, 1),
                b--)
        },
        updateAdvancedTiming: function() {
            this._frameCount++,
            this._elapsedAccumulator += this.elapsed,
            this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)),
            this._frameCount = 0,
            this._elapsedAccumulator = 0),
            this.msMin = Math.min(this.msMin, this.elapsed),
            this.msMax = Math.max(this.msMax, this.elapsed),
            this.frames++,
            this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)),
            this.fpsMin = Math.min(this.fpsMin, this.fps),
            this.fpsMax = Math.max(this.fpsMax, this.fps),
            this._timeLastSecond = this.now,
            this.frames = 0)
        },
        gamePaused: function() {
            this._pauseStarted = Date.now(),
            this.events.pause();
            for (var a = this._timers.length; a--; )
                this._timers[a]._pause()
        },
        gameResumed: function() {
            this.time = Date.now(),
            this.pauseDuration = this.time - this._pauseStarted,
            this.events.resume();
            for (var a = this._timers.length; a--; )
                this._timers[a]._resume()
        },
        totalElapsedSeconds: function() {
            return .001 * (this.time - this._started)
        },
        elapsedSince: function(a) {
            return this.time - a
        },
        elapsedSecondsSince: function(a) {
            return .001 * (this.time - a)
        },
        reset: function() {
            this._started = this.time,
            this.removeAll()
        }
    },
    Object.defineProperty(b.Time.prototype, "desiredFps", {
        get: function() {
            return this._desiredFps
        },
        set: function(a) {
            this._desiredFps = a,
            this.physicsElapsed = 1 / a,
            this.physicsElapsedMS = 1e3 * this.physicsElapsed,
            this.desiredFpsMult = 1 / a
        }
    }),
    b.Time.prototype.constructor = b.Time,
    b.Timer = function(a, c) {
        void 0 === c && (c = !0),
        this.game = a,
        this.running = !1,
        this.autoDestroy = c,
        this.expired = !1,
        this.elapsed = 0,
        this.events = [],
        this.onComplete = new b.Signal,
        this.nextTick = 0,
        this.timeCap = 1e3,
        this.paused = !1,
        this._codePaused = !1,
        this._started = 0,
        this._pauseStarted = 0,
        this._pauseTotal = 0,
        this._now = Date.now(),
        this._len = 0,
        this._marked = 0,
        this._i = 0,
        this._diff = 0,
        this._newTick = 0
    }
    ,
    b.Timer.MINUTE = 6e4,
    b.Timer.SECOND = 1e3,
    b.Timer.HALF = 500,
    b.Timer.QUARTER = 250,
    b.Timer.prototype = {
        create: function(a, c, d, e, f, g) {
            a = Math.round(a);
            var h = a;
            0 === this._now ? h += this.game.time.time : h += this._now;
            var i = new b.TimerEvent(this,a,h,d,c,e,f,g);
            return this.events.push(i),
            this.order(),
            this.expired = !1,
            i
        },
        add: function(a, b, c) {
            return this.create(a, !1, 0, b, c, Array.prototype.slice.call(arguments, 3))
        },
        repeat: function(a, b, c, d) {
            return this.create(a, !1, b, c, d, Array.prototype.slice.call(arguments, 4))
        },
        loop: function(a, b, c) {
            return this.create(a, !0, 0, b, c, Array.prototype.slice.call(arguments, 3))
        },
        start: function(a) {
            if (!this.running) {
                this._started = this.game.time.time + (a || 0),
                this.running = !0;
                for (var b = 0; b < this.events.length; b++)
                    this.events[b].tick = this.events[b].delay + this._started
            }
        },
        stop: function(a) {
            this.running = !1,
            void 0 === a && (a = !0),
            a && (this.events.length = 0)
        },
        remove: function(a) {
            for (var b = 0; b < this.events.length; b++)
                if (this.events[b] === a)
                    return this.events[b].pendingDelete = !0,
                    !0;
            return !1
        },
        order: function() {
            this.events.length > 0 && (this.events.sort(this.sortHandler),
            this.nextTick = this.events[0].tick)
        },
        sortHandler: function(a, b) {
            return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0
        },
        clearPendingEvents: function() {
            for (this._i = this.events.length; this._i--; )
                this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
            this._len = this.events.length,
            this._i = 0
        },
        update: function(a) {
            if (this.paused)
                return !0;
            if (this.elapsed = a - this._now,
            this._now = a,
            this.elapsed > this.timeCap && this.adjustEvents(a - this.elapsed),
            this._marked = 0,
            this.clearPendingEvents(),
            this.running && this._now >= this.nextTick && this._len > 0) {
                for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete; )
                    this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick),
                    this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay),
                    !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick,
                    this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--,
                    this.events[this._i].tick = this._newTick,
                    this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++,
                    this.events[this._i].pendingDelete = !0,
                    this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)),
                    this._i++;
                this.events.length > this._marked ? this.order() : (this.expired = !0,
                this.onComplete.dispatch(this))
            }
            return !this.expired || !this.autoDestroy
        },
        pause: function() {
            this.running && (this._codePaused = !0,
            this.paused || (this._pauseStarted = this.game.time.time,
            this.paused = !0))
        },
        _pause: function() {
            !this.paused && this.running && (this._pauseStarted = this.game.time.time,
            this.paused = !0)
        },
        adjustEvents: function(a) {
            for (var b = 0; b < this.events.length; b++)
                if (!this.events[b].pendingDelete) {
                    var c = this.events[b].tick - a;
                    c < 0 && (c = 0),
                    this.events[b].tick = this._now + c
                }
            var d = this.nextTick - a;
            this.nextTick = d < 0 ? this._now : this._now + d
        },
        resume: function() {
            if (this.paused) {
                var a = this.game.time.time;
                this._pauseTotal += a - this._now,
                this._now = a,
                this.adjustEvents(this._pauseStarted),
                this.paused = !1,
                this._codePaused = !1
            }
        },
        _resume: function() {
            this._codePaused || this.resume()
        },
        removeAll: function() {
            this.onComplete.removeAll(),
            this.events.length = 0,
            this._len = 0,
            this._i = 0
        },
        destroy: function() {
            this.onComplete.removeAll(),
            this.running = !1,
            this.events = [],
            this._len = 0,
            this._i = 0
        }
    },
    Object.defineProperty(b.Timer.prototype, "next", {
        get: function() {
            return this.nextTick
        }
    }),
    Object.defineProperty(b.Timer.prototype, "duration", {
        get: function() {
            return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
        }
    }),
    Object.defineProperty(b.Timer.prototype, "length", {
        get: function() {
            return this.events.length
        }
    }),
    Object.defineProperty(b.Timer.prototype, "ms", {
        get: function() {
            return this.running ? this._now - this._started - this._pauseTotal : 0
        }
    }),
    Object.defineProperty(b.Timer.prototype, "seconds", {
        get: function() {
            return this.running ? .001 * this.ms : 0
        }
    }),
    b.Timer.prototype.constructor = b.Timer,
    b.TimerEvent = function(a, b, c, d, e, f, g, h) {
        this.timer = a,
        this.delay = b,
        this.tick = c,
        this.repeatCount = d - 1,
        this.loop = e,
        this.callback = f,
        this.callbackContext = g,
        this.args = h,
        this.pendingDelete = !1
    }
    ,
    b.TimerEvent.prototype.constructor = b.TimerEvent,
    b.AnimationManager = function(a) {
        this.sprite = a,
        this.game = a.game,
        this.currentFrame = null,
        this.currentAnim = null,
        this.updateIfVisible = !0,
        this.isLoaded = !1,
        this._frameData = null,
        this._anims = {},
        this._outputFrames = []
    }
    ,
    b.AnimationManager.prototype = {
        loadFrameData: function(a, b) {
            if (void 0 === a)
                return !1;
            if (this.isLoaded)
                for (var c in this._anims)
                    this._anims[c].updateFrameData(a);
            return this._frameData = a,
            void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b,
            this.isLoaded = !0,
            !0
        },
        copyFrameData: function(a, b) {
            if (this._frameData = a.clone(),
            this.isLoaded)
                for (var c in this._anims)
                    this._anims[c].updateFrameData(this._frameData);
            return void 0 === b || null === b ? this.frame = 0 : "string" == typeof b ? this.frameName = b : this.frame = b,
            this.isLoaded = !0,
            !0
        },
        add: function(a, c, d, e, f) {
            return c = c || [],
            d = d || 60,
            void 0 === e && (e = !1),
            void 0 === f && (f = !(!c || "number" != typeof c[0])),
            this._outputFrames = [],
            this._frameData.getFrameIndexes(c, f, this._outputFrames),
            this._anims[a] = new b.Animation(this.game,this.sprite,a,this._frameData,this._outputFrames,d,e),
            this.currentAnim = this._anims[a],
            this.sprite.tilingTexture && (this.sprite.refreshTexture = !0),
            this._anims[a]
        },
        validateFrames: function(a, b) {
            void 0 === b && (b = !0);
            for (var c = 0; c < a.length; c++)
                if (!0 === b) {
                    if (a[c] > this._frameData.total)
                        return !1
                } else if (!1 === this._frameData.checkFrameName(a[c]))
                    return !1;
            return !0
        },
        play: function(a, b, c, d) {
            if (this._anims[a])
                return this.currentAnim === this._anims[a] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1,
                this.currentAnim.play(b, c, d)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(),
                this.currentAnim = this._anims[a],
                this.currentAnim.paused = !1,
                this.currentFrame = this.currentAnim.currentFrame,
                this.currentAnim.play(b, c, d))
        },
        stop: function(a, b) {
            void 0 === b && (b = !1),
            !this.currentAnim || "string" == typeof a && a !== this.currentAnim.name || this.currentAnim.stop(b)
        },
        update: function() {
            return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame,
            !0))
        },
        next: function(a) {
            this.currentAnim && (this.currentAnim.next(a),
            this.currentFrame = this.currentAnim.currentFrame)
        },
        previous: function(a) {
            this.currentAnim && (this.currentAnim.previous(a),
            this.currentFrame = this.currentAnim.currentFrame)
        },
        getAnimation: function(a) {
            return "string" == typeof a && this._anims[a] ? this._anims[a] : null
        },
        refreshFrame: function() {},
        destroy: function() {
            var a = null;
            for (var a in this._anims)
                this._anims.hasOwnProperty(a) && this._anims[a].destroy();
            this._anims = {},
            this._outputFrames = [],
            this._frameData = null,
            this.currentAnim = null,
            this.currentFrame = null,
            this.sprite = null,
            this.game = null
        }
    },
    b.AnimationManager.prototype.constructor = b.AnimationManager,
    Object.defineProperty(b.AnimationManager.prototype, "frameData", {
        get: function() {
            return this._frameData
        }
    }),
    Object.defineProperty(b.AnimationManager.prototype, "frameTotal", {
        get: function() {
            return this._frameData.total
        }
    }),
    Object.defineProperty(b.AnimationManager.prototype, "paused", {
        get: function() {
            return this.currentAnim.isPaused
        },
        set: function(a) {
            this.currentAnim.paused = a
        }
    }),
    Object.defineProperty(b.AnimationManager.prototype, "name", {
        get: function() {
            if (this.currentAnim)
                return this.currentAnim.name
        }
    }),
    Object.defineProperty(b.AnimationManager.prototype, "frame", {
        get: function() {
            if (this.currentFrame)
                return this.currentFrame.index
        },
        set: function(a) {
            "number" == typeof a && this._frameData && null !== this._frameData.getFrame(a) && (this.currentFrame = this._frameData.getFrame(a),
            this.currentFrame && this.sprite.setFrame(this.currentFrame))
        }
    }),
    Object.defineProperty(b.AnimationManager.prototype, "frameName", {
        get: function() {
            if (this.currentFrame)
                return this.currentFrame.name
        },
        set: function(a) {
            "string" == typeof a && this._frameData && null !== this._frameData.getFrameByName(a) ? (this.currentFrame = this._frameData.getFrameByName(a),
            this.currentFrame && (this._frameIndex = this.currentFrame.index,
            this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + a)
        }
    }),
    b.Animation = function(a, c, d, e, f, g, h) {
        void 0 === h && (h = !1),
        this.game = a,
        this._parent = c,
        this._frameData = e,
        this.name = d,
        this._frames = [],
        this._frames = this._frames.concat(f),
        this.delay = 1e3 / g,
        this.loop = h,
        this.loopCount = 0,
        this.killOnComplete = !1,
        this.isFinished = !1,
        this.isPlaying = !1,
        this.isPaused = !1,
        this._pauseStartTime = 0,
        this._frameIndex = 0,
        this._frameDiff = 0,
        this._frameSkip = 1,
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
        this.onStart = new b.Signal,
        this.onUpdate = null,
        this.onComplete = new b.Signal,
        this.onLoop = new b.Signal,
        this.isReversed = !1,
        this.game.onPause.add(this.onPause, this),
        this.game.onResume.add(this.onResume, this)
    }
    ,
    b.Animation.prototype = {
        play: function(a, b, c) {
            return "number" == typeof a && (this.delay = 1e3 / a),
            "boolean" == typeof b && (this.loop = b),
            void 0 !== c && (this.killOnComplete = c),
            this.isPlaying = !0,
            this.isFinished = !1,
            this.paused = !1,
            this.loopCount = 0,
            this._timeLastFrame = this.game.time.time,
            this._timeNextFrame = this.game.time.time + this.delay,
            this._frameIndex = this.isReversed ? this._frames.length - 1 : 0,
            this.updateCurrentFrame(!1, !0),
            this._parent.events.onAnimationStart$dispatch(this._parent, this),
            this.onStart.dispatch(this._parent, this),
            this._parent.animations.currentAnim = this,
            this._parent.animations.currentFrame = this.currentFrame,
            this
        },
        restart: function() {
            this.isPlaying = !0,
            this.isFinished = !1,
            this.paused = !1,
            this.loopCount = 0,
            this._timeLastFrame = this.game.time.time,
            this._timeNextFrame = this.game.time.time + this.delay,
            this._frameIndex = 0,
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this._parent.setFrame(this.currentFrame),
            this._parent.animations.currentAnim = this,
            this._parent.animations.currentFrame = this.currentFrame,
            this.onStart.dispatch(this._parent, this)
        },
        reverse: function() {
            return this.reversed = !this.reversed,
            this
        },
        reverseOnce: function() {
            return this.onComplete.addOnce(this.reverse, this),
            this.reverse()
        },
        setFrame: function(a, b) {
            var c;
            if (void 0 === b && (b = !1),
            "string" == typeof a)
                for (var d = 0; d < this._frames.length; d++)
                    this._frameData.getFrame(this._frames[d]).name === a && (c = d);
            else if ("number" == typeof a)
                if (b)
                    c = a;
                else
                    for (var d = 0; d < this._frames.length; d++)
                        this._frames[d] === a && (c = d);
            c && (this._frameIndex = c - 1,
            this._timeNextFrame = this.game.time.time,
            this.update())
        },
        stop: function(a, b) {
            void 0 === a && (a = !1),
            void 0 === b && (b = !1),
            this.isPlaying = !1,
            this.isFinished = !0,
            this.paused = !1,
            a && (this.currentFrame = this._frameData.getFrame(this._frames[0]),
            this._parent.setFrame(this.currentFrame)),
            b && (this._parent.events.onAnimationComplete$dispatch(this._parent, this),
            this.onComplete.dispatch(this._parent, this))
        },
        onPause: function() {
            this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
        },
        onResume: function() {
            this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
        },
        update: function() {
            return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1,
            this._frameDiff = this.game.time.time - this._timeNextFrame,
            this._timeLastFrame = this.game.time.time,
            this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay),
            this._frameDiff -= this._frameSkip * this.delay),
            this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff),
            this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip,
            !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length,
            this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex),
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this.currentFrame && this._parent.setFrame(this.currentFrame),
            this.loopCount++,
            this._parent.events.onAnimationLoop$dispatch(this._parent, this),
            this.onLoop.dispatch(this._parent, this),
            !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame),
            !!this._frameData)) : (this.complete(),
            !1) : this.updateCurrentFrame(!0)))
        },
        updateCurrentFrame: function(a, b) {
            if (void 0 === b && (b = !1),
            !this._frameData)
                return !1;
            var c = this.currentFrame.index;
            return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this.currentFrame && (b || !b && c !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame),
            !this.onUpdate || !a || (this.onUpdate.dispatch(this, this.currentFrame),
            !!this._frameData)
        },
        next: function(a) {
            void 0 === a && (a = 1);
            var b = this._frameIndex + a;
            b >= this._frames.length && (this.loop ? b %= this._frames.length : b = this._frames.length - 1),
            b !== this._frameIndex && (this._frameIndex = b,
            this.updateCurrentFrame(!0))
        },
        previous: function(a) {
            void 0 === a && (a = 1);
            var b = this._frameIndex - a;
            b < 0 && (this.loop ? b = this._frames.length + b : b++),
            b !== this._frameIndex && (this._frameIndex = b,
            this.updateCurrentFrame(!0))
        },
        updateFrameData: function(a) {
            this._frameData = a,
            this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
        },
        destroy: function() {
            this._frameData && (this.game.onPause.remove(this.onPause, this),
            this.game.onResume.remove(this.onResume, this),
            this.game = null,
            this._parent = null,
            this._frames = null,
            this._frameData = null,
            this.currentFrame = null,
            this.isPlaying = !1,
            this.onStart.dispose(),
            this.onLoop.dispose(),
            this.onComplete.dispose(),
            this.onUpdate && this.onUpdate.dispose())
        },
        complete: function() {
            this._frameIndex = this._frames.length - 1,
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]),
            this.isPlaying = !1,
            this.isFinished = !0,
            this.paused = !1,
            this._parent.events.onAnimationComplete$dispatch(this._parent, this),
            this.onComplete.dispatch(this._parent, this),
            this.killOnComplete && this._parent.kill()
        }
    },
    b.Animation.prototype.constructor = b.Animation,
    Object.defineProperty(b.Animation.prototype, "paused", {
        get: function() {
            return this.isPaused
        },
        set: function(a) {
            this.isPaused = a,
            a ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
        }
    }),
    Object.defineProperty(b.Animation.prototype, "reversed", {
        get: function() {
            return this.isReversed
        },
        set: function(a) {
            this.isReversed = a
        }
    }),
    Object.defineProperty(b.Animation.prototype, "frameTotal", {
        get: function() {
            return this._frames.length
        }
    }),
    Object.defineProperty(b.Animation.prototype, "frame", {
        get: function() {
            return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
        },
        set: function(a) {
            this.currentFrame = this._frameData.getFrame(this._frames[a]),
            null !== this.currentFrame && (this._frameIndex = a,
            this._parent.setFrame(this.currentFrame),
            this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
        }
    }),
    Object.defineProperty(b.Animation.prototype, "speed", {
        get: function() {
            return 1e3 / this.delay
        },
        set: function(a) {
            a > 0 && (this.delay = 1e3 / a)
        }
    }),
    Object.defineProperty(b.Animation.prototype, "enableUpdate", {
        get: function() {
            return null !== this.onUpdate
        },
        set: function(a) {
            a && null === this.onUpdate ? this.onUpdate = new b.Signal : a || null === this.onUpdate || (this.onUpdate.dispose(),
            this.onUpdate = null)
        }
    }),
    b.Animation.generateFrameNames = function(a, c, d, e, f) {
        void 0 === e && (e = "");
        var g = []
          , h = "";
        if (c < d)
            for (var i = c; i <= d; i++)
                h = "number" == typeof f ? b.Utils.pad(i.toString(), f, "0", 1) : i.toString(),
                h = a + h + e,
                g.push(h);
        else
            for (var i = c; i >= d; i--)
                h = "number" == typeof f ? b.Utils.pad(i.toString(), f, "0", 1) : i.toString(),
                h = a + h + e,
                g.push(h);
        return g
    }
    ,
    b.Frame = function(a, c, d, e, f, g) {
        this.index = a,
        this.x = c,
        this.y = d,
        this.width = e,
        this.height = f,
        this.name = g,
        this.centerX = Math.floor(e / 2),
        this.centerY = Math.floor(f / 2),
        this.distance = b.Math.distance(0, 0, e, f),
        this.rotated = !1,
        this.rotationDirection = "cw",
        this.trimmed = !1,
        this.sourceSizeW = e,
        this.sourceSizeH = f,
        this.spriteSourceSizeX = 0,
        this.spriteSourceSizeY = 0,
        this.spriteSourceSizeW = 0,
        this.spriteSourceSizeH = 0,
        this.right = this.x + this.width,
        this.bottom = this.y + this.height
    }
    ,
    b.Frame.prototype = {
        resize: function(a, c) {
            this.width = a,
            this.height = c,
            this.centerX = Math.floor(a / 2),
            this.centerY = Math.floor(c / 2),
            this.distance = b.Math.distance(0, 0, a, c),
            this.sourceSizeW = a,
            this.sourceSizeH = c,
            this.right = this.x + a,
            this.bottom = this.y + c
        },
        setTrim: function(a, b, c, d, e, f, g) {
            this.trimmed = a,
            a && (this.sourceSizeW = b,
            this.sourceSizeH = c,
            this.centerX = Math.floor(b / 2),
            this.centerY = Math.floor(c / 2),
            this.spriteSourceSizeX = d,
            this.spriteSourceSizeY = e,
            this.spriteSourceSizeW = f,
            this.spriteSourceSizeH = g)
        },
        clone: function() {
            var a = new b.Frame(this.index,this.x,this.y,this.width,this.height,this.name);
            for (var c in this)
                this.hasOwnProperty(c) && (a[c] = this[c]);
            return a
        },
        getRect: function(a) {
            return void 0 === a ? a = new b.Rectangle(this.x,this.y,this.width,this.height) : a.setTo(this.x, this.y, this.width, this.height),
            a
        }
    },
    b.Frame.prototype.constructor = b.Frame,
    b.FrameData = function() {
        this._frames = [],
        this._frameNames = []
    }
    ,
    b.FrameData.prototype = {
        addFrame: function(a) {
            return a.index = this._frames.length,
            this._frames.push(a),
            "" !== a.name && (this._frameNames[a.name] = a.index),
            a
        },
        getFrame: function(a) {
            return a >= this._frames.length && (a = 0),
            this._frames[a]
        },
        getFrameByName: function(a) {
            return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null
        },
        checkFrameName: function(a) {
            return null != this._frameNames[a]
        },
        clone: function() {
            for (var a = new b.FrameData, c = 0; c < this._frames.length; c++)
                a._frames.push(this._frames[c].clone());
            for (var d in this._frameNames)
                this._frameNames.hasOwnProperty(d) && a._frameNames.push(this._frameNames[d]);
            return a
        },
        getFrameRange: function(a, b, c) {
            void 0 === c && (c = []);
            for (var d = a; d <= b; d++)
                c.push(this._frames[d]);
            return c
        },
        getFrames: function(a, b, c) {
            if (void 0 === b && (b = !0),
            void 0 === c && (c = []),
            void 0 === a || 0 === a.length)
                for (var d = 0; d < this._frames.length; d++)
                    c.push(this._frames[d]);
            else
                for (var d = 0; d < a.length; d++)
                    b ? c.push(this.getFrame(a[d])) : c.push(this.getFrameByName(a[d]));
            return c
        },
        getFrameIndexes: function(a, b, c) {
            if (void 0 === b && (b = !0),
            void 0 === c && (c = []),
            void 0 === a || 0 === a.length)
                for (var d = 0; d < this._frames.length; d++)
                    c.push(this._frames[d].index);
            else
                for (var d = 0; d < a.length; d++)
                    b && this._frames[a[d]] ? c.push(this._frames[a[d]].index) : this.getFrameByName(a[d]) && c.push(this.getFrameByName(a[d]).index);
            return c
        },
        destroy: function() {
            this._frames = null,
            this._frameNames = null
        }
    },
    b.FrameData.prototype.constructor = b.FrameData,
    Object.defineProperty(b.FrameData.prototype, "total", {
        get: function() {
            return this._frames.length
        }
    }),
    b.AnimationParser = {
        spriteSheet: function(a, c, d, e, f, g, h) {
            var i = c;
            if ("string" == typeof c && (i = a.cache.getImage(c)),
            null === i)
                return null;
            var j = i.width
              , k = i.height;
            d <= 0 && (d = Math.floor(-j / Math.min(-1, d))),
            e <= 0 && (e = Math.floor(-k / Math.min(-1, e)));
            var l = Math.floor((j - g) / (d + h))
              , m = Math.floor((k - g) / (e + h))
              , n = l * m;
            if (-1 !== f && (n = f),
            0 === j || 0 === k || j < d || k < e || 0 === n)
                return console.warn("Phaser.AnimationParser.spriteSheet: '" + c + "'s width/height zero or width/height < given frameWidth/frameHeight"),
                null;
            for (var o = new b.FrameData, p = g, q = g, r = 0; r < n; r++)
                o.addFrame(new b.Frame(r,p,q,d,e,"")),
                (p += d + h) + d > j && (p = g,
                q += e + h);
            return o
        },
        JSONData: function(a, c) {
            if (!c.frames)
                return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"),
                void console.log(c);
            for (var f, d = new b.FrameData, e = c.frames, g = 0; g < e.length; g++)
                f = d.addFrame(new b.Frame(g,e[g].frame.x,e[g].frame.y,e[g].frame.w,e[g].frame.h,e[g].filename)),
                e[g].trimmed && f.setTrim(e[g].trimmed, e[g].sourceSize.w, e[g].sourceSize.h, e[g].spriteSourceSize.x, e[g].spriteSourceSize.y, e[g].spriteSourceSize.w, e[g].spriteSourceSize.h);
            return d
        },
        JSONDataPyxel: function(a, c) {
            if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(a) {
                if (!c[a])
                    return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + a + '" key.'),
                    void console.log(c)
            }),
            1 !== c.layers.length)
                return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."),
                void console.log(c);
            for (var i, e = new b.FrameData, f = c.tileheight, g = c.tilewidth, h = c.layers[0].tiles, j = 0; j < h.length; j++)
                i = e.addFrame(new b.Frame(j,h[j].x,h[j].y,g,f,"frame_" + j)),
                i.setTrim(!1);
            return e
        },
        JSONDataHash: function(a, c) {
            if (!c.frames)
                return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"),
                void console.log(c);
            var f, d = new b.FrameData, e = c.frames, g = 0;
            for (var h in e)
                f = d.addFrame(new b.Frame(g,e[h].frame.x,e[h].frame.y,e[h].frame.w,e[h].frame.h,h)),
                e[h].trimmed && f.setTrim(e[h].trimmed, e[h].sourceSize.w, e[h].sourceSize.h, e[h].spriteSourceSize.x, e[h].spriteSourceSize.y, e[h].spriteSourceSize.w, e[h].spriteSourceSize.h),
                g++;
            return d
        },
        XMLData: function(a, c) {
            if (!c.getElementsByTagName("TextureAtlas"))
                return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
            for (var f, g, h, i, j, k, l, m, n, o, p, d = new b.FrameData, e = c.getElementsByTagName("SubTexture"), q = 0; q < e.length; q++)
                h = e[q].attributes,
                g = h.name.value,
                i = parseInt(h.x.value, 10),
                j = parseInt(h.y.value, 10),
                k = parseInt(h.width.value, 10),
                l = parseInt(h.height.value, 10),
                m = null,
                n = null,
                h.frameX && (m = Math.abs(parseInt(h.frameX.value, 10)),
                n = Math.abs(parseInt(h.frameY.value, 10)),
                o = parseInt(h.frameWidth.value, 10),
                p = parseInt(h.frameHeight.value, 10)),
                f = d.addFrame(new b.Frame(q,i,j,k,l,g)),
                null === m && null === n || f.setTrim(!0, k, l, m, n, o, p);
            return d
        }
    },
    b.Cache = function(a) {
        this.game = a,
        this.autoResolveURL = !1,
        this._cache = {
            canvas: {},
            image: {},
            texture: {},
            sound: {},
            video: {},
            text: {},
            json: {},
            xml: {},
            physics: {},
            tilemap: {},
            binary: {},
            bitmapData: {},
            bitmapFont: {},
            shader: {},
            renderTexture: {}
        },
        this._urlMap = {},
        this._urlResolver = new Image,
        this._urlTemp = null,
        this.onSoundUnlock = new b.Signal,
        this._cacheMap = [],
        this._cacheMap[b.Cache.CANVAS] = this._cache.canvas,
        this._cacheMap[b.Cache.IMAGE] = this._cache.image,
        this._cacheMap[b.Cache.TEXTURE] = this._cache.texture,
        this._cacheMap[b.Cache.SOUND] = this._cache.sound,
        this._cacheMap[b.Cache.TEXT] = this._cache.text,
        this._cacheMap[b.Cache.PHYSICS] = this._cache.physics,
        this._cacheMap[b.Cache.TILEMAP] = this._cache.tilemap,
        this._cacheMap[b.Cache.BINARY] = this._cache.binary,
        this._cacheMap[b.Cache.BITMAPDATA] = this._cache.bitmapData,
        this._cacheMap[b.Cache.BITMAPFONT] = this._cache.bitmapFont,
        this._cacheMap[b.Cache.JSON] = this._cache.json,
        this._cacheMap[b.Cache.XML] = this._cache.xml,
        this._cacheMap[b.Cache.VIDEO] = this._cache.video,
        this._cacheMap[b.Cache.SHADER] = this._cache.shader,
        this._cacheMap[b.Cache.RENDER_TEXTURE] = this._cache.renderTexture,
        this.addDefaultImage(),
        this.addMissingImage()
    }
    ,
    b.Cache.CANVAS = 1,
    b.Cache.IMAGE = 2,
    b.Cache.TEXTURE = 3,
    b.Cache.SOUND = 4,
    b.Cache.TEXT = 5,
    b.Cache.PHYSICS = 6,
    b.Cache.TILEMAP = 7,
    b.Cache.BINARY = 8,
    b.Cache.BITMAPDATA = 9,
    b.Cache.BITMAPFONT = 10,
    b.Cache.JSON = 11,
    b.Cache.XML = 12,
    b.Cache.VIDEO = 13,
    b.Cache.SHADER = 14,
    b.Cache.RENDER_TEXTURE = 15,
    b.Cache.DEFAULT = null,
    b.Cache.MISSING = null,
    b.Cache.prototype = {
        addCanvas: function(a, b, c) {
            void 0 === c && (c = b.getContext("2d")),
            this._cache.canvas[a] = {
                canvas: b,
                context: c
            }
        },
        addImage: function(a, c, d) {
            this.checkImageKey(a) && this.removeImage(a);
            var e = {
                key: a,
                url: c,
                data: d,
                base: new PIXI.BaseTexture(d),
                frame: new b.Frame(0,0,0,d.width,d.height,a),
                frameData: new b.FrameData
            };
            return e.frameData.addFrame(new b.Frame(0,0,0,d.width,d.height,c)),
            this._cache.image[a] = e,
            this._resolveURL(c, e),
            "__default" === a ? b.Cache.DEFAULT = new PIXI.Texture(e.base) : "__missing" === a && (b.Cache.MISSING = new PIXI.Texture(e.base)),
            e
        },
        addDefaultImage: function() {
            var a = new Image;
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
            var c = this.addImage("__default", null, a);
            c.base.skipRender = !0,
            b.Cache.DEFAULT = new PIXI.Texture(c.base)
        },
        addMissingImage: function() {
            var a = new Image;
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            var c = this.addImage("__missing", null, a);
            b.Cache.MISSING = new PIXI.Texture(c.base)
        },
        addSound: function(a, b, c, d, e) {
            void 0 === d && (d = !0,
            e = !1),
            void 0 === e && (d = !1,
            e = !0);
            var f = !1;
            e && (f = !0),
            this._cache.sound[a] = {
                url: b,
                data: c,
                isDecoding: !1,
                decoded: f,
                webAudio: d,
                audioTag: e,
                locked: this.game.sound.touchLocked
            },
            this._resolveURL(b, this._cache.sound[a])
        },
        addText: function(a, b, c) {
            this._cache.text[a] = {
                url: b,
                data: c
            },
            this._resolveURL(b, this._cache.text[a])
        },
        addPhysicsData: function(a, b, c, d) {
            this._cache.physics[a] = {
                url: b,
                data: c,
                format: d
            },
            this._resolveURL(b, this._cache.physics[a])
        },
        addTilemap: function(a, b, c, d) {
            this._cache.tilemap[a] = {
                url: b,
                data: c,
                format: d
            },
            this._resolveURL(b, this._cache.tilemap[a])
        },
        addBinary: function(a, b) {
            this._cache.binary[a] = b
        },
        addBitmapData: function(a, c, d) {
            return c.key = a,
            void 0 === d && (d = new b.FrameData,
            d.addFrame(c.textureFrame)),
            this._cache.bitmapData[a] = {
                data: c,
                frameData: d
            },
            c
        },
        addBitmapFont: function(a, c, d, e, f, g, h) {
            var i = {
                url: c,
                data: d,
                font: null,
                base: new PIXI.BaseTexture(d)
            };
            void 0 === g && (g = 0),
            void 0 === h && (h = 0),
            i.font = "json" === f ? b.LoaderParser.jsonBitmapFont(e, i.base, g, h) : b.LoaderParser.xmlBitmapFont(e, i.base, g, h),
            this._cache.bitmapFont[a] = i,
            this._resolveURL(c, i)
        },
        addJSON: function(a, b, c) {
            this._cache.json[a] = {
                url: b,
                data: c
            },
            this._resolveURL(b, this._cache.json[a])
        },
        addXML: function(a, b, c) {
            this._cache.xml[a] = {
                url: b,
                data: c
            },
            this._resolveURL(b, this._cache.xml[a])
        },
        addVideo: function(a, b, c, d) {
            this._cache.video[a] = {
                url: b,
                data: c,
                isBlob: d,
                locked: !0
            },
            this._resolveURL(b, this._cache.video[a])
        },
        addShader: function(a, b, c) {
            this._cache.shader[a] = {
                url: b,
                data: c
            },
            this._resolveURL(b, this._cache.shader[a])
        },
        addRenderTexture: function(a, c) {
            this._cache.renderTexture[a] = {
                texture: c,
                frame: new b.Frame(0,0,0,c.width,c.height,"","")
            }
        },
        addSpriteSheet: function(a, c, d, e, f, g, h, i) {
            void 0 === g && (g = -1),
            void 0 === h && (h = 0),
            void 0 === i && (i = 0);
            var j = {
                key: a,
                url: c,
                data: d,
                frameWidth: e,
                frameHeight: f,
                margin: h,
                spacing: i,
                base: new PIXI.BaseTexture(d),
                frameData: b.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i)
            };
            this._cache.image[a] = j,
            this._resolveURL(c, j)
        },
        addTextureAtlas: function(a, c, d, e, f) {
            var g = {
                key: a,
                url: c,
                data: d,
                base: new PIXI.BaseTexture(d)
            };
            f === b.Loader.TEXTURE_ATLAS_XML_STARLING ? g.frameData = b.AnimationParser.XMLData(this.game, e, a) : f === b.Loader.TEXTURE_ATLAS_JSON_PYXEL ? g.frameData = b.AnimationParser.JSONDataPyxel(this.game, e, a) : Array.isArray(e.frames) ? g.frameData = b.AnimationParser.JSONData(this.game, e, a) : g.frameData = b.AnimationParser.JSONDataHash(this.game, e, a),
            this._cache.image[a] = g,
            this._resolveURL(c, g)
        },
        reloadSound: function(a) {
            var b = this
              , c = this.getSound(a);
            c && (c.data.src = c.url,
            c.data.addEventListener("canplaythrough", function() {
                return b.reloadSoundComplete(a)
            }, !1),
            c.data.load())
        },
        reloadSoundComplete: function(a) {
            var b = this.getSound(a);
            b && (b.locked = !1,
            this.onSoundUnlock.dispatch(a))
        },
        updateSound: function(a, b, c) {
            var d = this.getSound(a);
            d && (d[b] = c)
        },
        decodedSound: function(a, b) {
            var c = this.getSound(a);
            c.data = b,
            c.decoded = !0,
            c.isDecoding = !1
        },
        isSoundDecoded: function(a) {
            var c = this.getItem(a, b.Cache.SOUND, "isSoundDecoded");
            if (c)
                return c.decoded
        },
        isSoundReady: function(a) {
            var c = this.getItem(a, b.Cache.SOUND, "isSoundDecoded");
            if (c)
                return c.decoded && !this.game.sound.touchLocked
        },
        checkKey: function(a, b) {
            return !!this._cacheMap[a][b]
        },
        checkURL: function(a) {
            return !!this._urlMap[this._resolveURL(a)]
        },
        checkCanvasKey: function(a) {
            return this.checkKey(b.Cache.CANVAS, a)
        },
        checkImageKey: function(a) {
            return this.checkKey(b.Cache.IMAGE, a)
        },
        checkTextureKey: function(a) {
            return this.checkKey(b.Cache.TEXTURE, a)
        },
        checkSoundKey: function(a) {
            return this.checkKey(b.Cache.SOUND, a)
        },
        checkTextKey: function(a) {
            return this.checkKey(b.Cache.TEXT, a)
        },
        checkPhysicsKey: function(a) {
            return this.checkKey(b.Cache.PHYSICS, a)
        },
        checkTilemapKey: function(a) {
            return this.checkKey(b.Cache.TILEMAP, a)
        },
        checkBinaryKey: function(a) {
            return this.checkKey(b.Cache.BINARY, a)
        },
        checkBitmapDataKey: function(a) {
            return this.checkKey(b.Cache.BITMAPDATA, a)
        },
        checkBitmapFontKey: function(a) {
            return this.checkKey(b.Cache.BITMAPFONT, a)
        },
        checkJSONKey: function(a) {
            return this.checkKey(b.Cache.JSON, a)
        },
        checkXMLKey: function(a) {
            return this.checkKey(b.Cache.XML, a)
        },
        checkVideoKey: function(a) {
            return this.checkKey(b.Cache.VIDEO, a)
        },
        checkShaderKey: function(a) {
            return this.checkKey(b.Cache.SHADER, a)
        },
        checkRenderTextureKey: function(a) {
            return this.checkKey(b.Cache.RENDER_TEXTURE, a)
        },
        getItem: function(a, b, c, d) {
            return this.checkKey(b, a) ? void 0 === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d] : (c && console.warn("Phaser.Cache." + c + ': Key "' + a + '" not found in Cache.'),
            null)
        },
        getCanvas: function(a) {
            return this.getItem(a, b.Cache.CANVAS, "getCanvas", "canvas")
        },
        getImage: function(a, c) {
            void 0 !== a && null !== a || (a = "__default"),
            void 0 === c && (c = !1);
            var d = this.getItem(a, b.Cache.IMAGE, "getImage");
            return null === d && (d = this.getItem("__missing", b.Cache.IMAGE, "getImage")),
            c ? d : d.data
        },
        getTextureFrame: function(a) {
            return this.getItem(a, b.Cache.TEXTURE, "getTextureFrame", "frame")
        },
        getSound: function(a) {
            return this.getItem(a, b.Cache.SOUND, "getSound")
        },
        getSoundData: function(a) {
            return this.getItem(a, b.Cache.SOUND, "getSoundData", "data")
        },
        getText: function(a) {
            return this.getItem(a, b.Cache.TEXT, "getText", "data")
        },
        getPhysicsData: function(a, c, d) {
            var e = this.getItem(a, b.Cache.PHYSICS, "getPhysicsData", "data");
            if (null === e || void 0 === c || null === c)
                return e;
            if (e[c]) {
                var f = e[c];
                if (!f || !d)
                    return f;
                for (var g in f)
                    if (g = f[g],
                    g.fixtureKey === d)
                        return g;
                console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + d + " in " + a + '"')
            } else
                console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + a + " / " + c + '"');
            return null
        },
        getTilemapData: function(a) {
            return this.getItem(a, b.Cache.TILEMAP, "getTilemapData")
        },
        getBinary: function(a) {
            return this.getItem(a, b.Cache.BINARY, "getBinary")
        },
        getBitmapData: function(a) {
            return this.getItem(a, b.Cache.BITMAPDATA, "getBitmapData", "data")
        },
        getBitmapFont: function(a) {
            return this.getItem(a, b.Cache.BITMAPFONT, "getBitmapFont")
        },
        getJSON: function(a, c) {
            var d = this.getItem(a, b.Cache.JSON, "getJSON", "data");
            return d ? c ? b.Utils.extend(!0, Array.isArray(d) ? [] : {}, d) : d : null
        },
        getXML: function(a) {
            return this.getItem(a, b.Cache.XML, "getXML", "data")
        },
        getVideo: function(a) {
            return this.getItem(a, b.Cache.VIDEO, "getVideo")
        },
        getShader: function(a) {
            return this.getItem(a, b.Cache.SHADER, "getShader", "data")
        },
        getRenderTexture: function(a) {
            return this.getItem(a, b.Cache.RENDER_TEXTURE, "getRenderTexture")
        },
        getBaseTexture: function(a, c) {
            return void 0 === c && (c = b.Cache.IMAGE),
            this.getItem(a, c, "getBaseTexture", "base")
        },
        getFrame: function(a, c) {
            return void 0 === c && (c = b.Cache.IMAGE),
            this.getItem(a, c, "getFrame", "frame")
        },
        getFrameCount: function(a, b) {
            var c = this.getFrameData(a, b);
            return c ? c.total : 0
        },
        getFrameData: function(a, c) {
            return void 0 === c && (c = b.Cache.IMAGE),
            this.getItem(a, c, "getFrameData", "frameData")
        },
        hasFrameData: function(a, c) {
            return void 0 === c && (c = b.Cache.IMAGE),
            null !== this.getItem(a, c, "", "frameData")
        },
        updateFrameData: function(a, c, d) {
            void 0 === d && (d = b.Cache.IMAGE),
            this._cacheMap[d][a] && (this._cacheMap[d][a].frameData = c)
        },
        getFrameByIndex: function(a, b, c) {
            var d = this.getFrameData(a, c);
            return d ? d.getFrame(b) : null
        },
        getFrameByName: function(a, b, c) {
            var d = this.getFrameData(a, c);
            return d ? d.getFrameByName(b) : null
        },
        getURL: function(a) {
            var a = this._resolveURL(a);
            return a ? this._urlMap[a] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + a + '" or Cache.autoResolveURL was false'),
            null)
        },
        getKeys: function(a) {
            void 0 === a && (a = b.Cache.IMAGE);
            var c = [];
            if (this._cacheMap[a])
                for (var d in this._cacheMap[a])
                    "__default" !== d && "__missing" !== d && c.push(d);
            return c
        },
        removeCanvas: function(a) {
            delete this._cache.canvas[a]
        },
        removeImage: function(a, b) {
            void 0 === b && (b = !0);
            var c = this.getImage(a, !0);
            b && c.base && c.base.destroy(),
            delete this._cache.image[a]
        },
        removeSound: function(a) {
            delete this._cache.sound[a]
        },
        removeText: function(a) {
            delete this._cache.text[a]
        },
        removePhysics: function(a) {
            delete this._cache.physics[a]
        },
        removeTilemap: function(a) {
            delete this._cache.tilemap[a]
        },
        removeBinary: function(a) {
            delete this._cache.binary[a]
        },
        removeBitmapData: function(a) {
            delete this._cache.bitmapData[a]
        },
        removeBitmapFont: function(a) {
            delete this._cache.bitmapFont[a]
        },
        removeJSON: function(a) {
            delete this._cache.json[a]
        },
        removeXML: function(a) {
            delete this._cache.xml[a]
        },
        removeVideo: function(a) {
            delete this._cache.video[a]
        },
        removeShader: function(a) {
            delete this._cache.shader[a]
        },
        removeRenderTexture: function(a) {
            delete this._cache.renderTexture[a]
        },
        removeSpriteSheet: function(a) {
            delete this._cache.spriteSheet[a]
        },
        removeTextureAtlas: function(a) {
            delete this._cache.atlas[a]
        },
        clearGLTextures: function() {
            for (var a in this._cache.image)
                this._cache.image[a].base._glTextures = []
        },
        _resolveURL: function(a, b) {
            return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + a,
            this._urlTemp = this._urlResolver.src,
            this._urlResolver.src = "",
            b && (this._urlMap[this._urlTemp] = b),
            this._urlTemp) : null
        },
        destroy: function() {
            for (var a = 0; a < this._cacheMap.length; a++) {
                var b = this._cacheMap[a];
                for (var c in b)
                    "__default" !== c && "__missing" !== c && (b[c].destroy && b[c].destroy(),
                    delete b[c])
            }
            this._urlMap = null,
            this._urlResolver = null,
            this._urlTemp = null
        }
    },
    b.Cache.prototype.constructor = b.Cache,
    b.Loader = function(a) {
        this.game = a,
        this.cache = a.cache,
        this.resetLocked = !1,
        this.isLoading = !1,
        this.hasLoaded = !1,
        this.preloadSprite = null,
        this.crossOrigin = !1,
        this.baseURL = "",
        this.path = "",
        this.headers = {
            requestedWith: !1,
            json: "application/json",
            xml: "application/xml"
        },
        this.onLoadStart = new b.Signal,
        this.onLoadComplete = new b.Signal,
        this.onPackComplete = new b.Signal,
        this.onFileStart = new b.Signal,
        this.onFileComplete = new b.Signal,
        this.onFileError = new b.Signal,
        this.useXDomainRequest = !1,
        this._warnedAboutXDomainRequest = !1,
        this.enableParallel = !0,
        this.maxParallelDownloads = 4,
        this._withSyncPointDepth = 0,
        this._fileList = [],
        this._flightQueue = [],
        this._processingHead = 0,
        this._fileLoadStarted = !1,
        this._totalPackCount = 0,
        this._totalFileCount = 0,
        this._loadedPackCount = 0,
        this._loadedFileCount = 0
    }
    ,
    b.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0,
    b.Loader.TEXTURE_ATLAS_JSON_HASH = 1,
    b.Loader.TEXTURE_ATLAS_XML_STARLING = 2,
    b.Loader.PHYSICS_LIME_CORONA_JSON = 3,
    b.Loader.PHYSICS_PHASER_JSON = 4,
    b.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5,
    b.Loader.prototype = {
        setPreloadSprite: function(a, c) {
            c = c || 0,
            this.preloadSprite = {
                sprite: a,
                direction: c,
                width: a.width,
                height: a.height,
                rect: null
            },
            this.preloadSprite.rect = 0 === c ? new b.Rectangle(0,0,1,a.height) : new b.Rectangle(0,0,a.width,1),
            a.crop(this.preloadSprite.rect),
            a.visible = !0
        },
        resize: function() {
            this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
        },
        checkKeyExists: function(a, b) {
            return this.getAssetIndex(a, b) > -1
        },
        getAssetIndex: function(a, b) {
            for (var c = -1, d = 0; d < this._fileList.length; d++) {
                var e = this._fileList[d];
                if (e.type === a && e.key === b && (c = d,
                !e.loaded && !e.loading))
                    break
            }
            return c
        },
        getAsset: function(a, b) {
            var c = this.getAssetIndex(a, b);
            return c > -1 && {
                index: c,
                file: this._fileList[c]
            }
        },
        reset: function(a, b) {
            void 0 === b && (b = !1),
            this.resetLocked || (a && (this.preloadSprite = null),
            this.isLoading = !1,
            this._processingHead = 0,
            this._fileList.length = 0,
            this._flightQueue.length = 0,
            this._fileLoadStarted = !1,
            this._totalFileCount = 0,
            this._totalPackCount = 0,
            this._loadedPackCount = 0,
            this._loadedFileCount = 0,
            b && (this.onLoadStart.removeAll(),
            this.onLoadComplete.removeAll(),
            this.onPackComplete.removeAll(),
            this.onFileStart.removeAll(),
            this.onFileComplete.removeAll(),
            this.onFileError.removeAll()))
        },
        addToFileList: function(a, b, c, d, e, f) {
            if (void 0 === e && (e = !1),
            void 0 === b || "" === b)
                return console.warn("Phaser.Loader: Invalid or no key given of type " + a),
                this;
            if (void 0 === c || null === c) {
                if (!f)
                    return console.warn("Phaser.Loader: No URL given for file type: " + a + " key: " + b),
                    this;
                c = b + f
            }
            var g = {
                type: a,
                key: b,
                path: this.path,
                url: c,
                syncPoint: this._withSyncPointDepth > 0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1
            };
            if (d)
                for (var h in d)
                    g[h] = d[h];
            var i = this.getAssetIndex(a, b);
            if (e && i > -1) {
                var j = this._fileList[i];
                j.loading || j.loaded ? (this._fileList.push(g),
                this._totalFileCount++) : this._fileList[i] = g
            } else
                -1 === i && (this._fileList.push(g),
                this._totalFileCount++);
            return this
        },
        replaceInFileList: function(a, b, c, d) {
            return this.addToFileList(a, b, c, d, !0)
        },
        pack: function(a, b, c, d) {
            if (void 0 === b && (b = null),
            void 0 === c && (c = null),
            void 0 === d && (d = null),
            !b && !c)
                return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."),
                this;
            var e = {
                type: "packfile",
                key: a,
                url: b,
                path: this.path,
                syncPoint: !0,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1,
                callbackContext: d
            };
            c && ("string" == typeof c && (c = JSON.parse(c)),
            e.data = c || {},
            e.loaded = !0);
            for (var f = 0; f < this._fileList.length + 1; f++) {
                var g = this._fileList[f];
                if (!g || !g.loaded && !g.loading && "packfile" !== g.type) {
                    this._fileList.splice(f, 0, e),
                    this._totalPackCount++;
                    break
                }
            }
            return this
        },
        image: function(a, b, c) {
            return this.addToFileList("image", a, b, void 0, c, ".png")
        },
        images: function(a, b) {
            if (Array.isArray(b))
                for (var c = 0; c < a.length; c++)
                    this.image(a[c], b[c]);
            else
                for (var c = 0; c < a.length; c++)
                    this.image(a[c]);
            return this
        },
        text: function(a, b, c) {
            return this.addToFileList("text", a, b, void 0, c, ".txt")
        },
        json: function(a, b, c) {
            return this.addToFileList("json", a, b, void 0, c, ".json")
        },
        shader: function(a, b, c) {
            return this.addToFileList("shader", a, b, void 0, c, ".frag")
        },
        xml: function(a, b, c) {
            return this.addToFileList("xml", a, b, void 0, c, ".xml")
        },
        script: function(a, b, c, d) {
            return void 0 === c && (c = !1),
            !1 !== c && void 0 === d && (d = this),
            this.addToFileList("script", a, b, {
                syncPoint: !0,
                callback: c,
                callbackContext: d
            }, !1, ".js")
        },
        binary: function(a, b, c, d) {
            return void 0 === c && (c = !1),
            !1 !== c && void 0 === d && (d = c),
            this.addToFileList("binary", a, b, {
                callback: c,
                callbackContext: d
            }, !1, ".bin")
        },
        spritesheet: function(a, b, c, d, e, f, g) {
            return void 0 === e && (e = -1),
            void 0 === f && (f = 0),
            void 0 === g && (g = 0),
            this.addToFileList("spritesheet", a, b, {
                frameWidth: c,
                frameHeight: d,
                frameMax: e,
                margin: f,
                spacing: g
            }, !1, ".png")
        },
        audio: function(a, b, c) {
            return this.game.sound.noAudio ? this : (void 0 === c && (c = !0),
            "string" == typeof b && (b = [b]),
            this.addToFileList("audio", a, b, {
                buffer: null,
                autoDecode: c
            }))
        },
        audioSprite: function(a, b, c, d, e) {
            return this.game.sound.noAudio ? this : (void 0 === c && (c = null),
            void 0 === d && (d = null),
            void 0 === e && (e = !0),
            this.audio(a, b, e),
            c ? this.json(a + "-audioatlas", c) : d ? ("string" == typeof d && (d = JSON.parse(d)),
            this.cache.addJSON(a + "-audioatlas", "", d)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"),
            this)
        },
        audiosprite: function(a, b, c, d, e) {
            return this.audioSprite(a, b, c, d, e)
        },
        video: function(a, b, c, d) {
            return void 0 === c && (c = this.game.device.firefox ? "loadeddata" : "canplaythrough"),
            void 0 === d && (d = !1),
            "string" == typeof b && (b = [b]),
            this.addToFileList("video", a, b, {
                buffer: null,
                asBlob: d,
                loadEvent: c
            })
        },
        tilemap: function(a, c, d, e) {
            if (void 0 === c && (c = null),
            void 0 === d && (d = null),
            void 0 === e && (e = b.Tilemap.CSV),
            c || d || (c = e === b.Tilemap.CSV ? a + ".csv" : a + ".json"),
            d) {
                switch (e) {
                case b.Tilemap.CSV:
                    break;
                case b.Tilemap.TILED_JSON:
                    "string" == typeof d && (d = JSON.parse(d))
                }
                this.cache.addTilemap(a, null, d, e)
            } else
                this.addToFileList("tilemap", a, c, {
                    format: e
                });
            return this
        },
        physics: function(a, c, d, e) {
            return void 0 === c && (c = null),
            void 0 === d && (d = null),
            void 0 === e && (e = b.Physics.LIME_CORONA_JSON),
            c || d || (c = a + ".json"),
            d ? ("string" == typeof d && (d = JSON.parse(d)),
            this.cache.addPhysicsData(a, null, d, e)) : this.addToFileList("physics", a, c, {
                format: e
            }),
            this
        },
        bitmapFont: function(a, b, c, d, e, f) {
            if (void 0 !== b && null !== b || (b = a + ".png"),
            void 0 === c && (c = null),
            void 0 === d && (d = null),
            null === c && null === d && (c = a + ".xml"),
            void 0 === e && (e = 0),
            void 0 === f && (f = 0),
            c)
                this.addToFileList("bitmapfont", a, b, {
                    atlasURL: c,
                    xSpacing: e,
                    ySpacing: f
                });
            else if ("string" == typeof d) {
                var g, h;
                try {
                    g = JSON.parse(d)
                } catch (a) {
                    h = this.parseXml(d)
                }
                if (!h && !g)
                    throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                this.addToFileList("bitmapfont", a, b, {
                    atlasURL: null,
                    atlasData: g || h,
                    atlasType: g ? "json" : "xml",
                    xSpacing: e,
                    ySpacing: f
                })
            }
            return this
        },
        atlasJSONArray: function(a, c, d, e) {
            return this.atlas(a, c, d, e, b.Loader.TEXTURE_ATLAS_JSON_ARRAY)
        },
        atlasJSONHash: function(a, c, d, e) {
            return this.atlas(a, c, d, e, b.Loader.TEXTURE_ATLAS_JSON_HASH)
        },
        atlasXML: function(a, c, d, e) {
            return void 0 === d && (d = null),
            void 0 === e && (e = null),
            d || e || (d = a + ".xml"),
            this.atlas(a, c, d, e, b.Loader.TEXTURE_ATLAS_XML_STARLING)
        },
        atlas: function(a, c, d, e, f) {
            if (void 0 !== c && null !== c || (c = a + ".png"),
            void 0 === d && (d = null),
            void 0 === e && (e = null),
            void 0 === f && (f = b.Loader.TEXTURE_ATLAS_JSON_ARRAY),
            d || e || (d = f === b.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json"),
            d)
                this.addToFileList("textureatlas", a, c, {
                    atlasURL: d,
                    format: f
                });
            else {
                switch (f) {
                case b.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                    "string" == typeof e && (e = JSON.parse(e));
                    break;
                case b.Loader.TEXTURE_ATLAS_XML_STARLING:
                    if ("string" == typeof e) {
                        var g = this.parseXml(e);
                        if (!g)
                            throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                        e = g
                    }
                }
                this.addToFileList("textureatlas", a, c, {
                    atlasURL: null,
                    atlasData: e,
                    format: f
                })
            }
            return this
        },
        withSyncPoint: function(a, b) {
            this._withSyncPointDepth++;
            try {
                a.call(b || this, this)
            } finally {
                this._withSyncPointDepth--
            }
            return this
        },
        addSyncPoint: function(a, b) {
            var c = this.getAsset(a, b);
            return c && (c.file.syncPoint = !0),
            this
        },
        removeFile: function(a, b) {
            var c = this.getAsset(a, b);
            c && (c.loaded || c.loading || this._fileList.splice(c.index, 1))
        },
        removeAll: function() {
            this._fileList.length = 0,
            this._flightQueue.length = 0
        },
        start: function() {
            this.isLoading || (this.hasLoaded = !1,
            this.isLoading = !0,
            this.updateProgress(),
            this.processLoadQueue())
        },
        processLoadQueue: function() {
            if (!this.isLoading)
                return console.warn("Phaser.Loader - active loading canceled / reset"),
                void this.finishedLoading(!0);
            for (var a = 0; a < this._flightQueue.length; a++) {
                var c = this._flightQueue[a];
                (c.loaded || c.error) && (this._flightQueue.splice(a, 1),
                a--,
                c.loading = !1,
                c.requestUrl = null,
                c.requestObject = null,
                c.error && this.onFileError.dispatch(c.key, c),
                "packfile" !== c.type ? (this._loadedFileCount++,
                this.onFileComplete.dispatch(this.progress, c.key, !c.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === c.type && c.error && (this._loadedPackCount++,
                this.onPackComplete.dispatch(c.key, !c.error, this._loadedPackCount, this._totalPackCount)))
            }
            for (var d = !1, e = this.enableParallel ? b.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, a = this._processingHead; a < this._fileList.length; a++) {
                var c = this._fileList[a];
                if ("packfile" === c.type && !c.error && c.loaded && a === this._processingHead && (this.processPack(c),
                this._loadedPackCount++,
                this.onPackComplete.dispatch(c.key, !c.error, this._loadedPackCount, this._totalPackCount)),
                c.loaded || c.error ? a === this._processingHead && (this._processingHead = a + 1) : !c.loading && this._flightQueue.length < e && ("packfile" !== c.type || c.data ? d || (this._fileLoadStarted || (this._fileLoadStarted = !0,
                this.onLoadStart.dispatch()),
                this._flightQueue.push(c),
                c.loading = !0,
                this.onFileStart.dispatch(this.progress, c.key, c.url),
                this.loadFile(c)) : (this._flightQueue.push(c),
                c.loading = !0,
                this.loadFile(c))),
                !c.loaded && c.syncPoint && (d = !0),
                this._flightQueue.length >= e || d && this._loadedPackCount === this._totalPackCount)
                    break
            }
            if (this.updateProgress(),
            this._processingHead >= this._fileList.length)
                this.finishedLoading();
            else if (!this._flightQueue.length) {
                console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                var f = this;
                setTimeout(function() {
                    f.finishedLoading(!0)
                }, 2e3)
            }
        },
        finishedLoading: function(a) {
            this.hasLoaded || (this.hasLoaded = !0,
            this.isLoading = !1,
            a || this._fileLoadStarted || (this._fileLoadStarted = !0,
            this.onLoadStart.dispatch()),
            this.onLoadComplete.dispatch(),
            this.game.state.loadComplete(),
            this.reset())
        },
        asyncComplete: function(a, b) {
            void 0 === b && (b = ""),
            a.loaded = !0,
            a.error = !!b,
            b && (a.errorMessage = b,
            console.warn("Phaser.Loader - " + a.type + "[" + a.key + "]: " + b)),
            this.processLoadQueue()
        },
        processPack: function(a) {
            var c = a.data[a.key];
            if (!c)
                return void console.warn("Phaser.Loader - " + a.key + ": pack has data, but not for pack key");
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                switch (e.type) {
                case "image":
                    this.image(e.key, e.url, e.overwrite);
                    break;
                case "text":
                    this.text(e.key, e.url, e.overwrite);
                    break;
                case "json":
                    this.json(e.key, e.url, e.overwrite);
                    break;
                case "xml":
                    this.xml(e.key, e.url, e.overwrite);
                    break;
                case "script":
                    this.script(e.key, e.url, e.callback, a.callbackContext || this);
                    break;
                case "binary":
                    this.binary(e.key, e.url, e.callback, a.callbackContext || this);
                    break;
                case "spritesheet":
                    this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
                    break;
                case "video":
                    this.video(e.key, e.urls);
                    break;
                case "audio":
                    this.audio(e.key, e.urls, e.autoDecode);
                    break;
                case "audiosprite":
                    this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
                    break;
                case "tilemap":
                    this.tilemap(e.key, e.url, e.data, b.Tilemap[e.format]);
                    break;
                case "physics":
                    this.physics(e.key, e.url, e.data, b.Loader[e.format]);
                    break;
                case "bitmapFont":
                    this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
                    break;
                case "atlasJSONArray":
                    this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
                    break;
                case "atlasJSONHash":
                    this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
                    break;
                case "atlasXML":
                    this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
                    break;
                case "atlas":
                    this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, b.Loader[e.format]);
                    break;
                case "shader":
                    this.shader(e.key, e.url, e.overwrite)
                }
            }
        },
        transformUrl: function(a, b) {
            return !!a && (a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a)
        },
        loadFile: function(a) {
            switch (a.type) {
            case "packfile":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                break;
            case "image":
            case "spritesheet":
            case "textureatlas":
            case "bitmapfont":
                this.loadImageTag(a);
                break;
            case "audio":
                a.url = this.getAudioURL(a.url),
                a.url ? this.game.sound.usingWebAudio ? this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(a) : this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
                break;
            case "video":
                a.url = this.getVideoURL(a.url),
                a.url ? a.asBlob ? this.xhrLoad(a, this.transformUrl(a.url, a), "blob", this.fileComplete) : this.loadVideoTag(a) : this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
                break;
            case "json":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
                break;
            case "xml":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
                break;
            case "tilemap":
                a.format === b.Tilemap.TILED_JSON ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete) : a.format === b.Tilemap.CSV ? this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete) : this.asyncComplete(a, "invalid Tilemap format: " + a.format);
                break;
            case "text":
            case "script":
            case "shader":
            case "physics":
                this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
                break;
            case "binary":
                this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete)
            }
        },
        loadImageTag: function(a) {
            var b = this;
            a.data = new Image,
            a.data.name = a.key,
            this.crossOrigin && (a.data.crossOrigin = this.crossOrigin),
            a.data.onload = function() {
                a.data.onload && (a.data.onload = null,
                a.data.onerror = null,
                b.fileComplete(a))
            }
            ,
            a.data.onerror = function() {
                a.data.onload && (a.data.onload = null,
                a.data.onerror = null,
                b.fileError(a))
            }
            ,
            a.data.src = this.transformUrl(a.url, a),
            a.data.complete && a.data.width && a.data.height && (a.data.onload = null,
            a.data.onerror = null,
            this.fileComplete(a))
        },
        loadVideoTag: function(a) {
            var c = this;
            a.data = document.createElement("video"),
            a.data.name = a.key,
            a.data.controls = !1,
            a.data.autoplay = !1;
            var d = function() {
                a.data.removeEventListener(a.loadEvent, d, !1),
                a.data.onerror = null,
                a.data.canplay = !0,
                b.GAMES[c.game.id].load.fileComplete(a)
            };
            a.data.onerror = function() {
                a.data.removeEventListener(a.loadEvent, d, !1),
                a.data.onerror = null,
                a.data.canplay = !1,
                c.fileError(a)
            }
            ,
            a.data.addEventListener(a.loadEvent, d, !1),
            a.data.src = this.transformUrl(a.url, a),
            a.data.load()
        },
        loadAudioTag: function(a) {
            var b = this;
            if (this.game.sound.touchLocked)
                a.data = new Audio,
                a.data.name = a.key,
                a.data.preload = "auto",
                a.data.src = this.transformUrl(a.url, a),
                this.fileComplete(a);
            else {
                a.data = new Audio,
                a.data.name = a.key;
                var c = function() {
                    a.data.removeEventListener("canplaythrough", c, !1),
                    a.data.onerror = null,
                    b.fileComplete(a)
                };
                a.data.onerror = function() {
                    a.data.removeEventListener("canplaythrough", c, !1),
                    a.data.onerror = null,
                    b.fileError(a)
                }
                ,
                a.data.preload = "auto",
                a.data.src = this.transformUrl(a.url, a),
                a.data.addEventListener("canplaythrough", c, !1),
                a.data.load()
            }
        },
        xhrLoad: function(a, b, c, d, e) {
            if (this.useXDomainRequest && window.XDomainRequest)
                return void this.xhrLoadWithXDR(a, b, c, d, e);
            var f = new XMLHttpRequest;
            f.open("GET", b, !0),
            f.responseType = c,
            !1 !== this.headers.requestedWith && f.setRequestHeader("X-Requested-With", this.headers.requestedWith),
            this.headers[a.type] && f.setRequestHeader("Accept", this.headers[a.type]),
            e = e || this.fileError;
            var g = this;
            f.onload = function() {
                try {
                    return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f)
                } catch (b) {
                    g.hasLoaded ? window.console && console.error(b) : g.asyncComplete(a, b.message || "Exception")
                }
            }
            ,
            f.onerror = function() {
                try {
                    return e.call(g, a, f)
                } catch (b) {
                    g.hasLoaded ? window.console && console.error(b) : g.asyncComplete(a, b.message || "Exception")
                }
            }
            ,
            a.requestObject = f,
            a.requestUrl = b,
            f.send()
        },
        xhrLoadWithXDR: function(a, b, c, d, e) {
            this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0,
            console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
            var f = new window.XDomainRequest;
            f.open("GET", b, !0),
            f.responseType = c,
            f.timeout = 3e3,
            e = e || this.fileError;
            var g = this;
            f.onerror = function() {
                try {
                    return e.call(g, a, f)
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception")
                }
            }
            ,
            f.ontimeout = function() {
                try {
                    return e.call(g, a, f)
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception")
                }
            }
            ,
            f.onprogress = function() {}
            ,
            f.onload = function() {
                try {
                    return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f)
                } catch (b) {
                    g.asyncComplete(a, b.message || "Exception")
                }
            }
            ,
            a.requestObject = f,
            a.requestUrl = b,
            setTimeout(function() {
                f.send()
            }, 0)
        },
        getVideoURL: function(a) {
            for (var b = 0; b < a.length; b++) {
                var d, c = a[b];
                if (c.uri) {
                    if (d = c.type,
                    c = c.uri,
                    this.game.device.canPlayVideo(d))
                        return c
                } else {
                    if (0 === c.indexOf("blob:") || 0 === c.indexOf("data:"))
                        return c;
                    c.indexOf("?") >= 0 && (c = c.substr(0, c.indexOf("?")));
                    if (d = c.substr((Math.max(0, c.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(),
                    this.game.device.canPlayVideo(d))
                        return a[b]
                }
            }
            return null
        },
        getAudioURL: function(a) {
            if (this.game.sound.noAudio)
                return null;
            for (var b = 0; b < a.length; b++) {
                var d, c = a[b];
                if (c.uri) {
                    if (d = c.type,
                    c = c.uri,
                    this.game.device.canPlayAudio(d))
                        return c
                } else {
                    if (0 === c.indexOf("blob:") || 0 === c.indexOf("data:"))
                        return c;
                    c.indexOf("?") >= 0 && (c = c.substr(0, c.indexOf("?")));
                    if (d = c.substr((Math.max(0, c.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(),
                    this.game.device.canPlayAudio(d))
                        return a[b]
                }
            }
            return null
        },
        fileError: function(a, b, c) {
            var d = a.requestUrl || this.transformUrl(a.url, a)
              , e = "error loading asset from URL " + d;
            !c && b && (c = b.status),
            c && (e = e + " (" + c + ")"),
            this.asyncComplete(a, e)
        },
        fileComplete: function(a, c) {
            var d = !0;
            switch (a.type) {
            case "packfile":
                var e = JSON.parse(c.responseText);
                a.data = e || {};
                break;
            case "image":
                this.cache.addImage(a.key, a.url, a.data);
                break;
            case "spritesheet":
                this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
                break;
            case "textureatlas":
                if (null == a.atlasURL)
                    this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format);
                else if (d = !1,
                a.format === b.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format === b.Loader.TEXTURE_ATLAS_JSON_HASH || a.format === b.Loader.TEXTURE_ATLAS_JSON_PYXEL)
                    this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete);
                else {
                    if (a.format !== b.Loader.TEXTURE_ATLAS_XML_STARLING)
                        throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                    this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete)
                }
                break;
            case "bitmapfont":
                a.atlasURL ? (d = !1,
                this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function(a, b) {
                    var c;
                    try {
                        c = JSON.parse(b.responseText)
                    } catch (a) {}
                    c ? (a.atlasType = "json",
                    this.jsonLoadComplete(a, b)) : (a.atlasType = "xml",
                    this.xmlLoadComplete(a, b))
                })) : this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
                break;
            case "video":
                if (a.asBlob)
                    try {
                        a.data = c.response
                    } catch (b) {
                        throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key)
                    }
                this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
                break;
            case "audio":
                this.game.sound.usingWebAudio ? (a.data = c.response,
                this.cache.addSound(a.key, a.url, a.data, !0, !1),
                a.autoDecode && this.game.sound.decode(a.key)) : this.cache.addSound(a.key, a.url, a.data, !1, !0);
                break;
            case "text":
                a.data = c.responseText,
                this.cache.addText(a.key, a.url, a.data);
                break;
            case "shader":
                a.data = c.responseText,
                this.cache.addShader(a.key, a.url, a.data);
                break;
            case "physics":
                var e = JSON.parse(c.responseText);
                this.cache.addPhysicsData(a.key, a.url, e, a.format);
                break;
            case "script":
                a.data = document.createElement("script"),
                a.data.language = "javascript",
                a.data.type = "text/javascript",
                a.data.defer = !1,
                a.data.text = c.responseText,
                document.head.appendChild(a.data),
                a.callback && (a.data = a.callback.call(a.callbackContext, a.key, c.responseText));
                break;
            case "binary":
                a.callback ? a.data = a.callback.call(a.callbackContext, a.key, c.response) : a.data = c.response,
                this.cache.addBinary(a.key, a.data)
            }
            d && this.asyncComplete(a)
        },
        jsonLoadComplete: function(a, b) {
            var c = JSON.parse(b.responseText);
            "tilemap" === a.type ? this.cache.addTilemap(a.key, a.url, c, a.format) : "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing) : "json" === a.type ? this.cache.addJSON(a.key, a.url, c) : this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format),
            this.asyncComplete(a)
        },
        csvLoadComplete: function(a, b) {
            var c = b.responseText;
            this.cache.addTilemap(a.key, a.url, c, a.format),
            this.asyncComplete(a)
        },
        xmlLoadComplete: function(a, b) {
            var c = b.responseText
              , d = this.parseXml(c);
            if (!d) {
                var e = b.responseType || b.contentType;
                return console.warn("Phaser.Loader - " + a.key + ": invalid XML (" + e + ")"),
                void this.asyncComplete(a, "invalid XML")
            }
            "bitmapfont" === a.type ? this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing) : "textureatlas" === a.type ? this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format) : "xml" === a.type && this.cache.addXML(a.key, a.url, d),
            this.asyncComplete(a)
        },
        parseXml: function(a) {
            var b;
            try {
                if (window.DOMParser) {
                    var c = new DOMParser;
                    b = c.parseFromString(a, "text/xml")
                } else
                    b = new ActiveXObject("Microsoft.XMLDOM"),
                    b.async = "false",
                    b.loadXML(a)
            } catch (a) {
                b = null
            }
            return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null
        },
        updateProgress: function() {
            this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress),
            this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
        },
        totalLoadedFiles: function() {
            return this._loadedFileCount
        },
        totalQueuedFiles: function() {
            return this._totalFileCount - this._loadedFileCount
        },
        totalLoadedPacks: function() {
            return this._totalPackCount
        },
        totalQueuedPacks: function() {
            return this._totalPackCount - this._loadedPackCount
        }
    },
    Object.defineProperty(b.Loader.prototype, "progressFloat", {
        get: function() {
            var a = this._loadedFileCount / this._totalFileCount * 100;
            return b.Math.clamp(a || 0, 0, 100)
        }
    }),
    Object.defineProperty(b.Loader.prototype, "progress", {
        get: function() {
            return Math.round(this.progressFloat)
        }
    }),
    b.Loader.prototype.constructor = b.Loader,
    b.LoaderParser = {
        bitmapFont: function(a, b, c, d) {
            return this.xmlBitmapFont(a, b, c, d)
        },
        xmlBitmapFont: function(a, b, c, d) {
            var e = {}
              , f = a.getElementsByTagName("info")[0]
              , g = a.getElementsByTagName("common")[0];
            e.font = f.getAttribute("face"),
            e.size = parseInt(f.getAttribute("size"), 10),
            e.lineHeight = parseInt(g.getAttribute("lineHeight"), 10) + d,
            e.chars = {};
            for (var h = a.getElementsByTagName("char"), i = 0; i < h.length; i++) {
                var j = parseInt(h[i].getAttribute("id"), 10);
                e.chars[j] = {
                    x: parseInt(h[i].getAttribute("x"), 10),
                    y: parseInt(h[i].getAttribute("y"), 10),
                    width: parseInt(h[i].getAttribute("width"), 10),
                    height: parseInt(h[i].getAttribute("height"), 10),
                    xOffset: parseInt(h[i].getAttribute("xoffset"), 10),
                    yOffset: parseInt(h[i].getAttribute("yoffset"), 10),
                    xAdvance: parseInt(h[i].getAttribute("xadvance"), 10) + c,
                    kerning: {}
                }
            }
            var k = a.getElementsByTagName("kerning");
            for (i = 0; i < k.length; i++) {
                var l = parseInt(k[i].getAttribute("first"), 10)
                  , m = parseInt(k[i].getAttribute("second"), 10)
                  , n = parseInt(k[i].getAttribute("amount"), 10);
                e.chars[m].kerning[l] = n
            }
            return this.finalizeBitmapFont(b, e)
        },
        jsonBitmapFont: function(a, b, c, d) {
            var e = {
                font: a.font.info._face,
                size: parseInt(a.font.info._size, 10),
                lineHeight: parseInt(a.font.common._lineHeight, 10) + d,
                chars: {}
            };
            return a.font.chars.char.forEach(function(b) {
                var d = parseInt(b._id, 10);
                e.chars[d] = {
                    x: parseInt(b._x, 10),
                    y: parseInt(b._y, 10),
                    width: parseInt(b._width, 10),
                    height: parseInt(b._height, 10),
                    xOffset: parseInt(b._xoffset, 10),
                    yOffset: parseInt(b._yoffset, 10),
                    xAdvance: parseInt(b._xadvance, 10) + c,
                    kerning: {}
                }
            }),
            a.font.kernings && a.font.kernings.kerning && a.font.kernings.kerning.forEach(function(b) {
                e.chars[b._second].kerning[b._first] = parseInt(b._amount, 10)
            }),
            this.finalizeBitmapFont(b, e)
        },
        finalizeBitmapFont: function(a, c) {
            return Object.keys(c.chars).forEach(function(e) {
                var f = c.chars[e];
                f.texture = new PIXI.Texture(a,new b.Rectangle(f.x,f.y,f.width,f.height))
            }),
            c
        }
    },
    b.AudioSprite = function(a, b) {
        this.game = a,
        this.key = b,
        this.config = this.game.cache.getJSON(b + "-audioatlas"),
        this.autoplayKey = null,
        this.autoplay = !1,
        this.sounds = {};
        for (var c in this.config.spritemap) {
            var d = this.config.spritemap[c]
              , e = this.game.add.sound(this.key);
            e.addMarker(c, d.start, d.end - d.start, null, d.loop),
            this.sounds[c] = e
        }
        this.config.autoplay && (this.autoplayKey = this.config.autoplay,
        this.play(this.autoplayKey),
        this.autoplay = this.sounds[this.autoplayKey])
    }
    ,
    b.AudioSprite.prototype = {
        play: function(a, b) {
            return void 0 === b && (b = 1),
            this.sounds[a].play(a, null, b)
        },
        stop: function(a) {
            if (a)
                this.sounds[a].stop();
            else
                for (var b in this.sounds)
                    this.sounds[b].stop()
        },
        get: function(a) {
            return this.sounds[a]
        }
    },
    b.AudioSprite.prototype.constructor = b.AudioSprite,
    b.Sound = function(a, c, d, e, f) {
        void 0 === d && (d = 1),
        void 0 === e && (e = !1),
        void 0 === f && (f = a.sound.connectToMaster),
        this.game = a,
        this.name = c,
        this.key = c,
        this.loop = e,
        this.markers = {},
        this.context = null,
        this.autoplay = !1,
        this.totalDuration = 0,
        this.startTime = 0,
        this.currentTime = 0,
        this.duration = 0,
        this.durationMS = 0,
        this.position = 0,
        this.stopTime = 0,
        this.paused = !1,
        this.pausedPosition = 0,
        this.pausedTime = 0,
        this.isPlaying = !1,
        this.currentMarker = "",
        this.fadeTween = null,
        this.pendingPlayback = !1,
        this.override = !1,
        this.allowMultiple = !1,
        this.usingWebAudio = this.game.sound.usingWebAudio,
        this.usingAudioTag = this.game.sound.usingAudioTag,
        this.externalNode = null,
        this.masterGainNode = null,
        this.gainNode = null,
        this._sound = null,
        this.usingWebAudio ? (this.context = this.game.sound.context,
        this.masterGainNode = this.game.sound.masterGain,
        void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(),
        this.gainNode.gain.value = d * this.game.sound.volume,
        f && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(c) && this.game.cache.isSoundReady(c) ? (this._sound = this.game.cache.getSoundData(c),
        this.totalDuration = 0,
        this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)),
        this.onDecoded = new b.Signal,
        this.onPlay = new b.Signal,
        this.onPause = new b.Signal,
        this.onResume = new b.Signal,
        this.onLoop = new b.Signal,
        this.onStop = new b.Signal,
        this.onMute = new b.Signal,
        this.onMarkerComplete = new b.Signal,
        this.onFadeComplete = new b.Signal,
        this._volume = d,
        this._buffer = null,
        this._muted = !1,
        this._tempMarker = 0,
        this._tempPosition = 0,
        this._tempVolume = 0,
        this._tempPause = 0,
        this._muteVolume = 0,
        this._tempLoop = 0,
        this._paused = !1,
        this._onDecodedEventDispatched = !1
    }
    ,
    b.Sound.prototype = {
        soundHasUnlocked: function(a) {
            a === this.key && (this._sound = this.game.cache.getSoundData(this.key),
            this.totalDuration = this._sound.duration)
        },
        addMarker: function(a, b, c, d, e) {
            void 0 !== c && null !== c || (c = 1),
            void 0 !== d && null !== d || (d = 1),
            void 0 === e && (e = !1),
            this.markers[a] = {
                name: a,
                start: b,
                stop: b + c,
                volume: d,
                duration: c,
                durationMS: 1e3 * c,
                loop: e
            }
        },
        removeMarker: function(a) {
            delete this.markers[a]
        },
        onEndedHandler: function() {
            this._sound.onended = null,
            this.isPlaying = !1,
            this.currentTime = this.durationMS,
            this.stop()
        },
        update: function() {
            if (!this.game.cache.checkSoundKey(this.key))
                return void this.destroy();
            this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this),
            this._onDecodedEventDispatched = !0),
            this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1,
            this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)),
            this.isPlaying && (this.currentTime = this.game.time.time - this.startTime,
            this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this),
            this.isPlaying = !1,
            "" === this.currentMarker ? (this.currentTime = 0,
            this.startTime = this.game.time.time,
            this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this),
            this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this),
            "" === this.currentMarker && (this.currentTime = 0,
            this.startTime = this.game.time.time),
            this.isPlaying = !1,
            this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))
        },
        loopFull: function(a) {
            return this.play(null, 0, a, !0)
        },
        play: function(a, b, c, d, e) {
            if (void 0 !== a && !1 !== a && null !== a || (a = ""),
            void 0 === e && (e = !0),
            this.isPlaying && !this.allowMultiple && !e && !this.override)
                return this;
            if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) {
                if (this.usingWebAudio) {
                    if (void 0 === this._sound.stop)
                        this._sound.noteOff(0);
                    else
                        try {
                            this._sound.stop(0)
                        } catch (a) {}
                    this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                } else
                    this.usingAudioTag && (this._sound.pause(),
                    this._sound.currentTime = 0);
                this.isPlaying = !1
            }
            if ("" === a && Object.keys(this.markers).length > 0)
                return this;
            if ("" !== a) {
                if (!this.markers[a])
                    return console.warn("Phaser.Sound.play: audio marker " + a + " doesn't exist"),
                    this;
                this.currentMarker = a,
                this.position = this.markers[a].start,
                this.volume = this.markers[a].volume,
                this.loop = this.markers[a].loop,
                this.duration = this.markers[a].duration,
                this.durationMS = this.markers[a].durationMS,
                void 0 !== c && (this.volume = c),
                void 0 !== d && (this.loop = d),
                this._tempMarker = a,
                this._tempPosition = this.position,
                this._tempVolume = this.volume,
                this._tempLoop = this.loop
            } else
                b = b || 0,
                void 0 === c && (c = this._volume),
                void 0 === d && (d = this.loop),
                this.position = Math.max(0, b),
                this.volume = c,
                this.loop = d,
                this.duration = 0,
                this.durationMS = 0,
                this._tempMarker = a,
                this._tempPosition = b,
                this._tempVolume = c,
                this._tempLoop = d;
            return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(),
            this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode),
            this._buffer = this.game.cache.getSoundData(this.key),
            this._sound.buffer = this._buffer,
            this.loop && "" === a && (this._sound.loop = !0),
            this.loop || "" !== a || (this._sound.onended = this.onEndedHandler.bind(this)),
            this.totalDuration = this._sound.buffer.duration,
            0 === this.duration && (this.duration = this.totalDuration,
            this.durationMS = Math.ceil(1e3 * this.totalDuration)),
            void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === a ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration),
            this.isPlaying = !0,
            this.startTime = this.game.time.time,
            this.currentTime = 0,
            this.stopTime = this.startTime + this.durationMS,
            this.onPlay.dispatch(this)) : (this.pendingPlayback = !0,
            this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key),
            this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(),
            this.totalDuration = this._sound.duration,
            0 === this.duration && (this.duration = this.totalDuration,
            this.durationMS = 1e3 * this.totalDuration),
            this._sound.currentTime = this.position,
            this._sound.muted = this._muted,
            this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume,
            this.isPlaying = !0,
            this.startTime = this.game.time.time,
            this.currentTime = 0,
            this.stopTime = this.startTime + this.durationMS,
            this.onPlay.dispatch(this)) : this.pendingPlayback = !0,
            this
        },
        restart: function(a, b, c, d) {
            a = a || "",
            b = b || 0,
            c = c || 1,
            void 0 === d && (d = !1),
            this.play(a, b, c, d, !0)
        },
        pause: function() {
            this.isPlaying && this._sound && (this.paused = !0,
            this.pausedPosition = this.currentTime,
            this.pausedTime = this.game.time.time,
            this._tempPause = this._sound.currentTime,
            this.onPause.dispatch(this),
            this.stop())
        },
        resume: function() {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var a = Math.max(0, this.position + this.pausedPosition / 1e3);
                    this._sound = this.context.createBufferSource(),
                    this._sound.buffer = this._buffer,
                    this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode),
                    this.loop && (this._sound.loop = !0),
                    this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                    var b = this.duration - this.pausedPosition / 1e3;
                    void 0 === this._sound.start ? this._sound.noteGrainOn(0, a, b) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, a) : this._sound.start(0, a, b)
                } else
                    this._sound.currentTime = this._tempPause,
                    this._sound.play();
                this.isPlaying = !0,
                this.paused = !1,
                this.startTime += this.game.time.time - this.pausedTime,
                this.onResume.dispatch(this)
            }
        },
        stop: function() {
            if (this.isPlaying && this._sound)
                if (this.usingWebAudio) {
                    if (void 0 === this._sound.stop)
                        this._sound.noteOff(0);
                    else
                        try {
                            this._sound.stop(0)
                        } catch (a) {}
                    this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                } else
                    this.usingAudioTag && (this._sound.pause(),
                    this._sound.currentTime = 0);
            if (this.pendingPlayback = !1,
            this.isPlaying = !1,
            !this.paused) {
                var a = this.currentMarker;
                "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this),
                this.currentMarker = "",
                null !== this.fadeTween && this.fadeTween.stop(),
                this.onStop.dispatch(this, a)
            }
        },
        fadeIn: function(a, b, c) {
            void 0 === b && (b = !1),
            void 0 === c && (c = this.currentMarker),
            this.paused || (this.play(c, 0, 0, b),
            this.fadeTo(a, 1))
        },
        fadeOut: function(a) {
            this.fadeTo(a, 0)
        },
        fadeTo: function(a, c) {
            if (this.isPlaying && !this.paused && c !== this.volume) {
                if (void 0 === a && (a = 1e3),
                void 0 === c)
                    return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
                this.fadeTween = this.game.add.tween(this).to({
                    volume: c
                }, a, b.Easing.Linear.None, !0),
                this.fadeTween.onComplete.add(this.fadeComplete, this)
            }
        },
        fadeComplete: function() {
            this.onFadeComplete.dispatch(this, this.volume),
            0 === this.volume && this.stop()
        },
        updateGlobalVolume: function(a) {
            this.usingAudioTag && this._sound && (this._sound.volume = a * this._volume)
        },
        destroy: function(a) {
            void 0 === a && (a = !0),
            this.stop(),
            a ? this.game.sound.remove(this) : (this.markers = {},
            this.context = null,
            this._buffer = null,
            this.externalNode = null,
            this.onDecoded.dispose(),
            this.onPlay.dispose(),
            this.onPause.dispose(),
            this.onResume.dispose(),
            this.onLoop.dispose(),
            this.onStop.dispose(),
            this.onMute.dispose(),
            this.onMarkerComplete.dispose())
        }
    },
    b.Sound.prototype.constructor = b.Sound,
    Object.defineProperty(b.Sound.prototype, "isDecoding", {
        get: function() {
            return this.game.cache.getSound(this.key).isDecoding
        }
    }),
    Object.defineProperty(b.Sound.prototype, "isDecoded", {
        get: function() {
            return this.game.cache.isSoundDecoded(this.key)
        }
    }),
    Object.defineProperty(b.Sound.prototype, "mute", {
        get: function() {
            return this._muted || this.game.sound.mute
        },
        set: function(a) {
            (a = a || !1) !== this._muted && (a ? (this._muted = !0,
            this._muteVolume = this._tempVolume,
            this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1,
            this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)),
            this.onMute.dispatch(this))
        }
    }),
    Object.defineProperty(b.Sound.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            if (this.game.device.firefox && this.usingAudioTag && (a = this.game.math.clamp(a, 0, 1)),
            this._muted)
                return void (this._muteVolume = a);
            this._tempVolume = a,
            this._volume = a,
            this.usingWebAudio ? this.gainNode.gain.value = a : this.usingAudioTag && this._sound && (this._sound.volume = a)
        }
    }),
    b.SoundManager = function(a) {
        this.game = a,
        this.onSoundDecode = new b.Signal,
        this.onVolumeChange = new b.Signal,
        this.onMute = new b.Signal,
        this.onUnMute = new b.Signal,
        this.context = null,
        this.usingWebAudio = !1,
        this.usingAudioTag = !1,
        this.noAudio = !1,
        this.connectToMaster = !0,
        this.touchLocked = !1,
        this.channels = 32,
        this.muteOnPause = !0,
        this._codeMuted = !1,
        this._muted = !1,
        this._unlockSource = null,
        this._volume = 1,
        this._sounds = [],
        this._watchList = new b.ArraySet,
        this._watching = !1,
        this._watchCallback = null,
        this._watchContext = null
    }
    ,
    b.SoundManager.prototype = {
        boot: function() {
            if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1),
            window.PhaserGlobal) {
                if (!0 === window.PhaserGlobal.disableAudio)
                    return this.noAudio = !0,
                    void (this.touchLocked = !1);
                if (!0 === window.PhaserGlobal.disableWebAudio)
                    return this.usingAudioTag = !0,
                    void (this.touchLocked = !1)
            }
            if (window.PhaserGlobal && window.PhaserGlobal.audioContext)
                this.context = window.PhaserGlobal.audioContext;
            else if (window.AudioContext)
                try {
                    this.context = new window.AudioContext
                } catch (a) {
                    this.context = null,
                    this.usingWebAudio = !1,
                    this.touchLocked = !1
                }
            else if (window.webkitAudioContext)
                try {
                    this.context = new window.webkitAudioContext
                } catch (a) {
                    this.context = null,
                    this.usingWebAudio = !1,
                    this.touchLocked = !1
                }
            if (null === this.context) {
                if (void 0 === window.Audio)
                    return void (this.noAudio = !0);
                this.usingAudioTag = !0
            } else
                this.usingWebAudio = !0,
                void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(),
                this.masterGain.gain.value = 1,
                this.masterGain.connect(this.context.destination);
            this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
        },
        setTouchLock: function() {
            this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this),
            this.touchLocked = !0)
        },
        unlock: function() {
            if (this.noAudio || !this.touchLocked || null !== this._unlockSource)
                return !0;
            if (this.usingAudioTag)
                this.touchLocked = !1,
                this._unlockSource = null;
            else if (this.usingWebAudio) {
                var a = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource(),
                this._unlockSource.buffer = a,
                this._unlockSource.connect(this.context.destination),
                void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
            }
            return !0
        },
        stopAll: function() {
            if (!this.noAudio)
                for (var a = 0; a < this._sounds.length; a++)
                    this._sounds[a] && this._sounds[a].stop()
        },
        pauseAll: function() {
            if (!this.noAudio)
                for (var a = 0; a < this._sounds.length; a++)
                    this._sounds[a] && this._sounds[a].pause()
        },
        resumeAll: function() {
            if (!this.noAudio)
                for (var a = 0; a < this._sounds.length; a++)
                    this._sounds[a] && this._sounds[a].resume()
        },
        decode: function(a, b) {
            b = b || null;
            var c = this.game.cache.getSoundData(a);
            if (c && !1 === this.game.cache.isSoundDecoded(a)) {
                this.game.cache.updateSound(a, "isDecoding", !0);
                var d = this;
                try {
                    this.context.decodeAudioData(c, function(c) {
                        c && (d.game.cache.decodedSound(a, c),
                        d.onSoundDecode.dispatch(a, b))
                    })
                } catch (a) {}
            }
        },
        setDecodedCallback: function(a, c, d) {
            "string" == typeof a && (a = [a]),
            this._watchList.reset();
            for (var e = 0; e < a.length; e++)
                a[e]instanceof b.Sound ? this.game.cache.isSoundDecoded(a[e].key) || this._watchList.add(a[e].key) : this.game.cache.isSoundDecoded(a[e]) || this._watchList.add(a[e]);
            0 === this._watchList.total ? (this._watching = !1,
            c.call(d)) : (this._watching = !0,
            this._watchCallback = c,
            this._watchContext = d)
        },
        update: function() {
            if (!this.noAudio) {
                !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1,
                this._unlockSource = null);
                for (var a = 0; a < this._sounds.length; a++)
                    this._sounds[a].update();
                if (this._watching) {
                    for (var b = this._watchList.first; b; )
                        this.game.cache.isSoundDecoded(b) && this._watchList.remove(b),
                        b = this._watchList.next;
                    0 === this._watchList.total && (this._watching = !1,
                    this._watchCallback.call(this._watchContext))
                }
            }
        },
        add: function(a, c, d, e) {
            void 0 === c && (c = 1),
            void 0 === d && (d = !1),
            void 0 === e && (e = this.connectToMaster);
            var f = new b.Sound(this.game,a,c,d,e);
            return this._sounds.push(f),
            f
        },
        addSprite: function(a) {
            return new b.AudioSprite(this.game,a)
        },
        remove: function(a) {
            for (var b = this._sounds.length; b--; )
                if (this._sounds[b] === a)
                    return this._sounds[b].destroy(!1),
                    this._sounds.splice(b, 1),
                    !0;
            return !1
        },
        removeByKey: function(a) {
            for (var b = this._sounds.length, c = 0; b--; )
                this._sounds[b].key === a && (this._sounds[b].destroy(!1),
                this._sounds.splice(b, 1),
                c++);
            return c
        },
        play: function(a, b, c) {
            if (!this.noAudio) {
                var d = this.add(a, b, c);
                return d.play(),
                d
            }
        },
        setMute: function() {
            if (!this._muted) {
                this._muted = !0,
                this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value,
                this.masterGain.gain.value = 0);
                for (var a = 0; a < this._sounds.length; a++)
                    this._sounds[a].usingAudioTag && (this._sounds[a].mute = !0);
                this.onMute.dispatch()
            }
        },
        unsetMute: function() {
            if (this._muted && !this._codeMuted) {
                this._muted = !1,
                this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                for (var a = 0; a < this._sounds.length; a++)
                    this._sounds[a].usingAudioTag && (this._sounds[a].mute = !1);
                this.onUnMute.dispatch()
            }
        },
        destroy: function() {
            this.stopAll();
            for (var a = 0; a < this._sounds.length; a++)
                this._sounds[a] && this._sounds[a].destroy();
            this._sounds = [],
            this.onSoundDecode.dispose(),
            this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
        }
    },
    b.SoundManager.prototype.constructor = b.SoundManager,
    Object.defineProperty(b.SoundManager.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(a) {
            if (a = a || !1) {
                if (this._muted)
                    return;
                this._codeMuted = !0,
                this.setMute()
            } else {
                if (!this._muted)
                    return;
                this._codeMuted = !1,
                this.unsetMute()
            }
        }
    }),
    Object.defineProperty(b.SoundManager.prototype, "volume", {
        get: function() {
            return this._volume
        },
        set: function(a) {
            if (a < 0 ? a = 0 : a > 1 && (a = 1),
            this._volume !== a) {
                if (this._volume = a,
                this.usingWebAudio)
                    this.masterGain.gain.value = a;
                else
                    for (var b = 0; b < this._sounds.length; b++)
                        this._sounds[b].usingAudioTag && this._sounds[b].updateGlobalVolume(a);
                this.onVolumeChange.dispatch(a)
            }
        }
    }),
    b.ScaleManager = function(a, c, d) {
        this.game = a,
        this.dom = b.DOM,
        this.grid = null,
        this.width = 0,
        this.height = 0,
        this.minWidth = null,
        this.maxWidth = null,
        this.minHeight = null,
        this.maxHeight = null,
        this.offset = new b.Point,
        this.forceLandscape = !1,
        this.forcePortrait = !1,
        this.incorrectOrientation = !1,
        this._pageAlignHorizontally = !1,
        this._pageAlignVertically = !1,
        this.onOrientationChange = new b.Signal,
        this.enterIncorrectOrientation = new b.Signal,
        this.leaveIncorrectOrientation = new b.Signal,
        this.hasPhaserSetFullScreen = !1,
        this.fullScreenTarget = null,
        this._createdFullScreenTarget = null,
        this.onFullScreenInit = new b.Signal,
        this.onFullScreenChange = new b.Signal,
        this.onFullScreenError = new b.Signal,
        this.screenOrientation = this.dom.getScreenOrientation(),
        this.scaleFactor = new b.Point(1,1),
        this.scaleFactorInversed = new b.Point(1,1),
        this.margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            x: 0,
            y: 0
        },
        this.bounds = new b.Rectangle,
        this.aspectRatio = 0,
        this.sourceAspectRatio = 0,
        this.event = null,
        this.windowConstraints = {
            right: "layout",
            bottom: ""
        },
        this.compatibility = {
            supportsFullScreen: !1,
            orientationFallback: null,
            noMargins: !1,
            scrollTo: null,
            forceMinimumDocumentHeight: !1,
            canExpandParent: !0,
            clickTrampoline: ""
        },
        this._scaleMode = b.ScaleManager.NO_SCALE,
        this._fullScreenScaleMode = b.ScaleManager.NO_SCALE,
        this.parentIsWindow = !1,
        this.parentNode = null,
        this.parentScaleFactor = new b.Point(1,1),
        this.trackParentInterval = 2e3,
        this.onSizeChange = new b.Signal,
        this.onResize = null,
        this.onResizeContext = null,
        this._pendingScaleMode = null,
        this._fullScreenRestore = null,
        this._gameSize = new b.Rectangle,
        this._userScaleFactor = new b.Point(1,1),
        this._userScaleTrim = new b.Point(0,0),
        this._lastUpdate = 0,
        this._updateThrottle = 0,
        this._updateThrottleReset = 100,
        this._parentBounds = new b.Rectangle,
        this._tempBounds = new b.Rectangle,
        this._lastReportedCanvasSize = new b.Rectangle,
        this._lastReportedGameSize = new b.Rectangle,
        this._booted = !1,
        a.config && this.parseConfig(a.config),
        this.setupScale(c, d)
    }
    ,
    b.ScaleManager.EXACT_FIT = 0,
    b.ScaleManager.NO_SCALE = 1,
    b.ScaleManager.SHOW_ALL = 2,
    b.ScaleManager.RESIZE = 3,
    b.ScaleManager.USER_SCALE = 4,
    b.ScaleManager.prototype = {
        boot: function() {
            var a = this.compatibility;
            a.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS,
            this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? a.scrollTo = new b.Point(0,1) : a.scrollTo = new b.Point(0,0)),
            this.game.device.desktop ? (a.orientationFallback = "screen",
            a.clickTrampoline = "when-not-mouse") : (a.orientationFallback = "",
            a.clickTrampoline = "");
            var c = this;
            this._orientationChange = function(a) {
                return c.orientationChange(a)
            }
            ,
            this._windowResize = function(a) {
                return c.windowResize(a)
            }
            ,
            window.addEventListener("orientationchange", this._orientationChange, !1),
            window.addEventListener("resize", this._windowResize, !1),
            this.compatibility.supportsFullScreen && (this._fullScreenChange = function(a) {
                return c.fullScreenChange(a)
            }
            ,
            this._fullScreenError = function(a) {
                return c.fullScreenError(a)
            }
            ,
            document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1),
            document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1),
            document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1),
            document.addEventListener("fullscreenchange", this._fullScreenChange, !1),
            document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1),
            document.addEventListener("mozfullscreenerror", this._fullScreenError, !1),
            document.addEventListener("MSFullscreenError", this._fullScreenError, !1),
            document.addEventListener("fullscreenerror", this._fullScreenError, !1)),
            this.game.onResume.add(this._gameResumed, this),
            this.dom.getOffset(this.game.canvas, this.offset),
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
            this.setGameSize(this.game.width, this.game.height),
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback),
            b.FlexGrid && (this.grid = new b.FlexGrid(this,this.width,this.height)),
            this._booted = !0,
            null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode,
            this._pendingScaleMode = null)
        },
        parseConfig: function(a) {
            void 0 !== a.scaleMode && (this._booted ? this.scaleMode = a.scaleMode : this._pendingScaleMode = a.scaleMode),
            void 0 !== a.fullScreenScaleMode && (this.fullScreenScaleMode = a.fullScreenScaleMode),
            a.fullScreenTarget && (this.fullScreenTarget = a.fullScreenTarget)
        },
        setupScale: function(a, c) {
            var d, e = new b.Rectangle;
            "" !== this.game.parent && ("string" == typeof this.game.parent ? d = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (d = this.game.parent)),
            d ? (this.parentNode = d,
            this.parentIsWindow = !1,
            this.getParentBounds(this._parentBounds),
            e.width = this._parentBounds.width,
            e.height = this._parentBounds.height,
            this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null,
            this.parentIsWindow = !0,
            e.width = this.dom.visualBounds.width,
            e.height = this.dom.visualBounds.height,
            this.offset.set(0, 0));
            var f = 0
              , g = 0;
            "number" == typeof a ? f = a : (this.parentScaleFactor.x = parseInt(a, 10) / 100,
            f = e.width * this.parentScaleFactor.x),
            "number" == typeof c ? g = c : (this.parentScaleFactor.y = parseInt(c, 10) / 100,
            g = e.height * this.parentScaleFactor.y),
            f = Math.floor(f),
            g = Math.floor(g),
            this._gameSize.setTo(0, 0, f, g),
            this.updateDimensions(f, g, !1)
        },
        _gameResumed: function() {
            this.queueUpdate(!0)
        },
        setGameSize: function(a, c) {
            this._gameSize.setTo(0, 0, a, c),
            this.currentScaleMode !== b.ScaleManager.RESIZE && this.updateDimensions(a, c, !0),
            this.queueUpdate(!0)
        },
        setUserScale: function(a, b, c, d) {
            this._userScaleFactor.setTo(a, b),
            this._userScaleTrim.setTo(0 | c, 0 | d),
            this.queueUpdate(!0)
        },
        setResizeCallback: function(a, b) {
            this.onResize = a,
            this.onResizeContext = b
        },
        signalSizeChange: function() {
            if (!b.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !b.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                var a = this.width
                  , c = this.height;
                this._lastReportedCanvasSize.setTo(0, 0, a, c),
                this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height),
                this.grid && this.grid.onResize(a, c),
                this.onSizeChange.dispatch(this, a, c),
                this.currentScaleMode === b.ScaleManager.RESIZE && (this.game.state.resize(a, c),
                this.game.load.resize(a, c))
            }
        },
        setMinMax: function(a, b, c, d) {
            this.minWidth = a,
            this.minHeight = b,
            void 0 !== c && (this.maxWidth = c),
            void 0 !== d && (this.maxHeight = d)
        },
        preUpdate: function() {
            if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                var a = this._updateThrottle;
                this._updateThrottleReset = a >= 400 ? 0 : 100,
                this.dom.getOffset(this.game.canvas, this.offset);
                var c = this._parentBounds.width
                  , d = this._parentBounds.height
                  , e = this.getParentBounds(this._parentBounds)
                  , f = e.width !== c || e.height !== d
                  , g = this.updateOrientationState();
                (f || g) && (this.onResize && this.onResize.call(this.onResizeContext, this, e),
                this.updateLayout(),
                this.signalSizeChange());
                var h = 2 * this._updateThrottle;
                this._updateThrottle < a && (h = Math.min(a, this._updateThrottleReset)),
                this._updateThrottle = b.Math.clamp(h, 25, this.trackParentInterval),
                this._lastUpdate = this.game.time.time
            }
        },
        pauseUpdate: function() {
            this.preUpdate(),
            this._updateThrottle = this.trackParentInterval
        },
        updateDimensions: function(a, b, c) {
            this.width = a * this.parentScaleFactor.x,
            this.height = b * this.parentScaleFactor.y,
            this.game.width = this.width,
            this.game.height = this.height,
            this.sourceAspectRatio = this.width / this.height,
            this.updateScalingAndBounds(),
            c && (this.game.renderer.resize(this.width, this.height),
            this.game.camera.setSize(this.width, this.height),
            this.game.world.resize(this.width, this.height))
        },
        updateScalingAndBounds: function() {
            this.scaleFactor.x = this.game.width / this.width,
            this.scaleFactor.y = this.game.height / this.height,
            this.scaleFactorInversed.x = this.width / this.game.width,
            this.scaleFactorInversed.y = this.height / this.game.height,
            this.aspectRatio = this.width / this.height,
            this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset),
            this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height),
            this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
        },
        forceOrientation: function(a, b) {
            void 0 === b && (b = !1),
            this.forceLandscape = a,
            this.forcePortrait = b,
            this.queueUpdate(!0)
        },
        classifyOrientation: function(a) {
            return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null
        },
        updateOrientationState: function() {
            var a = this.screenOrientation
              , b = this.incorrectOrientation;
            this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback),
            this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
            var c = a !== this.screenOrientation
              , d = b !== this.incorrectOrientation;
            return d && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()),
            (c || d) && this.onOrientationChange.dispatch(this, a, b),
            c || d
        },
        orientationChange: function(a) {
            this.event = a,
            this.queueUpdate(!0)
        },
        windowResize: function(a) {
            this.event = a,
            this.queueUpdate(!0)
        },
        scrollTop: function() {
            var a = this.compatibility.scrollTo;
            a && window.scrollTo(a.x, a.y)
        },
        refresh: function() {
            this.scrollTop(),
            this.queueUpdate(!0)
        },
        updateLayout: function() {
            var a = this.currentScaleMode;
            if (a === b.ScaleManager.RESIZE)
                return void this.reflowGame();
            if (this.scrollTop(),
            this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"),
            this.incorrectOrientation ? this.setMaximum() : a === b.ScaleManager.EXACT_FIT ? this.setExactFit() : a === b.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0),
            this.resetCanvas(),
            this.setShowAll()) : this.setShowAll() : a === b.ScaleManager.NO_SCALE ? (this.width = this.game.width,
            this.height = this.game.height) : a === b.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x,
            this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y),
            !this.compatibility.canExpandParent && (a === b.ScaleManager.SHOW_ALL || a === b.ScaleManager.USER_SCALE)) {
                var c = this.getParentBounds(this._tempBounds);
                this.width = Math.min(this.width, c.width),
                this.height = Math.min(this.height, c.height)
            }
            this.width = 0 | this.width,
            this.height = 0 | this.height,
            this.reflowCanvas()
        },
        getParentBounds: function(a) {
            var c = a || new b.Rectangle
              , d = this.boundingParent
              , e = this.dom.visualBounds
              , f = this.dom.layoutBounds;
            if (d) {
                var g = d.getBoundingClientRect()
                  , h = d.offsetParent ? d.offsetParent.getBoundingClientRect() : d.getBoundingClientRect();
                c.setTo(g.left - h.left, g.top - h.top, g.width, g.height);
                var i = this.windowConstraints;
                if (i.right) {
                    var j = "layout" === i.right ? f : e;
                    c.right = Math.min(c.right, j.width)
                }
                if (i.bottom) {
                    var j = "layout" === i.bottom ? f : e;
                    c.bottom = Math.min(c.bottom, j.height)
                }
            } else
                c.setTo(0, 0, e.width, e.height);
            return c.setTo(Math.round(c.x), Math.round(c.y), Math.round(c.width), Math.round(c.height)),
            c
        },
        alignCanvas: function(a, b) {
            var c = this.getParentBounds(this._tempBounds)
              , d = this.game.canvas
              , e = this.margin;
            if (a) {
                e.left = e.right = 0;
                var f = d.getBoundingClientRect();
                if (this.width < c.width && !this.incorrectOrientation) {
                    var g = f.left - c.x
                      , h = c.width / 2 - this.width / 2;
                    h = Math.max(h, 0);
                    var i = h - g;
                    e.left = Math.round(i)
                }
                d.style.marginLeft = e.left + "px",
                0 !== e.left && (e.right = -(c.width - f.width - e.left),
                d.style.marginRight = e.right + "px")
            }
            if (b) {
                e.top = e.bottom = 0;
                var f = d.getBoundingClientRect();
                if (this.height < c.height && !this.incorrectOrientation) {
                    var g = f.top - c.y
                      , h = c.height / 2 - this.height / 2;
                    h = Math.max(h, 0);
                    var i = h - g;
                    e.top = Math.round(i)
                }
                d.style.marginTop = e.top + "px",
                0 !== e.top && (e.bottom = -(c.height - f.height - e.top),
                d.style.marginBottom = e.bottom + "px")
            }
            e.x = e.left,
            e.y = e.top
        },
        reflowGame: function() {
            this.resetCanvas("", "");
            var a = this.getParentBounds(this._tempBounds);
            this.updateDimensions(a.width, a.height, !0)
        },
        reflowCanvas: function() {
            this.incorrectOrientation || (this.width = b.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width),
            this.height = b.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)),
            this.resetCanvas(),
            this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)),
            this.updateScalingAndBounds()
        },
        resetCanvas: function(a, b) {
            void 0 === a && (a = this.width + "px"),
            void 0 === b && (b = this.height + "px");
            var c = this.game.canvas;
            this.compatibility.noMargins || (c.style.marginLeft = "",
            c.style.marginTop = "",
            c.style.marginRight = "",
            c.style.marginBottom = ""),
            c.style.width = a,
            c.style.height = b
        },
        queueUpdate: function(a) {
            a && (this._parentBounds.width = 0,
            this._parentBounds.height = 0),
            this._updateThrottle = this._updateThrottleReset
        },
        reset: function(a) {
            a && this.grid && this.grid.reset()
        },
        setMaximum: function() {
            this.width = this.dom.visualBounds.width,
            this.height = this.dom.visualBounds.height
        },
        setShowAll: function(a) {
            var e, b = this.getParentBounds(this._tempBounds), c = b.width, d = b.height;
            e = a ? Math.max(d / this.game.height, c / this.game.width) : Math.min(d / this.game.height, c / this.game.width),
            this.width = Math.round(this.game.width * e),
            this.height = Math.round(this.game.height * e)
        },
        setExactFit: function() {
            var a = this.getParentBounds(this._tempBounds);
            this.width = a.width,
            this.height = a.height,
            this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)),
            this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
        },
        createFullScreenTarget: function() {
            var a = document.createElement("div");
            return a.style.margin = "0",
            a.style.padding = "0",
            a.style.background = "#000",
            a
        },
        startFullScreen: function(a, c) {
            if (this.isFullScreen)
                return !1;
            if (!this.compatibility.supportsFullScreen) {
                var d = this;
                return void setTimeout(function() {
                    d.fullScreenError()
                }, 10)
            }
            if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                var e = this.game.input;
                if (e.activePointer && e.activePointer !== e.mousePointer && (c || !1 !== c))
                    return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [a, !1])
            }
            void 0 !== a && this.game.renderType === b.CANVAS && (this.game.stage.smoothed = a);
            var f = this.fullScreenTarget;
            f || (this.cleanupCreatedTarget(),
            this._createdFullScreenTarget = this.createFullScreenTarget(),
            f = this._createdFullScreenTarget);
            var g = {
                targetElement: f
            };
            if (this.hasPhaserSetFullScreen = !0,
            this.onFullScreenInit.dispatch(this, g),
            this._createdFullScreenTarget) {
                var h = this.game.canvas;
                h.parentNode.insertBefore(f, h),
                f.appendChild(h)
            }
            return this.game.device.fullscreenKeyboard ? f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : f[this.game.device.requestFullscreen](),
            !0
        },
        stopFullScreen: function() {
            return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1,
            document[this.game.device.cancelFullscreen](),
            !0)
        },
        cleanupCreatedTarget: function() {
            var a = this._createdFullScreenTarget;
            if (a && a.parentNode) {
                var b = a.parentNode;
                b.insertBefore(this.game.canvas, a),
                b.removeChild(a)
            }
            this._createdFullScreenTarget = null
        },
        prepScreenMode: function(a) {
            var c = !!this._createdFullScreenTarget
              , d = this._createdFullScreenTarget || this.fullScreenTarget;
            a ? (c || this.fullScreenScaleMode === b.ScaleManager.EXACT_FIT) && d !== this.game.canvas && (this._fullScreenRestore = {
                targetWidth: d.style.width,
                targetHeight: d.style.height
            },
            d.style.width = "100%",
            d.style.height = "100%") : (this._fullScreenRestore && (d.style.width = this._fullScreenRestore.targetWidth,
            d.style.height = this._fullScreenRestore.targetHeight,
            this._fullScreenRestore = null),
            this.updateDimensions(this._gameSize.width, this._gameSize.height, !0),
            this.resetCanvas())
        },
        fullScreenChange: function(a) {
            this.event = a,
            this.isFullScreen ? (this.prepScreenMode(!0),
            this.updateLayout(),
            this.queueUpdate(!0)) : (this.prepScreenMode(!1),
            this.cleanupCreatedTarget(),
            this.updateLayout(),
            this.queueUpdate(!0)),
            this.onFullScreenChange.dispatch(this, this.width, this.height)
        },
        fullScreenError: function(a) {
            this.event = a,
            this.cleanupCreatedTarget(),
            console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"),
            this.onFullScreenError.dispatch(this)
        },
        scaleSprite: function(a, b, c, d) {
            if (void 0 === b && (b = this.width),
            void 0 === c && (c = this.height),
            void 0 === d && (d = !1),
            !a || !a.scale)
                return a;
            if (a.scale.x = 1,
            a.scale.y = 1,
            a.width <= 0 || a.height <= 0 || b <= 0 || c <= 0)
                return a;
            var e = b
              , f = a.height * b / a.width
              , g = a.width * c / a.height
              , h = c
              , i = g > b;
            return i = i ? d : !d,
            i ? (a.width = Math.floor(e),
            a.height = Math.floor(f)) : (a.width = Math.floor(g),
            a.height = Math.floor(h)),
            a
        },
        destroy: function() {
            this.game.onResume.remove(this._gameResumed, this),
            window.removeEventListener("orientationchange", this._orientationChange, !1),
            window.removeEventListener("resize", this._windowResize, !1),
            this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1),
            document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1),
            document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1),
            document.removeEventListener("fullscreenchange", this._fullScreenChange, !1),
            document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1),
            document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1),
            document.removeEventListener("MSFullscreenError", this._fullScreenError, !1),
            document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
        }
    },
    b.ScaleManager.prototype.constructor = b.ScaleManager,
    Object.defineProperty(b.ScaleManager.prototype, "boundingParent", {
        get: function() {
            return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "scaleMode", {
        get: function() {
            return this._scaleMode
        },
        set: function(a) {
            return a !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0),
            this.queueUpdate(!0)),
            this._scaleMode = a),
            this._scaleMode
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "fullScreenScaleMode", {
        get: function() {
            return this._fullScreenScaleMode
        },
        set: function(a) {
            return a !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1),
            this._fullScreenScaleMode = a,
            this.prepScreenMode(!0),
            this.queueUpdate(!0)) : this._fullScreenScaleMode = a),
            this._fullScreenScaleMode
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "currentScaleMode", {
        get: function() {
            return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "pageAlignHorizontally", {
        get: function() {
            return this._pageAlignHorizontally
        },
        set: function(a) {
            a !== this._pageAlignHorizontally && (this._pageAlignHorizontally = a,
            this.queueUpdate(!0))
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "pageAlignVertically", {
        get: function() {
            return this._pageAlignVertically
        },
        set: function(a) {
            a !== this._pageAlignVertically && (this._pageAlignVertically = a,
            this.queueUpdate(!0))
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "isFullScreen", {
        get: function() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "isPortrait", {
        get: function() {
            return "portrait" === this.classifyOrientation(this.screenOrientation)
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "isLandscape", {
        get: function() {
            return "landscape" === this.classifyOrientation(this.screenOrientation)
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "isGamePortrait", {
        get: function() {
            return this.height > this.width
        }
    }),
    Object.defineProperty(b.ScaleManager.prototype, "isGameLandscape", {
        get: function() {
            return this.width > this.height
        }
    }),
    b.Utils.Debug = function(a) {
        this.game = a,
        this.sprite = null,
        this.bmd = null,
        this.canvas = null,
        this.context = null,
        this.font = "14px Courier",
        this.columnWidth = 100,
        this.lineHeight = 16,
        this.renderShadow = !0,
        this.currentX = 0,
        this.currentY = 0,
        this.currentAlpha = 1,
        this.dirty = !1
    }
    ,
    b.Utils.Debug.prototype = {
        boot: function() {
            this.game.renderType === b.CANVAS ? this.context = this.game.context : (this.bmd = new b.BitmapData(this.game,"__DEBUG",this.game.width,this.game.height,!0),
            this.sprite = this.game.make.image(0, 0, this.bmd),
            this.game.stage.addChild(this.sprite),
            this.game.scale.onSizeChange.add(this.resize, this),
            this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height),
            this.context = this.canvas.getContext("2d"))
        },
        resize: function(a, b, c) {
            this.bmd.resize(b, c),
            this.canvas.width = b,
            this.canvas.height = c
        },
        preUpdate: function() {
            this.dirty && this.sprite && (this.bmd.clear(),
            this.bmd.draw(this.canvas, 0, 0),
            this.context.clearRect(0, 0, this.game.width, this.game.height),
            this.dirty = !1)
        },
        reset: function() {
            this.context && this.context.clearRect(0, 0, this.game.width, this.game.height),
            this.sprite && this.bmd.clear()
        },
        start: function(a, b, c, d) {
            "number" != typeof a && (a = 0),
            "number" != typeof b && (b = 0),
            c = c || "rgb(255,255,255)",
            void 0 === d && (d = 0),
            this.currentX = a,
            this.currentY = b,
            this.currentColor = c,
            this.columnWidth = d,
            this.dirty = !0,
            this.context.save(),
            this.context.setTransform(1, 0, 0, 1, 0, 0),
            this.context.strokeStyle = c,
            this.context.fillStyle = c,
            this.context.font = this.font,
            this.context.globalAlpha = this.currentAlpha
        },
        stop: function() {
            this.context.restore()
        },
        line: function() {
            for (var a = this.currentX, b = 0; b < arguments.length; b++)
                this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)",
                this.context.fillText(arguments[b], a + 1, this.currentY + 1),
                this.context.fillStyle = this.currentColor),
                this.context.fillText(arguments[b], a, this.currentY),
                a += this.columnWidth;
            this.currentY += this.lineHeight
        },
        soundInfo: function(a, b, c, d) {
            this.start(b, c, d),
            this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked),
            this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback),
            this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding),
            this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying),
            this.line("Time: " + a.currentTime),
            this.line("Volume: " + a.volume + " Muted: " + a.mute),
            this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag),
            "" !== a.currentMarker && (this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")"),
            this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop),
            this.line("Position: " + a.position)),
            this.stop()
        },
        cameraInfo: function(a, b, c, d) {
            this.start(b, c, d),
            this.line("Camera (" + a.width + " x " + a.height + ")"),
            this.line("X: " + a.x + " Y: " + a.y),
            a.bounds && this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height),
            this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height),
            this.line("Total in view: " + a.totalInView),
            this.stop()
        },
        timer: function(a, b, c, d) {
            this.start(b, c, d),
            this.line("Timer (running: " + a.running + " expired: " + a.expired + ")"),
            this.line("Next Tick: " + a.next + " Duration: " + a.duration),
            this.line("Paused: " + a.paused + " Length: " + a.length),
            this.stop()
        },
        pointer: function(a, b, c, d, e) {
            null != a && (void 0 === b && (b = !1),
            c = c || "rgba(0,255,0,0.5)",
            d = d || "rgba(255,0,0,0.5)",
            !0 === b && !0 === a.isUp || (this.start(a.x, a.y - 100, e),
            this.context.beginPath(),
            this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI),
            a.active ? this.context.fillStyle = c : this.context.fillStyle = d,
            this.context.fill(),
            this.context.closePath(),
            this.context.beginPath(),
            this.context.moveTo(a.positionDown.x, a.positionDown.y),
            this.context.lineTo(a.position.x, a.position.y),
            this.context.lineWidth = 2,
            this.context.stroke(),
            this.context.closePath(),
            this.line("ID: " + a.id + " Active: " + a.active),
            this.line("World X: " + a.worldX + " World Y: " + a.worldY),
            this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame),
            this.line("Duration: " + a.duration + " ms"),
            this.line("is Down: " + a.isDown + " is Up: " + a.isUp),
            this.stop()))
        },
        spriteInputInfo: function(a, b, c, d) {
            this.start(b, c, d),
            this.line("Sprite Input: (" + a.width + " x " + a.height + ")"),
            this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1)),
            this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0)),
            this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0)),
            this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut()),
            this.stop()
        },
        key: function(a, b, c, d) {
            this.start(b, c, d, 150),
            this.line("Key:", a.keyCode, "isDown:", a.isDown),
            this.line("justDown:", a.justDown, "justUp:", a.justUp),
            this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0)),
            this.stop()
        },
        inputInfo: function(a, b, c) {
            this.start(a, b, c),
            this.line("Input"),
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y),
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY),
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)),
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY),
            this.stop()
        },
        spriteBounds: function(a, b, c) {
            var d = a.getBounds();
            d.x += this.game.camera.x,
            d.y += this.game.camera.y,
            this.rectangle(d, b, c)
        },
        ropeSegments: function(a, b, c) {
            var e = this;
            a.segments.forEach(function(a) {
                e.rectangle(a, b, c)
            }, this)
        },
        spriteInfo: function(a, b, c, d) {
            this.start(b, c, d),
            this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y),
            this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1)),
            this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1)),
            this.line("visible: " + a.visible + " in camera: " + a.inCamera),
            this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1)),
            this.stop()
        },
        spriteCoords: function(a, b, c, d) {
            this.start(b, c, d, 100),
            a.name && this.line(a.name),
            this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2)),
            this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2)),
            this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2)),
            this.stop()
        },
        lineInfo: function(a, b, c, d) {
            this.start(b, c, d, 80),
            this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2)),
            this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2)),
            this.line("length:", a.length.toFixed(2), "angle:", a.angle),
            this.stop()
        },
        pixel: function(a, b, c, d) {
            d = d || 2,
            this.start(),
            this.context.fillStyle = c,
            this.context.fillRect(a, b, d, d),
            this.stop()
        },
        geom: function(a, c, d, e) {
            void 0 === d && (d = !0),
            void 0 === e && (e = 0),
            c = c || "rgba(0,255,0,0.4)",
            this.start(),
            this.context.fillStyle = c,
            this.context.strokeStyle = c,
            a instanceof b.Rectangle || 1 === e ? d ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height) : a instanceof b.Circle || 2 === e ? (this.context.beginPath(),
            this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, !1),
            this.context.closePath(),
            d ? this.context.fill() : this.context.stroke()) : a instanceof b.Point || 3 === e ? this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4) : (a instanceof b.Line || 4 === e) && (this.context.lineWidth = 1,
            this.context.beginPath(),
            this.context.moveTo(a.start.x + .5 - this.game.camera.x, a.start.y + .5 - this.game.camera.y),
            this.context.lineTo(a.end.x + .5 - this.game.camera.x, a.end.y + .5 - this.game.camera.y),
            this.context.closePath(),
            this.context.stroke()),
            this.stop()
        },
        rectangle: function(a, b, c) {
            void 0 === c && (c = !0),
            b = b || "rgba(0, 255, 0, 0.4)",
            this.start(),
            c ? (this.context.fillStyle = b,
            this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)) : (this.context.strokeStyle = b,
            this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height)),
            this.stop()
        },
        text: function(a, b, c, d, e) {
            d = d || "rgb(255,255,255)",
            e = e || "16px Courier",
            this.start(),
            this.context.font = e,
            this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)",
            this.context.fillText(a, b + 1, c + 1)),
            this.context.fillStyle = d,
            this.context.fillText(a, b, c),
            this.stop()
        },
        quadTree: function(a, b) {
            b = b || "rgba(255,0,0,0.3)",
            this.start();
            var c = a.bounds;
            if (0 === a.nodes.length) {
                this.context.strokeStyle = b,
                this.context.strokeRect(c.x, c.y, c.width, c.height),
                this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier"),
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var d = 0; d < a.objects.length; d++)
                    this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height)
            } else
                for (var d = 0; d < a.nodes.length; d++)
                    this.quadTree(a.nodes[d]);
            this.stop()
        },
        body: function(a, c, d) {
            a.body && (this.start(),
            a.body.type === b.Physics.ARCADE ? b.Physics.Arcade.Body.render(this.context, a.body, c, d) : a.body.type === b.Physics.NINJA ? b.Physics.Ninja.Body.render(this.context, a.body, c, d) : a.body.type === b.Physics.BOX2D && b.Physics.Box2D.renderBody(this.context, a.body, c),
            this.stop())
        },
        bodyInfo: function(a, c, d, e) {
            a.body && (this.start(c, d, e, 210),
            a.body.type === b.Physics.ARCADE ? b.Physics.Arcade.Body.renderBodyInfo(this, a.body) : a.body.type === b.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, a.body),
            this.stop())
        },
        box2dWorld: function() {
            this.start(),
            this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0),
            this.game.physics.box2d.renderDebugDraw(this.context),
            this.stop()
        },
        box2dBody: function(a, c) {
            this.start(),
            b.Physics.Box2D.renderBody(this.context, a, c),
            this.stop()
        },
        displayList: function(a) {
            if (void 0 === a && (a = this.game.world),
            a.hasOwnProperty("renderOrderID") ? console.log("[" + a.renderOrderID + "]", a) : console.log("[]", a),
            a.children && a.children.length > 0)
                for (var b = 0; b < a.children.length; b++)
                    this.game.debug.displayList(a.children[b])
        },
        destroy: function() {
            PIXI.CanvasPool.remove(this)
        }
    },
    b.Utils.Debug.prototype.constructor = b.Utils.Debug,
    b.DOM = {
        getOffset: function(a, c) {
            c = c || new b.Point;
            var d = a.getBoundingClientRect()
              , e = b.DOM.scrollY
              , f = b.DOM.scrollX
              , g = document.documentElement.clientTop
              , h = document.documentElement.clientLeft;
            return c.x = d.left + f - h,
            c.y = d.top + e - g,
            c
        },
        getBounds: function(a, b) {
            return void 0 === b && (b = 0),
            !(!(a = a && !a.nodeType ? a[0] : a) || 1 !== a.nodeType) && this.calibrate(a.getBoundingClientRect(), b)
        },
        calibrate: function(a, b) {
            b = +b || 0;
            var c = {
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            return c.width = (c.right = a.right + b) - (c.left = a.left - b),
            c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b),
            c
        },
        getAspectRatio: function(a) {
            a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
            var b = a.width
              , c = a.height;
            return "function" == typeof b && (b = b.call(a)),
            "function" == typeof c && (c = c.call(a)),
            b / c
        },
        inLayoutViewport: function(a, b) {
            var c = this.getBounds(a, b);
            return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height
        },
        getScreenOrientation: function(a) {
            var b = window.screen
              , c = b.orientation || b.mozOrientation || b.msOrientation;
            if (c && "string" == typeof c.type)
                return c.type;
            if ("string" == typeof c)
                return c;
            var d = "portrait-primary"
              , e = "landscape-primary";
            if ("screen" === a)
                return b.height > b.width ? d : e;
            if ("viewport" === a)
                return this.visualBounds.height > this.visualBounds.width ? d : e;
            if ("window.orientation" === a && "number" == typeof window.orientation)
                return 0 === window.orientation || 180 === window.orientation ? d : e;
            if (window.matchMedia) {
                if (window.matchMedia("(orientation: portrait)").matches)
                    return d;
                if (window.matchMedia("(orientation: landscape)").matches)
                    return e
            }
            return this.visualBounds.height > this.visualBounds.width ? d : e
        },
        visualBounds: new b.Rectangle,
        layoutBounds: new b.Rectangle,
        documentBounds: new b.Rectangle
    },
    b.Device.whenReady(function(a) {
        var c = window && "pageXOffset"in window ? function() {
            return window.pageXOffset
        }
        : function() {
            return document.documentElement.scrollLeft
        }
          , d = window && "pageYOffset"in window ? function() {
            return window.pageYOffset
        }
        : function() {
            return document.documentElement.scrollTop
        }
        ;
        if (Object.defineProperty(b.DOM, "scrollX", {
            get: c
        }),
        Object.defineProperty(b.DOM, "scrollY", {
            get: d
        }),
        Object.defineProperty(b.DOM.visualBounds, "x", {
            get: c
        }),
        Object.defineProperty(b.DOM.visualBounds, "y", {
            get: d
        }),
        Object.defineProperty(b.DOM.layoutBounds, "x", {
            value: 0
        }),
        Object.defineProperty(b.DOM.layoutBounds, "y", {
            value: 0
        }),
        a.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
            var f = function() {
                return Math.max(window.innerWidth, document.documentElement.clientWidth)
            }
              , g = function() {
                return Math.max(window.innerHeight, document.documentElement.clientHeight)
            };
            Object.defineProperty(b.DOM.visualBounds, "width", {
                get: f
            }),
            Object.defineProperty(b.DOM.visualBounds, "height", {
                get: g
            }),
            Object.defineProperty(b.DOM.layoutBounds, "width", {
                get: f
            }),
            Object.defineProperty(b.DOM.layoutBounds, "height", {
                get: g
            })
        } else
            Object.defineProperty(b.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }),
            Object.defineProperty(b.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }),
            Object.defineProperty(b.DOM.layoutBounds, "width", {
                get: function() {
                    var a = document.documentElement.clientWidth
                      , b = window.innerWidth;
                    return a < b ? b : a
                }
            }),
            Object.defineProperty(b.DOM.layoutBounds, "height", {
                get: function() {
                    var a = document.documentElement.clientHeight
                      , b = window.innerHeight;
                    return a < b ? b : a
                }
            });
        Object.defineProperty(b.DOM.documentBounds, "x", {
            value: 0
        }),
        Object.defineProperty(b.DOM.documentBounds, "y", {
            value: 0
        }),
        Object.defineProperty(b.DOM.documentBounds, "width", {
            get: function() {
                var a = document.documentElement;
                return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth)
            }
        }),
        Object.defineProperty(b.DOM.documentBounds, "height", {
            get: function() {
                var a = document.documentElement;
                return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight)
            }
        })
    }, null, !0),
    b.ArraySet = function(a) {
        this.position = 0,
        this.list = a || []
    }
    ,
    b.ArraySet.prototype = {
        add: function(a) {
            return this.exists(a) || this.list.push(a),
            a
        },
        getIndex: function(a) {
            return this.list.indexOf(a)
        },
        getByKey: function(a, b) {
            for (var c = this.list.length; c--; )
                if (this.list[c][a] === b)
                    return this.list[c];
            return null
        },
        exists: function(a) {
            return this.list.indexOf(a) > -1
        },
        reset: function() {
            this.list.length = 0
        },
        remove: function(a) {
            var b = this.list.indexOf(a);
            if (b > -1)
                return this.list.splice(b, 1),
                a
        },
        setAll: function(a, b) {
            for (var c = this.list.length; c--; )
                this.list[c] && (this.list[c][a] = b)
        },
        callAll: function(a) {
            for (var b = Array.prototype.slice.call(arguments, 1), c = this.list.length; c--; )
                this.list[c] && this.list[c][a] && this.list[c][a].apply(this.list[c], b)
        },
        removeAll: function(a) {
            void 0 === a && (a = !1);
            for (var b = this.list.length; b--; )
                if (this.list[b]) {
                    var c = this.remove(this.list[b]);
                    a && c.destroy()
                }
            this.position = 0,
            this.list = []
        }
    },
    Object.defineProperty(b.ArraySet.prototype, "total", {
        get: function() {
            return this.list.length
        }
    }),
    Object.defineProperty(b.ArraySet.prototype, "first", {
        get: function() {
            return this.position = 0,
            this.list.length > 0 ? this.list[0] : null
        }
    }),
    Object.defineProperty(b.ArraySet.prototype, "next", {
        get: function() {
            return this.position < this.list.length ? (this.position++,
            this.list[this.position]) : null
        }
    }),
    b.ArraySet.prototype.constructor = b.ArraySet,
    b.ArrayUtils = {
        getRandomItem: function(a, b, c) {
            if (null === a)
                return null;
            void 0 === b && (b = 0),
            void 0 === c && (c = a.length);
            var d = b + Math.floor(Math.random() * c);
            return void 0 === a[d] ? null : a[d]
        },
        removeRandomItem: function(a, b, c) {
            if (null == a)
                return null;
            void 0 === b && (b = 0),
            void 0 === c && (c = a.length);
            var d = b + Math.floor(Math.random() * c);
            if (d < a.length) {
                var e = a.splice(d, 1);
                return void 0 === e[0] ? null : e[0]
            }
            return null
        },
        shuffle: function(a) {
            for (var b = a.length - 1; b > 0; b--) {
                var c = Math.floor(Math.random() * (b + 1))
                  , d = a[b];
                a[b] = a[c],
                a[c] = d
            }
            return a
        },
        transposeMatrix: function(a) {
            for (var b = a.length, c = a[0].length, d = new Array(c), e = 0; e < c; e++) {
                d[e] = new Array(b);
                for (var f = b - 1; f > -1; f--)
                    d[e][f] = a[f][e]
            }
            return d
        },
        rotateMatrix: function(a, c) {
            if ("string" != typeof c && (c = (c % 360 + 360) % 360),
            90 === c || -270 === c || "rotateLeft" === c)
                a = b.ArrayUtils.transposeMatrix(a),
                a = a.reverse();
            else if (-90 === c || 270 === c || "rotateRight" === c)
                a = a.reverse(),
                a = b.ArrayUtils.transposeMatrix(a);
            else if (180 === Math.abs(c) || "rotate180" === c) {
                for (var d = 0; d < a.length; d++)
                    a[d].reverse();
                a = a.reverse()
            }
            return a
        },
        findClosest: function(a, b) {
            if (!b.length)
                return NaN;
            if (1 === b.length || a < b[0])
                return b[0];
            for (var c = 1; b[c] < a; )
                c++;
            var d = b[c - 1]
              , e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
            return e - a <= a - d ? e : d
        },
        rotateRight: function(a) {
            var b = a.pop();
            return a.unshift(b),
            b
        },
        rotateLeft: function(a) {
            var b = a.shift();
            return a.push(b),
            b
        },
        rotate: function(a) {
            var b = a.shift();
            return a.push(b),
            b
        },
        numberArray: function(a, b) {
            for (var c = [], d = a; d <= b; d++)
                c.push(d);
            return c
        },
        numberArrayStep: function(a, c, d) {
            void 0 !== a && null !== a || (a = 0),
            void 0 !== c && null !== c || (c = a,
            a = 0),
            void 0 === d && (d = 1);
            for (var e = [], f = Math.max(b.Math.roundAwayFromZero((c - a) / (d || 1)), 0), g = 0; g < f; g++)
                e.push(a),
                a += d;
            return e
        }
    },
    b.LinkedList = function() {
        this.next = null,
        this.prev = null,
        this.first = null,
        this.last = null,
        this.total = 0
    }
    ,
    b.LinkedList.prototype = {
        add: function(a) {
            return 0 === this.total && null === this.first && null === this.last ? (this.first = a,
            this.last = a,
            this.next = a,
            a.prev = this,
            this.total++,
            a) : (this.last.next = a,
            a.prev = this.last,
            this.last = a,
            this.total++,
            a)
        },
        reset: function() {
            this.first = null,
            this.last = null,
            this.next = null,
            this.prev = null,
            this.total = 0
        },
        remove: function(a) {
            if (1 === this.total)
                return this.reset(),
                void (a.next = a.prev = null);
            a === this.first ? this.first = this.first.next : a === this.last && (this.last = this.last.prev),
            a.prev && (a.prev.next = a.next),
            a.next && (a.next.prev = a.prev),
            a.next = a.prev = null,
            null === this.first && (this.last = null),
            this.total--
        },
        callAll: function(a) {
            if (this.first && this.last) {
                var b = this.first;
                do {
                    b && b[a] && b[a].call(b),
                    b = b.next
                } while (b !== this.last.next)
            }
        }
    },
    b.LinkedList.prototype.constructor = b.LinkedList,
    b.Create = function(a) {
        this.game = a,
        this.bmd = null,
        this.canvas = null,
        this.ctx = null,
        this.palettes = [{
            0: "#000",
            1: "#9D9D9D",
            2: "#FFF",
            3: "#BE2633",
            4: "#E06F8B",
            5: "#493C2B",
            6: "#A46422",
            7: "#EB8931",
            8: "#F7E26B",
            9: "#2F484E",
            A: "#44891A",
            B: "#A3CE27",
            C: "#1B2632",
            D: "#005784",
            E: "#31A2F2",
            F: "#B2DCEF"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#f5f4eb"
        }, {
            0: "#000",
            1: "#2234d1",
            2: "#0c7e45",
            3: "#44aacc",
            4: "#8a3622",
            5: "#5c2e78",
            6: "#aa5c3d",
            7: "#b5b5b5",
            8: "#5e606e",
            9: "#4c81fb",
            A: "#6cd947",
            B: "#7be2f9",
            C: "#eb8a60",
            D: "#e23d69",
            E: "#ffd93f",
            F: "#fff"
        }, {
            0: "#000",
            1: "#fff",
            2: "#8b4131",
            3: "#7bbdc5",
            4: "#8b41ac",
            5: "#6aac41",
            6: "#3931a4",
            7: "#d5de73",
            8: "#945a20",
            9: "#5a4100",
            A: "#bd736a",
            B: "#525252",
            C: "#838383",
            D: "#acee8b",
            E: "#7b73de",
            F: "#acacac"
        }, {
            0: "#000",
            1: "#191028",
            2: "#46af45",
            3: "#a1d685",
            4: "#453e78",
            5: "#7664fe",
            6: "#833129",
            7: "#9ec2e8",
            8: "#dc534b",
            9: "#e18d79",
            A: "#d6b97b",
            B: "#e9d8a1",
            C: "#216c4b",
            D: "#d365c8",
            E: "#afaab9",
            F: "#fff"
        }]
    }
    ,
    b.Create.PALETTE_ARNE = 0,
    b.Create.PALETTE_JMP = 1,
    b.Create.PALETTE_CGA = 2,
    b.Create.PALETTE_C64 = 3,
    b.Create.PALETTE_JAPANESE_MACHINE = 4,
    b.Create.prototype = {
        texture: function(a, b, c, d, e) {
            void 0 === c && (c = 8),
            void 0 === d && (d = c),
            void 0 === e && (e = 0);
            var f = b[0].length * c
              , g = b.length * d;
            null === this.bmd && (this.bmd = this.game.make.bitmapData(),
            this.canvas = this.bmd.canvas,
            this.ctx = this.bmd.context),
            this.bmd.resize(f, g),
            this.bmd.clear();
            for (var h = 0; h < b.length; h++)
                for (var i = b[h], j = 0; j < i.length; j++) {
                    var k = i[j];
                    "." !== k && " " !== k && (this.ctx.fillStyle = this.palettes[e][k],
                    this.ctx.fillRect(j * c, h * d, c, d))
                }
            return this.bmd.generateTexture(a)
        },
        grid: function(a, b, c, d, e, f) {
            null === this.bmd && (this.bmd = this.game.make.bitmapData(),
            this.canvas = this.bmd.canvas,
            this.ctx = this.bmd.context),
            this.bmd.resize(b, c),
            this.ctx.fillStyle = f;
            for (var g = 0; g < c; g += e)
                this.ctx.fillRect(0, g, b, 1);
            for (var h = 0; h < b; h += d)
                this.ctx.fillRect(h, 0, 1, c);
            return this.bmd.generateTexture(a)
        }
    },
    b.Create.prototype.constructor = b.Create,
    b.FlexGrid = function(a, c, d) {
        this.game = a.game,
        this.manager = a,
        this.width = c,
        this.height = d,
        this.boundsCustom = new b.Rectangle(0,0,c,d),
        this.boundsFluid = new b.Rectangle(0,0,c,d),
        this.boundsFull = new b.Rectangle(0,0,c,d),
        this.boundsNone = new b.Rectangle(0,0,c,d),
        this.positionCustom = new b.Point(0,0),
        this.positionFluid = new b.Point(0,0),
        this.positionFull = new b.Point(0,0),
        this.positionNone = new b.Point(0,0),
        this.scaleCustom = new b.Point(1,1),
        this.scaleFluid = new b.Point(1,1),
        this.scaleFluidInversed = new b.Point(1,1),
        this.scaleFull = new b.Point(1,1),
        this.scaleNone = new b.Point(1,1),
        this.customWidth = 0,
        this.customHeight = 0,
        this.customOffsetX = 0,
        this.customOffsetY = 0,
        this.ratioH = c / d,
        this.ratioV = d / c,
        this.multiplier = 0,
        this.layers = []
    }
    ,
    b.FlexGrid.prototype = {
        setSize: function(a, c) {
            this.width = a,
            this.height = c,
            this.ratioH = a / c,
            this.ratioV = c / a,
            this.scaleNone = new b.Point(1,1),
            this.boundsNone.width = this.width,
            this.boundsNone.height = this.height,
            this.refresh()
        },
        createCustomLayer: function(a, c, d, e) {
            void 0 === e && (e = !0),
            this.customWidth = a,
            this.customHeight = c,
            this.boundsCustom.width = a,
            this.boundsCustom.height = c;
            var f = new b.FlexLayer(this,this.positionCustom,this.boundsCustom,this.scaleCustom);
            return e && this.game.world.add(f),
            this.layers.push(f),
            void 0 !== d && null !== typeof d && f.addMultiple(d),
            f
        },
        createFluidLayer: function(a, c) {
            void 0 === c && (c = !0);
            var d = new b.FlexLayer(this,this.positionFluid,this.boundsFluid,this.scaleFluid);
            return c && this.game.world.add(d),
            this.layers.push(d),
            void 0 !== a && null !== typeof a && d.addMultiple(a),
            d
        },
        createFullLayer: function(a) {
            var c = new b.FlexLayer(this,this.positionFull,this.boundsFull,this.scaleFluid);
            return this.game.world.add(c),
            this.layers.push(c),
            void 0 !== a && c.addMultiple(a),
            c
        },
        createFixedLayer: function(a) {
            var c = new b.FlexLayer(this,this.positionNone,this.boundsNone,this.scaleNone);
            return this.game.world.add(c),
            this.layers.push(c),
            void 0 !== a && c.addMultiple(a),
            c
        },
        reset: function() {
            for (var a = this.layers.length; a--; )
                this.layers[a].persist || (this.layers[a].position = null,
                this.layers[a].scale = null,
                this.layers.slice(a, 1))
        },
        onResize: function(a, b) {
            this.ratioH = a / b,
            this.ratioV = b / a,
            this.refresh(a, b)
        },
        refresh: function() {
            this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width),
            this.boundsFluid.width = Math.round(this.width * this.multiplier),
            this.boundsFluid.height = Math.round(this.height * this.multiplier),
            this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height),
            this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height),
            this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height),
            this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x),
            this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y),
            this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
            this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY),
            this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y),
            this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
        },
        fitSprite: function(a) {
            this.manager.scaleSprite(a),
            a.x = this.manager.bounds.centerX,
            a.y = this.manager.bounds.centerY
        },
        debug: function() {
            this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16),
            this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
        }
    },
    b.FlexGrid.prototype.constructor = b.FlexGrid,
    b.FlexLayer = function(a, c, d, e) {
        b.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), !1),
        this.manager = a.manager,
        this.grid = a,
        this.persist = !1,
        this.position = c,
        this.bounds = d,
        this.scale = e,
        this.topLeft = d.topLeft,
        this.topMiddle = new b.Point(d.halfWidth,0),
        this.topRight = d.topRight,
        this.bottomLeft = d.bottomLeft,
        this.bottomMiddle = new b.Point(d.halfWidth,d.bottom),
        this.bottomRight = d.bottomRight
    }
    ,
    b.FlexLayer.prototype = Object.create(b.Group.prototype),
    b.FlexLayer.prototype.constructor = b.FlexLayer,
    b.FlexLayer.prototype.resize = function() {}
    ,
    b.FlexLayer.prototype.debug = function() {
        this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16),
        this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1),
        this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"),
        this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"),
        this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
    }
    ,
    b.Color = {
        packPixel: function(a, c, d, e) {
            return b.Device.LITTLE_ENDIAN ? (e << 24 | d << 16 | c << 8 | a) >>> 0 : (a << 24 | c << 16 | d << 8 | e) >>> 0
        },
        unpackPixel: function(a, c, d, e) {
            return void 0 !== c && null !== c || (c = b.Color.createColor()),
            void 0 !== d && null !== d || (d = !1),
            void 0 !== e && null !== e || (e = !1),
            b.Device.LITTLE_ENDIAN ? (c.a = (4278190080 & a) >>> 24,
            c.b = (16711680 & a) >>> 16,
            c.g = (65280 & a) >>> 8,
            c.r = 255 & a) : (c.r = (4278190080 & a) >>> 24,
            c.g = (16711680 & a) >>> 16,
            c.b = (65280 & a) >>> 8,
            c.a = 255 & a),
            c.color = a,
            c.rgba = "rgba(" + c.r + "," + c.g + "," + c.b + "," + c.a / 255 + ")",
            d && b.Color.RGBtoHSL(c.r, c.g, c.b, c),
            e && b.Color.RGBtoHSV(c.r, c.g, c.b, c),
            c
        },
        fromRGBA: function(a, c) {
            return c || (c = b.Color.createColor()),
            c.r = (4278190080 & a) >>> 24,
            c.g = (16711680 & a) >>> 16,
            c.b = (65280 & a) >>> 8,
            c.a = 255 & a,
            c.rgba = "rgba(" + c.r + "," + c.g + "," + c.b + "," + c.a + ")",
            c
        },
        toRGBA: function(a, b, c, d) {
            return a << 24 | b << 16 | c << 8 | d
        },
        toABGR: function(a, b, c, d) {
            return (d << 24 | c << 16 | b << 8 | a) >>> 0
        },
        RGBtoHSL: function(a, c, d, e) {
            e || (e = b.Color.createColor(a, c, d, 1)),
            a /= 255,
            c /= 255,
            d /= 255;
            var f = Math.min(a, c, d)
              , g = Math.max(a, c, d);
            if (e.h = 0,
            e.s = 0,
            e.l = (g + f) / 2,
            g !== f) {
                var h = g - f;
                e.s = e.l > .5 ? h / (2 - g - f) : h / (g + f),
                g === a ? e.h = (c - d) / h + (c < d ? 6 : 0) : g === c ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - c) / h + 4),
                e.h /= 6
            }
            return e
        },
        HSLtoRGB: function(a, c, d, e) {
            if (e ? (e.r = d,
            e.g = d,
            e.b = d) : e = b.Color.createColor(d, d, d),
            0 !== c) {
                var f = d < .5 ? d * (1 + c) : d + c - d * c
                  , g = 2 * d - f;
                e.r = b.Color.hueToColor(g, f, a + 1 / 3),
                e.g = b.Color.hueToColor(g, f, a),
                e.b = b.Color.hueToColor(g, f, a - 1 / 3)
            }
            return e.r = Math.floor(255 * e.r | 0),
            e.g = Math.floor(255 * e.g | 0),
            e.b = Math.floor(255 * e.b | 0),
            b.Color.updateColor(e),
            e
        },
        RGBtoHSV: function(a, c, d, e) {
            e || (e = b.Color.createColor(a, c, d, 255)),
            a /= 255,
            c /= 255,
            d /= 255;
            var f = Math.min(a, c, d)
              , g = Math.max(a, c, d)
              , h = g - f;
            return e.h = 0,
            e.s = 0 === g ? 0 : h / g,
            e.v = g,
            g !== f && (g === a ? e.h = (c - d) / h + (c < d ? 6 : 0) : g === c ? e.h = (d - a) / h + 2 : g === d && (e.h = (a - c) / h + 4),
            e.h /= 6),
            e
        },
        HSVtoRGB: function(a, c, d, e) {
            void 0 === e && (e = b.Color.createColor(0, 0, 0, 1, a, c, 0, d));
            var f, g, h, i = Math.floor(6 * a), j = 6 * a - i, k = d * (1 - c), l = d * (1 - j * c), m = d * (1 - (1 - j) * c);
            switch (i % 6) {
            case 0:
                f = d,
                g = m,
                h = k;
                break;
            case 1:
                f = l,
                g = d,
                h = k;
                break;
            case 2:
                f = k,
                g = d,
                h = m;
                break;
            case 3:
                f = k,
                g = l,
                h = d;
                break;
            case 4:
                f = m,
                g = k,
                h = d;
                break;
            case 5:
                f = d,
                g = k,
                h = l
            }
            return e.r = Math.floor(255 * f),
            e.g = Math.floor(255 * g),
            e.b = Math.floor(255 * h),
            b.Color.updateColor(e),
            e
        },
        hueToColor: function(a, b, c) {
            return c < 0 && (c += 1),
            c > 1 && (c -= 1),
            c < 1 / 6 ? a + 6 * (b - a) * c : c < .5 ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a
        },
        createColor: function(a, c, d, e, f, g, h, i) {
            var j = {
                r: a || 0,
                g: c || 0,
                b: d || 0,
                a: e || 1,
                h: f || 0,
                s: g || 0,
                l: h || 0,
                v: i || 0,
                color: 0,
                color32: 0,
                rgba: ""
            };
            return b.Color.updateColor(j)
        },
        updateColor: function(a) {
            return a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")",
            a.color = b.Color.getColor(a.r, a.g, a.b),
            a.color32 = b.Color.getColor32(255 * a.a, a.r, a.g, a.b),
            a
        },
        getColor32: function(a, b, c, d) {
            return a << 24 | b << 16 | c << 8 | d
        },
        getColor: function(a, b, c) {
            return a << 16 | b << 8 | c
        },
        RGBtoString: function(a, c, d, e, f) {
            return void 0 === e && (e = 255),
            void 0 === f && (f = "#"),
            "#" === f ? "#" + ((1 << 24) + (a << 16) + (c << 8) + d).toString(16).slice(1) : "0x" + b.Color.componentToHex(e) + b.Color.componentToHex(a) + b.Color.componentToHex(c) + b.Color.componentToHex(d)
        },
        hexToRGB: function(a) {
            var c = b.Color.hexToColor(a);
            if (c)
                return b.Color.getColor32(c.a, c.r, c.g, c.b)
        },
        hexToColor: function(a, c) {
            a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, b, c, d) {
                return b + b + c + c + d + d
            });
            var d = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
            if (d) {
                var e = parseInt(d[1], 16)
                  , f = parseInt(d[2], 16)
                  , g = parseInt(d[3], 16);
                c ? (c.r = e,
                c.g = f,
                c.b = g) : c = b.Color.createColor(e, f, g)
            }
            return c
        },
        webToColor: function(a, c) {
            c || (c = b.Color.createColor());
            var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a);
            return d && (c.r = parseInt(d[1], 10),
            c.g = parseInt(d[2], 10),
            c.b = parseInt(d[3], 10),
            c.a = void 0 !== d[4] ? parseFloat(d[4]) : 1,
            b.Color.updateColor(c)),
            c
        },
        valueToColor: function(a, c) {
            if (c || (c = b.Color.createColor()),
            "string" == typeof a)
                return 0 === a.indexOf("rgb") ? b.Color.webToColor(a, c) : (c.a = 1,
                b.Color.hexToColor(a, c));
            if ("number" == typeof a) {
                var d = b.Color.getRGB(a);
                return c.r = d.r,
                c.g = d.g,
                c.b = d.b,
                c.a = d.a / 255,
                c
            }
            return c
        },
        componentToHex: function(a) {
            var b = a.toString(16);
            return 1 === b.length ? "0" + b : b
        },
        HSVColorWheel: function(a, c) {
            void 0 === a && (a = 1),
            void 0 === c && (c = 1);
            for (var d = [], e = 0; e <= 359; e++)
                d.push(b.Color.HSVtoRGB(e / 359, a, c));
            return d
        },
        HSLColorWheel: function(a, c) {
            void 0 === a && (a = .5),
            void 0 === c && (c = .5);
            for (var d = [], e = 0; e <= 359; e++)
                d.push(b.Color.HSLtoRGB(e / 359, a, c));
            return d
        },
        interpolateColor: function(a, c, d, e, f) {
            void 0 === f && (f = 255);
            var g = b.Color.getRGB(a)
              , h = b.Color.getRGB(c)
              , i = (h.red - g.red) * e / d + g.red
              , j = (h.green - g.green) * e / d + g.green
              , k = (h.blue - g.blue) * e / d + g.blue;
            return b.Color.getColor32(f, i, j, k)
        },
        interpolateColorWithRGB: function(a, c, d, e, f, g) {
            var h = b.Color.getRGB(a)
              , i = (c - h.red) * g / f + h.red
              , j = (d - h.green) * g / f + h.green
              , k = (e - h.blue) * g / f + h.blue;
            return b.Color.getColor(i, j, k)
        },
        interpolateRGB: function(a, c, d, e, f, g, h, i) {
            var j = (e - a) * i / h + a
              , k = (f - c) * i / h + c
              , l = (g - d) * i / h + d;
            return b.Color.getColor(j, k, l)
        },
        getRandomColor: function(a, c, d) {
            if (void 0 === a && (a = 0),
            void 0 === c && (c = 255),
            void 0 === d && (d = 255),
            c > 255 || a > c)
                return b.Color.getColor(255, 255, 255);
            var e = a + Math.round(Math.random() * (c - a))
              , f = a + Math.round(Math.random() * (c - a))
              , g = a + Math.round(Math.random() * (c - a));
            return b.Color.getColor32(d, e, f, g)
        },
        getRGB: function(a) {
            return a > 16777215 ? {
                alpha: a >>> 24,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: 255 & a,
                a: a >>> 24,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: 255 & a
            } : {
                alpha: 255,
                red: a >> 16 & 255,
                green: a >> 8 & 255,
                blue: 255 & a,
                a: 255,
                r: a >> 16 & 255,
                g: a >> 8 & 255,
                b: 255 & a
            }
        },
        getWebRGB: function(a) {
            if ("object" == typeof a)
                return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")";
            var c = b.Color.getRGB(a);
            return "rgba(" + c.r.toString() + "," + c.g.toString() + "," + c.b.toString() + "," + (c.a / 255).toString() + ")"
        },
        getAlpha: function(a) {
            return a >>> 24
        },
        getAlphaFloat: function(a) {
            return (a >>> 24) / 255
        },
        getRed: function(a) {
            return a >> 16 & 255
        },
        getGreen: function(a) {
            return a >> 8 & 255
        },
        getBlue: function(a) {
            return 255 & a
        },
        blendNormal: function(a) {
            return a
        },
        blendLighten: function(a, b) {
            return b > a ? b : a
        },
        blendDarken: function(a, b) {
            return b > a ? a : b
        },
        blendMultiply: function(a, b) {
            return a * b / 255
        },
        blendAverage: function(a, b) {
            return (a + b) / 2
        },
        blendAdd: function(a, b) {
            return Math.min(255, a + b)
        },
        blendSubtract: function(a, b) {
            return Math.max(0, a + b - 255)
        },
        blendDifference: function(a, b) {
            return Math.abs(a - b)
        },
        blendNegation: function(a, b) {
            return 255 - Math.abs(255 - a - b)
        },
        blendScreen: function(a, b) {
            return 255 - ((255 - a) * (255 - b) >> 8)
        },
        blendExclusion: function(a, b) {
            return a + b - 2 * a * b / 255
        },
        blendOverlay: function(a, b) {
            return b < 128 ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255
        },
        blendSoftLight: function(a, b) {
            return b < 128 ? 2 * (64 + (a >> 1)) * (b / 255) : 255 - 2 * (255 - (64 + (a >> 1))) * (255 - b) / 255
        },
        blendHardLight: function(a, c) {
            return b.Color.blendOverlay(c, a)
        },
        blendColorDodge: function(a, b) {
            return 255 === b ? b : Math.min(255, (a << 8) / (255 - b))
        },
        blendColorBurn: function(a, b) {
            return 0 === b ? b : Math.max(0, 255 - (255 - a << 8) / b)
        },
        blendLinearDodge: function(a, c) {
            return b.Color.blendAdd(a, c)
        },
        blendLinearBurn: function(a, c) {
            return b.Color.blendSubtract(a, c)
        },
        blendLinearLight: function(a, c) {
            return c < 128 ? b.Color.blendLinearBurn(a, 2 * c) : b.Color.blendLinearDodge(a, 2 * (c - 128))
        },
        blendVividLight: function(a, c) {
            return c < 128 ? b.Color.blendColorBurn(a, 2 * c) : b.Color.blendColorDodge(a, 2 * (c - 128))
        },
        blendPinLight: function(a, c) {
            return c < 128 ? b.Color.blendDarken(a, 2 * c) : b.Color.blendLighten(a, 2 * (c - 128))
        },
        blendHardMix: function(a, c) {
            return b.Color.blendVividLight(a, c) < 128 ? 0 : 255
        },
        blendReflect: function(a, b) {
            return 255 === b ? b : Math.min(255, a * a / (255 - b))
        },
        blendGlow: function(a, c) {
            return b.Color.blendReflect(c, a)
        },
        blendPhoenix: function(a, b) {
            return Math.min(a, b) - Math.max(a, b) + 255
        }
    },
    b.Physics = function(a, b) {
        b = b || {},
        this.game = a,
        this.config = b,
        this.arcade = null,
        this.p2 = null,
        this.ninja = null,
        this.box2d = null,
        this.chipmunk = null,
        this.matter = null,
        this.parseConfig()
    }
    ,
    b.Physics.ARCADE = 0,
    b.Physics.P2JS = 1,
    b.Physics.NINJA = 2,
    b.Physics.BOX2D = 3,
    b.Physics.CHIPMUNK = 4,
    b.Physics.MATTERJS = 5,
    b.Physics.prototype = {
        parseConfig: function() {
            this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !b.Physics.hasOwnProperty("Arcade") || (this.arcade = new b.Physics.Arcade(this.game)),
            this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && b.Physics.hasOwnProperty("Ninja") && (this.ninja = new b.Physics.Ninja(this.game)),
            this.config.hasOwnProperty("p2") && !0 === this.config.p2 && b.Physics.hasOwnProperty("P2") && (this.p2 = new b.Physics.P2(this.game,this.config)),
            this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && b.Physics.hasOwnProperty("BOX2D") && (this.box2d = new b.Physics.BOX2D(this.game,this.config)),
            this.config.hasOwnProperty("matter") && !0 === this.config.matter && b.Physics.hasOwnProperty("Matter") && (this.matter = new b.Physics.Matter(this.game,this.config))
        },
        startSystem: function(a) {
            a === b.Physics.ARCADE ? this.arcade = new b.Physics.Arcade(this.game) : a === b.Physics.P2JS ? null === this.p2 ? this.p2 = new b.Physics.P2(this.game,this.config) : this.p2.reset() : a === b.Physics.NINJA ? this.ninja = new b.Physics.Ninja(this.game) : a === b.Physics.BOX2D ? null === this.box2d ? this.box2d = new b.Physics.Box2D(this.game,this.config) : this.box2d.reset() : a === b.Physics.MATTERJS && (null === this.matter ? this.matter = new b.Physics.Matter(this.game,this.config) : this.matter.reset())
        },
        enable: function(a, c, d) {
            void 0 === c && (c = b.Physics.ARCADE),
            void 0 === d && (d = !1),
            c === b.Physics.ARCADE ? this.arcade.enable(a) : c === b.Physics.P2JS && this.p2 ? this.p2.enable(a, d) : c === b.Physics.NINJA && this.ninja ? this.ninja.enableAABB(a) : c === b.Physics.BOX2D && this.box2d ? this.box2d.enable(a) : c === b.Physics.MATTERJS && this.matter ? this.matter.enable(a) : console.warn(a.key + " is attempting to enable a physics body using an unknown physics system.")
        },
        preUpdate: function() {
            this.p2 && this.p2.preUpdate(),
            this.box2d && this.box2d.preUpdate(),
            this.matter && this.matter.preUpdate()
        },
        update: function() {
            this.p2 && this.p2.update(),
            this.box2d && this.box2d.update(),
            this.matter && this.matter.update()
        },
        setBoundsToWorld: function() {
            this.arcade && this.arcade.setBoundsToWorld(),
            this.ninja && this.ninja.setBoundsToWorld(),
            this.p2 && this.p2.setBoundsToWorld(),
            this.box2d && this.box2d.setBoundsToWorld(),
            this.matter && this.matter.setBoundsToWorld()
        },
        clear: function() {
            this.p2 && this.p2.clear(),
            this.box2d && this.box2d.clear(),
            this.matter && this.matter.clear()
        },
        reset: function() {
            this.p2 && this.p2.reset(),
            this.box2d && this.box2d.reset(),
            this.matter && this.matter.reset()
        },
        destroy: function() {
            this.p2 && this.p2.destroy(),
            this.box2d && this.box2d.destroy(),
            this.matter && this.matter.destroy(),
            this.arcade = null,
            this.ninja = null,
            this.p2 = null,
            this.box2d = null,
            this.matter = null
        }
    },
    b.Physics.prototype.constructor = b.Physics,
    b.Physics.Arcade = function(a) {
        this.game = a,
        this.gravity = new b.Point,
        this.bounds = new b.Rectangle(0,0,a.world.width,a.world.height),
        this.checkCollision = {
            up: !0,
            down: !0,
            left: !0,
            right: !0
        },
        this.maxObjects = 10,
        this.maxLevels = 4,
        this.OVERLAP_BIAS = 4,
        this.forceX = !1,
        this.sortDirection = b.Physics.Arcade.LEFT_RIGHT,
        this.skipQuadTree = !0,
        this.isPaused = !1,
        this.quadTree = new b.QuadTree(this.game.world.bounds.x,this.game.world.bounds.y,this.game.world.bounds.width,this.game.world.bounds.height,this.maxObjects,this.maxLevels),
        this._total = 0,
        this.setBoundsToWorld()
    }
    ,
    b.Physics.Arcade.prototype.constructor = b.Physics.Arcade,
    b.Physics.Arcade.SORT_NONE = 0,
    b.Physics.Arcade.LEFT_RIGHT = 1,
    b.Physics.Arcade.RIGHT_LEFT = 2,
    b.Physics.Arcade.TOP_BOTTOM = 3,
    b.Physics.Arcade.BOTTOM_TOP = 4,
    b.Physics.Arcade.prototype = {
        setBounds: function(a, b, c, d) {
            this.bounds.setTo(a, b, c, d)
        },
        setBoundsToWorld: function() {
            this.bounds.copyFrom(this.game.world.bounds)
        },
        enable: function(a, c) {
            void 0 === c && (c = !0);
            var d = 1;
            if (Array.isArray(a))
                for (d = a.length; d--; )
                    a[d]instanceof b.Group ? this.enable(a[d].children, c) : (this.enableBody(a[d]),
                    c && a[d].hasOwnProperty("children") && a[d].children.length > 0 && this.enable(a[d], !0));
            else
                a instanceof b.Group ? this.enable(a.children, c) : (this.enableBody(a),
                c && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, !0))
        },
        enableBody: function(a) {
            a.hasOwnProperty("body") && null === a.body && (a.body = new b.Physics.Arcade.Body(a),
            a.parent && a.parent instanceof b.Group && a.parent.addToHash(a))
        },
        updateMotion: function(a) {
            var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
            a.angularVelocity += b,
            a.rotation += a.angularVelocity * this.game.time.physicsElapsed,
            a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x),
            a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y)
        },
        computeVelocity: function(a, b, c, d, e, f) {
            return void 0 === f && (f = 1e4),
            1 === a && b.allowGravity ? c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed : 2 === a && b.allowGravity && (c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed),
            d ? c += d * this.game.time.physicsElapsed : e && (e *= this.game.time.physicsElapsed,
            c - e > 0 ? c -= e : c + e < 0 ? c += e : c = 0),
            c > f ? c = f : c < -f && (c = -f),
            c
        },
        overlap: function(a, b, c, d, e) {
            if (c = c || null,
            d = d || null,
            e = e || c,
            this._total = 0,
            !Array.isArray(a) && Array.isArray(b))
                for (var f = 0; f < b.length; f++)
                    this.collideHandler(a, b[f], c, d, e, !0);
            else if (Array.isArray(a) && !Array.isArray(b))
                for (var f = 0; f < a.length; f++)
                    this.collideHandler(a[f], b, c, d, e, !0);
            else if (Array.isArray(a) && Array.isArray(b))
                for (var f = 0; f < a.length; f++)
                    for (var g = 0; g < b.length; g++)
                        this.collideHandler(a[f], b[g], c, d, e, !0);
            else
                this.collideHandler(a, b, c, d, e, !0);
            return this._total > 0
        },
        collide: function(a, b, c, d, e) {
            if (c = c || null,
            d = d || null,
            e = e || c,
            this._total = 0,
            !Array.isArray(a) && Array.isArray(b))
                for (var f = 0; f < b.length; f++)
                    this.collideHandler(a, b[f], c, d, e, !1);
            else if (Array.isArray(a) && !Array.isArray(b))
                for (var f = 0; f < a.length; f++)
                    this.collideHandler(a[f], b, c, d, e, !1);
            else if (Array.isArray(a) && Array.isArray(b))
                for (var f = 0; f < a.length; f++)
                    for (var g = 0; g < b.length; g++)
                        this.collideHandler(a[f], b[g], c, d, e, !1);
            else
                this.collideHandler(a, b, c, d, e, !1);
            return this._total > 0
        },
        sortLeftRight: function(a, b) {
            return a.body && b.body ? a.body.x - b.body.x : 0
        },
        sortRightLeft: function(a, b) {
            return a.body && b.body ? b.body.x - a.body.x : 0
        },
        sortTopBottom: function(a, b) {
            return a.body && b.body ? a.body.y - b.body.y : 0
        },
        sortBottomTop: function(a, b) {
            return a.body && b.body ? b.body.y - a.body.y : 0
        },
        sort: function(a, c) {
            null !== a.physicsSortDirection ? c = a.physicsSortDirection : void 0 === c && (c = this.sortDirection),
            c === b.Physics.Arcade.LEFT_RIGHT ? a.hash.sort(this.sortLeftRight) : c === b.Physics.Arcade.RIGHT_LEFT ? a.hash.sort(this.sortRightLeft) : c === b.Physics.Arcade.TOP_BOTTOM ? a.hash.sort(this.sortTopBottom) : c === b.Physics.Arcade.BOTTOM_TOP && a.hash.sort(this.sortBottomTop)
        },
        collideHandler: function(a, c, d, e, f, g) {
            if (void 0 === c && a.physicsType === b.GROUP)
                return this.sort(a),
                void this.collideGroupVsSelf(a, d, e, f, g);
            a && c && a.exists && c.exists && (this.sortDirection !== b.Physics.Arcade.SORT_NONE && (a.physicsType === b.GROUP && this.sort(a),
            c.physicsType === b.GROUP && this.sort(c)),
            a.physicsType === b.SPRITE ? c.physicsType === b.SPRITE ? this.collideSpriteVsSprite(a, c, d, e, f, g) : c.physicsType === b.GROUP ? this.collideSpriteVsGroup(a, c, d, e, f, g) : c.physicsType === b.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(a, c, d, e, f, g) : a.physicsType === b.GROUP ? c.physicsType === b.SPRITE ? this.collideSpriteVsGroup(c, a, d, e, f, g) : c.physicsType === b.GROUP ? this.collideGroupVsGroup(a, c, d, e, f, g) : c.physicsType === b.TILEMAPLAYER && this.collideGroupVsTilemapLayer(a, c, d, e, f, g) : a.physicsType === b.TILEMAPLAYER && (c.physicsType === b.SPRITE ? this.collideSpriteVsTilemapLayer(c, a, d, e, f, g) : c.physicsType === b.GROUP && this.collideGroupVsTilemapLayer(c, a, d, e, f, g)))
        },
        collideSpriteVsSprite: function(a, b, c, d, e, f) {
            return !(!a.body || !b.body) && (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b),
            this._total++),
            !0)
        },
        collideSpriteVsGroup: function(a, c, d, e, f, g) {
            if (0 !== c.length && a.body)
                if (this.skipQuadTree || a.body.skipQuadTree)
                    for (var h = {}, i = 0; i < c.hash.length; i++) {
                        var j = c.hash[i];
                        if (j && j.exists && j.body) {
                            if (h = j.body.getBounds(h),
                            this.sortDirection === b.Physics.Arcade.LEFT_RIGHT) {
                                if (a.body.right < h.x)
                                    break;
                                if (h.right < a.body.x)
                                    continue
                            } else if (this.sortDirection === b.Physics.Arcade.RIGHT_LEFT) {
                                if (a.body.x > h.right)
                                    break;
                                if (h.x > a.body.right)
                                    continue
                            } else if (this.sortDirection === b.Physics.Arcade.TOP_BOTTOM) {
                                if (a.body.bottom < h.y)
                                    break;
                                if (h.bottom < a.body.y)
                                    continue
                            } else if (this.sortDirection === b.Physics.Arcade.BOTTOM_TOP) {
                                if (a.body.y > h.bottom)
                                    break;
                                if (h.y > a.body.bottom)
                                    continue
                            }
                            this.collideSpriteVsSprite(a, j, d, e, f, g)
                        }
                    }
                else {
                    this.quadTree.clear(),
                    this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
                    this.quadTree.populate(c);
                    for (var k = this.quadTree.retrieve(a), i = 0; i < k.length; i++)
                        this.separate(a.body, k[i], e, f, g) && (d && d.call(f, a, k[i].sprite),
                        this._total++)
                }
        },
        collideGroupVsSelf: function(a, c, d, e, f) {
            if (0 !== a.length)
                for (var g = 0; g < a.hash.length; g++) {
                    var h = {}
                      , i = a.hash[g];
                    if (i && i.exists && i.body) {
                        h = i.body.getBounds(h);
                        for (var j = g + 1; j < a.hash.length; j++) {
                            var k = {}
                              , l = a.hash[j];
                            if (l && l.exists && l.body) {
                                if (k = l.body.getBounds(k),
                                this.sortDirection === b.Physics.Arcade.LEFT_RIGHT) {
                                    if (h.right < k.x)
                                        break;
                                    if (k.right < h.x)
                                        continue
                                } else if (this.sortDirection === b.Physics.Arcade.RIGHT_LEFT) {
                                    if (h.x > k.right)
                                        continue;
                                    if (k.x > h.right)
                                        break
                                } else if (this.sortDirection === b.Physics.Arcade.TOP_BOTTOM) {
                                    if (h.bottom < k.y)
                                        continue;
                                    if (k.bottom < h.y)
                                        break
                                } else if (this.sortDirection === b.Physics.Arcade.BOTTOM_TOP) {
                                    if (h.y > k.bottom)
                                        continue;
                                    if (k.y > i.body.bottom)
                                        break
                                }
                                this.collideSpriteVsSprite(i, l, c, d, e, f)
                            }
                        }
                    }
                }
        },
        collideGroupVsGroup: function(a, c, d, e, f, g) {
            if (0 !== a.length && 0 !== c.length)
                for (var h = 0; h < a.children.length; h++)
                    a.children[h].exists && (a.children[h].physicsType === b.GROUP ? this.collideGroupVsGroup(a.children[h], c, d, e, f, g) : this.collideSpriteVsGroup(a.children[h], c, d, e, f, g))
        },
        separate: function(a, b, c, d, e) {
            if (!a.enable || !b.enable || a.checkCollision.none || b.checkCollision.none || !this.intersects(a, b))
                return !1;
            if (c && !1 === c.call(d, a.sprite, b.sprite))
                return !1;
            if (a.isCircle && b.isCircle)
                return this.separateCircle(a, b, e);
            if (a.isCircle !== b.isCircle) {
                var f = a.isCircle ? b : a
                  , g = a.isCircle ? a : b
                  , h = {
                    x: f.x,
                    y: f.y,
                    right: f.right,
                    bottom: f.bottom
                }
                  , i = {
                    x: g.x + g.radius,
                    y: g.y + g.radius
                };
                if ((i.y < h.y || i.y > h.bottom) && (i.x < h.x || i.x > h.right))
                    return this.separateCircle(a, b, e)
            }
            var j = !1
              , k = !1;
            this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x) ? (j = this.separateX(a, b, e),
            this.intersects(a, b) && (k = this.separateY(a, b, e))) : (k = this.separateY(a, b, e),
            this.intersects(a, b) && (j = this.separateX(a, b, e)));
            var l = j || k;
            return l && (e ? (a.onOverlap && a.onOverlap.dispatch(a.sprite, b.sprite),
            b.onOverlap && b.onOverlap.dispatch(b.sprite, a.sprite)) : (a.onCollide && a.onCollide.dispatch(a.sprite, b.sprite),
            b.onCollide && b.onCollide.dispatch(b.sprite, a.sprite))),
            l
        },
        intersects: function(a, c) {
            return a !== c && (a.isCircle ? c.isCircle ? b.Math.distance(a.center.x, a.center.y, c.center.x, c.center.y) <= a.radius + c.radius : this.circleBodyIntersects(a, c) : c.isCircle ? this.circleBodyIntersects(c, a) : !(a.right <= c.position.x) && (!(a.bottom <= c.position.y) && (!(a.position.x >= c.right) && !(a.position.y >= c.bottom))))
        },
        circleBodyIntersects: function(a, c) {
            var d = b.Math.clamp(a.center.x, c.left, c.right)
              , e = b.Math.clamp(a.center.y, c.top, c.bottom);
            return (a.center.x - d) * (a.center.x - d) + (a.center.y - e) * (a.center.y - e) <= a.radius * a.radius
        },
        separateCircle: function(a, c, d) {
            this.getOverlapX(a, c),
            this.getOverlapY(a, c);
            var e = c.center.x - a.center.x
              , f = c.center.y - a.center.y
              , g = Math.atan2(f, e)
              , h = 0;
            if (a.isCircle !== c.isCircle) {
                var i = {
                    x: c.isCircle ? a.position.x : c.position.x,
                    y: c.isCircle ? a.position.y : c.position.y,
                    right: c.isCircle ? a.right : c.right,
                    bottom: c.isCircle ? a.bottom : c.bottom
                }
                  , j = {
                    x: a.isCircle ? a.position.x + a.radius : c.position.x + c.radius,
                    y: a.isCircle ? a.position.y + a.radius : c.position.y + c.radius,
                    radius: a.isCircle ? a.radius : c.radius
                };
                j.y < i.y ? j.x < i.x ? h = b.Math.distance(j.x, j.y, i.x, i.y) - j.radius : j.x > i.right && (h = b.Math.distance(j.x, j.y, i.right, i.y) - j.radius) : j.y > i.bottom && (j.x < i.x ? h = b.Math.distance(j.x, j.y, i.x, i.bottom) - j.radius : j.x > i.right && (h = b.Math.distance(j.x, j.y, i.right, i.bottom) - j.radius)),
                h *= -1
            } else
                h = a.radius + c.radius - b.Math.distance(a.center.x, a.center.y, c.center.x, c.center.y);
            if (d || 0 === h || a.immovable && c.immovable || a.customSeparateX || c.customSeparateX)
                return 0 !== h && (a.onOverlap && a.onOverlap.dispatch(a.sprite, c.sprite),
                c.onOverlap && c.onOverlap.dispatch(c.sprite, a.sprite)),
                0 !== h;
            var k = {
                x: a.velocity.x * Math.cos(g) + a.velocity.y * Math.sin(g),
                y: a.velocity.x * Math.sin(g) - a.velocity.y * Math.cos(g)
            }
              , l = {
                x: c.velocity.x * Math.cos(g) + c.velocity.y * Math.sin(g),
                y: c.velocity.x * Math.sin(g) - c.velocity.y * Math.cos(g)
            }
              , m = ((a.mass - c.mass) * k.x + 2 * c.mass * l.x) / (a.mass + c.mass)
              , n = (2 * a.mass * k.x + (c.mass - a.mass) * l.x) / (a.mass + c.mass);
            return a.immovable || (a.velocity.x = (m * Math.cos(g) - k.y * Math.sin(g)) * a.bounce.x,
            a.velocity.y = (k.y * Math.cos(g) + m * Math.sin(g)) * a.bounce.y),
            c.immovable || (c.velocity.x = (n * Math.cos(g) - l.y * Math.sin(g)) * c.bounce.x,
            c.velocity.y = (l.y * Math.cos(g) + n * Math.sin(g)) * c.bounce.y),
            Math.abs(g) < Math.PI / 2 ? a.velocity.x > 0 && !a.immovable && c.velocity.x > a.velocity.x ? a.velocity.x *= -1 : c.velocity.x < 0 && !c.immovable && a.velocity.x < c.velocity.x ? c.velocity.x *= -1 : a.velocity.y > 0 && !a.immovable && c.velocity.y > a.velocity.y ? a.velocity.y *= -1 : c.velocity.y < 0 && !c.immovable && a.velocity.y < c.velocity.y && (c.velocity.y *= -1) : Math.abs(g) > Math.PI / 2 && (a.velocity.x < 0 && !a.immovable && c.velocity.x < a.velocity.x ? a.velocity.x *= -1 : c.velocity.x > 0 && !c.immovable && a.velocity.x > c.velocity.x ? c.velocity.x *= -1 : a.velocity.y < 0 && !a.immovable && c.velocity.y < a.velocity.y ? a.velocity.y *= -1 : c.velocity.y > 0 && !c.immovable && a.velocity.x > c.velocity.y && (c.velocity.y *= -1)),
            a.immovable || (a.x += a.velocity.x * this.game.time.physicsElapsed - h * Math.cos(g),
            a.y += a.velocity.y * this.game.time.physicsElapsed - h * Math.sin(g)),
            c.immovable || (c.x += c.velocity.x * this.game.time.physicsElapsed + h * Math.cos(g),
            c.y += c.velocity.y * this.game.time.physicsElapsed + h * Math.sin(g)),
            a.onCollide && a.onCollide.dispatch(a.sprite, c.sprite),
            c.onCollide && c.onCollide.dispatch(c.sprite, a.sprite),
            !0
        },
        getOverlapX: function(a, b, c) {
            var d = 0
              , e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
            return 0 === a.deltaX() && 0 === b.deltaX() ? (a.embedded = !0,
            b.embedded = !0) : a.deltaX() > b.deltaX() ? (d = a.right - b.x,
            d > e && !c || !1 === a.checkCollision.right || !1 === b.checkCollision.left ? d = 0 : (a.touching.none = !1,
            a.touching.right = !0,
            b.touching.none = !1,
            b.touching.left = !0)) : a.deltaX() < b.deltaX() && (d = a.x - b.width - b.x,
            -d > e && !c || !1 === a.checkCollision.left || !1 === b.checkCollision.right ? d = 0 : (a.touching.none = !1,
            a.touching.left = !0,
            b.touching.none = !1,
            b.touching.right = !0)),
            a.overlapX = d,
            b.overlapX = d,
            d
        },
        getOverlapY: function(a, b, c) {
            var d = 0
              , e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
            return 0 === a.deltaY() && 0 === b.deltaY() ? (a.embedded = !0,
            b.embedded = !0) : a.deltaY() > b.deltaY() ? (d = a.bottom - b.y,
            d > e && !c || !1 === a.checkCollision.down || !1 === b.checkCollision.up ? d = 0 : (a.touching.none = !1,
            a.touching.down = !0,
            b.touching.none = !1,
            b.touching.up = !0)) : a.deltaY() < b.deltaY() && (d = a.y - b.bottom,
            -d > e && !c || !1 === a.checkCollision.up || !1 === b.checkCollision.down ? d = 0 : (a.touching.none = !1,
            a.touching.up = !0,
            b.touching.none = !1,
            b.touching.down = !0)),
            a.overlapY = d,
            b.overlapY = d,
            d
        },
        separateX: function(a, b, c) {
            var d = this.getOverlapX(a, b, c);
            if (c || 0 === d || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX)
                return 0 !== d || a.embedded && b.embedded;
            var e = a.velocity.x
              , f = b.velocity.x;
            if (a.immovable || b.immovable)
                a.immovable ? (b.x += d,
                b.velocity.x = e - f * b.bounce.x,
                a.moves && (b.y += (a.y - a.prev.y) * a.friction.y)) : (a.x -= d,
                a.velocity.x = f - e * a.bounce.x,
                b.moves && (a.y += (b.y - b.prev.y) * b.friction.y));
            else {
                d *= .5,
                a.x -= d,
                b.x += d;
                var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1)
                  , h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1)
                  , i = .5 * (g + h);
                g -= i,
                h -= i,
                a.velocity.x = i + g * a.bounce.x,
                b.velocity.x = i + h * b.bounce.x
            }
            return !0
        },
        separateY: function(a, b, c) {
            var d = this.getOverlapY(a, b, c);
            if (c || 0 === d || a.immovable && b.immovable || a.customSeparateY || b.customSeparateY)
                return 0 !== d || a.embedded && b.embedded;
            var e = a.velocity.y
              , f = b.velocity.y;
            if (a.immovable || b.immovable)
                a.immovable ? (b.y += d,
                b.velocity.y = e - f * b.bounce.y,
                a.moves && (b.x += (a.x - a.prev.x) * a.friction.x)) : (a.y -= d,
                a.velocity.y = f - e * a.bounce.y,
                b.moves && (a.x += (b.x - b.prev.x) * b.friction.x));
            else {
                d *= .5,
                a.y -= d,
                b.y += d;
                var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1)
                  , h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1)
                  , i = .5 * (g + h);
                g -= i,
                h -= i,
                a.velocity.y = i + g * a.bounce.y,
                b.velocity.y = i + h * b.bounce.y
            }
            return !0
        },
        getObjectsUnderPointer: function(a, b, c, d) {
            if (0 !== b.length && a.exists)
                return this.getObjectsAtLocation(a.x, a.y, b, c, d, a)
        },
        getObjectsAtLocation: function(a, c, d, e, f, g) {
            this.quadTree.clear(),
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels),
            this.quadTree.populate(d);
            for (var h = new b.Rectangle(a,c,1,1), i = [], j = this.quadTree.retrieve(h), k = 0; k < j.length; k++)
                j[k].hitTest(a, c) && (e && e.call(f, g, j[k].sprite),
                i.push(j[k].sprite));
            return i
        },
        moveToObject: function(a, b, c, d) {
            void 0 === c && (c = 60),
            void 0 === d && (d = 0);
            var e = Math.atan2(b.y - a.y, b.x - a.x);
            return d > 0 && (c = this.distanceBetween(a, b) / (d / 1e3)),
            a.body.velocity.x = Math.cos(e) * c,
            a.body.velocity.y = Math.sin(e) * c,
            e
        },
        moveToPointer: function(a, b, c, d) {
            void 0 === b && (b = 60),
            c = c || this.game.input.activePointer,
            void 0 === d && (d = 0);
            var e = this.angleToPointer(a, c);
            return d > 0 && (b = this.distanceToPointer(a, c) / (d / 1e3)),
            a.body.velocity.x = Math.cos(e) * b,
            a.body.velocity.y = Math.sin(e) * b,
            e
        },
        moveToXY: function(a, b, c, d, e) {
            void 0 === d && (d = 60),
            void 0 === e && (e = 0);
            var f = Math.atan2(c - a.y, b - a.x);
            return e > 0 && (d = this.distanceToXY(a, b, c) / (e / 1e3)),
            a.body.velocity.x = Math.cos(f) * d,
            a.body.velocity.y = Math.sin(f) * d,
            f
        },
        velocityFromAngle: function(a, c, d) {
            return void 0 === c && (c = 60),
            d = d || new b.Point,
            d.setTo(Math.cos(this.game.math.degToRad(a)) * c, Math.sin(this.game.math.degToRad(a)) * c)
        },
        velocityFromRotation: function(a, c, d) {
            return void 0 === c && (c = 60),
            d = d || new b.Point,
            d.setTo(Math.cos(a) * c, Math.sin(a) * c)
        },
        accelerationFromRotation: function(a, c, d) {
            return void 0 === c && (c = 60),
            d = d || new b.Point,
            d.setTo(Math.cos(a) * c, Math.sin(a) * c)
        },
        accelerateToObject: function(a, b, c, d, e) {
            void 0 === c && (c = 60),
            void 0 === d && (d = 1e3),
            void 0 === e && (e = 1e3);
            var f = this.angleBetween(a, b);
            return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c),
            a.body.maxVelocity.setTo(d, e),
            f
        },
        accelerateToPointer: function(a, b, c, d, e) {
            void 0 === c && (c = 60),
            void 0 === b && (b = this.game.input.activePointer),
            void 0 === d && (d = 1e3),
            void 0 === e && (e = 1e3);
            var f = this.angleToPointer(a, b);
            return a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c),
            a.body.maxVelocity.setTo(d, e),
            f
        },
        accelerateToXY: function(a, b, c, d, e, f) {
            void 0 === d && (d = 60),
            void 0 === e && (e = 1e3),
            void 0 === f && (f = 1e3);
            var g = this.angleToXY(a, b, c);
            return a.body.acceleration.setTo(Math.cos(g) * d, Math.sin(g) * d),
            a.body.maxVelocity.setTo(e, f),
            g
        },
        distanceBetween: function(a, b, c) {
            void 0 === c && (c = !1);
            var d = c ? a.world.x - b.world.x : a.x - b.x
              , e = c ? a.world.y - b.world.y : a.y - b.y;
            return Math.sqrt(d * d + e * e)
        },
        distanceToXY: function(a, b, c, d) {
            void 0 === d && (d = !1);
            var e = d ? a.world.x - b : a.x - b
              , f = d ? a.world.y - c : a.y - c;
            return Math.sqrt(e * e + f * f)
        },
        distanceToPointer: function(a, b, c) {
            void 0 === b && (b = this.game.input.activePointer),
            void 0 === c && (c = !1);
            var d = c ? a.world.x - b.worldX : a.x - b.worldX
              , e = c ? a.world.y - b.worldY : a.y - b.worldY;
            return Math.sqrt(d * d + e * e)
        },
        angleBetween: function(a, b, c) {
            return void 0 === c && (c = !1),
            c ? Math.atan2(b.world.y - a.world.y, b.world.x - a.world.x) : Math.atan2(b.y - a.y, b.x - a.x)
        },
        angleBetweenCenters: function(a, b) {
            var c = b.centerX - a.centerX
              , d = b.centerY - a.centerY;
            return Math.atan2(d, c)
        },
        angleToXY: function(a, b, c, d) {
            return void 0 === d && (d = !1),
            d ? Math.atan2(c - a.world.y, b - a.world.x) : Math.atan2(c - a.y, b - a.x)
        },
        angleToPointer: function(a, b, c) {
            return void 0 === b && (b = this.game.input.activePointer),
            void 0 === c && (c = !1),
            c ? Math.atan2(b.worldY - a.world.y, b.worldX - a.world.x) : Math.atan2(b.worldY - a.y, b.worldX - a.x)
        },
        worldAngleToPointer: function(a, b) {
            return this.angleToPointer(a, b, !0)
        }
    },
    b.Physics.Arcade.Body = function(a) {
        this.sprite = a,
        this.game = a.game,
        this.type = b.Physics.ARCADE,
        this.enable = !0,
        this.isCircle = !1,
        this.radius = 0,
        this.offset = new b.Point,
        this.position = new b.Point(a.x,a.y),
        this.prev = new b.Point(this.position.x,this.position.y),
        this.allowRotation = !0,
        this.rotation = a.angle,
        this.preRotation = a.angle,
        this.width = a.width,
        this.height = a.height,
        this.sourceWidth = a.width,
        this.sourceHeight = a.height,
        a.texture && (this.sourceWidth = a.texture.frame.width,
        this.sourceHeight = a.texture.frame.height),
        this.halfWidth = Math.abs(a.width / 2),
        this.halfHeight = Math.abs(a.height / 2),
        this.center = new b.Point(a.x + this.halfWidth,a.y + this.halfHeight),
        this.velocity = new b.Point,
        this.newVelocity = new b.Point,
        this.deltaMax = new b.Point,
        this.acceleration = new b.Point,
        this.drag = new b.Point,
        this.allowGravity = !0,
        this.gravity = new b.Point,
        this.bounce = new b.Point,
        this.worldBounce = null,
        this.onWorldBounds = null,
        this.onCollide = null,
        this.onOverlap = null,
        this.maxVelocity = new b.Point(1e4,1e4),
        this.friction = new b.Point(1,0),
        this.angularVelocity = 0,
        this.angularAcceleration = 0,
        this.angularDrag = 0,
        this.maxAngular = 1e3,
        this.mass = 1,
        this.angle = 0,
        this.speed = 0,
        this.facing = b.NONE,
        this.immovable = !1,
        this.moves = !0,
        this.customSeparateX = !1,
        this.customSeparateY = !1,
        this.overlapX = 0,
        this.overlapY = 0,
        this.overlapR = 0,
        this.embedded = !1,
        this.collideWorldBounds = !1,
        this.checkCollision = {
            none: !1,
            any: !0,
            up: !0,
            down: !0,
            left: !0,
            right: !0
        },
        this.touching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        },
        this.wasTouching = {
            none: !0,
            up: !1,
            down: !1,
            left: !1,
            right: !1
        },
        this.blocked = {
            up: !1,
            down: !1,
            left: !1,
            right: !1
        },
        this.tilePadding = new b.Point,
        this.dirty = !1,
        this.skipQuadTree = !1,
        this.syncBounds = !1,
        this.isMoving = !1,
        this.stopVelocityOnCollide = !0,
        this.moveTimer = 0,
        this.moveDistance = 0,
        this.moveDuration = 0,
        this.moveTarget = null,
        this.moveEnd = null,
        this.onMoveComplete = new b.Signal,
        this.movementCallback = null,
        this.movementCallbackContext = null,
        this._reset = !0,
        this._sx = a.scale.x,
        this._sy = a.scale.y,
        this._dx = 0,
        this._dy = 0
    }
    ,
    b.Physics.Arcade.Body.prototype = {
        updateBounds: function() {
            if (this.syncBounds) {
                var a = this.sprite.getBounds();
                a.ceilAll(),
                a.width === this.width && a.height === this.height || (this.width = a.width,
                this.height = a.height,
                this._reset = !0)
            } else {
                var b = Math.abs(this.sprite.scale.x)
                  , c = Math.abs(this.sprite.scale.y);
                b === this._sx && c === this._sy || (this.width = this.sourceWidth * b,
                this.height = this.sourceHeight * c,
                this._sx = b,
                this._sy = c,
                this._reset = !0)
            }
            this._reset && (this.halfWidth = Math.floor(this.width / 2),
            this.halfHeight = Math.floor(this.height / 2),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
        },
        preUpdate: function() {
            this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0,
            this.wasTouching.none = this.touching.none,
            this.wasTouching.up = this.touching.up,
            this.wasTouching.down = this.touching.down,
            this.wasTouching.left = this.touching.left,
            this.wasTouching.right = this.touching.right,
            this.touching.none = !0,
            this.touching.up = !1,
            this.touching.down = !1,
            this.touching.left = !1,
            this.touching.right = !1,
            this.blocked.up = !1,
            this.blocked.down = !1,
            this.blocked.left = !1,
            this.blocked.right = !1,
            this.embedded = !1,
            this.updateBounds(),
            this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x,
            this.position.x -= this.sprite.scale.x < 0 ? this.width : 0,
            this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y,
            this.position.y -= this.sprite.scale.y < 0 ? this.height : 0,
            this.rotation = this.sprite.angle,
            this.preRotation = this.rotation,
            (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x,
            this.prev.y = this.position.y),
            this.moves && (this.game.physics.arcade.updateMotion(this),
            this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed),
            this.position.x += this.newVelocity.x,
            this.position.y += this.newVelocity.y,
            this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)),
            this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y),
            this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)),
            this._dx = this.deltaX(),
            this._dy = this.deltaY(),
            this._reset = !1)
        },
        updateMovement: function() {
            var a = 0
              , b = 0 !== this.overlapX || 0 !== this.overlapY;
            if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS,
            a = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y),
            a = this.moveTarget.length / this.moveDistance),
            this.movementCallback)
                var c = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, a);
            return !(b || a >= 1 || void 0 !== c && !0 !== c) || (this.stopMovement(a >= 1 || this.stopVelocityOnCollide && b),
            !1)
        },
        stopMovement: function(a) {
            this.isMoving && (this.isMoving = !1,
            a && this.velocity.set(0),
            this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
        },
        postUpdate: function() {
            this.enable && this.dirty && (this.isMoving && this.updateMovement(),
            this.dirty = !1,
            this.deltaX() < 0 ? this.facing = b.LEFT : this.deltaX() > 0 && (this.facing = b.RIGHT),
            this.deltaY() < 0 ? this.facing = b.UP : this.deltaY() > 0 && (this.facing = b.DOWN),
            this.moves && (this._dx = this.deltaX(),
            this._dy = this.deltaY(),
            0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)),
            0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)),
            this.sprite.position.x += this._dx,
            this.sprite.position.y += this._dy,
            this._reset = !0),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight),
            this.allowRotation && (this.sprite.angle += this.deltaZ()),
            this.prev.x = this.position.x,
            this.prev.y = this.position.y)
        },
        checkWorldBounds: function() {
            var a = this.position
              , b = this.game.physics.arcade.bounds
              , c = this.game.physics.arcade.checkCollision
              , d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x
              , e = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
            if (this.isCircle) {
                var f = {
                    x: this.center.x - this.radius,
                    y: this.center.y - this.radius,
                    right: this.center.x + this.radius,
                    bottom: this.center.y + this.radius
                };
                f.x < b.x && c.left ? (a.x = b.x - this.halfWidth + this.radius,
                this.velocity.x *= d,
                this.blocked.left = !0) : f.right > b.right && c.right && (a.x = b.right - this.halfWidth - this.radius,
                this.velocity.x *= d,
                this.blocked.right = !0),
                f.y < b.y && c.up ? (a.y = b.y - this.halfHeight + this.radius,
                this.velocity.y *= e,
                this.blocked.up = !0) : f.bottom > b.bottom && c.down && (a.y = b.bottom - this.halfHeight - this.radius,
                this.velocity.y *= e,
                this.blocked.down = !0)
            } else
                a.x < b.x && c.left ? (a.x = b.x,
                this.velocity.x *= d,
                this.blocked.left = !0) : this.right > b.right && c.right && (a.x = b.right - this.width,
                this.velocity.x *= d,
                this.blocked.right = !0),
                a.y < b.y && c.up ? (a.y = b.y,
                this.velocity.y *= e,
                this.blocked.up = !0) : this.bottom > b.bottom && c.down && (a.y = b.bottom - this.height,
                this.velocity.y *= e,
                this.blocked.down = !0);
            return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
        },
        moveFrom: function(a, b, c) {
            if (void 0 === b && (b = this.speed),
            0 === b)
                return !1;
            var d;
            return void 0 === c ? (d = this.angle,
            c = this.game.math.radToDeg(d)) : d = this.game.math.degToRad(c),
            this.moveTimer = 0,
            this.moveDuration = a,
            0 === c || 180 === c ? this.velocity.set(Math.cos(d) * b, 0) : 90 === c || 270 === c ? this.velocity.set(0, Math.sin(d) * b) : this.velocity.set(Math.cos(d) * b, Math.sin(d) * b),
            this.isMoving = !0,
            !0
        },
        moveTo: function(a, c, d) {
            var e = c / (a / 1e3);
            if (0 === e)
                return !1;
            var f;
            return void 0 === d ? (f = this.angle,
            d = this.game.math.radToDeg(f)) : f = this.game.math.degToRad(d),
            c = Math.abs(c),
            this.moveDuration = 0,
            this.moveDistance = c,
            null === this.moveTarget && (this.moveTarget = new b.Line,
            this.moveEnd = new b.Point),
            this.moveTarget.fromAngle(this.x, this.y, f, c),
            this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y),
            this.moveTarget.setTo(this.x, this.y, this.x, this.y),
            0 === d || 180 === d ? this.velocity.set(Math.cos(f) * e, 0) : 90 === d || 270 === d ? this.velocity.set(0, Math.sin(f) * e) : this.velocity.set(Math.cos(f) * e, Math.sin(f) * e),
            this.isMoving = !0,
            !0
        },
        setSize: function(a, b, c, d) {
            void 0 === c && (c = this.offset.x),
            void 0 === d && (d = this.offset.y),
            this.sourceWidth = a,
            this.sourceHeight = b,
            this.width = this.sourceWidth * this._sx,
            this.height = this.sourceHeight * this._sy,
            this.halfWidth = Math.floor(this.width / 2),
            this.halfHeight = Math.floor(this.height / 2),
            this.offset.setTo(c, d),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight),
            this.isCircle = !1,
            this.radius = 0
        },
        setCircle: function(a, b, c) {
            void 0 === b && (b = this.offset.x),
            void 0 === c && (c = this.offset.y),
            a > 0 ? (this.isCircle = !0,
            this.radius = a,
            this.sourceWidth = 2 * a,
            this.sourceHeight = 2 * a,
            this.width = this.sourceWidth * this._sx,
            this.height = this.sourceHeight * this._sy,
            this.halfWidth = Math.floor(this.width / 2),
            this.halfHeight = Math.floor(this.height / 2),
            this.offset.setTo(b, c),
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
        },
        reset: function(a, b) {
            this.velocity.set(0),
            this.acceleration.set(0),
            this.speed = 0,
            this.angularVelocity = 0,
            this.angularAcceleration = 0,
            this.position.x = a - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x,
            this.position.x -= this.sprite.scale.x < 0 ? this.width : 0,
            this.position.y = b - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y,
            this.position.y -= this.sprite.scale.y < 0 ? this.height : 0,
            this.prev.x = this.position.x,
            this.prev.y = this.position.y,
            this.rotation = this.sprite.angle,
            this.preRotation = this.rotation,
            this._sx = this.sprite.scale.x,
            this._sy = this.sprite.scale.y,
            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
        },
        getBounds: function(a) {
            return this.isCircle ? (a.x = this.center.x - this.radius,
            a.y = this.center.y - this.radius,
            a.right = this.center.x + this.radius,
            a.bottom = this.center.y + this.radius) : (a.x = this.x,
            a.y = this.y,
            a.right = this.right,
            a.bottom = this.bottom),
            a
        },
        hitTest: function(a, c) {
            return this.isCircle ? b.Circle.contains(this, a, c) : b.Rectangle.contains(this, a, c)
        },
        onFloor: function() {
            return this.blocked.down
        },
        onCeiling: function() {
            return this.blocked.up
        },
        onWall: function() {
            return this.blocked.left || this.blocked.right
        },
        deltaAbsX: function() {
            return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
        },
        deltaAbsY: function() {
            return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
        },
        deltaX: function() {
            return this.position.x - this.prev.x
        },
        deltaY: function() {
            return this.position.y - this.prev.y
        },
        deltaZ: function() {
            return this.rotation - this.preRotation
        },
        destroy: function() {
            this.sprite.parent && this.sprite.parent instanceof b.Group && this.sprite.parent.removeFromHash(this.sprite),
            this.sprite.body = null,
            this.sprite = null
        }
    },
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "left", {
        get: function() {
            return this.position.x
        }
    }),
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "right", {
        get: function() {
            return this.position.x + this.width
        }
    }),
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "top", {
        get: function() {
            return this.position.y
        }
    }),
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "bottom", {
        get: function() {
            return this.position.y + this.height
        }
    }),
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "x", {
        get: function() {
            return this.position.x
        },
        set: function(a) {
            this.position.x = a
        }
    }),
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "y", {
        get: function() {
            return this.position.y
        },
        set: function(a) {
            this.position.y = a
        }
    }),
    b.Physics.Arcade.Body.render = function(a, b, c, d) {
        void 0 === d && (d = !0),
        c = c || "rgba(0,255,0,0.4)",
        a.fillStyle = c,
        a.strokeStyle = c,
        b.isCircle ? (a.beginPath(),
        a.arc(b.center.x - b.game.camera.x, b.center.y - b.game.camera.y, b.radius, 0, 2 * Math.PI),
        d ? a.fill() : a.stroke()) : d ? a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height) : a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height)
    }
    ,
    b.Physics.Arcade.Body.renderBodyInfo = function(a, b) {
        a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height),
        a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2)),
        a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2)),
        a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2)),
        a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down),
        a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down)
    }
    ,
    b.Physics.Arcade.Body.prototype.constructor = b.Physics.Arcade.Body,
    b.Physics.Arcade.TilemapCollision = function() {}
    ,
    b.Physics.Arcade.TilemapCollision.prototype = {
        TILE_BIAS: 16,
        collideSpriteVsTilemapLayer: function(a, b, c, d, e, f) {
            if (a.body) {
                var g = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, !1, !1);
                if (0 !== g.length)
                    for (var h = 0; h < g.length; h++)
                        d ? d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], b, f) && (this._total++,
                        c && c.call(e, a, g[h])) : this.separateTile(h, a.body, g[h], b, f) && (this._total++,
                        c && c.call(e, a, g[h]))
            }
        },
        collideGroupVsTilemapLayer: function(a, b, c, d, e, f) {
            if (0 !== a.length)
                for (var g = 0; g < a.children.length; g++)
                    a.children[g].exists && this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f)
        },
        separateTile: function(a, b, c, d, e) {
            if (!b.enable)
                return !1;
            var f = d.fixedToCamera ? 0 : d.position.x
              , g = d.fixedToCamera ? 0 : d.position.y;
            if (!c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))
                return !1;
            if (e)
                return !0;
            if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c))
                return !1;
            if (void 0 !== c.layer.callbacks && c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c))
                return !1;
            if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom))
                return !1;
            var h = 0
              , i = 0
              , j = 0
              , k = 1;
            if (b.deltaAbsX() > b.deltaAbsY() ? j = -1 : b.deltaAbsX() < b.deltaAbsY() && (k = -1),
            0 !== b.deltaX() && 0 !== b.deltaY() && (c.faceLeft || c.faceRight) && (c.faceTop || c.faceBottom) && (j = Math.min(Math.abs(b.position.x - f - c.right), Math.abs(b.right - f - c.left)),
            k = Math.min(Math.abs(b.position.y - g - c.bottom), Math.abs(b.bottom - g - c.top))),
            j < k) {
                if ((c.faceLeft || c.faceRight) && 0 !== (h = this.tileCheckX(b, c, d)) && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))
                    return !0;
                (c.faceTop || c.faceBottom) && (i = this.tileCheckY(b, c, d))
            } else {
                if ((c.faceTop || c.faceBottom) && 0 !== (i = this.tileCheckY(b, c, d)) && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g))
                    return !0;
                (c.faceLeft || c.faceRight) && (h = this.tileCheckX(b, c, d))
            }
            return 0 !== h || 0 !== i
        },
        tileCheckX: function(a, b, c) {
            var d = 0
              , e = c.fixedToCamera ? 0 : c.position.x;
            return a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left ? b.faceRight && a.x - e < b.right && (d = a.x - e - b.right) < -this.TILE_BIAS && (d = 0) : a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right - e > b.left && (d = a.right - e - b.left) > this.TILE_BIAS && (d = 0),
            0 !== d && (a.customSeparateX ? a.overlapX = d : this.processTileSeparationX(a, d)),
            d
        },
        tileCheckY: function(a, b, c) {
            var d = 0
              , e = c.fixedToCamera ? 0 : c.position.y;
            return a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up ? b.faceBottom && a.y - e < b.bottom && (d = a.y - e - b.bottom) < -this.TILE_BIAS && (d = 0) : a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom - e > b.top && (d = a.bottom - e - b.top) > this.TILE_BIAS && (d = 0),
            0 !== d && (a.customSeparateY ? a.overlapY = d : this.processTileSeparationY(a, d)),
            d
        },
        processTileSeparationX: function(a, b) {
            b < 0 ? a.blocked.left = !0 : b > 0 && (a.blocked.right = !0),
            a.position.x -= b,
            0 === a.bounce.x ? a.velocity.x = 0 : a.velocity.x = -a.velocity.x * a.bounce.x
        },
        processTileSeparationY: function(a, b) {
            b < 0 ? a.blocked.up = !0 : b > 0 && (a.blocked.down = !0),
            a.position.y -= b,
            0 === a.bounce.y ? a.velocity.y = 0 : a.velocity.y = -a.velocity.y * a.bounce.y
        }
    },
    b.Utils.mixinPrototype(b.Physics.Arcade.prototype, b.Physics.Arcade.TilemapCollision.prototype),
    p2.Body.prototype.parent = null,
    p2.Spring.prototype.parent = null,
    b.Physics.P2 = function(a, c) {
        this.game = a,
        void 0 === c ? c = {
            gravity: [0, 0],
            broadphase: new p2.SAPBroadphase
        } : (c.hasOwnProperty("gravity") || (c.gravity = [0, 0]),
        c.hasOwnProperty("broadphase") || (c.broadphase = new p2.SAPBroadphase)),
        this.config = c,
        this.world = new p2.World(this.config),
        this.frameRate = 1 / 60,
        this.useElapsedTime = !1,
        this.paused = !1,
        this.materials = [],
        this.gravity = new b.Physics.P2.InversePointProxy(this,this.world.gravity),
        this.walls = {
            left: null,
            right: null,
            top: null,
            bottom: null
        },
        this.onBodyAdded = new b.Signal,
        this.onBodyRemoved = new b.Signal,
        this.onSpringAdded = new b.Signal,
        this.onSpringRemoved = new b.Signal,
        this.onConstraintAdded = new b.Signal,
        this.onConstraintRemoved = new b.Signal,
        this.onContactMaterialAdded = new b.Signal,
        this.onContactMaterialRemoved = new b.Signal,
        this.postBroadphaseCallback = null,
        this.callbackContext = null,
        this.onBeginContact = new b.Signal,
        this.onEndContact = new b.Signal,
        c.hasOwnProperty("mpx") && c.hasOwnProperty("pxm") && c.hasOwnProperty("mpxi") && c.hasOwnProperty("pxmi") && (this.mpx = c.mpx,
        this.mpxi = c.mpxi,
        this.pxm = c.pxm,
        this.pxmi = c.pxmi),
        this.world.on("beginContact", this.beginContactHandler, this),
        this.world.on("endContact", this.endContactHandler, this),
        this.collisionGroups = [],
        this.nothingCollisionGroup = new b.Physics.P2.CollisionGroup(1),
        this.boundsCollisionGroup = new b.Physics.P2.CollisionGroup(2),
        this.everythingCollisionGroup = new b.Physics.P2.CollisionGroup(2147483648),
        this.boundsCollidesWith = [],
        this._toRemove = [],
        this._collisionGroupID = 2,
        this._boundsLeft = !0,
        this._boundsRight = !0,
        this._boundsTop = !0,
        this._boundsBottom = !0,
        this._boundsOwnGroup = !1,
        this.setBoundsToWorld(!0, !0, !0, !0, !1)
    }
    ,
    b.Physics.P2.prototype = {
        removeBodyNextStep: function(a) {
            this._toRemove.push(a)
        },
        preUpdate: function() {
            for (var a = this._toRemove.length; a--; )
                this.removeBody(this._toRemove[a]);
            this._toRemove.length = 0
        },
        enable: function(a, c, d) {
            void 0 === c && (c = !1),
            void 0 === d && (d = !0);
            var e = 1;
            if (Array.isArray(a))
                for (e = a.length; e--; )
                    a[e]instanceof b.Group ? this.enable(a[e].children, c, d) : (this.enableBody(a[e], c),
                    d && a[e].hasOwnProperty("children") && a[e].children.length > 0 && this.enable(a[e], c, !0));
            else
                a instanceof b.Group ? this.enable(a.children, c, d) : (this.enableBody(a, c),
                d && a.hasOwnProperty("children") && a.children.length > 0 && this.enable(a.children, c, !0))
        },
        enableBody: function(a, c) {
            a.hasOwnProperty("body") && null === a.body && (a.body = new b.Physics.P2.Body(this.game,a,a.x,a.y,1),
            a.body.debug = c,
            void 0 !== a.anchor && a.anchor.set(.5))
        },
        setImpactEvents: function(a) {
            a ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
        },
        setPostBroadphaseCallback: function(a, b) {
            this.postBroadphaseCallback = a,
            this.callbackContext = b,
            null !== a ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
        },
        postBroadphaseHandler: function(a) {
            if (this.postBroadphaseCallback && 0 !== a.pairs.length)
                for (var b = a.pairs.length - 2; b >= 0; b -= 2)
                    a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent) && a.pairs.splice(b, 2)
        },
        impactHandler: function(a) {
            if (a.bodyA.parent && a.bodyB.parent) {
                var b = a.bodyA.parent
                  , c = a.bodyB.parent;
                b._bodyCallbacks[a.bodyB.id] && b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB),
                c._bodyCallbacks[a.bodyA.id] && c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA),
                b._groupCallbacks[a.shapeB.collisionGroup] && b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB),
                c._groupCallbacks[a.shapeA.collisionGroup] && c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA)
            }
        },
        beginContactHandler: function(a) {
            a.bodyA && a.bodyB && (this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations),
            a.bodyA.parent && a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations),
            a.bodyB.parent && a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations))
        },
        endContactHandler: function(a) {
            a.bodyA && a.bodyB && (this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB),
            a.bodyA.parent && a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB),
            a.bodyB.parent && a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA))
        },
        setBoundsToWorld: function(a, b, c, d, e) {
            this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e)
        },
        setWorldMaterial: function(a, b, c, d, e) {
            void 0 === b && (b = !0),
            void 0 === c && (c = !0),
            void 0 === d && (d = !0),
            void 0 === e && (e = !0),
            b && this.walls.left && (this.walls.left.shapes[0].material = a),
            c && this.walls.right && (this.walls.right.shapes[0].material = a),
            d && this.walls.top && (this.walls.top.shapes[0].material = a),
            e && this.walls.bottom && (this.walls.bottom.shapes[0].material = a)
        },
        updateBoundsCollisionGroup: function(a) {
            void 0 === a && (a = !0);
            var b = a ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
            this.walls.left && (this.walls.left.shapes[0].collisionGroup = b),
            this.walls.right && (this.walls.right.shapes[0].collisionGroup = b),
            this.walls.top && (this.walls.top.shapes[0].collisionGroup = b),
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = b),
            this._boundsOwnGroup = a
        },
        setBounds: function(a, b, c, d, e, f, g, h, i) {
            void 0 === e && (e = this._boundsLeft),
            void 0 === f && (f = this._boundsRight),
            void 0 === g && (g = this._boundsTop),
            void 0 === h && (h = this._boundsBottom),
            void 0 === i && (i = this._boundsOwnGroup),
            this.setupWall(e, "left", a, b, 1.5707963267948966, i),
            this.setupWall(f, "right", a + c, b, -1.5707963267948966, i),
            this.setupWall(g, "top", a, b, -3.141592653589793, i),
            this.setupWall(h, "bottom", a, b + d, 0, i),
            this._boundsLeft = e,
            this._boundsRight = f,
            this._boundsTop = g,
            this._boundsBottom = h,
            this._boundsOwnGroup = i
        },
        setupWall: function(a, b, c, d, e, f) {
            a ? (this.walls[b] ? this.walls[b].position = [this.pxmi(c), this.pxmi(d)] : (this.walls[b] = new p2.Body({
                mass: 0,
                position: [this.pxmi(c), this.pxmi(d)],
                angle: e
            }),
            this.walls[b].addShape(new p2.Plane),
            this.world.addBody(this.walls[b])),
            f && (this.walls[b].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[b] && (this.world.removeBody(this.walls[b]),
            this.walls[b] = null)
        },
        pause: function() {
            this.paused = !0
        },
        resume: function() {
            this.paused = !1
        },
        update: function() {
            this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
        },
        reset: function() {
            this.world.on("beginContact", this.beginContactHandler, this),
            this.world.on("endContact", this.endContactHandler, this),
            this.nothingCollisionGroup = new b.Physics.P2.CollisionGroup(1),
            this.boundsCollisionGroup = new b.Physics.P2.CollisionGroup(2),
            this.everythingCollisionGroup = new b.Physics.P2.CollisionGroup(2147483648),
            this._collisionGroupID = 2,
            this.setBoundsToWorld(!0, !0, !0, !0, !1)
        },
        clear: function() {
            this.world.time = 0,
            this.world.fixedStepTime = 0,
            this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
            for (var a = this.world.constraints, b = a.length - 1; b >= 0; b--)
                this.world.removeConstraint(a[b]);
            for (var c = this.world.bodies, b = c.length - 1; b >= 0; b--)
                this.world.removeBody(c[b]);
            for (var d = this.world.springs, b = d.length - 1; b >= 0; b--)
                this.world.removeSpring(d[b]);
            for (var e = this.world.contactMaterials, b = e.length - 1; b >= 0; b--)
                this.world.removeContactMaterial(e[b]);
            this.world.off("beginContact", this.beginContactHandler, this),
            this.world.off("endContact", this.endContactHandler, this),
            this.postBroadphaseCallback = null,
            this.callbackContext = null,
            this.impactCallback = null,
            this.collisionGroups = [],
            this._toRemove = [],
            this.boundsCollidesWith = [],
            this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }
        },
        destroy: function() {
            this.clear(),
            this.game = null
        },
        addBody: function(a) {
            return !a.data.world && (this.world.addBody(a.data),
            this.onBodyAdded.dispatch(a),
            !0)
        },
        removeBody: function(a) {
            return a.data.world === this.world && (this.world.removeBody(a.data),
            this.onBodyRemoved.dispatch(a)),
            a
        },
        addSpring: function(a) {
            return a instanceof b.Physics.P2.Spring || a instanceof b.Physics.P2.RotationalSpring ? this.world.addSpring(a.data) : this.world.addSpring(a),
            this.onSpringAdded.dispatch(a),
            a
        },
        removeSpring: function(a) {
            return a instanceof b.Physics.P2.Spring || a instanceof b.Physics.P2.RotationalSpring ? this.world.removeSpring(a.data) : this.world.removeSpring(a),
            this.onSpringRemoved.dispatch(a),
            a
        },
        createDistanceConstraint: function(a, c, d, e, f, g) {
            if (a = this.getBody(a),
            c = this.getBody(c),
            a && c)
                return this.addConstraint(new b.Physics.P2.DistanceConstraint(this,a,c,d,e,f,g));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createGearConstraint: function(a, c, d, e) {
            if (a = this.getBody(a),
            c = this.getBody(c),
            a && c)
                return this.addConstraint(new b.Physics.P2.GearConstraint(this,a,c,d,e));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createRevoluteConstraint: function(a, c, d, e, f, g) {
            if (a = this.getBody(a),
            d = this.getBody(d),
            a && d)
                return this.addConstraint(new b.Physics.P2.RevoluteConstraint(this,a,c,d,e,f,g));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createLockConstraint: function(a, c, d, e, f) {
            if (a = this.getBody(a),
            c = this.getBody(c),
            a && c)
                return this.addConstraint(new b.Physics.P2.LockConstraint(this,a,c,d,e,f));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        createPrismaticConstraint: function(a, c, d, e, f, g, h) {
            if (a = this.getBody(a),
            c = this.getBody(c),
            a && c)
                return this.addConstraint(new b.Physics.P2.PrismaticConstraint(this,a,c,d,e,f,g,h));
            console.warn("Cannot create Constraint, invalid body objects given")
        },
        addConstraint: function(a) {
            return this.world.addConstraint(a),
            this.onConstraintAdded.dispatch(a),
            a
        },
        removeConstraint: function(a) {
            return this.world.removeConstraint(a),
            this.onConstraintRemoved.dispatch(a),
            a
        },
        addContactMaterial: function(a) {
            return this.world.addContactMaterial(a),
            this.onContactMaterialAdded.dispatch(a),
            a
        },
        removeContactMaterial: function(a) {
            return this.world.removeContactMaterial(a),
            this.onContactMaterialRemoved.dispatch(a),
            a
        },
        getContactMaterial: function(a, b) {
            return this.world.getContactMaterial(a, b)
        },
        setMaterial: function(a, b) {
            for (var c = b.length; c--; )
                b[c].setMaterial(a)
        },
        createMaterial: function(a, c) {
            a = a || "";
            var d = new b.Physics.P2.Material(a);
            return this.materials.push(d),
            void 0 !== c && c.setMaterial(d),
            d
        },
        createContactMaterial: function(a, c, d) {
            void 0 === a && (a = this.createMaterial()),
            void 0 === c && (c = this.createMaterial());
            var e = new b.Physics.P2.ContactMaterial(a,c,d);
            return this.addContactMaterial(e)
        },
        getBodies: function() {
            for (var a = [], b = this.world.bodies.length; b--; )
                a.push(this.world.bodies[b].parent);
            return a
        },
        getBody: function(a) {
            return a instanceof p2.Body ? a : a instanceof b.Physics.P2.Body ? a.data : a.body && a.body.type === b.Physics.P2JS ? a.body.data : null
        },
        getSprings: function() {
            for (var a = [], b = this.world.springs.length; b--; )
                a.push(this.world.springs[b].parent);
            return a
        },
        getConstraints: function() {
            for (var a = [], b = this.world.constraints.length; b--; )
                a.push(this.world.constraints[b]);
            return a
        },
        hitTest: function(a, c, d, e) {
            void 0 === c && (c = this.world.bodies),
            void 0 === d && (d = 5),
            void 0 === e && (e = !1);
            for (var f = [this.pxmi(a.x), this.pxmi(a.y)], g = [], h = c.length; h--; )
                c[h]instanceof b.Physics.P2.Body && (!e || c[h].data.type !== p2.Body.STATIC) ? g.push(c[h].data) : c[h]instanceof p2.Body && c[h].parent && (!e || c[h].type !== p2.Body.STATIC) ? g.push(c[h]) : c[h]instanceof b.Sprite && c[h].hasOwnProperty("body") && (!e || c[h].body.data.type !== p2.Body.STATIC) && g.push(c[h].body.data);
            return this.world.hitTest(f, g, d)
        },
        toJSON: function() {
            return this.world.toJSON()
        },
        createCollisionGroup: function(a) {
            var c = Math.pow(2, this._collisionGroupID);
            this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | c),
            this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | c),
            this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | c),
            this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | c),
            this._collisionGroupID++;
            var d = new b.Physics.P2.CollisionGroup(c);
            return this.collisionGroups.push(d),
            a && this.setCollisionGroup(a, d),
            d
        },
        setCollisionGroup: function(a, c) {
            if (a instanceof b.Group)
                for (var d = 0; d < a.total; d++)
                    a.children[d].body && a.children[d].body.type === b.Physics.P2JS && a.children[d].body.setCollisionGroup(c);
            else
                a.body.setCollisionGroup(c)
        },
        createSpring: function(a, c, d, e, f, g, h, i, j) {
            if (a = this.getBody(a),
            c = this.getBody(c),
            a && c)
                return this.addSpring(new b.Physics.P2.Spring(this,a,c,d,e,f,g,h,i,j));
            console.warn("Cannot create Spring, invalid body objects given")
        },
        createRotationalSpring: function(a, c, d, e, f) {
            if (a = this.getBody(a),
            c = this.getBody(c),
            a && c)
                return this.addSpring(new b.Physics.P2.RotationalSpring(this,a,c,d,e,f));
            console.warn("Cannot create Rotational Spring, invalid body objects given")
        },
        createBody: function(a, c, d, e, f, g) {
            void 0 === e && (e = !1);
            var h = new b.Physics.P2.Body(this.game,null,a,c,d);
            if (g) {
                if (!h.addPolygon(f, g))
                    return !1
            }
            return e && this.world.addBody(h.data),
            h
        },
        createParticle: function(a, c, d, e, f, g) {
            void 0 === e && (e = !1);
            var h = new b.Physics.P2.Body(this.game,null,a,c,d);
            if (g) {
                if (!h.addPolygon(f, g))
                    return !1
            }
            return e && this.world.addBody(h.data),
            h
        },
        convertCollisionObjects: function(a, b, c) {
            void 0 === c && (c = !0);
            for (var d = [], e = 0, f = a.collision[b].length; e < f; e++) {
                var g = a.collision[b][e]
                  , h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
                h && d.push(h)
            }
            return d
        },
        clearTilemapLayerBodies: function(a, b) {
            b = a.getLayer(b);
            for (var c = a.layers[b].bodies.length; c--; )
                a.layers[b].bodies[c].destroy();
            a.layers[b].bodies.length = 0
        },
        convertTilemap: function(a, b, c, d) {
            b = a.getLayer(b),
            void 0 === c && (c = !0),
            void 0 === d && (d = !0),
            this.clearTilemapLayerBodies(a, b);
            for (var e = 0, f = 0, g = 0, h = 0, i = a.layers[b].height; h < i; h++) {
                e = 0;
                for (var j = 0, k = a.layers[b].width; j < k; j++) {
                    var l = a.layers[b].data[h][j];
                    if (l && l.index > -1 && l.collides)
                        if (d) {
                            var m = a.getTileRight(b, j, h);
                            if (0 === e && (f = l.x * l.width,
                            g = l.y * l.height,
                            e = l.width),
                            m && m.collides)
                                e += l.width;
                            else {
                                var n = this.createBody(f, g, 0, !1);
                                n.addRectangle(e, l.height, e / 2, l.height / 2, 0),
                                c && this.addBody(n),
                                a.layers[b].bodies.push(n),
                                e = 0
                            }
                        } else {
                            var n = this.createBody(l.x * l.width, l.y * l.height, 0, !1);
                            n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0),
                            c && this.addBody(n),
                            a.layers[b].bodies.push(n)
                        }
                }
            }
            return a.layers[b].bodies
        },
        mpx: function(a) {
            return a *= 20
        },
        pxm: function(a) {
            return .05 * a
        },
        mpxi: function(a) {
            return a *= -20
        },
        pxmi: function(a) {
            return -.05 * a
        }
    },
    Object.defineProperty(b.Physics.P2.prototype, "friction", {
        get: function() {
            return this.world.defaultContactMaterial.friction
        },
        set: function(a) {
            this.world.defaultContactMaterial.friction = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "restitution", {
        get: function() {
            return this.world.defaultContactMaterial.restitution
        },
        set: function(a) {
            this.world.defaultContactMaterial.restitution = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "contactMaterial", {
        get: function() {
            return this.world.defaultContactMaterial
        },
        set: function(a) {
            this.world.defaultContactMaterial = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "applySpringForces", {
        get: function() {
            return this.world.applySpringForces
        },
        set: function(a) {
            this.world.applySpringForces = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "applyDamping", {
        get: function() {
            return this.world.applyDamping
        },
        set: function(a) {
            this.world.applyDamping = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "applyGravity", {
        get: function() {
            return this.world.applyGravity
        },
        set: function(a) {
            this.world.applyGravity = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "solveConstraints", {
        get: function() {
            return this.world.solveConstraints
        },
        set: function(a) {
            this.world.solveConstraints = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "time", {
        get: function() {
            return this.world.time
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "emitImpactEvent", {
        get: function() {
            return this.world.emitImpactEvent
        },
        set: function(a) {
            this.world.emitImpactEvent = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "sleepMode", {
        get: function() {
            return this.world.sleepMode
        },
        set: function(a) {
            this.world.sleepMode = a
        }
    }),
    Object.defineProperty(b.Physics.P2.prototype, "total", {
        get: function() {
            return this.world.bodies.length
        }
    }),
    b.Physics.P2.FixtureList = function(a) {
        Array.isArray(a) || (a = [a]),
        this.rawList = a,
        this.init(),
        this.parse(this.rawList)
    }
    ,
    b.Physics.P2.FixtureList.prototype = {
        init: function() {
            this.namedFixtures = {},
            this.groupedFixtures = [],
            this.allFixtures = []
        },
        setCategory: function(a, b) {
            var c = function(b) {
                b.collisionGroup = a
            };
            this.getFixtures(b).forEach(c)
        },
        setMask: function(a, b) {
            var c = function(b) {
                b.collisionMask = a
            };
            this.getFixtures(b).forEach(c)
        },
        setSensor: function(a, b) {
            var c = function(b) {
                b.sensor = a
            };
            this.getFixtures(b).forEach(c)
        },
        setMaterial: function(a, b) {
            var c = function(b) {
                b.material = a
            };
            this.getFixtures(b).forEach(c)
        },
        getFixtures: function(a) {
            var b = [];
            if (a) {
                a instanceof Array || (a = [a]);
                var c = this;
                return a.forEach(function(a) {
                    c.namedFixtures[a] && b.push(c.namedFixtures[a])
                }),
                this.flatten(b)
            }
            return this.allFixtures
        },
        getFixtureByKey: function(a) {
            return this.namedFixtures[a]
        },
        getGroup: function(a) {
            return this.groupedFixtures[a]
        },
        parse: function() {
            var a, b, c, d;
            c = this.rawList,
            d = [];
            for (a in c)
                b = c[a],
                isNaN(a - 0) ? this.namedFixtures[a] = this.flatten(b) : (this.groupedFixtures[a] = this.groupedFixtures[a] || [],
                this.groupedFixtures[a] = this.groupedFixtures[a].concat(b)),
                d.push(this.allFixtures = this.flatten(this.groupedFixtures))
        },
        flatten: function(a) {
            var b, c;
            return b = [],
            c = arguments.callee,
            a.forEach(function(a) {
                return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [a])
            }),
            b
        }
    },
    b.Physics.P2.PointProxy = function(a, b) {
        this.world = a,
        this.destination = b
    }
    ,
    b.Physics.P2.PointProxy.prototype.constructor = b.Physics.P2.PointProxy,
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "x", {
        get: function() {
            return this.world.mpx(this.destination[0])
        },
        set: function(a) {
            this.destination[0] = this.world.pxm(a)
        }
    }),
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "y", {
        get: function() {
            return this.world.mpx(this.destination[1])
        },
        set: function(a) {
            this.destination[1] = this.world.pxm(a)
        }
    }),
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0]
        },
        set: function(a) {
            this.destination[0] = a
        }
    }),
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "my", {
        get: function() {
            return this.destination[1]
        },
        set: function(a) {
            this.destination[1] = a
        }
    }),
    b.Physics.P2.InversePointProxy = function(a, b) {
        this.world = a,
        this.destination = b
    }
    ,
    b.Physics.P2.InversePointProxy.prototype.constructor = b.Physics.P2.InversePointProxy,
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.destination[0])
        },
        set: function(a) {
            this.destination[0] = this.world.pxmi(a)
        }
    }),
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.destination[1])
        },
        set: function(a) {
            this.destination[1] = this.world.pxmi(a)
        }
    }),
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "mx", {
        get: function() {
            return this.destination[0]
        },
        set: function(a) {
            this.destination[0] = -a
        }
    }),
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "my", {
        get: function() {
            return this.destination[1]
        },
        set: function(a) {
            this.destination[1] = -a
        }
    }),
    b.Physics.P2.Body = function(a, c, d, e, f) {
        c = c || null,
        d = d || 0,
        e = e || 0,
        void 0 === f && (f = 1),
        this.game = a,
        this.world = a.physics.p2,
        this.sprite = c,
        this.type = b.Physics.P2JS,
        this.offset = new b.Point,
        this.data = new p2.Body({
            position: [this.world.pxmi(d), this.world.pxmi(e)],
            mass: f
        }),
        this.data.parent = this,
        this.velocity = new b.Physics.P2.InversePointProxy(this.world,this.data.velocity),
        this.force = new b.Physics.P2.InversePointProxy(this.world,this.data.force),
        this.gravity = new b.Point,
        this.onBeginContact = new b.Signal,
        this.onEndContact = new b.Signal,
        this.collidesWith = [],
        this.removeNextStep = !1,
        this.debugBody = null,
        this.dirty = !1,
        this._collideWorldBounds = !0,
        this._bodyCallbacks = {},
        this._bodyCallbackContext = {},
        this._groupCallbacks = {},
        this._groupCallbackContext = {},
        this._reset = !1,
        c && (this.setRectangleFromSprite(c),
        c.exists && this.game.physics.p2.addBody(this))
    }
    ,
    b.Physics.P2.Body.prototype = {
        createBodyCallback: function(a, b, c) {
            var d = -1;
            a.id ? d = a.id : a.body && (d = a.body.id),
            d > -1 && (null === b ? (delete this._bodyCallbacks[d],
            delete this._bodyCallbackContext[d]) : (this._bodyCallbacks[d] = b,
            this._bodyCallbackContext[d] = c))
        },
        createGroupCallback: function(a, b, c) {
            null === b ? (delete this._groupCallbacks[a.mask],
            delete this._groupCallbackContext[a.mask]) : (this._groupCallbacks[a.mask] = b,
            this._groupCallbackContext[a.mask] = c)
        },
        getCollisionMask: function() {
            var a = 0;
            this._collideWorldBounds && (a = this.game.physics.p2.boundsCollisionGroup.mask);
            for (var b = 0; b < this.collidesWith.length; b++)
                a |= this.collidesWith[b].mask;
            return a
        },
        updateCollisionMask: function(a) {
            var b = this.getCollisionMask();
            if (void 0 === a)
                for (var c = this.data.shapes.length - 1; c >= 0; c--)
                    this.data.shapes[c].collisionMask = b;
            else
                a.collisionMask = b
        },
        setCollisionGroup: function(a, b) {
            var c = this.getCollisionMask();
            if (void 0 === b)
                for (var d = this.data.shapes.length - 1; d >= 0; d--)
                    this.data.shapes[d].collisionGroup = a.mask,
                    this.data.shapes[d].collisionMask = c;
            else
                b.collisionGroup = a.mask,
                b.collisionMask = c
        },
        clearCollision: function(a, b, c) {
            if (void 0 === a && (a = !0),
            void 0 === b && (b = !0),
            void 0 === c)
                for (var d = this.data.shapes.length - 1; d >= 0; d--)
                    a && (this.data.shapes[d].collisionGroup = null),
                    b && (this.data.shapes[d].collisionMask = null);
            else
                a && (c.collisionGroup = null),
                b && (c.collisionMask = null);
            a && (this.collidesWith.length = 0)
        },
        removeCollisionGroup: function(a, b, c) {
            void 0 === b && (b = !0);
            var d;
            if (Array.isArray(a))
                for (var e = 0; e < a.length; e++)
                    (d = this.collidesWith.indexOf(a[e])) > -1 && (this.collidesWith.splice(d, 1),
                    b && (delete this._groupCallbacks[a.mask],
                    delete this._groupCallbackContext[a.mask]));
            else
                (d = this.collidesWith.indexOf(a)) > -1 && (this.collidesWith.splice(d, 1),
                b && (delete this._groupCallbacks[a.mask],
                delete this._groupCallbackContext[a.mask]));
            var f = this.getCollisionMask();
            if (void 0 === c)
                for (var e = this.data.shapes.length - 1; e >= 0; e--)
                    this.data.shapes[e].collisionMask = f;
            else
                c.collisionMask = f
        },
        collides: function(a, b, c, d) {
            if (Array.isArray(a))
                for (var e = 0; e < a.length; e++)
                    -1 === this.collidesWith.indexOf(a[e]) && (this.collidesWith.push(a[e]),
                    b && this.createGroupCallback(a[e], b, c));
            else
                -1 === this.collidesWith.indexOf(a) && (this.collidesWith.push(a),
                b && this.createGroupCallback(a, b, c));
            var f = this.getCollisionMask();
            if (void 0 === d)
                for (var e = this.data.shapes.length - 1; e >= 0; e--)
                    this.data.shapes[e].collisionMask = f;
            else
                d.collisionMask = f
        },
        adjustCenterOfMass: function() {
            this.data.adjustCenterOfMass(),
            this.shapeChanged()
        },
        getVelocityAtPoint: function(a, b) {
            return this.data.getVelocityAtPoint(a, b)
        },
        applyDamping: function(a) {
            this.data.applyDamping(a)
        },
        applyImpulse: function(a, b, c) {
            this.data.applyImpulse(a, [this.world.pxmi(b), this.world.pxmi(c)])
        },
        applyImpulseLocal: function(a, b, c) {
            this.data.applyImpulseLocal(a, [this.world.pxmi(b), this.world.pxmi(c)])
        },
        applyForce: function(a, b, c) {
            this.data.applyForce(a, [this.world.pxmi(b), this.world.pxmi(c)])
        },
        setZeroForce: function() {
            this.data.setZeroForce()
        },
        setZeroRotation: function() {
            this.data.angularVelocity = 0
        },
        setZeroVelocity: function() {
            this.data.velocity[0] = 0,
            this.data.velocity[1] = 0
        },
        setZeroDamping: function() {
            this.data.damping = 0,
            this.data.angularDamping = 0
        },
        toLocalFrame: function(a, b) {
            return this.data.toLocalFrame(a, b)
        },
        toWorldFrame: function(a, b) {
            return this.data.toWorldFrame(a, b)
        },
        rotateLeft: function(a) {
            this.data.angularVelocity = this.world.pxm(-a)
        },
        rotateRight: function(a) {
            this.data.angularVelocity = this.world.pxm(a)
        },
        moveForward: function(a) {
            var b = this.world.pxmi(-a)
              , c = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = b * Math.cos(c),
            this.data.velocity[1] = b * Math.sin(c)
        },
        moveBackward: function(a) {
            var b = this.world.pxmi(-a)
              , c = this.data.angle + Math.PI / 2;
            this.data.velocity[0] = -b * Math.cos(c),
            this.data.velocity[1] = -b * Math.sin(c)
        },
        thrust: function(a) {
            var b = this.world.pxmi(-a)
              , c = this.data.angle + Math.PI / 2;
            this.data.force[0] += b * Math.cos(c),
            this.data.force[1] += b * Math.sin(c)
        },
        thrustLeft: function(a) {
            var b = this.world.pxmi(-a)
              , c = this.data.angle;
            this.data.force[0] += b * Math.cos(c),
            this.data.force[1] += b * Math.sin(c)
        },
        thrustRight: function(a) {
            var b = this.world.pxmi(-a)
              , c = this.data.angle;
            this.data.force[0] -= b * Math.cos(c),
            this.data.force[1] -= b * Math.sin(c)
        },
        reverse: function(a) {
            var b = this.world.pxmi(-a)
              , c = this.data.angle + Math.PI / 2;
            this.data.force[0] -= b * Math.cos(c),
            this.data.force[1] -= b * Math.sin(c)
        },
        moveLeft: function(a) {
            this.data.velocity[0] = this.world.pxmi(-a)
        },
        moveRight: function(a) {
            this.data.velocity[0] = this.world.pxmi(a)
        },
        moveUp: function(a) {
            this.data.velocity[1] = this.world.pxmi(-a)
        },
        moveDown: function(a) {
            this.data.velocity[1] = this.world.pxmi(a)
        },
        preUpdate: function() {
            this.dirty = !0,
            this.removeNextStep && (this.removeFromWorld(),
            this.removeNextStep = !1)
        },
        postUpdate: function() {
            this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x,
            this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y,
            this.fixedRotation || (this.sprite.rotation = this.data.angle),
            this.debugBody && this.debugBody.updateSpriteTransform(),
            this.dirty = !1
        },
        reset: function(a, b, c, d) {
            void 0 === c && (c = !1),
            void 0 === d && (d = !1),
            this.setZeroForce(),
            this.setZeroVelocity(),
            this.setZeroRotation(),
            c && this.setZeroDamping(),
            d && (this.mass = 1),
            this.x = a,
            this.y = b
        },
        addToWorld: function() {
            if (this.game.physics.p2._toRemove)
                for (var a = 0; a < this.game.physics.p2._toRemove.length; a++)
                    this.game.physics.p2._toRemove[a] === this && this.game.physics.p2._toRemove.splice(a, 1);
            this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
        },
        removeFromWorld: function() {
            this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
        },
        destroy: function() {
            this.removeFromWorld(),
            this.clearShapes(),
            this._bodyCallbacks = {},
            this._bodyCallbackContext = {},
            this._groupCallbacks = {},
            this._groupCallbackContext = {},
            this.debugBody && this.debugBody.destroy(!0, !0),
            this.debugBody = null,
            this.sprite && (this.sprite.body = null,
            this.sprite = null)
        },
        clearShapes: function() {
            for (var a = this.data.shapes.length; a--; )
                this.data.removeShape(this.data.shapes[a]);
            this.shapeChanged()
        },
        addShape: function(a, b, c, d) {
            return void 0 === b && (b = 0),
            void 0 === c && (c = 0),
            void 0 === d && (d = 0),
            this.data.addShape(a, [this.world.pxmi(b), this.world.pxmi(c)], d),
            this.shapeChanged(),
            a
        },
        addCircle: function(a, b, c, d) {
            var e = new p2.Circle({
                radius: this.world.pxm(a)
            });
            return this.addShape(e, b, c, d)
        },
        addRectangle: function(a, b, c, d, e) {
            var f = new p2.Box({
                width: this.world.pxm(a),
                height: this.world.pxm(b)
            });
            return this.addShape(f, c, d, e)
        },
        addPlane: function(a, b, c) {
            var d = new p2.Plane;
            return this.addShape(d, a, b, c)
        },
        addParticle: function(a, b, c) {
            var d = new p2.Particle;
            return this.addShape(d, a, b, c)
        },
        addLine: function(a, b, c, d) {
            var e = new p2.Line({
                length: this.world.pxm(a)
            });
            return this.addShape(e, b, c, d)
        },
        addCapsule: function(a, b, c, d, e) {
            var f = new p2.Capsule({
                length: this.world.pxm(a),
                radius: this.world.pxm(b)
            });
            return this.addShape(f, c, d, e)
        },
        addPolygon: function(a, b) {
            a = a || {},
            Array.isArray(b) || (b = Array.prototype.slice.call(arguments, 1));
            var c = [];
            if (1 === b.length && Array.isArray(b[0]))
                c = b[0].slice(0);
            else if (Array.isArray(b[0]))
                c = b.slice();
            else if ("number" == typeof b[0])
                for (var d = 0, e = b.length; d < e; d += 2)
                    c.push([b[d], b[d + 1]]);
            var f = c.length - 1;
            c[f][0] === c[0][0] && c[f][1] === c[0][1] && c.pop();
            for (var g = 0; g < c.length; g++)
                c[g][0] = this.world.pxmi(c[g][0]),
                c[g][1] = this.world.pxmi(c[g][1]);
            var h = this.data.fromPolygon(c, a);
            return this.shapeChanged(),
            h
        },
        removeShape: function(a) {
            var b = this.data.removeShape(a);
            return this.shapeChanged(),
            b
        },
        setCircle: function(a, b, c, d) {
            return this.clearShapes(),
            this.addCircle(a, b, c, d)
        },
        setRectangle: function(a, b, c, d, e) {
            return void 0 === a && (a = 16),
            void 0 === b && (b = 16),
            this.clearShapes(),
            this.addRectangle(a, b, c, d, e)
        },
        setRectangleFromSprite: function(a) {
            return void 0 === a && (a = this.sprite),
            this.clearShapes(),
            this.addRectangle(a.width, a.height, 0, 0, a.rotation)
        },
        setMaterial: function(a, b) {
            if (void 0 === b)
                for (var c = this.data.shapes.length - 1; c >= 0; c--)
                    this.data.shapes[c].material = a;
            else
                b.material = a
        },
        shapeChanged: function() {
            this.debugBody && this.debugBody.draw()
        },
        addPhaserPolygon: function(a, b) {
            for (var c = this.game.cache.getPhysicsData(a, b), d = [], e = 0; e < c.length; e++) {
                var f = c[e]
                  , g = this.addFixture(f);
                d[f.filter.group] = d[f.filter.group] || [],
                d[f.filter.group] = d[f.filter.group].concat(g),
                f.fixtureKey && (d[f.fixtureKey] = g)
            }
            return this.data.aabbNeedsUpdate = !0,
            this.shapeChanged(),
            d
        },
        addFixture: function(a) {
            var b = [];
            if (a.circle) {
                var c = new p2.Circle({
                    radius: this.world.pxm(a.circle.radius)
                });
                c.collisionGroup = a.filter.categoryBits,
                c.collisionMask = a.filter.maskBits,
                c.sensor = a.isSensor;
                var d = p2.vec2.create();
                d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2),
                d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2),
                this.data.addShape(c, d),
                b.push(c)
            } else
                for (var e = a.polygons, f = p2.vec2.create(), g = 0; g < e.length; g++) {
                    for (var h = e[g], i = [], j = 0; j < h.length; j += 2)
                        i.push([this.world.pxmi(h[j]), this.world.pxmi(h[j + 1])]);
                    for (var c = new p2.Convex({
                        vertices: i
                    }), k = 0; k !== c.vertices.length; k++) {
                        var l = c.vertices[k];
                        p2.vec2.sub(l, l, c.centerOfMass)
                    }
                    p2.vec2.scale(f, c.centerOfMass, 1),
                    f[0] -= this.world.pxmi(this.sprite.width / 2),
                    f[1] -= this.world.pxmi(this.sprite.height / 2),
                    c.updateTriangles(),
                    c.updateCenterOfMass(),
                    c.updateBoundingRadius(),
                    c.collisionGroup = a.filter.categoryBits,
                    c.collisionMask = a.filter.maskBits,
                    c.sensor = a.isSensor,
                    this.data.addShape(c, f),
                    b.push(c)
                }
            return b
        },
        loadPolygon: function(a, b) {
            if (null === a)
                var c = b;
            else
                var c = this.game.cache.getPhysicsData(a, b);
            for (var d = p2.vec2.create(), e = 0; e < c.length; e++) {
                for (var f = [], g = 0; g < c[e].shape.length; g += 2)
                    f.push([this.world.pxmi(c[e].shape[g]), this.world.pxmi(c[e].shape[g + 1])]);
                for (var h = new p2.Convex({
                    vertices: f
                }), i = 0; i !== h.vertices.length; i++) {
                    var j = h.vertices[i];
                    p2.vec2.sub(j, j, h.centerOfMass)
                }
                p2.vec2.scale(d, h.centerOfMass, 1),
                d[0] -= this.world.pxmi(this.sprite.width / 2),
                d[1] -= this.world.pxmi(this.sprite.height / 2),
                h.updateTriangles(),
                h.updateCenterOfMass(),
                h.updateBoundingRadius(),
                this.data.addShape(h, d)
            }
            return this.data.aabbNeedsUpdate = !0,
            this.shapeChanged(),
            !0
        }
    },
    b.Physics.P2.Body.prototype.constructor = b.Physics.P2.Body,
    b.Physics.P2.Body.DYNAMIC = 1,
    b.Physics.P2.Body.STATIC = 2,
    b.Physics.P2.Body.KINEMATIC = 4,
    Object.defineProperty(b.Physics.P2.Body.prototype, "static", {
        get: function() {
            return this.data.type === b.Physics.P2.Body.STATIC
        },
        set: function(a) {
            a && this.data.type !== b.Physics.P2.Body.STATIC ? (this.data.type = b.Physics.P2.Body.STATIC,
            this.mass = 0) : a || this.data.type !== b.Physics.P2.Body.STATIC || (this.data.type = b.Physics.P2.Body.DYNAMIC,
            this.mass = 1)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "dynamic", {
        get: function() {
            return this.data.type === b.Physics.P2.Body.DYNAMIC
        },
        set: function(a) {
            a && this.data.type !== b.Physics.P2.Body.DYNAMIC ? (this.data.type = b.Physics.P2.Body.DYNAMIC,
            this.mass = 1) : a || this.data.type !== b.Physics.P2.Body.DYNAMIC || (this.data.type = b.Physics.P2.Body.STATIC,
            this.mass = 0)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "kinematic", {
        get: function() {
            return this.data.type === b.Physics.P2.Body.KINEMATIC
        },
        set: function(a) {
            a && this.data.type !== b.Physics.P2.Body.KINEMATIC ? (this.data.type = b.Physics.P2.Body.KINEMATIC,
            this.mass = 4) : a || this.data.type !== b.Physics.P2.Body.KINEMATIC || (this.data.type = b.Physics.P2.Body.STATIC,
            this.mass = 0)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "allowSleep", {
        get: function() {
            return this.data.allowSleep
        },
        set: function(a) {
            a !== this.data.allowSleep && (this.data.allowSleep = a)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "angle", {
        get: function() {
            return b.Math.wrapAngle(b.Math.radToDeg(this.data.angle))
        },
        set: function(a) {
            this.data.angle = b.Math.degToRad(b.Math.wrapAngle(a))
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "angularDamping", {
        get: function() {
            return this.data.angularDamping
        },
        set: function(a) {
            this.data.angularDamping = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "angularForce", {
        get: function() {
            return this.data.angularForce
        },
        set: function(a) {
            this.data.angularForce = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "angularVelocity", {
        get: function() {
            return this.data.angularVelocity
        },
        set: function(a) {
            this.data.angularVelocity = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "damping", {
        get: function() {
            return this.data.damping
        },
        set: function(a) {
            this.data.damping = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "fixedRotation", {
        get: function() {
            return this.data.fixedRotation
        },
        set: function(a) {
            a !== this.data.fixedRotation && (this.data.fixedRotation = a)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "inertia", {
        get: function() {
            return this.data.inertia
        },
        set: function(a) {
            this.data.inertia = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "mass", {
        get: function() {
            return this.data.mass
        },
        set: function(a) {
            a !== this.data.mass && (this.data.mass = a,
            this.data.updateMassProperties())
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "motionState", {
        get: function() {
            return this.data.type
        },
        set: function(a) {
            a !== this.data.type && (this.data.type = a)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "rotation", {
        get: function() {
            return this.data.angle
        },
        set: function(a) {
            this.data.angle = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "sleepSpeedLimit", {
        get: function() {
            return this.data.sleepSpeedLimit
        },
        set: function(a) {
            this.data.sleepSpeedLimit = a
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "x", {
        get: function() {
            return this.world.mpxi(this.data.position[0])
        },
        set: function(a) {
            this.data.position[0] = this.world.pxmi(a)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "y", {
        get: function() {
            return this.world.mpxi(this.data.position[1])
        },
        set: function(a) {
            this.data.position[1] = this.world.pxmi(a)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "id", {
        get: function() {
            return this.data.id
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "debug", {
        get: function() {
            return null !== this.debugBody
        },
        set: function(a) {
            a && !this.debugBody ? this.debugBody = new b.Physics.P2.BodyDebug(this.game,this.data) : !a && this.debugBody && (this.debugBody.destroy(),
            this.debugBody = null)
        }
    }),
    Object.defineProperty(b.Physics.P2.Body.prototype, "collideWorldBounds", {
        get: function() {
            return this._collideWorldBounds
        },
        set: function(a) {
            a && !this._collideWorldBounds ? (this._collideWorldBounds = !0,
            this.updateCollisionMask()) : !a && this._collideWorldBounds && (this._collideWorldBounds = !1,
            this.updateCollisionMask())
        }
    }),
    b.Physics.P2.BodyDebug = function(a, c, d) {
        b.Group.call(this, a);
        var e = {
            pixelsPerLengthUnit: a.physics.p2.mpx(1),
            debugPolygons: !1,
            lineWidth: 1,
            alpha: .5
        };
        this.settings = b.Utils.extend(e, d),
        this.ppu = this.settings.pixelsPerLengthUnit,
        this.ppu = -1 * this.ppu,
        this.body = c,
        this.canvas = new b.Graphics(a),
        this.canvas.alpha = this.settings.alpha,
        this.add(this.canvas),
        this.draw(),
        this.updateSpriteTransform()
    }
    ,
    b.Physics.P2.BodyDebug.prototype = Object.create(b.Group.prototype),
    b.Physics.P2.BodyDebug.prototype.constructor = b.Physics.P2.BodyDebug,
    b.Utils.extend(b.Physics.P2.BodyDebug.prototype, {
        updateSpriteTransform: function() {
            this.position.x = this.body.position[0] * this.ppu,
            this.position.y = this.body.position[1] * this.ppu,
            this.rotation = this.body.angle
        },
        draw: function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o;
            if (h = this.body,
            j = this.canvas,
            j.clear(),
            c = parseInt(this.randomPastelHex(), 16),
            f = 16711680,
            g = this.lineWidth,
            h instanceof p2.Body && h.shapes.length) {
                var p = h.shapes.length;
                for (d = 0; d !== p; ) {
                    if (b = h.shapes[d],
                    i = b.position || 0,
                    a = b.angle || 0,
                    b instanceof p2.Circle)
                        this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g);
                    else if (b instanceof p2.Capsule)
                        this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, f, c, g);
                    else if (b instanceof p2.Plane)
                        this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, f, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a);
                    else if (b instanceof p2.Line)
                        this.drawLine(j, b.length * this.ppu, f, g);
                    else if (b instanceof p2.Box)
                        this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, f, c, g);
                    else if (b instanceof p2.Convex) {
                        for (l = [],
                        m = p2.vec2.create(),
                        e = n = 0,
                        o = b.vertices.length; 0 <= o ? n < o : n > o; e = 0 <= o ? ++n : --n)
                            k = b.vertices[e],
                            p2.vec2.rotate(m, k, a),
                            l.push([(m[0] + i[0]) * this.ppu, -(m[1] + i[1]) * this.ppu]);
                        this.drawConvex(j, l, b.triangles, f, c, g, this.settings.debugPolygons, [i[0] * this.ppu, -i[1] * this.ppu])
                    }
                    d++
                }
            }
        },
        drawRectangle: function(a, b, c, d, e, f, g, h, i) {
            void 0 === i && (i = 1),
            void 0 === g && (g = 0),
            a.lineStyle(i, g, 1),
            a.beginFill(h),
            a.drawRect(b - e / 2, c - f / 2, e, f)
        },
        drawCircle: function(a, b, c, d, e, f, g) {
            void 0 === g && (g = 1),
            void 0 === f && (f = 16777215),
            a.lineStyle(g, 0, 1),
            a.beginFill(f, 1),
            a.drawCircle(b, c, 2 * -e),
            a.endFill(),
            a.moveTo(b, c),
            a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d))
        },
        drawLine: function(a, b, c, d) {
            void 0 === d && (d = 1),
            void 0 === c && (c = 0),
            a.lineStyle(5 * d, c, 1),
            a.moveTo(-b / 2, 0),
            a.lineTo(b / 2, 0)
        },
        drawConvex: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p, q, r, s;
            if (void 0 === f && (f = 1),
            void 0 === d && (d = 0),
            g) {
                for (i = [16711680, 65280, 255],
                j = 0; j !== b.length + 1; )
                    l = b[j % b.length],
                    m = b[(j + 1) % b.length],
                    o = l[0],
                    r = l[1],
                    p = m[0],
                    s = m[1],
                    a.lineStyle(f, i[j % i.length], 1),
                    a.moveTo(o, -r),
                    a.lineTo(p, -s),
                    a.drawCircle(o, -r, 2 * f),
                    j++;
                return a.lineStyle(f, 0, 1),
                a.drawCircle(h[0], h[1], 2 * f)
            }
            for (a.lineStyle(f, d, 1),
            a.beginFill(e),
            j = 0; j !== b.length; )
                k = b[j],
                n = k[0],
                q = k[1],
                0 === j ? a.moveTo(n, -q) : a.lineTo(n, -q),
                j++;
            if (a.endFill(),
            b.length > 2)
                return a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]),
                a.lineTo(b[0][0], -b[0][1])
        },
        drawPath: function(a, b, c, d, e) {
            var g, h, i, j, k, l, m, n, o, p, q, r;
            for (void 0 === e && (e = 1),
            void 0 === c && (c = 0),
            a.lineStyle(e, c, 1),
            "number" == typeof d && a.beginFill(d),
            h = null,
            i = null,
            g = 0; g < b.length; )
                p = b[g],
                q = p[0],
                r = p[1],
                q === h && r === i || (0 === g ? a.moveTo(q, r) : (j = h,
                k = i,
                l = q,
                m = r,
                n = b[(g + 1) % b.length][0],
                o = b[(g + 1) % b.length][1],
                0 !== (l - j) * (o - k) - (n - j) * (m - k) && a.lineTo(q, r)),
                h = q,
                i = r),
                g++;
            "number" == typeof d && a.endFill(),
            b.length > 2 && "number" == typeof d && (a.moveTo(b[b.length - 1][0], b[b.length - 1][1]),
            a.lineTo(b[0][0], b[0][1]))
        },
        drawPlane: function(a, b, c, d, e, f, g, h, i, j) {
            var l, m;
            void 0 === f && (f = 1),
            void 0 === d && (d = 16777215),
            a.lineStyle(f, e, 11),
            a.beginFill(d),
            a.moveTo(b, -c),
            l = b + Math.cos(j) * this.game.width,
            m = c + Math.sin(j) * this.game.height,
            a.lineTo(l, -m),
            a.moveTo(b, -c),
            l = b + Math.cos(j) * -this.game.width,
            m = c + Math.sin(j) * -this.game.height,
            a.lineTo(l, -m)
        },
        drawCapsule: function(a, b, c, d, e, f, g, h, i) {
            void 0 === i && (i = 1),
            void 0 === g && (g = 0),
            a.lineStyle(i, g, 1);
            var j = Math.cos(d)
              , k = Math.sin(d);
            a.beginFill(h, 1),
            a.drawCircle(-e / 2 * j + b, -e / 2 * k + c, 2 * -f),
            a.drawCircle(e / 2 * j + b, e / 2 * k + c, 2 * -f),
            a.endFill(),
            a.lineStyle(i, g, 0),
            a.beginFill(h, 1),
            a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c),
            a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c),
            a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c),
            a.lineTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c),
            a.endFill(),
            a.lineStyle(i, g, 1),
            a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c),
            a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c),
            a.moveTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c),
            a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c)
        },
        randomPastelHex: function() {
            var a, b, c, d;
            return c = [255, 255, 255],
            d = Math.floor(256 * Math.random()),
            b = Math.floor(256 * Math.random()),
            a = Math.floor(256 * Math.random()),
            d = Math.floor((d + 3 * c[0]) / 4),
            b = Math.floor((b + 3 * c[1]) / 4),
            a = Math.floor((a + 3 * c[2]) / 4),
            this.rgbToHex(d, b, a)
        },
        rgbToHex: function(a, b, c) {
            return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c)
        },
        componentToHex: function(a) {
            var b;
            return b = a.toString(16),
            2 === b.length ? b : b + "0"
        }
    }),
    b.Physics.P2.Spring = function(a, b, c, d, e, f, g, h, i, j) {
        this.game = a.game,
        this.world = a,
        void 0 === d && (d = 1),
        void 0 === e && (e = 100),
        void 0 === f && (f = 1),
        d = a.pxm(d);
        var k = {
            restLength: d,
            stiffness: e,
            damping: f
        };
        void 0 !== g && null !== g && (k.worldAnchorA = [a.pxm(g[0]), a.pxm(g[1])]),
        void 0 !== h && null !== h && (k.worldAnchorB = [a.pxm(h[0]), a.pxm(h[1])]),
        void 0 !== i && null !== i && (k.localAnchorA = [a.pxm(i[0]), a.pxm(i[1])]),
        void 0 !== j && null !== j && (k.localAnchorB = [a.pxm(j[0]), a.pxm(j[1])]),
        this.data = new p2.LinearSpring(b,c,k),
        this.data.parent = this
    }
    ,
    b.Physics.P2.Spring.prototype.constructor = b.Physics.P2.Spring,
    b.Physics.P2.RotationalSpring = function(a, b, c, d, e, f) {
        this.game = a.game,
        this.world = a,
        void 0 === d && (d = null),
        void 0 === e && (e = 100),
        void 0 === f && (f = 1),
        d && (d = a.pxm(d));
        var g = {
            restAngle: d,
            stiffness: e,
            damping: f
        };
        this.data = new p2.RotationalSpring(b,c,g),
        this.data.parent = this
    }
    ,
    b.Physics.P2.Spring.prototype.constructor = b.Physics.P2.Spring,
    b.Physics.P2.Material = function(a) {
        this.name = a,
        p2.Material.call(this)
    }
    ,
    b.Physics.P2.Material.prototype = Object.create(p2.Material.prototype),
    b.Physics.P2.Material.prototype.constructor = b.Physics.P2.Material,
    b.Physics.P2.ContactMaterial = function(a, b, c) {
        p2.ContactMaterial.call(this, a, b, c)
    }
    ,
    b.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype),
    b.Physics.P2.ContactMaterial.prototype.constructor = b.Physics.P2.ContactMaterial,
    b.Physics.P2.CollisionGroup = function(a) {
        this.mask = a
    }
    ,
    b.Physics.P2.DistanceConstraint = function(a, b, c, d, e, f, g) {
        void 0 === d && (d = 100),
        void 0 === e && (e = [0, 0]),
        void 0 === f && (f = [0, 0]),
        void 0 === g && (g = Number.MAX_VALUE),
        this.game = a.game,
        this.world = a,
        d = a.pxm(d),
        e = [a.pxmi(e[0]), a.pxmi(e[1])],
        f = [a.pxmi(f[0]), a.pxmi(f[1])];
        var h = {
            distance: d,
            localAnchorA: e,
            localAnchorB: f,
            maxForce: g
        };
        p2.DistanceConstraint.call(this, b, c, h)
    }
    ,
    b.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype),
    b.Physics.P2.DistanceConstraint.prototype.constructor = b.Physics.P2.DistanceConstraint,
    b.Physics.P2.GearConstraint = function(a, b, c, d, e) {
        void 0 === d && (d = 0),
        void 0 === e && (e = 1),
        this.game = a.game,
        this.world = a;
        var f = {
            angle: d,
            ratio: e
        };
        p2.GearConstraint.call(this, b, c, f)
    }
    ,
    b.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype),
    b.Physics.P2.GearConstraint.prototype.constructor = b.Physics.P2.GearConstraint,
    b.Physics.P2.LockConstraint = function(a, b, c, d, e, f) {
        void 0 === d && (d = [0, 0]),
        void 0 === e && (e = 0),
        void 0 === f && (f = Number.MAX_VALUE),
        this.game = a.game,
        this.world = a,
        d = [a.pxm(d[0]), a.pxm(d[1])];
        var g = {
            localOffsetB: d,
            localAngleB: e,
            maxForce: f
        };
        p2.LockConstraint.call(this, b, c, g)
    }
    ,
    b.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype),
    b.Physics.P2.LockConstraint.prototype.constructor = b.Physics.P2.LockConstraint,
    b.Physics.P2.PrismaticConstraint = function(a, b, c, d, e, f, g, h) {
        void 0 === d && (d = !0),
        void 0 === e && (e = [0, 0]),
        void 0 === f && (f = [0, 0]),
        void 0 === g && (g = [0, 0]),
        void 0 === h && (h = Number.MAX_VALUE),
        this.game = a.game,
        this.world = a,
        e = [a.pxmi(e[0]), a.pxmi(e[1])],
        f = [a.pxmi(f[0]), a.pxmi(f[1])];
        var i = {
            localAnchorA: e,
            localAnchorB: f,
            localAxisA: g,
            maxForce: h,
            disableRotationalLock: !d
        };
        p2.PrismaticConstraint.call(this, b, c, i)
    }
    ,
    b.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype),
    b.Physics.P2.PrismaticConstraint.prototype.constructor = b.Physics.P2.PrismaticConstraint,
    b.Physics.P2.RevoluteConstraint = function(a, b, c, d, e, f, g) {
        void 0 === f && (f = Number.MAX_VALUE),
        void 0 === g && (g = null),
        this.game = a.game,
        this.world = a,
        c = [a.pxmi(c[0]), a.pxmi(c[1])],
        e = [a.pxmi(e[0]), a.pxmi(e[1])],
        g && (g = [a.pxmi(g[0]), a.pxmi(g[1])]);
        var h = {
            worldPivot: g,
            localPivotA: c,
            localPivotB: e,
            maxForce: f
        };
        p2.RevoluteConstraint.call(this, b, d, h)
    }
    ,
    b.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype),
    b.Physics.P2.RevoluteConstraint.prototype.constructor = b.Physics.P2.RevoluteConstraint,
    b.ImageCollection = function(a, b, c, d, e, f, g) {
        (void 0 === c || c <= 0) && (c = 32),
        (void 0 === d || d <= 0) && (d = 32),
        void 0 === e && (e = 0),
        void 0 === f && (f = 0),
        this.name = a,
        this.firstgid = 0 | b,
        this.imageWidth = 0 | c,
        this.imageHeight = 0 | d,
        this.imageMargin = 0 | e,
        this.imageSpacing = 0 | f,
        this.properties = g || {},
        this.images = [],
        this.total = 0
    }
    ,
    b.ImageCollection.prototype = {
        containsImageIndex: function(a) {
            return a >= this.firstgid && a < this.firstgid + this.total
        },
        addImage: function(a, b) {
            this.images.push({
                gid: a,
                image: b
            }),
            this.total++
        }
    },
    b.ImageCollection.prototype.constructor = b.ImageCollection,
    b.Tile = function(a, b, c, d, e, f) {
        this.layer = a,
        this.index = b,
        this.x = c,
        this.y = d,
        this.rotation = 0,
        this.flipped = !1,
        this.worldX = c * e,
        this.worldY = d * f,
        this.width = e,
        this.height = f,
        this.centerX = Math.abs(e / 2),
        this.centerY = Math.abs(f / 2),
        this.alpha = 1,
        this.properties = {},
        this.scanned = !1,
        this.faceTop = !1,
        this.faceBottom = !1,
        this.faceLeft = !1,
        this.faceRight = !1,
        this.collideLeft = !1,
        this.collideRight = !1,
        this.collideUp = !1,
        this.collideDown = !1,
        this.collisionCallback = null,
        this.collisionCallbackContext = this
    }
    ,
    b.Tile.prototype = {
        containsPoint: function(a, b) {
            return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom)
        },
        intersects: function(a, b, c, d) {
            return !(c <= this.worldX) && (!(d <= this.worldY) && (!(a >= this.worldX + this.width) && !(b >= this.worldY + this.height)))
        },
        setCollisionCallback: function(a, b) {
            this.collisionCallback = a,
            this.collisionCallbackContext = b
        },
        destroy: function() {
            this.collisionCallback = null,
            this.collisionCallbackContext = null,
            this.properties = null
        },
        setCollision: function(a, b, c, d) {
            this.collideLeft = a,
            this.collideRight = b,
            this.collideUp = c,
            this.collideDown = d,
            this.faceLeft = a,
            this.faceRight = b,
            this.faceTop = c,
            this.faceBottom = d
        },
        resetCollision: function() {
            this.collideLeft = !1,
            this.collideRight = !1,
            this.collideUp = !1,
            this.collideDown = !1,
            this.faceTop = !1,
            this.faceBottom = !1,
            this.faceLeft = !1,
            this.faceRight = !1
        },
        isInteresting: function(a, b) {
            return a && b ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!b && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
        },
        copy: function(a) {
            this.index = a.index,
            this.alpha = a.alpha,
            this.properties = a.properties,
            this.collideUp = a.collideUp,
            this.collideDown = a.collideDown,
            this.collideLeft = a.collideLeft,
            this.collideRight = a.collideRight,
            this.collisionCallback = a.collisionCallback,
            this.collisionCallbackContext = a.collisionCallbackContext
        }
    },
    b.Tile.prototype.constructor = b.Tile,
    Object.defineProperty(b.Tile.prototype, "collides", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
        }
    }),
    Object.defineProperty(b.Tile.prototype, "canCollide", {
        get: function() {
            return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
        }
    }),
    Object.defineProperty(b.Tile.prototype, "left", {
        get: function() {
            return this.worldX
        }
    }),
    Object.defineProperty(b.Tile.prototype, "right", {
        get: function() {
            return this.worldX + this.width
        }
    }),
    Object.defineProperty(b.Tile.prototype, "top", {
        get: function() {
            return this.worldY
        }
    }),
    Object.defineProperty(b.Tile.prototype, "bottom", {
        get: function() {
            return this.worldY + this.height
        }
    }),
    b.Tilemap = function(a, c, d, e, f, g) {
        this.game = a,
        this.key = c;
        var h = b.TilemapParser.parse(this.game, c, d, e, f, g);
        null !== h && (this.width = h.width,
        this.height = h.height,
        this.tileWidth = h.tileWidth,
        this.tileHeight = h.tileHeight,
        this.orientation = h.orientation,
        this.format = h.format,
        this.version = h.version,
        this.properties = h.properties,
        this.widthInPixels = h.widthInPixels,
        this.heightInPixels = h.heightInPixels,
        this.layers = h.layers,
        this.tilesets = h.tilesets,
        this.imagecollections = h.imagecollections,
        this.tiles = h.tiles,
        this.objects = h.objects,
        this.collideIndexes = [],
        this.collision = h.collision,
        this.images = h.images,
        this.enableDebug = !1,
        this.currentLayer = 0,
        this.debugMap = [],
        this._results = [],
        this._tempA = 0,
        this._tempB = 0)
    }
    ,
    b.Tilemap.CSV = 0,
    b.Tilemap.TILED_JSON = 1,
    b.Tilemap.NORTH = 0,
    b.Tilemap.EAST = 1,
    b.Tilemap.SOUTH = 2,
    b.Tilemap.WEST = 3,
    b.Tilemap.prototype = {
        create: function(a, b, c, d, e, f) {
            return void 0 === f && (f = this.game.world),
            this.width = b,
            this.height = c,
            this.setTileSize(d, e),
            this.layers.length = 0,
            this.createBlankLayer(a, b, c, d, e, f)
        },
        setTileSize: function(a, b) {
            this.tileWidth = a,
            this.tileHeight = b,
            this.widthInPixels = this.width * a,
            this.heightInPixels = this.height * b
        },
        addTilesetImage: function(a, c, d, e, f, g, h) {
            if (void 0 === a)
                return null;
            void 0 === d && (d = this.tileWidth),
            void 0 === e && (e = this.tileHeight),
            void 0 === f && (f = 0),
            void 0 === g && (g = 0),
            void 0 === h && (h = 0),
            0 === d && (d = 32),
            0 === e && (e = 32);
            var i = null;
            if (void 0 !== c && null !== c || (c = a),
            c instanceof b.BitmapData)
                i = c.canvas;
            else {
                if (!this.game.cache.checkImageKey(c))
                    return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + c + '"'),
                    null;
                i = this.game.cache.getImage(c)
            }
            var j = this.getTilesetIndex(a);
            if (null === j && this.format === b.Tilemap.TILED_JSON)
                return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + a + '"'),
                null;
            if (this.tilesets[j])
                return this.tilesets[j].setImage(i),
                this.tilesets[j];
            var k = new b.Tileset(a,h,d,e,f,g,{});
            k.setImage(i),
            this.tilesets.push(k);
            for (var l = this.tilesets.length - 1, m = f, n = f, o = 0, p = 0, q = 0, r = h; r < h + k.total && (this.tiles[r] = [m, n, l],
            m += d + g,
            ++o !== k.total) && (++p !== k.columns || (m = f,
            n += e + g,
            p = 0,
            ++q !== k.rows)); r++)
                ;
            return k
        },
        createFromObjects: function(a, c, d, e, f, g, h, i, j) {
            if (void 0 === f && (f = !0),
            void 0 === g && (g = !1),
            void 0 === h && (h = this.game.world),
            void 0 === i && (i = b.Sprite),
            void 0 === j && (j = !0),
            !this.objects[a])
                return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + a);
            for (var k = 0; k < this.objects[a].length; k++) {
                var l = !1
                  , m = this.objects[a][k];
                if (void 0 !== m.gid && "number" == typeof c && m.gid === c ? l = !0 : void 0 !== m.id && "number" == typeof c && m.id === c ? l = !0 : void 0 !== m.name && "string" == typeof c && m.name === c && (l = !0),
                l) {
                    var n = new i(this.game,parseFloat(m.x, 10),parseFloat(m.y, 10),d,e);
                    n.name = m.name,
                    n.visible = m.visible,
                    n.autoCull = g,
                    n.exists = f,
                    m.width && (n.width = m.width),
                    m.height && (n.height = m.height),
                    m.rotation && (n.angle = m.rotation),
                    j && (n.y -= n.height),
                    h.add(n);
                    for (var o in m.properties)
                        h.set(n, o, m.properties[o], !1, !1, 0, !0)
                }
            }
        },
        createFromTiles: function(a, c, d, e, f, g) {
            "number" == typeof a && (a = [a]),
            void 0 === c || null === c ? c = [] : "number" == typeof c && (c = [c]),
            e = this.getLayer(e),
            void 0 === f && (f = this.game.world),
            void 0 === g && (g = {}),
            void 0 === g.customClass && (g.customClass = b.Sprite),
            void 0 === g.adjustY && (g.adjustY = !0);
            var h = this.layers[e].width
              , i = this.layers[e].height;
            if (this.copy(0, 0, h, i, e),
            this._results.length < 2)
                return 0;
            for (var k, j = 0, l = 1, m = this._results.length; l < m; l++)
                if (-1 !== a.indexOf(this._results[l].index)) {
                    k = new g.customClass(this.game,this._results[l].worldX,this._results[l].worldY,d);
                    for (var n in g)
                        k[n] = g[n];
                    f.add(k),
                    j++
                }
            if (1 === c.length)
                for (l = 0; l < a.length; l++)
                    this.replace(a[l], c[0], 0, 0, h, i, e);
            else if (c.length > 1)
                for (l = 0; l < a.length; l++)
                    this.replace(a[l], c[l], 0, 0, h, i, e);
            return j
        },
        createLayer: function(a, c, d, e) {
            void 0 === c && (c = this.game.width),
            void 0 === d && (d = this.game.height),
            void 0 === e && (e = this.game.world);
            var f = a;
            if ("string" == typeof a && (f = this.getLayerIndex(a)),
            null === f || f > this.layers.length)
                return void console.warn("Tilemap.createLayer: Invalid layer ID given: " + f);
            void 0 === c || c <= 0 ? c = Math.min(this.game.width, this.layers[f].widthInPixels) : c > this.game.width && (c = this.game.width),
            void 0 === d || d <= 0 ? d = Math.min(this.game.height, this.layers[f].heightInPixels) : d > this.game.height && (d = this.game.height),
            this.enableDebug && (console.group("Tilemap.createLayer"),
            console.log("Name:", this.layers[f].name),
            console.log("Size:", c, "x", d),
            console.log("Tileset:", this.tilesets[0].name, "index:", f));
            var g = e.add(new b.TilemapLayer(this.game,this,f,c,d));
            return this.enableDebug && console.groupEnd(),
            g
        },
        createBlankLayer: function(a, c, d, e, f, g) {
            if (void 0 === g && (g = this.game.world),
            null !== this.getLayerIndex(a))
                return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + a);
            for (var i, h = {
                name: a,
                x: 0,
                y: 0,
                width: c,
                height: d,
                widthInPixels: c * e,
                heightInPixels: d * f,
                alpha: 1,
                visible: !0,
                properties: {},
                indexes: [],
                callbacks: [],
                bodies: [],
                data: null
            }, j = [], k = 0; k < d; k++) {
                i = [];
                for (var l = 0; l < c; l++)
                    i.push(new b.Tile(h,-1,l,k,e,f));
                j.push(i)
            }
            h.data = j,
            this.layers.push(h),
            this.currentLayer = this.layers.length - 1;
            var m = h.widthInPixels
              , n = h.heightInPixels;
            m > this.game.width && (m = this.game.width),
            n > this.game.height && (n = this.game.height);
            var j = new b.TilemapLayer(this.game,this,this.layers.length - 1,m,n);
            return j.name = a,
            g.add(j)
        },
        getIndex: function(a, b) {
            for (var c = 0; c < a.length; c++)
                if (a[c].name === b)
                    return c;
            return null
        },
        getLayerIndex: function(a) {
            return this.getIndex(this.layers, a)
        },
        getTilesetIndex: function(a) {
            return this.getIndex(this.tilesets, a)
        },
        getImageIndex: function(a) {
            return this.getIndex(this.images, a)
        },
        setTileIndexCallback: function(a, b, c, d) {
            if (d = this.getLayer(d),
            "number" == typeof a)
                this.layers[d].callbacks[a] = {
                    callback: b,
                    callbackContext: c
                };
            else
                for (var e = 0, f = a.length; e < f; e++)
                    this.layers[d].callbacks[a[e]] = {
                        callback: b,
                        callbackContext: c
                    }
        },
        setTileLocationCallback: function(a, b, c, d, e, f, g) {
            if (g = this.getLayer(g),
            this.copy(a, b, c, d, g),
            !(this._results.length < 2))
                for (var h = 1; h < this._results.length; h++)
                    this._results[h].setCollisionCallback(e, f)
        },
        setCollision: function(a, b, c, d) {
            if (void 0 === b && (b = !0),
            void 0 === d && (d = !0),
            c = this.getLayer(c),
            "number" == typeof a)
                return this.setCollisionByIndex(a, b, c, !0);
            if (Array.isArray(a)) {
                for (var e = 0; e < a.length; e++)
                    this.setCollisionByIndex(a[e], b, c, !1);
                d && this.calculateFaces(c)
            }
        },
        setCollisionBetween: function(a, b, c, d, e) {
            if (void 0 === c && (c = !0),
            void 0 === e && (e = !0),
            d = this.getLayer(d),
            !(a > b)) {
                for (var f = a; f <= b; f++)
                    this.setCollisionByIndex(f, c, d, !1);
                e && this.calculateFaces(d)
            }
        },
        setCollisionByExclusion: function(a, b, c, d) {
            void 0 === b && (b = !0),
            void 0 === d && (d = !0),
            c = this.getLayer(c);
            for (var e = 0, f = this.tiles.length; e < f; e++)
                -1 === a.indexOf(e) && this.setCollisionByIndex(e, b, c, !1);
            d && this.calculateFaces(c)
        },
        setCollisionByIndex: function(a, b, c, d) {
            if (void 0 === b && (b = !0),
            void 0 === c && (c = this.currentLayer),
            void 0 === d && (d = !0),
            b)
                this.collideIndexes.push(a);
            else {
                var e = this.collideIndexes.indexOf(a);
                e > -1 && this.collideIndexes.splice(e, 1)
            }
            for (var f = 0; f < this.layers[c].height; f++)
                for (var g = 0; g < this.layers[c].width; g++) {
                    var h = this.layers[c].data[f][g];
                    h && h.index === a && (b ? h.setCollision(!0, !0, !0, !0) : h.resetCollision(),
                    h.faceTop = b,
                    h.faceBottom = b,
                    h.faceLeft = b,
                    h.faceRight = b)
                }
            return d && this.calculateFaces(c),
            c
        },
        getLayer: function(a) {
            return void 0 === a ? a = this.currentLayer : "string" == typeof a ? a = this.getLayerIndex(a) : a instanceof b.TilemapLayer && (a = a.index),
            a
        },
        setPreventRecalculate: function(a) {
            if (!0 === a && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0,
            this.needToRecalculate = {}),
            !1 === a && !0 === this.preventingRecalculate) {
                this.preventingRecalculate = !1;
                for (var b in this.needToRecalculate)
                    this.calculateFaces(b);
                this.needToRecalculate = !1
            }
        },
        calculateFaces: function(a) {
            if (this.preventingRecalculate)
                return void (this.needToRecalculate[a] = !0);
            for (var b = null, c = null, d = null, e = null, f = 0, g = this.layers[a].height; f < g; f++)
                for (var h = 0, i = this.layers[a].width; h < i; h++) {
                    var j = this.layers[a].data[f][h];
                    j && (b = this.getTileAbove(a, h, f),
                    c = this.getTileBelow(a, h, f),
                    d = this.getTileLeft(a, h, f),
                    e = this.getTileRight(a, h, f),
                    j.collides && (j.faceTop = !0,
                    j.faceBottom = !0,
                    j.faceLeft = !0,
                    j.faceRight = !0),
                    b && b.collides && (j.faceTop = !1),
                    c && c.collides && (j.faceBottom = !1),
                    d && d.collides && (j.faceLeft = !1),
                    e && e.collides && (j.faceRight = !1))
                }
        },
        getTileAbove: function(a, b, c) {
            return c > 0 ? this.layers[a].data[c - 1][b] : null
        },
        getTileBelow: function(a, b, c) {
            return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null
        },
        getTileLeft: function(a, b, c) {
            return b > 0 ? this.layers[a].data[c][b - 1] : null
        },
        getTileRight: function(a, b, c) {
            return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null
        },
        setLayer: function(a) {
            a = this.getLayer(a),
            this.layers[a] && (this.currentLayer = a)
        },
        hasTile: function(a, b, c) {
            return c = this.getLayer(c),
            void 0 !== this.layers[c].data[b] && void 0 !== this.layers[c].data[b][a] && this.layers[c].data[b][a].index > -1
        },
        removeTile: function(a, c, d) {
            if (d = this.getLayer(d),
            a >= 0 && a < this.layers[d].width && c >= 0 && c < this.layers[d].height && this.hasTile(a, c, d)) {
                var e = this.layers[d].data[c][a];
                return this.layers[d].data[c][a] = new b.Tile(this.layers[d],-1,a,c,this.tileWidth,this.tileHeight),
                this.layers[d].dirty = !0,
                this.calculateFaces(d),
                e
            }
        },
        removeTileWorldXY: function(a, b, c, d, e) {
            return e = this.getLayer(e),
            a = this.game.math.snapToFloor(a, c) / c,
            b = this.game.math.snapToFloor(b, d) / d,
            this.removeTile(a, b, e)
        },
        putTile: function(a, c, d, e) {
            if (null === a)
                return this.removeTile(c, d, e);
            if (e = this.getLayer(e),
            c >= 0 && c < this.layers[e].width && d >= 0 && d < this.layers[e].height) {
                var f;
                return a instanceof b.Tile ? (f = a.index,
                this.hasTile(c, d, e) ? this.layers[e].data[d][c].copy(a) : this.layers[e].data[d][c] = new b.Tile(e,f,c,d,a.width,a.height)) : (f = a,
                this.hasTile(c, d, e) ? this.layers[e].data[d][c].index = f : this.layers[e].data[d][c] = new b.Tile(this.layers[e],f,c,d,this.tileWidth,this.tileHeight)),
                this.collideIndexes.indexOf(f) > -1 ? this.layers[e].data[d][c].setCollision(!0, !0, !0, !0) : this.layers[e].data[d][c].resetCollision(),
                this.layers[e].dirty = !0,
                this.calculateFaces(e),
                this.layers[e].data[d][c]
            }
            return null
        },
        putTileWorldXY: function(a, b, c, d, e, f) {
            return f = this.getLayer(f),
            b = this.game.math.snapToFloor(b, d) / d,
            c = this.game.math.snapToFloor(c, e) / e,
            this.putTile(a, b, c, f)
        },
        searchTileIndex: function(a, b, c, d) {
            void 0 === b && (b = 0),
            void 0 === c && (c = !1),
            d = this.getLayer(d);
            var e = 0;
            if (c) {
                for (var f = this.layers[d].height - 1; f >= 0; f--)
                    for (var g = this.layers[d].width - 1; g >= 0; g--)
                        if (this.layers[d].data[f][g].index === a) {
                            if (e === b)
                                return this.layers[d].data[f][g];
                            e++
                        }
            } else
                for (var f = 0; f < this.layers[d].height; f++)
                    for (var g = 0; g < this.layers[d].width; g++)
                        if (this.layers[d].data[f][g].index === a) {
                            if (e === b)
                                return this.layers[d].data[f][g];
                            e++
                        }
            return null
        },
        getTile: function(a, b, c, d) {
            return void 0 === d && (d = !1),
            c = this.getLayer(c),
            a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? -1 === this.layers[c].data[b][a].index ? d ? this.layers[c].data[b][a] : null : this.layers[c].data[b][a] : null
        },
        getTileWorldXY: function(a, b, c, d, e, f) {
            return void 0 === c && (c = this.tileWidth),
            void 0 === d && (d = this.tileHeight),
            e = this.getLayer(e),
            a = this.game.math.snapToFloor(a, c) / c,
            b = this.game.math.snapToFloor(b, d) / d,
            this.getTile(a, b, e, f)
        },
        copy: function(a, b, c, d, e) {
            if (e = this.getLayer(e),
            !this.layers[e])
                return void (this._results.length = 0);
            void 0 === a && (a = 0),
            void 0 === b && (b = 0),
            void 0 === c && (c = this.layers[e].width),
            void 0 === d && (d = this.layers[e].height),
            a < 0 && (a = 0),
            b < 0 && (b = 0),
            c > this.layers[e].width && (c = this.layers[e].width),
            d > this.layers[e].height && (d = this.layers[e].height),
            this._results.length = 0,
            this._results.push({
                x: a,
                y: b,
                width: c,
                height: d,
                layer: e
            });
            for (var f = b; f < b + d; f++)
                for (var g = a; g < a + c; g++)
                    this._results.push(this.layers[e].data[f][g]);
            return this._results
        },
        paste: function(a, b, c, d) {
            if (void 0 === a && (a = 0),
            void 0 === b && (b = 0),
            d = this.getLayer(d),
            c && !(c.length < 2)) {
                for (var e = a - c[1].x, f = b - c[1].y, g = 1; g < c.length; g++)
                    this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
                this.layers[d].dirty = !0,
                this.calculateFaces(d)
            }
        },
        swap: function(a, b, c, d, e, f, g) {
            g = this.getLayer(g),
            this.copy(c, d, e, f, g),
            this._results.length < 2 || (this._tempA = a,
            this._tempB = b,
            this._results.forEach(this.swapHandler, this),
            this.paste(c, d, this._results, g))
        },
        swapHandler: function(a) {
            a.index === this._tempA ? a.index = this._tempB : a.index === this._tempB && (a.index = this._tempA)
        },
        forEach: function(a, b, c, d, e, f, g) {
            g = this.getLayer(g),
            this.copy(c, d, e, f, g),
            this._results.length < 2 || (this._results.forEach(a, b),
            this.paste(c, d, this._results, g))
        },
        replace: function(a, b, c, d, e, f, g) {
            if (g = this.getLayer(g),
            this.copy(c, d, e, f, g),
            !(this._results.length < 2)) {
                for (var h = 1; h < this._results.length; h++)
                    this._results[h].index === a && (this._results[h].index = b);
                this.paste(c, d, this._results, g)
            }
        },
        random: function(a, b, c, d, e) {
            if (e = this.getLayer(e),
            this.copy(a, b, c, d, e),
            !(this._results.length < 2)) {
                for (var f = [], g = 1; g < this._results.length; g++)
                    if (this._results[g].index) {
                        var h = this._results[g].index;
                        -1 === f.indexOf(h) && f.push(h)
                    }
                for (var i = 1; i < this._results.length; i++)
                    this._results[i].index = this.game.rnd.pick(f);
                this.paste(a, b, this._results, e)
            }
        },
        shuffle: function(a, c, d, e, f) {
            if (f = this.getLayer(f),
            this.copy(a, c, d, e, f),
            !(this._results.length < 2)) {
                for (var g = [], h = 1; h < this._results.length; h++)
                    this._results[h].index && g.push(this._results[h].index);
                b.ArrayUtils.shuffle(g);
                for (var i = 1; i < this._results.length; i++)
                    this._results[i].index = g[i - 1];
                this.paste(a, c, this._results, f)
            }
        },
        fill: function(a, b, c, d, e, f) {
            if (f = this.getLayer(f),
            this.copy(b, c, d, e, f),
            !(this._results.length < 2)) {
                for (var g = 1; g < this._results.length; g++)
                    this._results[g].index = a;
                this.paste(b, c, this._results, f)
            }
        },
        removeAllLayers: function() {
            this.layers.length = 0,
            this.currentLayer = 0
        },
        dump: function() {
            for (var a = "", b = [""], c = 0; c < this.layers[this.currentLayer].height; c++) {
                for (var d = 0; d < this.layers[this.currentLayer].width; d++)
                    a += "%c  ",
                    this.layers[this.currentLayer].data[c][d] > 1 ? this.debugMap[this.layers[this.currentLayer].data[c][d]] ? b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]]) : b.push("background: #ffffff") : b.push("background: rgb(0, 0, 0)");
                a += "\n"
            }
            b[0] = a,
            console.log.apply(console, b)
        },
        destroy: function() {
            this.removeAllLayers(),
            this.data = [],
            this.game = null
        }
    },
    b.Tilemap.prototype.constructor = b.Tilemap,
    Object.defineProperty(b.Tilemap.prototype, "layer", {
        get: function() {
            return this.layers[this.currentLayer]
        },
        set: function(a) {
            a !== this.currentLayer && this.setLayer(a)
        }
    }),
    b.TilemapLayer = function(a, c, d, e, f) {
        e |= 0,
        f |= 0,
        b.Sprite.call(this, a, 0, 0),
        this.map = c,
        this.index = d,
        this.layer = c.layers[d],
        this.canvas = PIXI.CanvasPool.create(this, e, f),
        this.context = this.canvas.getContext("2d"),
        this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))),
        this.type = b.TILEMAPLAYER,
        this.physicsType = b.TILEMAPLAYER,
        this.renderSettings = {
            enableScrollDelta: !1,
            overdrawRatio: .2,
            copyCanvas: null
        },
        this.debug = !1,
        this.exists = !0,
        this.debugSettings = {
            missingImageFill: "rgb(255,255,255)",
            debuggedTileOverfill: "rgba(0,255,0,0.4)",
            forceFullRedraw: !0,
            debugAlpha: .5,
            facingEdgeStroke: "rgba(0,255,0,1)",
            collidingTileOverfill: "rgba(0,255,0,0.2)"
        },
        this.scrollFactorX = 1,
        this.scrollFactorY = 1,
        this.dirty = !0,
        this.rayStepRate = 4,
        this._wrap = !1,
        this._mc = {
            scrollX: 0,
            scrollY: 0,
            renderWidth: 0,
            renderHeight: 0,
            tileWidth: c.tileWidth,
            tileHeight: c.tileHeight,
            cw: c.tileWidth,
            ch: c.tileHeight,
            tilesets: []
        },
        this._scrollX = 0,
        this._scrollY = 0,
        this._results = [],
        a.device.canvasBitBltShift || (this.renderSettings.copyCanvas = b.TilemapLayer.ensureSharedCopyCanvas()),
        this.fixedToCamera = !0
    }
    ,
    b.TilemapLayer.prototype = Object.create(b.Sprite.prototype),
    b.TilemapLayer.prototype.constructor = b.TilemapLayer,
    b.TilemapLayer.prototype.preUpdateCore = b.Component.Core.preUpdate,
    b.TilemapLayer.sharedCopyCanvas = null,
    b.TilemapLayer.ensureSharedCopyCanvas = function() {
        return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)),
        this.sharedCopyCanvas
    }
    ,
    b.TilemapLayer.prototype.preUpdate = function() {
        return this.preUpdateCore()
    }
    ,
    b.TilemapLayer.prototype.postUpdate = function() {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
        this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x,
        this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
    }
    ,
    b.TilemapLayer.prototype._renderCanvas = function(a) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
        this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x,
        this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y,
        this.render(),
        PIXI.Sprite.prototype._renderCanvas.call(this, a)
    }
    ,
    b.TilemapLayer.prototype._renderWebGL = function(a) {
        this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x,
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y),
        this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x,
        this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y,
        this.render(),
        PIXI.Sprite.prototype._renderWebGL.call(this, a)
    }
    ,
    b.TilemapLayer.prototype.destroy = function() {
        PIXI.CanvasPool.remove(this),
        b.Component.Destroy.prototype.destroy.call(this)
    }
    ,
    b.TilemapLayer.prototype.resize = function(a, b) {
        this.canvas.width = a,
        this.canvas.height = b,
        this.texture.frame.resize(a, b),
        this.texture.width = a,
        this.texture.height = b,
        this.texture.crop.width = a,
        this.texture.crop.height = b,
        this.texture.baseTexture.width = a,
        this.texture.baseTexture.height = b,
        this.texture.baseTexture.dirty(),
        this.texture.requiresUpdate = !0,
        this.texture._updateUvs(),
        this.dirty = !0
    }
    ,
    b.TilemapLayer.prototype.resizeWorld = function() {
        this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
    }
    ,
    b.TilemapLayer.prototype._fixX = function(a) {
        return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? a : 0 === this.scrollFactorX && 0 !== this.position.x ? a - this.position.x : this._scrollX + (a - this._scrollX / this.scrollFactorX)
    }
    ,
    b.TilemapLayer.prototype._unfixX = function(a) {
        return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX)
    }
    ,
    b.TilemapLayer.prototype._fixY = function(a) {
        return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? a : 0 === this.scrollFactorY && 0 !== this.position.y ? a - this.position.y : this._scrollY + (a - this._scrollY / this.scrollFactorY)
    }
    ,
    b.TilemapLayer.prototype._unfixY = function(a) {
        return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY)
    }
    ,
    b.TilemapLayer.prototype.getTileX = function(a) {
        return Math.floor(this._fixX(a) / this._mc.tileWidth)
    }
    ,
    b.TilemapLayer.prototype.getTileY = function(a) {
        return Math.floor(this._fixY(a) / this._mc.tileHeight)
    }
    ,
    b.TilemapLayer.prototype.getTileXY = function(a, b, c) {
        return c.x = this.getTileX(a),
        c.y = this.getTileY(b),
        c
    }
    ,
    b.TilemapLayer.prototype.getRayCastTiles = function(a, b, c, d) {
        b || (b = this.rayStepRate),
        void 0 === c && (c = !1),
        void 0 === d && (d = !1);
        var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
        if (0 === e.length)
            return [];
        for (var f = a.coordinatesOnLine(b), g = [], h = 0; h < e.length; h++)
            for (var i = 0; i < f.length; i++) {
                var j = e[h]
                  , k = f[i];
                if (j.containsPoint(k[0], k[1])) {
                    g.push(j);
                    break
                }
            }
        return g
    }
    ,
    b.TilemapLayer.prototype.getTiles = function(a, b, c, d, e, f) {
        void 0 === e && (e = !1),
        void 0 === f && (f = !1);
        var g = !(e || f);
        a = this._fixX(a),
        b = this._fixY(b);
        for (var h = Math.floor(a / (this._mc.cw * this.scale.x)), i = Math.floor(b / (this._mc.ch * this.scale.y)), j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h, k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i; this._results.length; )
            this._results.pop();
        for (var l = i; l < i + k; l++)
            for (var m = h; m < h + j; m++) {
                var n = this.layer.data[l];
                n && n[m] && (g || n[m].isInteresting(e, f)) && this._results.push(n[m])
            }
        return this._results.slice()
    }
    ,
    b.TilemapLayer.prototype.resolveTileset = function(a) {
        var b = this._mc.tilesets;
        if (a < 2e3)
            for (; b.length < a; )
                b.push(void 0);
        var c = this.map.tiles[a] && this.map.tiles[a][2];
        if (null !== c) {
            var d = this.map.tilesets[c];
            if (d && d.containsTileIndex(a))
                return b[a] = d
        }
        return b[a] = null
    }
    ,
    b.TilemapLayer.prototype.resetTilesetCache = function() {
        for (var a = this._mc.tilesets; a.length; )
            a.pop()
    }
    ,
    b.TilemapLayer.prototype.setScale = function(a, b) {
        a = a || 1,
        b = b || a;
        for (var c = 0; c < this.layer.data.length; c++)
            for (var d = this.layer.data[c], e = 0; e < d.length; e++) {
                var f = d[e];
                f.width = this.map.tileWidth * a,
                f.height = this.map.tileHeight * b,
                f.worldX = f.x * f.width,
                f.worldY = f.y * f.height
            }
        this.scale.setTo(a, b)
    }
    ,
    b.TilemapLayer.prototype.shiftCanvas = function(a, b, c) {
        var d = a.canvas
          , e = d.width - Math.abs(b)
          , f = d.height - Math.abs(c)
          , g = 0
          , h = 0
          , i = b
          , j = c;
        b < 0 && (g = -b,
        i = 0),
        c < 0 && (h = -c,
        j = 0);
        var k = this.renderSettings.copyCanvas;
        if (k) {
            (k.width < e || k.height < f) && (k.width = e,
            k.height = f);
            var l = k.getContext("2d");
            l.clearRect(0, 0, e, f),
            l.drawImage(d, g, h, e, f, 0, 0, e, f),
            a.clearRect(i, j, e, f),
            a.drawImage(k, 0, 0, e, f, i, j, e, f)
        } else
            a.save(),
            a.globalCompositeOperation = "copy",
            a.drawImage(d, g, h, e, f, i, j, e, f),
            a.restore()
    }
    ,
    b.TilemapLayer.prototype.renderRegion = function(a, b, c, d, e, f) {
        var g = this.context
          , h = this.layer.width
          , i = this.layer.height
          , j = this._mc.tileWidth
          , k = this._mc.tileHeight
          , l = this._mc.tilesets
          , m = NaN;
        this._wrap || (c <= e && (c = Math.max(0, c),
        e = Math.min(h - 1, e)),
        d <= f && (d = Math.max(0, d),
        f = Math.min(i - 1, f)));
        var r, s, t, u, v, w, n = c * j - a, o = d * k - b, p = (c + (1 << 20) * h) % h, q = (d + (1 << 20) * i) % i;
        for (u = q,
        w = f - d,
        s = o; w >= 0; u++,
        w--,
        s += k) {
            u >= i && (u -= i);
            var x = this.layer.data[u];
            for (t = p,
            v = e - c,
            r = n; v >= 0; t++,
            v--,
            r += j) {
                t >= h && (t -= h);
                var y = x[t];
                if (y && !(y.index < 0)) {
                    var z = y.index
                      , A = l[z];
                    void 0 === A && (A = this.resolveTileset(z)),
                    y.alpha === m || this.debug || (g.globalAlpha = y.alpha,
                    m = y.alpha),
                    A ? y.rotation || y.flipped ? (g.save(),
                    g.translate(r + y.centerX, s + y.centerY),
                    g.rotate(y.rotation),
                    y.flipped && g.scale(-1, 1),
                    A.draw(g, -y.centerX, -y.centerY, z),
                    g.restore()) : A.draw(g, r, s, z) : this.debugSettings.missingImageFill && (g.fillStyle = this.debugSettings.missingImageFill,
                    g.fillRect(r, s, j, k)),
                    y.debug && this.debugSettings.debuggedTileOverfill && (g.fillStyle = this.debugSettings.debuggedTileOverfill,
                    g.fillRect(r, s, j, k))
                }
            }
        }
    }
    ,
    b.TilemapLayer.prototype.renderDeltaScroll = function(a, b) {
        var c = this._mc.scrollX
          , d = this._mc.scrollY
          , e = this.canvas.width
          , f = this.canvas.height
          , g = this._mc.tileWidth
          , h = this._mc.tileHeight
          , i = 0
          , j = -g
          , k = 0
          , l = -h;
        if (a < 0 ? (i = e + a,
        j = e - 1) : a > 0 && (j = a),
        b < 0 ? (k = f + b,
        l = f - 1) : b > 0 && (l = b),
        this.shiftCanvas(this.context, a, b),
        i = Math.floor((i + c) / g),
        j = Math.floor((j + c) / g),
        k = Math.floor((k + d) / h),
        l = Math.floor((l + d) / h),
        i <= j) {
            this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
            var m = Math.floor((0 + d) / h)
              , n = Math.floor((f - 1 + d) / h);
            this.renderRegion(c, d, i, m, j, n)
        }
        if (k <= l) {
            this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
            var o = Math.floor((0 + c) / g)
              , p = Math.floor((e - 1 + c) / g);
            this.renderRegion(c, d, o, k, p, l)
        }
    }
    ,
    b.TilemapLayer.prototype.renderFull = function() {
        var a = this._mc.scrollX
          , b = this._mc.scrollY
          , c = this.canvas.width
          , d = this.canvas.height
          , e = this._mc.tileWidth
          , f = this._mc.tileHeight
          , g = Math.floor(a / e)
          , h = Math.floor((c - 1 + a) / e)
          , i = Math.floor(b / f)
          , j = Math.floor((d - 1 + b) / f);
        this.context.clearRect(0, 0, c, d),
        this.renderRegion(a, b, g, i, h, j)
    }
    ,
    b.TilemapLayer.prototype.render = function() {
        var a = !1;
        if (this.visible) {
            (this.dirty || this.layer.dirty) && (this.layer.dirty = !1,
            a = !0);
            var b = this.canvas.width
              , c = this.canvas.height
              , d = 0 | this._scrollX
              , e = 0 | this._scrollY
              , f = this._mc
              , g = f.scrollX - d
              , h = f.scrollY - e;
            if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c)
                return this.context.save(),
                f.scrollX = d,
                f.scrollY = e,
                f.renderWidth === b && f.renderHeight === c || (f.renderWidth = b,
                f.renderHeight = c),
                this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha,
                this.debugSettings.forceFullRedraw && (a = !0)),
                !a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c) ? this.renderDeltaScroll(g, h) : this.renderFull(),
                this.debug && (this.context.globalAlpha = 1,
                this.renderDebug()),
                this.texture.baseTexture.dirty(),
                this.dirty = !1,
                this.context.restore(),
                !0
        }
    }
    ,
    b.TilemapLayer.prototype.renderDebug = function() {
        var r, s, t, u, v, w, a = this._mc.scrollX, b = this._mc.scrollY, c = this.context, d = this.canvas.width, e = this.canvas.height, f = this.layer.width, g = this.layer.height, h = this._mc.tileWidth, i = this._mc.tileHeight, j = Math.floor(a / h), k = Math.floor((d - 1 + a) / h), l = Math.floor(b / i), m = Math.floor((e - 1 + b) / i), n = j * h - a, o = l * i - b, p = (j + (1 << 20) * f) % f, q = (l + (1 << 20) * g) % g;
        for (c.strokeStyle = this.debugSettings.facingEdgeStroke,
        u = q,
        w = m - l,
        s = o; w >= 0; u++,
        w--,
        s += i) {
            u >= g && (u -= g);
            var x = this.layer.data[u];
            for (t = p,
            v = k - j,
            r = n; v >= 0; t++,
            v--,
            r += h) {
                t >= f && (t -= f);
                var y = x[t];
                !y || y.index < 0 || !y.collides || (this.debugSettings.collidingTileOverfill && (c.fillStyle = this.debugSettings.collidingTileOverfill,
                c.fillRect(r, s, this._mc.cw, this._mc.ch)),
                this.debugSettings.facingEdgeStroke && (c.beginPath(),
                y.faceTop && (c.moveTo(r, s),
                c.lineTo(r + this._mc.cw, s)),
                y.faceBottom && (c.moveTo(r, s + this._mc.ch),
                c.lineTo(r + this._mc.cw, s + this._mc.ch)),
                y.faceLeft && (c.moveTo(r, s),
                c.lineTo(r, s + this._mc.ch)),
                y.faceRight && (c.moveTo(r + this._mc.cw, s),
                c.lineTo(r + this._mc.cw, s + this._mc.ch)),
                c.closePath(),
                c.stroke()))
            }
        }
    }
    ,
    Object.defineProperty(b.TilemapLayer.prototype, "wrap", {
        get: function() {
            return this._wrap
        },
        set: function(a) {
            this._wrap = a,
            this.dirty = !0
        }
    }),
    Object.defineProperty(b.TilemapLayer.prototype, "scrollX", {
        get: function() {
            return this._scrollX
        },
        set: function(a) {
            this._scrollX = a
        }
    }),
    Object.defineProperty(b.TilemapLayer.prototype, "scrollY", {
        get: function() {
            return this._scrollY
        },
        set: function(a) {
            this._scrollY = a
        }
    }),
    Object.defineProperty(b.TilemapLayer.prototype, "collisionWidth", {
        get: function() {
            return this._mc.cw
        },
        set: function(a) {
            this._mc.cw = 0 | a,
            this.dirty = !0
        }
    }),
    Object.defineProperty(b.TilemapLayer.prototype, "collisionHeight", {
        get: function() {
            return this._mc.ch
        },
        set: function(a) {
            this._mc.ch = 0 | a,
            this.dirty = !0
        }
    }),
    b.TilemapParser = {
        INSERT_NULL: !1,
        parse: function(a, c, d, e, f, g) {
            if (void 0 === d && (d = 32),
            void 0 === e && (e = 32),
            void 0 === f && (f = 10),
            void 0 === g && (g = 10),
            void 0 === c)
                return this.getEmptyData();
            if (null === c)
                return this.getEmptyData(d, e, f, g);
            var h = a.cache.getTilemapData(c);
            if (h) {
                if (h.format === b.Tilemap.CSV)
                    return this.parseCSV(c, h.data, d, e);
                if (!h.format || h.format === b.Tilemap.TILED_JSON)
                    return this.parseTiledJSON(h.data)
            } else
                console.warn("Phaser.TilemapParser.parse - No map data found for key " + c)
        },
        parseCSV: function(a, c, d, e) {
            var f = this.getEmptyData();
            c = c.trim();
            for (var g = [], h = c.split("\n"), i = h.length, j = 0, k = 0; k < h.length; k++) {
                g[k] = [];
                for (var l = h[k].split(","), m = 0; m < l.length; m++)
                    g[k][m] = new b.Tile(f.layers[0],parseInt(l[m], 10),m,k,d,e);
                0 === j && (j = l.length)
            }
            return f.format = b.Tilemap.CSV,
            f.name = a,
            f.width = j,
            f.height = i,
            f.tileWidth = d,
            f.tileHeight = e,
            f.widthInPixels = j * d,
            f.heightInPixels = i * e,
            f.layers[0].width = j,
            f.layers[0].height = i,
            f.layers[0].widthInPixels = f.widthInPixels,
            f.layers[0].heightInPixels = f.heightInPixels,
            f.layers[0].data = g,
            f
        },
        getEmptyData: function(a, b, c, d) {
            return {
                width: void 0 !== c && null !== c ? c : 0,
                height: void 0 !== d && null !== d ? d : 0,
                tileWidth: void 0 !== a && null !== a ? a : 0,
                tileHeight: void 0 !== b && null !== b ? b : 0,
                orientation: "orthogonal",
                version: "1",
                properties: {},
                widthInPixels: 0,
                heightInPixels: 0,
                layers: [{
                    name: "layer",
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    widthInPixels: 0,
                    heightInPixels: 0,
                    alpha: 1,
                    visible: !0,
                    properties: {},
                    indexes: [],
                    callbacks: [],
                    bodies: [],
                    data: []
                }],
                images: [],
                objects: {},
                collision: {},
                tilesets: [],
                tiles: []
            }
        },
        parseTiledJSON: function(a) {
            function G(a, b) {
                var c = {};
                for (var d in b) {
                    var e = b[d];
                    void 0 !== a[e] && (c[e] = a[e])
                }
                return c
            }
            if ("orthogonal" !== a.orientation)
                return console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser"),
                null;
            for (var c = {
                width: a.width,
                height: a.height,
                tileWidth: a.tilewidth,
                tileHeight: a.tileheight,
                orientation: a.orientation,
                format: b.Tilemap.TILED_JSON,
                version: a.version,
                properties: a.properties,
                widthInPixels: a.width * a.tilewidth,
                heightInPixels: a.height * a.tileheight
            }, d = [], e = 0; e < a.layers.length; e++)
                if ("tilelayer" === a.layers[e].type) {
                    var f = a.layers[e];
                    if (!f.compression && f.encoding && "base64" === f.encoding) {
                        for (var g = window.atob(f.data), h = g.length, i = new Array(h), j = 0; j < h; j += 4)
                            i[j / 4] = (g.charCodeAt(j) | g.charCodeAt(j + 1) << 8 | g.charCodeAt(j + 2) << 16 | g.charCodeAt(j + 3) << 24) >>> 0;
                        f.data = i,
                        delete f.encoding
                    } else if (f.compression) {
                        console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + f.name + "'");
                        continue
                    }
                    var k = {
                        name: f.name,
                        x: f.x,
                        y: f.y,
                        width: f.width,
                        height: f.height,
                        widthInPixels: f.width * a.tilewidth,
                        heightInPixels: f.height * a.tileheight,
                        alpha: f.opacity,
                        visible: f.visible,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: []
                    };
                    f.properties && (k.properties = f.properties);
                    for (var o, p, q, r, l = 0, m = [], n = [], s = 0, h = f.data.length; s < h; s++) {
                        if (o = 0,
                        p = !1,
                        r = f.data[s],
                        q = 0,
                        r > 536870912)
                            switch (r > 2147483648 && (r -= 2147483648,
                            q += 4),
                            r > 1073741824 && (r -= 1073741824,
                            q += 2),
                            r > 536870912 && (r -= 536870912,
                            q += 1),
                            q) {
                            case 5:
                                o = Math.PI / 2;
                                break;
                            case 6:
                                o = Math.PI;
                                break;
                            case 3:
                                o = 3 * Math.PI / 2;
                                break;
                            case 4:
                                o = 0,
                                p = !0;
                                break;
                            case 7:
                                o = Math.PI / 2,
                                p = !0;
                                break;
                            case 2:
                                o = Math.PI,
                                p = !0;
                                break;
                            case 1:
                                o = 3 * Math.PI / 2,
                                p = !0
                            }
                        if (r > 0) {
                            var t = new b.Tile(k,r,l,n.length,a.tilewidth,a.tileheight);
                            t.rotation = o,
                            t.flipped = p,
                            0 !== q && (t.flippedVal = q),
                            m.push(t)
                        } else
                            b.TilemapParser.INSERT_NULL ? m.push(null) : m.push(new b.Tile(k,-1,l,n.length,a.tilewidth,a.tileheight));
                        l++,
                        l === f.width && (n.push(m),
                        l = 0,
                        m = [])
                    }
                    k.data = n,
                    d.push(k)
                }
            c.layers = d;
            for (var u = [], e = 0; e < a.layers.length; e++)
                if ("imagelayer" === a.layers[e].type) {
                    var v = a.layers[e]
                      , w = {
                        name: v.name,
                        image: v.image,
                        x: v.x,
                        y: v.y,
                        alpha: v.opacity,
                        visible: v.visible,
                        properties: {}
                    };
                    v.properties && (w.properties = v.properties),
                    u.push(w)
                }
            c.images = u;
            for (var x = [], y = [], z = null, e = 0; e < a.tilesets.length; e++) {
                var A = a.tilesets[e];
                if (A.image) {
                    var B = new b.Tileset(A.name,A.firstgid,A.tilewidth,A.tileheight,A.margin,A.spacing,A.properties);
                    A.tileproperties && (B.tileProperties = A.tileproperties),
                    B.updateTileData(A.imagewidth, A.imageheight),
                    x.push(B)
                } else {
                    var C = new b.ImageCollection(A.name,A.firstgid,A.tilewidth,A.tileheight,A.margin,A.spacing,A.properties);
                    for (var D in A.tiles) {
                        var w = A.tiles[D].image
                          , r = A.firstgid + parseInt(D, 10);
                        C.addImage(r, w)
                    }
                    y.push(C)
                }
                z && (z.lastgid = A.firstgid - 1),
                z = A
            }
            c.tilesets = x,
            c.imagecollections = y;
            for (var E = {}, F = {}, e = 0; e < a.layers.length; e++)
                if ("objectgroup" === a.layers[e].type) {
                    var H = a.layers[e];
                    E[H.name] = [],
                    F[H.name] = [];
                    for (var I = 0, h = H.objects.length; I < h; I++)
                        if (H.objects[I].gid) {
                            var J = {
                                gid: H.objects[I].gid,
                                name: H.objects[I].name,
                                type: H.objects[I].hasOwnProperty("type") ? H.objects[I].type : "",
                                x: H.objects[I].x,
                                y: H.objects[I].y,
                                visible: H.objects[I].visible,
                                properties: H.objects[I].properties
                            };
                            H.objects[I].rotation && (J.rotation = H.objects[I].rotation),
                            E[H.name].push(J)
                        } else if (H.objects[I].polyline) {
                            var J = {
                                name: H.objects[I].name,
                                type: H.objects[I].type,
                                x: H.objects[I].x,
                                y: H.objects[I].y,
                                width: H.objects[I].width,
                                height: H.objects[I].height,
                                visible: H.objects[I].visible,
                                properties: H.objects[I].properties
                            };
                            H.objects[I].rotation && (J.rotation = H.objects[I].rotation),
                            J.polyline = [];
                            for (var K = 0; K < H.objects[I].polyline.length; K++)
                                J.polyline.push([H.objects[I].polyline[K].x, H.objects[I].polyline[K].y]);
                            F[H.name].push(J),
                            E[H.name].push(J)
                        } else if (H.objects[I].polygon) {
                            var J = G(H.objects[I], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                            J.polygon = [];
                            for (var K = 0; K < H.objects[I].polygon.length; K++)
                                J.polygon.push([H.objects[I].polygon[K].x, H.objects[I].polygon[K].y]);
                            E[H.name].push(J)
                        } else if (H.objects[I].ellipse) {
                            var J = G(H.objects[I], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            E[H.name].push(J)
                        } else {
                            var J = G(H.objects[I], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            J.rectangle = !0,
                            E[H.name].push(J)
                        }
                }
            c.objects = E,
            c.collision = F,
            c.tiles = [];
            for (var e = 0; e < c.tilesets.length; e++)
                for (var A = c.tilesets[e], l = A.tileMargin, L = A.tileMargin, M = 0, N = 0, O = 0, s = A.firstgid; s < A.firstgid + A.total && (c.tiles[s] = [l, L, e],
                l += A.tileWidth + A.tileSpacing,
                ++M !== A.total) && (++N !== A.columns || (l = A.tileMargin,
                L += A.tileHeight + A.tileSpacing,
                N = 0,
                ++O !== A.rows)); s++)
                    ;
            for (var k, t, P, A, e = 0; e < c.layers.length; e++) {
                k = c.layers[e],
                A = null;
                for (var j = 0; j < k.data.length; j++) {
                    m = k.data[j];
                    for (var Q = 0; Q < m.length; Q++)
                        null === (t = m[Q]) || t.index < 0 || (P = c.tiles[t.index][2],
                        A = c.tilesets[P],
                        A.tileProperties && A.tileProperties[t.index - A.firstgid] && (t.properties = b.Utils.mixin(A.tileProperties[t.index - A.firstgid], t.properties)))
                }
            }
            return c
        }
    },
    b.Tileset = function(a, b, c, d, e, f, g) {
        (void 0 === c || c <= 0) && (c = 32),
        (void 0 === d || d <= 0) && (d = 32),
        void 0 === e && (e = 0),
        void 0 === f && (f = 0),
        this.name = a,
        this.firstgid = 0 | b,
        this.tileWidth = 0 | c,
        this.tileHeight = 0 | d,
        this.tileMargin = 0 | e,
        this.tileSpacing = 0 | f,
        this.properties = g || {},
        this.image = null,
        this.rows = 0,
        this.columns = 0,
        this.total = 0,
        this.drawCoords = []
    }
    ,
    b.Tileset.prototype = {
        draw: function(a, b, c, d) {
            var e = d - this.firstgid << 1;
            e >= 0 && e + 1 < this.drawCoords.length && a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight)
        },
        containsTileIndex: function(a) {
            return a >= this.firstgid && a < this.firstgid + this.total
        },
        setImage: function(a) {
            this.image = a,
            this.updateTileData(a.width, a.height)
        },
        setSpacing: function(a, b) {
            this.tileMargin = 0 | a,
            this.tileSpacing = 0 | b,
            this.image && this.updateTileData(this.image.width, this.image.height)
        },
        updateTileData: function(a, b) {
            var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing)
              , d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
            c % 1 == 0 && d % 1 == 0 || console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"),
            c = Math.floor(c),
            d = Math.floor(d),
            (this.rows && this.rows !== c || this.columns && this.columns !== d) && console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"),
            this.rows = c,
            this.columns = d,
            this.total = c * d,
            this.drawCoords.length = 0;
            for (var e = this.tileMargin, f = this.tileMargin, g = 0; g < this.rows; g++) {
                for (var h = 0; h < this.columns; h++)
                    this.drawCoords.push(e),
                    this.drawCoords.push(f),
                    e += this.tileWidth + this.tileSpacing;
                e = this.tileMargin,
                f += this.tileHeight + this.tileSpacing
            }
        }
    },
    b.Tileset.prototype.constructor = b.Tileset,
    b.Particle = function(a, c, d, e, f) {
        b.Sprite.call(this, a, c, d, e, f),
        this.autoScale = !1,
        this.scaleData = null,
        this._s = 0,
        this.autoAlpha = !1,
        this.alphaData = null,
        this._a = 0
    }
    ,
    b.Particle.prototype = Object.create(b.Sprite.prototype),
    b.Particle.prototype.constructor = b.Particle,
    b.Particle.prototype.update = function() {
        this.autoScale && (this._s--,
        this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1),
        this.autoAlpha && (this._a--,
        this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
    }
    ,
    b.Particle.prototype.onEmit = function() {}
    ,
    b.Particle.prototype.setAlphaData = function(a) {
        this.alphaData = a,
        this._a = a.length - 1,
        this.alpha = this.alphaData[this._a].v,
        this.autoAlpha = !0
    }
    ,
    b.Particle.prototype.setScaleData = function(a) {
        this.scaleData = a,
        this._s = a.length - 1,
        this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y),
        this.autoScale = !0
    }
    ,
    b.Particle.prototype.reset = function(a, c, d) {
        return b.Component.Reset.prototype.reset.call(this, a, c, d),
        this.alpha = 1,
        this.scale.set(1),
        this.autoScale = !1,
        this.autoAlpha = !1,
        this
    }
    ,
    b.Particles = function(a) {
        this.game = a,
        this.emitters = {},
        this.ID = 0
    }
    ,
    b.Particles.prototype = {
        add: function(a) {
            return this.emitters[a.name] = a,
            a
        },
        remove: function(a) {
            delete this.emitters[a.name]
        },
        update: function() {
            for (var a in this.emitters)
                this.emitters[a].exists && this.emitters[a].update()
        }
    },
    b.Particles.prototype.constructor = b.Particles,
    b.Particles.Arcade = {},
    b.Particles.Arcade.Emitter = function(a, c, d, e) {
        this.maxParticles = e || 50,
        b.Group.call(this, a),
        this.name = "emitter" + this.game.particles.ID++,
        this.type = b.EMITTER,
        this.physicsType = b.GROUP,
        this.area = new b.Rectangle(c,d,1,1),
        this.minParticleSpeed = new b.Point(-100,-100),
        this.maxParticleSpeed = new b.Point(100,100),
        this.minParticleScale = 1,
        this.maxParticleScale = 1,
        this.scaleData = null,
        this.minRotation = -360,
        this.maxRotation = 360,
        this.minParticleAlpha = 1,
        this.maxParticleAlpha = 1,
        this.alphaData = null,
        this.gravity = 100,
        this.particleClass = b.Particle,
        this.particleDrag = new b.Point,
        this.angularDrag = 0,
        this.frequency = 100,
        this.lifespan = 2e3,
        this.bounce = new b.Point,
        this.on = !1,
        this.particleAnchor = new b.Point(.5,.5),
        this.blendMode = b.blendModes.NORMAL,
        this.emitX = c,
        this.emitY = d,
        this.autoScale = !1,
        this.autoAlpha = !1,
        this.particleBringToTop = !1,
        this.particleSendToBack = !1,
        this._minParticleScale = new b.Point(1,1),
        this._maxParticleScale = new b.Point(1,1),
        this._quantity = 0,
        this._timer = 0,
        this._counter = 0,
        this._flowQuantity = 0,
        this._flowTotal = 0,
        this._explode = !0,
        this._frames = null
    }
    ,
    b.Particles.Arcade.Emitter.prototype = Object.create(b.Group.prototype),
    b.Particles.Arcade.Emitter.prototype.constructor = b.Particles.Arcade.Emitter,
    b.Particles.Arcade.Emitter.prototype.update = function() {
        if (this.on && this.game.time.time >= this._timer)
            if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion,
            0 !== this._flowTotal)
                if (this._flowQuantity > 0) {
                    for (var a = 0; a < this._flowQuantity; a++)
                        if (this.emitParticle() && (this._counter++,
                        -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                            this.on = !1;
                            break
                        }
                } else
                    this.emitParticle() && (this._counter++,
                    -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            else
                this.emitParticle() && (this._counter++,
                this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
        for (var a = this.children.length; a--; )
            this.children[a].exists && this.children[a].update()
    }
    ,
    b.Particles.Arcade.Emitter.prototype.makeParticles = function(a, b, c, d, e) {
        void 0 === b && (b = 0),
        void 0 === c && (c = this.maxParticles),
        void 0 === d && (d = !1),
        void 0 === e && (e = !1);
        var f, g = 0, h = a, i = b;
        for (this._frames = b,
        c > this.maxParticles && (this.maxParticles = c); g < c; )
            Array.isArray(a) && (h = this.game.rnd.pick(a)),
            Array.isArray(b) && (i = this.game.rnd.pick(b)),
            f = new this.particleClass(this.game,0,0,h,i),
            this.game.physics.arcade.enable(f, !1),
            d ? (f.body.checkCollision.any = !0,
            f.body.checkCollision.none = !1) : f.body.checkCollision.none = !0,
            f.body.collideWorldBounds = e,
            f.body.skipQuadTree = !0,
            f.exists = !1,
            f.visible = !1,
            f.anchor.copyFrom(this.particleAnchor),
            this.add(f),
            g++;
        return this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.kill = function() {
        return this.on = !1,
        this.alive = !1,
        this.exists = !1,
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.revive = function() {
        return this.alive = !0,
        this.exists = !0,
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.explode = function(a, b) {
        return this._flowTotal = 0,
        this.start(!0, a, 0, b, !1),
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.flow = function(a, b, c, d, e) {
        return void 0 !== c && 0 !== c || (c = 1),
        void 0 === d && (d = -1),
        void 0 === e && (e = !0),
        c > this.maxParticles && (c = this.maxParticles),
        this._counter = 0,
        this._flowQuantity = c,
        this._flowTotal = d,
        e ? (this.start(!0, a, b, c),
        this._counter += c,
        this.on = !0,
        this._timer = this.game.time.time + b * this.game.time.slowMotion) : this.start(!1, a, b, c),
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.start = function(a, b, c, d, e) {
        if (void 0 === a && (a = !0),
        void 0 === b && (b = 0),
        void 0 !== c && null !== c || (c = 250),
        void 0 === d && (d = 0),
        void 0 === e && (e = !1),
        d > this.maxParticles && (d = this.maxParticles),
        this.revive(),
        this.visible = !0,
        this.lifespan = b,
        this.frequency = c,
        a || e)
            for (var f = 0; f < d; f++)
                this.emitParticle();
        else
            this.on = !0,
            this._quantity = d,
            this._counter = 0,
            this._timer = this.game.time.time + c * this.game.time.slowMotion;
        return this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.emitParticle = function(a, b, c, d) {
        void 0 === a && (a = null),
        void 0 === b && (b = null);
        var e = this.getFirstExists(!1);
        if (null === e)
            return !1;
        var f = this.game.rnd;
        void 0 !== c && void 0 !== d ? e.loadTexture(c, d) : void 0 !== c && e.loadTexture(c);
        var g = this.emitX
          , h = this.emitY;
        null !== a ? g = a : this.width > 1 && (g = f.between(this.left, this.right)),
        null !== b ? h = b : this.height > 1 && (h = f.between(this.top, this.bottom)),
        e.reset(g, h),
        e.angle = 0,
        e.lifespan = this.lifespan,
        this.particleBringToTop ? this.bringToTop(e) : this.particleSendToBack && this.sendToBack(e),
        this.autoScale ? e.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? e.scale.set(f.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || e.scale.set(f.realInRange(this._minParticleScale.x, this._maxParticleScale.x), f.realInRange(this._minParticleScale.y, this._maxParticleScale.y)),
        void 0 === d && (Array.isArray(this._frames) ? e.frame = this.game.rnd.pick(this._frames) : e.frame = this._frames),
        this.autoAlpha ? e.setAlphaData(this.alphaData) : e.alpha = f.realInRange(this.minParticleAlpha, this.maxParticleAlpha),
        e.blendMode = this.blendMode;
        var i = e.body;
        return i.updateBounds(),
        i.bounce.copyFrom(this.bounce),
        i.drag.copyFrom(this.particleDrag),
        i.velocity.x = f.between(this.minParticleSpeed.x, this.maxParticleSpeed.x),
        i.velocity.y = f.between(this.minParticleSpeed.y, this.maxParticleSpeed.y),
        i.angularVelocity = f.between(this.minRotation, this.maxRotation),
        i.gravity.y = this.gravity,
        i.angularDrag = this.angularDrag,
        e.onEmit(),
        !0
    }
    ,
    b.Particles.Arcade.Emitter.prototype.destroy = function() {
        this.game.particles.remove(this),
        b.Group.prototype.destroy.call(this, !0, !1)
    }
    ,
    b.Particles.Arcade.Emitter.prototype.setSize = function(a, b) {
        return this.area.width = a,
        this.area.height = b,
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.setXSpeed = function(a, b) {
        return a = a || 0,
        b = b || 0,
        this.minParticleSpeed.x = a,
        this.maxParticleSpeed.x = b,
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.setYSpeed = function(a, b) {
        return a = a || 0,
        b = b || 0,
        this.minParticleSpeed.y = a,
        this.maxParticleSpeed.y = b,
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.setRotation = function(a, b) {
        return a = a || 0,
        b = b || 0,
        this.minRotation = a,
        this.maxRotation = b,
        this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.setAlpha = function(a, c, d, e, f) {
        if (void 0 === a && (a = 1),
        void 0 === c && (c = 1),
        void 0 === d && (d = 0),
        void 0 === e && (e = b.Easing.Linear.None),
        void 0 === f && (f = !1),
        this.minParticleAlpha = a,
        this.maxParticleAlpha = c,
        this.autoAlpha = !1,
        d > 0 && a !== c) {
            var g = {
                v: a
            }
              , h = this.game.make.tween(g).to({
                v: c
            }, d, e);
            h.yoyo(f),
            this.alphaData = h.generateData(60),
            this.alphaData.reverse(),
            this.autoAlpha = !0
        }
        return this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.setScale = function(a, c, d, e, f, g, h) {
        if (void 0 === a && (a = 1),
        void 0 === c && (c = 1),
        void 0 === d && (d = 1),
        void 0 === e && (e = 1),
        void 0 === f && (f = 0),
        void 0 === g && (g = b.Easing.Linear.None),
        void 0 === h && (h = !1),
        this.minParticleScale = 1,
        this.maxParticleScale = 1,
        this._minParticleScale.set(a, d),
        this._maxParticleScale.set(c, e),
        this.autoScale = !1,
        f > 0 && (a !== c || d !== e)) {
            var i = {
                x: a,
                y: d
            }
              , j = this.game.make.tween(i).to({
                x: c,
                y: e
            }, f, g);
            j.yoyo(h),
            this.scaleData = j.generateData(60),
            this.scaleData.reverse(),
            this.autoScale = !0
        }
        return this
    }
    ,
    b.Particles.Arcade.Emitter.prototype.at = function(a) {
        return a.center ? (this.emitX = a.center.x,
        this.emitY = a.center.y) : (this.emitX = a.world.x + a.anchor.x * a.width,
        this.emitY = a.world.y + a.anchor.y * a.height),
        this
    }
    ,
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "width", {
        get: function() {
            return this.area.width
        },
        set: function(a) {
            this.area.width = a
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "height", {
        get: function() {
            return this.area.height
        },
        set: function(a) {
            this.area.height = a
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "x", {
        get: function() {
            return this.emitX
        },
        set: function(a) {
            this.emitX = a
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "y", {
        get: function() {
            return this.emitY
        },
        set: function(a) {
            this.emitY = a
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "left", {
        get: function() {
            return Math.floor(this.x - this.area.width / 2)
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "right", {
        get: function() {
            return Math.floor(this.x + this.area.width / 2)
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "top", {
        get: function() {
            return Math.floor(this.y - this.area.height / 2)
        }
    }),
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function() {
            return Math.floor(this.y + this.area.height / 2)
        }
    }),
    b.Weapon = function(a, c) {
        b.Plugin.call(this, a, c),
        this.bullets = null,
        this.autoExpandBulletsGroup = !1,
        this.autofire = !1,
        this.shots = 0,
        this.fireLimit = 0,
        this.fireRate = 100,
        this.fireRateVariance = 0,
        this.fireFrom = new b.Rectangle(0,0,1,1),
        this.fireAngle = b.ANGLE_UP,
        this.bulletInheritSpriteSpeed = !1,
        this.bulletAnimation = "",
        this.bulletFrameRandom = !1,
        this.bulletFrameCycle = !1,
        this.bulletWorldWrap = !1,
        this.bulletWorldWrapPadding = 0,
        this.bulletAngleOffset = 0,
        this.bulletAngleVariance = 0,
        this.bulletSpeed = 200,
        this.bulletSpeedVariance = 0,
        this.bulletLifespan = 0,
        this.bulletKillDistance = 0,
        this.bulletGravity = new b.Point(0,0),
        this.bulletRotateToVelocity = !1,
        this.bulletKey = "",
        this.bulletFrame = "",
        this._bulletClass = b.Bullet,
        this._bulletCollideWorldBounds = !1,
        this._bulletKillType = b.Weapon.KILL_WORLD_BOUNDS,
        this._data = {
            customBody: !1,
            width: 0,
            height: 0,
            offsetX: 0,
            offsetY: 0
        },
        this.bounds = new b.Rectangle,
        this.bulletBounds = a.world.bounds,
        this.bulletFrames = [],
        this.bulletFrameIndex = 0,
        this.anims = {},
        this.onFire = new b.Signal,
        this.onKill = new b.Signal,
        this.onFireLimit = new b.Signal,
        this.trackedSprite = null,
        this.trackedPointer = null,
        this.trackRotation = !1,
        this.trackOffset = new b.Point,
        this._nextFire = 0,
        this._rotatedPoint = new b.Point
    }
    ,
    b.Weapon.prototype = Object.create(b.Plugin.prototype),
    b.Weapon.prototype.constructor = b.Weapon,
    b.Weapon.KILL_NEVER = 0,
    b.Weapon.KILL_LIFESPAN = 1,
    b.Weapon.KILL_DISTANCE = 2,
    b.Weapon.KILL_WEAPON_BOUNDS = 3,
    b.Weapon.KILL_CAMERA_BOUNDS = 4,
    b.Weapon.KILL_WORLD_BOUNDS = 5,
    b.Weapon.KILL_STATIC_BOUNDS = 6,
    b.Weapon.prototype.createBullets = function(a, c, d, e) {
        return void 0 === a && (a = 1),
        void 0 === e && (e = this.game.world),
        this.bullets || (this.bullets = this.game.add.physicsGroup(b.Physics.ARCADE, e),
        this.bullets.classType = this._bulletClass),
        0 !== a && (-1 === a && (this.autoExpandBulletsGroup = !0,
        a = 1),
        this.bullets.createMultiple(a, c, d),
        this.bullets.setAll("data.bulletManager", this),
        this.bulletKey = c,
        this.bulletFrame = d),
        this
    }
    ,
    b.Weapon.prototype.forEach = function(a, b) {
        return this.bullets.forEachExists(a, b, arguments),
        this
    }
    ,
    b.Weapon.prototype.pauseAll = function() {
        return this.bullets.setAll("body.enable", !1),
        this
    }
    ,
    b.Weapon.prototype.resumeAll = function() {
        return this.bullets.setAll("body.enable", !0),
        this
    }
    ,
    b.Weapon.prototype.killAll = function() {
        return this.bullets.callAllExists("kill", !0),
        this.bullets.setAll("body.enable", !0),
        this
    }
    ,
    b.Weapon.prototype.resetShots = function(a) {
        return this.shots = 0,
        void 0 !== a && (this.fireLimit = a),
        this
    }
    ,
    b.Weapon.prototype.destroy = function() {
        this.parent.remove(this, !1),
        this.bullets.destroy(),
        this.game = null,
        this.parent = null,
        this.active = !1,
        this.visible = !1
    }
    ,
    b.Weapon.prototype.update = function() {
        this._bulletKillType === b.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(),
        this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)),
        this.autofire && this.fire()
    }
    ,
    b.Weapon.prototype.trackSprite = function(a, b, c, d) {
        return void 0 === b && (b = 0),
        void 0 === c && (c = 0),
        void 0 === d && (d = !1),
        this.trackedPointer = null,
        this.trackedSprite = a,
        this.trackRotation = d,
        this.trackOffset.set(b, c),
        this
    }
    ,
    b.Weapon.prototype.trackPointer = function(a, b, c) {
        return void 0 === a && (a = this.game.input.activePointer),
        void 0 === b && (b = 0),
        void 0 === c && (c = 0),
        this.trackedPointer = a,
        this.trackedSprite = null,
        this.trackRotation = !1,
        this.trackOffset.set(b, c),
        this
    }
    ,
    b.Weapon.prototype.fire = function(a, c, d) {
        if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit)
            return !1;
        var e = this.bulletSpeed;
        0 !== this.bulletSpeedVariance && (e += b.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)),
        a ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(a.x, a.y) : (this.fireFrom.x = a.x,
        this.fireFrom.y = a.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y),
        this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation),
        this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x,
        this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x,
        this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y),
        this.bulletInheritSpriteSpeed && (e += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x,
        this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
        var f = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x
          , g = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y
          , h = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
        void 0 !== c && void 0 !== d && (h = this.game.math.radToDeg(Math.atan2(d - g, c - f))),
        0 !== this.bulletAngleVariance && (h += b.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
        var i = 0
          , j = 0;
        0 === h || 180 === h ? i = Math.cos(this.game.math.degToRad(h)) * e : 90 === h || 270 === h ? j = Math.sin(this.game.math.degToRad(h)) * e : (i = Math.cos(this.game.math.degToRad(h)) * e,
        j = Math.sin(this.game.math.degToRad(h)) * e);
        var k = null;
        if (this.autoExpandBulletsGroup ? (k = this.bullets.getFirstExists(!1, !0, f, g, this.bulletKey, this.bulletFrame),
        k.data.bulletManager = this) : k = this.bullets.getFirstExists(!1),
        k) {
            if (k.reset(f, g),
            k.data.fromX = f,
            k.data.fromY = g,
            k.data.killType = this.bulletKillType,
            k.data.killDistance = this.bulletKillDistance,
            k.data.rotateToVelocity = this.bulletRotateToVelocity,
            this.bulletKillType === b.Weapon.KILL_LIFESPAN && (k.lifespan = this.bulletLifespan),
            k.angle = h + this.bulletAngleOffset,
            "" !== this.bulletAnimation) {
                if (null === k.animations.getAnimation(this.bulletAnimation)) {
                    var l = this.anims[this.bulletAnimation];
                    k.animations.add(l.name, l.frames, l.frameRate, l.loop, l.useNumericIndex)
                }
                k.animations.play(this.bulletAnimation)
            } else
                this.bulletFrameCycle ? (k.frame = this.bulletFrames[this.bulletFrameIndex],
                ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (k.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
            if (k.data.bodyDirty && (this._data.customBody && k.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY),
            k.body.collideWorldBounds = this.bulletCollideWorldBounds,
            k.data.bodyDirty = !1),
            k.body.velocity.set(i, j),
            k.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y),
            0 !== this.bulletSpeedVariance) {
                var m = this.fireRate;
                m += b.Math.between(-this.fireRateVariance, this.fireRateVariance),
                m < 0 && (m = 0),
                this._nextFire = this.game.time.now + m
            } else
                this._nextFire = this.game.time.now + this.fireRate;
            this.shots++,
            this.onFire.dispatch(k, this, e),
            this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
        }
        return k
    }
    ,
    b.Weapon.prototype.fireAtPointer = function(a) {
        return void 0 === a && (a = this.game.input.activePointer),
        this.fire(null, a.worldX, a.worldY)
    }
    ,
    b.Weapon.prototype.fireAtSprite = function(a) {
        return this.fire(null, a.world.x, a.world.y)
    }
    ,
    b.Weapon.prototype.fireAtXY = function(a, b) {
        return this.fire(null, a, b)
    }
    ,
    b.Weapon.prototype.setBulletBodyOffset = function(a, b, c, d) {
        return void 0 === c && (c = 0),
        void 0 === d && (d = 0),
        this._data.customBody = !0,
        this._data.width = a,
        this._data.height = b,
        this._data.offsetX = c,
        this._data.offsetY = d,
        this.bullets.callAll("body.setSize", "body", a, b, c, d),
        this.bullets.setAll("data.bodyDirty", !1),
        this
    }
    ,
    b.Weapon.prototype.setBulletFrames = function(a, c, d, e) {
        return void 0 === d && (d = !0),
        void 0 === e && (e = !1),
        this.bulletFrames = b.ArrayUtils.numberArray(a, c),
        this.bulletFrameIndex = 0,
        this.bulletFrameCycle = d,
        this.bulletFrameRandom = e,
        this
    }
    ,
    b.Weapon.prototype.addBulletAnimation = function(a, b, c, d, e) {
        return this.anims[a] = {
            name: a,
            frames: b,
            frameRate: c,
            loop: d,
            useNumericIndex: e
        },
        this.bullets.callAll("animations.add", "animations", a, b, c, d, e),
        this.bulletAnimation = a,
        this
    }
    ,
    b.Weapon.prototype.debug = function(a, b, c) {
        void 0 === a && (a = 16),
        void 0 === b && (b = 32),
        void 0 === c && (c = !1),
        this.game.debug.text("Weapon Plugin", a, b),
        this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, a, b + 24),
        c && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
    }
    ,
    Object.defineProperty(b.Weapon.prototype, "bulletClass", {
        get: function() {
            return this._bulletClass
        },
        set: function(a) {
            this._bulletClass = a,
            this.bullets.classType = this._bulletClass
        }
    }),
    Object.defineProperty(b.Weapon.prototype, "bulletKillType", {
        get: function() {
            return this._bulletKillType
        },
        set: function(a) {
            switch (a) {
            case b.Weapon.KILL_STATIC_BOUNDS:
            case b.Weapon.KILL_WEAPON_BOUNDS:
                this.bulletBounds = this.bounds;
                break;
            case b.Weapon.KILL_CAMERA_BOUNDS:
                this.bulletBounds = this.game.camera.view;
                break;
            case b.Weapon.KILL_WORLD_BOUNDS:
                this.bulletBounds = this.game.world.bounds
            }
            this._bulletKillType = a
        }
    }),
    Object.defineProperty(b.Weapon.prototype, "bulletCollideWorldBounds", {
        get: function() {
            return this._bulletCollideWorldBounds
        },
        set: function(a) {
            this._bulletCollideWorldBounds = a,
            this.bullets.setAll("body.collideWorldBounds", a),
            this.bullets.setAll("data.bodyDirty", !1)
        }
    }),
    Object.defineProperty(b.Weapon.prototype, "x", {
        get: function() {
            return this.fireFrom.x
        },
        set: function(a) {
            this.fireFrom.x = a
        }
    }),
    Object.defineProperty(b.Weapon.prototype, "y", {
        get: function() {
            return this.fireFrom.y
        },
        set: function(a) {
            this.fireFrom.y = a
        }
    }),
    b.Bullet = function(a, c, d, e, f) {
        b.Sprite.call(this, a, c, d, e, f),
        this.anchor.set(.5),
        this.data = {
            bulletManager: null,
            fromX: 0,
            fromY: 0,
            bodyDirty: !0,
            rotateToVelocity: !1,
            killType: 0,
            killDistance: 0
        }
    }
    ,
    b.Bullet.prototype = Object.create(b.Sprite.prototype),
    b.Bullet.prototype.constructor = b.Bullet,
    b.Bullet.prototype.kill = function() {
        return this.alive = !1,
        this.exists = !1,
        this.visible = !1,
        this.data.bulletManager.onKill.dispatch(this),
        this
    }
    ,
    b.Bullet.prototype.update = function() {
        this.exists && (this.data.killType > b.Weapon.KILL_LIFESPAN && (this.data.killType === b.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()),
        this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)),
        this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
    }
    ,
    b.Video = function(a, c, d) {
        if (void 0 === c && (c = null),
        void 0 === d && (d = null),
        this.game = a,
        this.key = c,
        this.width = 0,
        this.height = 0,
        this.type = b.VIDEO,
        this.disableTextureUpload = !1,
        this.touchLocked = !1,
        this.onPlay = new b.Signal,
        this.onChangeSource = new b.Signal,
        this.onComplete = new b.Signal,
        this.onAccess = new b.Signal,
        this.onError = new b.Signal,
        this.onTimeout = new b.Signal,
        this.timeout = 15e3,
        this._timeOutID = null,
        this.video = null,
        this.videoStream = null,
        this.isStreaming = !1,
        this.retryLimit = 20,
        this.retry = 0,
        this.retryInterval = 500,
        this._retryID = null,
        this._codeMuted = !1,
        this._muted = !1,
        this._codePaused = !1,
        this._paused = !1,
        this._pending = !1,
        this._autoplay = !1,
        this._endCallback = null,
        this._playCallback = null,
        c && this.game.cache.checkVideoKey(c)) {
            var e = this.game.cache.getVideo(c);
            e.isBlob ? this.createVideoFromBlob(e.data) : this.video = e.data,
            this.width = this.video.videoWidth,
            this.height = this.video.videoHeight
        } else
            d && this.createVideoFromURL(d, !1);
        this.video && !d ? (this.baseTexture = new PIXI.BaseTexture(this.video),
        this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(b.Cache.DEFAULT.baseTexture.source),
        this.baseTexture.forceLoaded(this.width, this.height)),
        this.texture = new PIXI.Texture(this.baseTexture),
        this.textureFrame = new b.Frame(0,0,0,this.width,this.height,"video"),
        this.texture.setFrame(this.textureFrame),
        this.texture.valid = !1,
        null !== c && this.video && (this.texture.valid = this.video.canplay),
        this.snapshot = null,
        b.BitmapData && (this.snapshot = new b.BitmapData(this.game,"",this.width,this.height)),
        !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : e && (e.locked = !1)
    }
    ,
    b.Video.prototype = {
        connectToMediaStream: function(a, b) {
            return a && b && (this.video = a,
            this.videoStream = b,
            this.isStreaming = !0,
            this.baseTexture.source = this.video,
            this.updateTexture(null, this.video.videoWidth, this.video.videoHeight),
            this.onAccess.dispatch(this)),
            this
        },
        startMediaStream: function(a, b, c) {
            if (void 0 === a && (a = !1),
            void 0 === b && (b = null),
            void 0 === c && (c = null),
            !this.game.device.getUserMedia)
                return this.onError.dispatch(this, "No getUserMedia"),
                !1;
            null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()),
            this.removeVideoElement(),
            this.video = document.createElement("video"),
            this.video.setAttribute("autoplay", "autoplay"),
            null !== b && (this.video.width = b),
            null !== c && (this.video.height = c),
            this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
            try {
                navigator.getUserMedia({
                    audio: a,
                    video: !0
                }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
            } catch (a) {
                this.getUserMediaError(a)
            }
            return this
        },
        getUserMediaTimeout: function() {
            clearTimeout(this._timeOutID),
            this.onTimeout.dispatch(this)
        },
        getUserMediaError: function(a) {
            clearTimeout(this._timeOutID),
            this.onError.dispatch(this, a)
        },
        getUserMediaSuccess: function(a) {
            clearTimeout(this._timeOutID),
            this.videoStream = a,
            void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = a : this.video.src = window.URL && window.URL.createObjectURL(a) || a;
            var b = this;
            this.video.onloadeddata = function() {
                function c() {
                    if (a > 0)
                        if (b.video.videoWidth > 0) {
                            var d = b.video.videoWidth
                              , e = b.video.videoHeight;
                            isNaN(b.video.videoHeight) && (e = d / (4 / 3)),
                            b.video.play(),
                            b.isStreaming = !0,
                            b.baseTexture.source = b.video,
                            b.updateTexture(null, d, e),
                            b.onAccess.dispatch(b)
                        } else
                            window.setTimeout(c, 500);
                    else
                        console.warn("Unable to connect to video stream. Webcam error?");
                    a--
                }
                var a = 10;
                c()
            }
        },
        createVideoFromBlob: function(a) {
            var b = this;
            return this.video = document.createElement("video"),
            this.video.controls = !1,
            this.video.setAttribute("autoplay", "autoplay"),
            this.video.addEventListener("loadeddata", function(a) {
                b.updateTexture(a)
            }, !0),
            this.video.src = window.URL.createObjectURL(a),
            this.video.canplay = !0,
            this
        },
        createVideoFromURL: function(a, b) {
            return void 0 === b && (b = !1),
            this.texture && (this.texture.valid = !1),
            this.video = document.createElement("video"),
            this.video.controls = !1,
            b && this.video.setAttribute("autoplay", "autoplay"),
            this.video.src = a,
            this.video.canplay = !0,
            this.video.load(),
            this.retry = this.retryLimit,
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval),
            this.key = a,
            this
        },
        updateTexture: function(a, b, c) {
            var d = !1;
            void 0 !== b && null !== b || (b = this.video.videoWidth,
            d = !0),
            void 0 !== c && null !== c || (c = this.video.videoHeight),
            this.width = b,
            this.height = c,
            this.baseTexture.source !== this.video && (this.baseTexture.source = this.video),
            this.baseTexture.forceLoaded(b, c),
            this.texture.frame.resize(b, c),
            this.texture.width = b,
            this.texture.height = c,
            this.texture.valid = !0,
            this.snapshot && this.snapshot.resize(b, c),
            d && null !== this.key && (this.onChangeSource.dispatch(this, b, c),
            this._autoplay && (this.video.play(),
            this.onPlay.dispatch(this, this.loop, this.playbackRate)))
        },
        complete: function() {
            this.onComplete.dispatch(this)
        },
        play: function(a, b) {
            return void 0 === a && (a = !1),
            void 0 === b && (b = 1),
            this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this),
            this.game.sound.onUnMute.add(this.unsetMute, this),
            this.game.sound.mute && this.setMute()),
            this.game.onPause.add(this.setPause, this),
            this.game.onResume.add(this.setResume, this),
            this._endCallback = this.complete.bind(this),
            this.video.addEventListener("ended", this._endCallback, !0),
            this.video.addEventListener("webkitendfullscreen", this._endCallback, !0),
            this.video.loop = a ? "loop" : "",
            this.video.playbackRate = b,
            this.touchLocked ? this._pending = !0 : (this._pending = !1,
            null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit,
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this),
            this.video.addEventListener("playing", this._playCallback, !0))),
            this.video.play(),
            this.onPlay.dispatch(this, a, b)),
            this
        },
        playHandler: function() {
            this.video.removeEventListener("playing", this._playCallback, !0),
            this.updateTexture()
        },
        stop: function() {
            return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this),
            this.game.sound.onUnMute.remove(this.unsetMute, this)),
            this.game.onPause.remove(this.setPause, this),
            this.game.onResume.remove(this.setResume, this),
            this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(),
            this.video.src = null) : (this.video.src = "",
            this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(a) {
                a.stop()
            }) : this.videoStream.stop()),
            this.videoStream = null,
            this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0),
            this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0),
            this.video.removeEventListener("playing", this._playCallback, !0),
            this.touchLocked ? this._pending = !1 : this.video.pause()),
            this
        },
        add: function(a) {
            if (Array.isArray(a))
                for (var b = 0; b < a.length; b++)
                    a[b].loadTexture && a[b].loadTexture(this);
            else
                a.loadTexture(this);
            return this
        },
        addToWorld: function(a, b, c, d, e, f) {
            e = e || 1,
            f = f || 1;
            var g = this.game.add.image(a, b, this);
            return g.anchor.set(c, d),
            g.scale.set(e, f),
            g
        },
        render: function() {
            !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
        },
        setMute: function() {
            this._muted || (this._muted = !0,
            this.video.muted = !0)
        },
        unsetMute: function() {
            this._muted && !this._codeMuted && (this._muted = !1,
            this.video.muted = !1)
        },
        setPause: function() {
            this._paused || this.touchLocked || (this._paused = !0,
            this.video.pause())
        },
        setResume: function() {
            !this._paused || this._codePaused || this.touchLocked || (this._paused = !1,
            this.video.ended || this.video.play())
        },
        changeSource: function(a, b) {
            return void 0 === b && (b = !0),
            this.texture.valid = !1,
            this.video.pause(),
            this.retry = this.retryLimit,
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval),
            this.video.src = a,
            this.video.load(),
            this._autoplay = b,
            b || (this.paused = !0),
            this
        },
        checkVideoProgress: function() {
            4 === this.video.readyState ? this.updateTexture() : (this.retry--,
            this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming))
        },
        setTouchLock: function() {
            this.game.input.touch.addTouchLockCallback(this.unlock, this),
            this.touchLocked = !0
        },
        unlock: function() {
            if (this.touchLocked = !1,
            this.video.play(),
            this.onPlay.dispatch(this, this.loop, this.playbackRate),
            this.key) {
                var a = this.game.cache.getVideo(this.key);
                a && !a.isBlob && (a.locked = !1)
            }
            return !0
        },
        grab: function(a, b, c) {
            return void 0 === a && (a = !1),
            void 0 === b && (b = 1),
            void 0 === c && (c = null),
            null === this.snapshot ? void console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable") : (a && this.snapshot.cls(),
            this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c),
            this.snapshot)
        },
        removeVideoElement: function() {
            if (this.video) {
                for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes(); )
                    this.video.removeChild(this.video.firstChild);
                this.video.removeAttribute("autoplay"),
                this.video.removeAttribute("src"),
                this.video = null
            }
        },
        destroy: function() {
            this.stop(),
            this.removeVideoElement(),
            this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this),
            this._retryID && window.clearTimeout(this._retryID)
        }
    },
    Object.defineProperty(b.Video.prototype, "currentTime", {
        get: function() {
            return this.video ? this.video.currentTime : 0
        },
        set: function(a) {
            this.video.currentTime = a
        }
    }),
    Object.defineProperty(b.Video.prototype, "duration", {
        get: function() {
            return this.video ? this.video.duration : 0
        }
    }),
    Object.defineProperty(b.Video.prototype, "progress", {
        get: function() {
            return this.video ? this.video.currentTime / this.video.duration : 0
        }
    }),
    Object.defineProperty(b.Video.prototype, "mute", {
        get: function() {
            return this._muted
        },
        set: function(a) {
            if (a = a || null) {
                if (this._muted)
                    return;
                this._codeMuted = !0,
                this.setMute()
            } else {
                if (!this._muted)
                    return;
                this._codeMuted = !1,
                this.unsetMute()
            }
        }
    }),
    Object.defineProperty(b.Video.prototype, "paused", {
        get: function() {
            return this._paused
        },
        set: function(a) {
            if (a = a || null,
            !this.touchLocked)
                if (a) {
                    if (this._paused)
                        return;
                    this._codePaused = !0,
                    this.setPause()
                } else {
                    if (!this._paused)
                        return;
                    this._codePaused = !1,
                    this.setResume()
                }
        }
    }),
    Object.defineProperty(b.Video.prototype, "volume", {
        get: function() {
            return this.video ? this.video.volume : 1
        },
        set: function(a) {
            a < 0 ? a = 0 : a > 1 && (a = 1),
            this.video && (this.video.volume = a)
        }
    }),
    Object.defineProperty(b.Video.prototype, "playbackRate", {
        get: function() {
            return this.video ? this.video.playbackRate : 1
        },
        set: function(a) {
            this.video && (this.video.playbackRate = a)
        }
    }),
    Object.defineProperty(b.Video.prototype, "loop", {
        get: function() {
            return !!this.video && this.video.loop
        },
        set: function(a) {
            a && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
        }
    }),
    Object.defineProperty(b.Video.prototype, "playing", {
        get: function() {
            return !(this.video.paused && this.video.ended)
        }
    }),
    b.Video.prototype.constructor = b.Video,
    void 0 === PIXI.blendModes && (PIXI.blendModes = b.blendModes),
    void 0 === PIXI.scaleModes && (PIXI.scaleModes = b.scaleModes),
    void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)),
    void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix),
    void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix),
    PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = b.POLYGON,
    PIXI.Graphics.RECT = b.RECTANGLE,
    PIXI.Graphics.CIRC = b.CIRCLE,
    PIXI.Graphics.ELIP = b.ELLIPSE,
    PIXI.Graphics.RREC = b.ROUNDEDRECTANGLE),
    PIXI.TextureSilentFail = !0,
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = b),
    exports.Phaser = b) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
        return a.Phaser = b
    }()) : a.Phaser = b,
    b
}
.call(this);
var ParkingFury = {
    render_textures_created: null,
    s_menu: null,
    s_ingame: null,
    s_splash: null,
    s_check: null,
    s_hit: null,
    s_engine: null,
    s_star: null,
    sound_enabled: null,
    score: null,
    levels: null,
    currentLevel: null,
    currentStars: null,
    levelsStars: null,
    save: null,
    load: null,
    sound_ON_OFF: null,
    mobile_browser: null,
    allLevelsUnlocked: null
};
ParkingFury.Boot = function(a) {}
,
unlockAllLevels = function() {
    console.log("UNLOCK ALL");
    for (var a = 0; a < levelsStars.length; a++)
        levelsStars[a] < 0 && (levelsStars[a] = 0);
    allLevelsUnlocked = !0
}
,
ParkingFury.Boot.prototype = {
    init: function() {
        s_menu = null,
        s_ingame = null,
        s_splash = null,
        s_check = null,
        s_hit = null,
        s_engine = null,
        s_star = null,
        sound_enabled = !0,
        this.game.device.desktop ? mobile_browser = !1 : (mobile_browser = !0,
        navigator.userAgent.match(/Windows NT/i) && (mobile_browser = !1)),
        sound_ON_OFF = function() {
            sound_enabled = !sound_enabled,
            s_menu.mute = !sound_enabled,
            s_ingame.mute = !sound_enabled,
            s_splash.mute = !sound_enabled,
            s_check.mute = !sound_enabled,
            s_hit.mute = !sound_enabled,
            s_engine.mute = !sound_enabled,
            s_star.mute = !sound_enabled
        }
        ,
        save = function() {
            try {
                localStorage.setItem("ParkingFury_01", JSON.stringify(levelsStars))
            } catch (a) {
                console.log('Your web browser does not support storing settings locally. In Safari, the most common cause of this is using "Private Browsing Mode". Some settings may not save or some features may not work properly for you.')
            }
        }
        ,
        load = function() {
            var a = localStorage.getItem("ParkingFury_01");
            a ? (console.log("Seves Exist"),
            levelsStars = JSON.parse(a)) : console.log("Saves Not Exist")
        }
        ,
        this.game.tweens.frameBased = !0,
        render_textures_created = !1,
        currentLevel = 0,
        currentStars = 0,
        levelsStars = [0, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        allLevelsUnlocked = !1,
        score = 66,
        this.input.maxPointers = 2,
        this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL,
        this.game.scale.pageAlignHorizontally = !0,
        this.game.scale.pageAlignVertically = !0,
        load()
    },
    preload: function() {
        this.load.image("preloaderBackground", "assets/background_menu.png"),
        this.load.image("preloaderBar", "assets/loader.png"),
        this.load.image("game_logo", "assets/game_logo.png")
    },
    create: function() {
        this.state.start("Preloader")
    }
},
ParkingFury.Preloader = function(a) {
    this.background = null,
    this.preloadBar = null,
    this.ready = !1
}
,
ParkingFury.Preloader.prototype = {
    preload: function() {
        this.background = this.add.sprite(0, 0, "preloaderBackground"),
        this.background.anchor.setTo(.5, .5),
        this.background.x = 320,
        this.background.y = 240;
        var a = this.add.sprite(320, 150, "game_logo");
        a.scale.setTo(.8, .8),
        a.anchor.setTo(.5, .5),
        this.preloadBar = this.add.sprite(90, 400, "preloaderBar"),
        this.load.setPreloadSprite(this.preloadBar),
        this.load.image("btn_play", "assets/btn_play.png"),
        this.load.image("btn_more", "assets/btn_more_games.png"),
        this.load.image("btn_credits", "assets/btn_credits.png"),
        this.load.image("btn_home", "assets/btn_home.png"),
        this.load.image("btn_restart", "assets/btn_restart.png"),
        this.load.image("btn_back", "assets/btn_back.png"),
        this.load.image("bkg_pattern", "assets/bkg_pattern.png"),
        this.load.image("btn_levels", "assets/btn_levels.png"),
        this.load.image("logo105", "assets/logo105.png"),
        this.load.image("car_shadow", "assets/cars/car_shadow.png"),
        this.load.image("car_wheel", "assets/cars/car_wheel.png"),
        this.load.image("c2_1.png", "assets/cars/c2_1.png"),
        this.load.image("c2_2.png", "assets/cars/c2_2.png"),
        this.load.image("c3_1.png", "assets/cars/c3_1.png"),
        this.load.image("c3_2.png", "assets/cars/c3_2.png"),
        this.load.image("c3_3.png", "assets/cars/c3_3.png"),
        this.load.image("c3_4.png", "assets/cars/c3_4.png"),
        this.load.image("c4_1.png", "assets/cars/c4_1.png"),
        this.load.image("c4_2.png", "assets/cars/c4_2.png"),
        this.load.image("c4_3.png", "assets/cars/c4_3.png"),
        this.load.image("c5_1.png", "assets/cars/c5_1.png"),
        this.load.image("c5_2.png", "assets/cars/c5_2.png"),
        this.load.image("c5_3.png", "assets/cars/c5_3.png"),
        this.load.image("c6_1.png", "assets/cars/c6_1.png"),
        this.load.image("c6_2.png", "assets/cars/c6_2.png"),
        this.load.image("c6_3.png", "assets/cars/c6_3.png"),
        this.load.image("hero_car_1.png", "assets/cars/hero_car_1.png"),
        this.load.image("hero_car_2.png", "assets/cars/hero_car_2.png"),
        this.game.load.json("car_1", "assets/json/cars/car_1.json"),
        this.game.load.json("car_2", "assets/json/cars/car_2.json"),
        this.game.load.json("car_3", "assets/json/cars/car_3.json"),
        this.game.load.json("car_4", "assets/json/cars/car_4.json"),
        this.game.load.json("car_5", "assets/json/cars/car_5.json"),
        this.game.load.json("car_6", "assets/json/cars/car_6.json"),
        this.game.load.json("car_7", "assets/json/cars/car_7.json"),
        this.game.load.json("car_8", "assets/json/cars/car_8.json"),
        this.game.load.json("car_9", "assets/json/cars/car_9.json"),
        this.game.load.json("car_10", "assets/json/cars/car_10.json"),
        this.game.load.json("car_11", "assets/json/cars/car_11.json"),
        this.game.load.json("car_12", "assets/json/cars/car_12.json"),
        this.game.load.json("car_13", "assets/json/cars/car_13.json"),
        this.game.load.json("car_14", "assets/json/cars/car_14.json"),
        this.game.load.json("car_15", "assets/json/cars/car_15.json"),
        this.game.load.json("car_16", "assets/json/cars/car_16.json"),
        this.game.load.json("car_17", "assets/json/cars/car_17.json"),
        this.game.load.json("level_0", "assets/json/levels/level_0.json"),
        this.game.load.json("level_0_ground", "assets/json/levels/level_0_ground.json"),
        this.game.load.json("level_0_decals", "assets/json/levels/level_0_decals.json"),
        this.game.load.json("level_0_missions", "assets/json/levels/level_0_missions.json"),
        this.game.load.json("level_0_phys", "assets/json/levels/level_0_phys.json"),
        this.game.load.json("level_1", "assets/json/levels/level_1.json"),
        this.game.load.json("level_1_ground", "assets/json/levels/level_1_ground.json"),
        this.game.load.json("level_1_decals", "assets/json/levels/level_1_decals.json"),
        this.game.load.json("level_1_missions", "assets/json/levels/level_1_missions.json"),
        this.game.load.json("level_1_phys", "assets/json/levels/level_1_phys.json"),
        this.game.load.json("level_2", "assets/json/levels/level_2.json"),
        this.game.load.json("level_2_ground", "assets/json/levels/level_2_ground.json"),
        this.game.load.json("level_2_decals", "assets/json/levels/level_2_decals.json"),
        this.game.load.json("level_2_missions", "assets/json/levels/level_2_missions.json"),
        this.game.load.json("level_2_phys", "assets/json/levels/level_2_phys.json"),
        this.game.load.json("level_3", "assets/json/levels/level_3.json"),
        this.game.load.json("level_3_ground", "assets/json/levels/level_3_ground.json"),
        this.game.load.json("level_3_decals", "assets/json/levels/level_3_decals.json"),
        this.game.load.json("level_3_missions", "assets/json/levels/level_3_missions.json"),
        this.game.load.json("level_3_phys", "assets/json/levels/level_3_phys.json"),
        this.game.load.json("level_4", "assets/json/levels/level_4.json"),
        this.game.load.json("level_4_ground", "assets/json/levels/level_4_ground.json"),
        this.game.load.json("level_4_decals", "assets/json/levels/level_4_decals.json"),
        this.game.load.json("level_4_missions", "assets/json/levels/level_4_missions.json"),
        this.game.load.json("level_4_phys", "assets/json/levels/level_4_phys.json"),
        this.game.load.json("level_5", "assets/json/levels/level_5.json"),
        this.game.load.json("level_5_ground", "assets/json/levels/level_5_ground.json"),
        this.game.load.json("level_5_decals", "assets/json/levels/level_5_decals.json"),
        this.game.load.json("level_5_missions", "assets/json/levels/level_5_missions.json"),
        this.game.load.json("level_5_phys", "assets/json/levels/level_5_phys.json"),
        this.game.load.json("level_6", "assets/json/levels/level_6.json"),
        this.game.load.json("level_6_ground", "assets/json/levels/level_6_ground.json"),
        this.game.load.json("level_6_decals", "assets/json/levels/level_6_decals.json"),
        this.game.load.json("level_6_missions", "assets/json/levels/level_6_missions.json"),
        this.game.load.json("level_6_phys", "assets/json/levels/level_6_phys.json"),
        this.game.load.json("level_7", "assets/json/levels/level_7.json"),
        this.game.load.json("level_7_ground", "assets/json/levels/level_7_ground.json"),
        this.game.load.json("level_7_decals", "assets/json/levels/level_7_decals.json"),
        this.game.load.json("level_7_missions", "assets/json/levels/level_7_missions.json"),
        this.game.load.json("level_7_phys", "assets/json/levels/level_7_phys.json"),
        this.game.load.json("level_8", "assets/json/levels/level_8.json"),
        this.game.load.json("level_8_ground", "assets/json/levels/level_8_ground.json"),
        this.game.load.json("level_8_decals", "assets/json/levels/level_8_decals.json"),
        this.game.load.json("level_8_missions", "assets/json/levels/level_8_missions.json"),
        this.game.load.json("level_8_phys", "assets/json/levels/level_8_phys.json"),
        this.game.load.json("level_9", "assets/json/levels/level_9.json"),
        this.game.load.json("level_9_ground", "assets/json/levels/level_9_ground.json"),
        this.game.load.json("level_9_decals", "assets/json/levels/level_9_decals.json"),
        this.game.load.json("level_9_missions", "assets/json/levels/level_9_missions.json"),
        this.game.load.json("level_9_phys", "assets/json/levels/level_9_phys.json"),
        this.game.load.json("map_part_plitka_1.json", "assets/json/clips/map_part_plitka_1.json"),
        this.game.load.json("map_part_plitka_2.json", "assets/json/clips/map_part_plitka_2.json"),
        this.game.load.json("map_part_plitka_3.json", "assets/json/clips/map_part_plitka_3.json"),
        this.game.load.json("map_part_trava_1.json", "assets/json/clips/map_part_trava_1.json"),
        this.game.load.json("map_part_trava_2.json", "assets/json/clips/map_part_trava_2.json"),
        this.game.load.json("map_part_trava_3.json", "assets/json/clips/map_part_trava_3.json"),
        this.load.image("flare", "assets/flare.png"),
        this.load.image("asphalt_1.jpg", "assets/textures/asphalt_1.jpg"),
        this.load.image("Bruk.png", "assets/textures/Bruk.png"),
        this.load.image("asphalt_2.png", "assets/textures/asphalt_2.png"),
        this.load.image("Trotuar.jpg", "assets/textures/Trotuar.jpg"),
        this.load.image("Trava.jpg", "assets/textures/Trava.jpg"),
        this.load.image("House.jpg", "assets/textures/House.jpg"),
        this.load.image("roof.jpg", "assets/textures/roof.jpg"),
        this.load.image("Tree1.png", "assets/textures/Tree1.png"),
        this.load.image("Tree2.png", "assets/textures/Tree2.png"),
        this.load.image("Barrels.png", "assets/textures/Barrels.png"),
        this.load.image("Barrels2.png", "assets/textures/Barrels2.png"),
        this.load.image("beton.png", "assets/textures/beton.png"),
        this.load.image("Car.png", "assets/textures/Car.png"),
        this.load.image("Door.png", "assets/textures/Door.png"),
        this.load.image("Klumba.jpg", "assets/textures/Klumba.jpg"),
        this.load.image("Musor1.png", "assets/textures/Musor1.png"),
        this.load.image("Musor2.png", "assets/textures/Musor2.png"),
        this.load.image("Zabor_X1.jpg", "assets/textures/Zabor_X1.jpg"),
        this.load.image("Zabor_X1_2.jpg", "assets/textures/Zabor_X1_2.jpg"),
        this.load.image("Zabor_X3.jpg", "assets/textures/Zabor_X3.jpg"),
        this.load.image("wood_box.png", "assets/textures/wood_box.png"),
        this.load.image("Bordur_Long.jpg", "assets/textures/Bordur_Long.jpg"),
        this.load.image("Bordur_rot.png", "assets/textures/Bordur_rot.png"),
        this.load.image("Bordur_Short.jpg", "assets/textures/Bordur_Short.jpg"),
        this.load.image("Zebra.png", "assets/textures/Zebra.png"),
        this.load.image("razmetka.png", "assets/textures/razmetka.png"),
        this.load.image("arrow_direct.png", "assets/textures/arrow_direct.png"),
        this.load.image("arrow_fin.png", "assets/textures/arrow_fin.png"),
        this.load.image("arrow_turn.png", "assets/textures/arrow_turn.png"),
        this.load.spritesheet("btn_sound", "assets/btn_sound_frames.png", 92, 91),
        this.load.spritesheet("star", "assets/star_frames.png", 96, 92),
        this.load.image("gui_stars_bkg", "assets/gui_stars_bkg.png"),
        this.load.image("gui_mission_complete", "assets/gui_mission_complete.png"),
        this.load.image("check", "assets/check.png"),
        this.load.image("fail", "assets/fail.png"),
        this.load.image("gui_wheel", "assets/gui_wheel.png"),
        this.load.image("gui_pedal_gas", "assets/gui_pedal_gas.png"),
        this.load.image("gui_pedal_brake", "assets/gui_pedal_brake.png"),
        this.load.bitmapFont("myfont", "assets/font.png", "assets/font.fnt"),
        this.load.audio("music_menu", ["assets/sounds/menu_music.ogg", "assets/sounds/menu_music.mp3"]),
        this.load.audio("music_game", ["assets/sounds/ingame_FunkGameLoop.ogg", "assets/sounds/ingame_FunkGameLoop.mp3"]),
        this.load.audio("music_splash", ["assets/sounds/splash.ogg", "assets/sounds/splash.mp3"]),
        this.load.audio("music_check", ["assets/sounds/check.ogg", "assets/sounds/check.mp3"]),
        this.load.audio("music_hit", ["assets/sounds/HitSound.ogg", "assets/sounds/HitSound.mp3"]),
        this.load.audio("music_engine", ["assets/sounds/engine_rev.ogg", "assets/sounds/engine_rev.mp3"]),
        this.load.audio("music_star", ["assets/sounds/star.ogg", "assets/sounds/star.mp3"]),
        this.load.image("coolmath_logo", "assets/coolmath_logo.png"),
        this.load.atlas("spark", "assets/spark_frames.png", "assets/spark_frames.json")
    },
    create: function() {
        console.log("PRELOADER"),
        this.preloadBar.cropEnabled = !1
    },
    startMainMenu: function() {
        console.log("Start MainMenu"),
        this.game.state.start("MainMenu", !0, !1, "splash")
    },
    update: function() {
        this.cache.isSoundDecoded("music_menu") && 0 == this.ready && (this.ready = !0,
        this.startMainMenu())
    }
},
ParkingFury.MainMenu = function(a) {
    this.background,
    this.menu_splash,
    this.menu_main,
    this.menu_result,
    this.menu_levels,
    this.menu_credits,
    this.star_r_1,
    this.star_r_2,
    this.star_r_3,
    this.result_score_text,
    this.result_flare,
    this.menu_to_show,
    this.levels_buttons,
    this.splash_graphics,
    this.splash_logo
}
,
ParkingFury.MainMenu.prototype = {
    init: function(a) {
        this.game.stage.disableVisibilityChange = !0,
        this.menu_to_show = 0,
        a && (this.menu_to_show = "result" == a ? 1 : "splash" == a ? 2 : 0),
        this.levels_buttons = []
    },
    create: function() {
        s_menu || (s_menu = this.game.add.audio("music_menu"),
        s_menu.volume = 1,
        s_menu.loop = !0,
        s_ingame = this.game.add.audio("music_game"),
        s_ingame.volume = 1,
        s_ingame.loop = !0,
        s_check = this.game.add.audio("music_check"),
        s_hit = this.game.add.audio("music_hit"),
        s_hit.volume = .8,
        s_engine = this.game.add.audio("music_engine"),
        s_engine.volume = .7,
        s_splash = this.game.add.audio("music_splash"),
        s_star = this.game.add.audio("music_star")),
        s_menu.play(),
        this.game.world.scale.set(1),
        this.background = this.add.sprite(0, 0, "preloaderBackground"),
        this.background.anchor.setTo(.1, .1),
        this.menu_splash = this.game.add.group(),
        this.menu_splash.position.x = 320,
        this.menu_splash.position.y = 240,
        this.splash_graphics = this.game.add.graphics(-320, -240),
        this.splash_graphics.beginFill(0),
        this.splash_graphics.drawRect(0, 0, 640, 480),
        this.splash_graphics.endFill(),
        this.menu_splash.addChild(this.splash_graphics),
        this.splash_logo = this.menu_splash.create(0, 0, "coolmath_logo"),
        this.splash_logo.scale.setTo(.7, .7),
        this.splash_logo.anchor.setTo(.5, .5),
        this.menu_main = this.game.add.group();
        var b = (this.menu_main.create(17, 4, "game_logo"),
        this.menu_main.create(442, 278, "btn_play"));
        b.anchor.setTo(.5, .5),
        b.inputEnabled = !0,
        b.input.useHandCursor = !0,
        b.events.onInputOver.add(this.over, this),
        b.events.onInputOut.add(this.out, this),
        b.events.onInputDown.add(this.play_pressed, this);
        var c = this.menu_main.create(495, 400, "btn_credits");
        c.anchor.setTo(.5, .5),
        c.inputEnabled = !0,
        c.input.useHandCursor = !0,
        c.events.onInputOver.add(this.over, this),
        c.events.onInputOut.add(this.out, this),
        c.events.onInputDown.add(this.credits_pressed, this);
        var d = this.menu_main.create(568, 316, "btn_sound");
        d.anchor.setTo(.5, .5),
        d.inputEnabled = !0,
        d.input.useHandCursor = !0,
        d.events.onInputOver.add(this.over, this),
        d.events.onInputOut.add(this.out, this),
        d.events.onInputDown.add(this.sound_pressed, this),
        sound_enabled ? d.frame = 0 : d.frame = 1,
        this.menu_result = this.game.add.group();
        var e = this.game.add.tileSprite(0, 24, 640, 66, "bkg_pattern");
        this.menu_result.addChild(e);
        var f = this.game.add.graphics(0, 76.1);
        this.menu_result.addChild(f),
        f.beginFill(16569617),
        f.drawRect(0, 0, 640, 6.7),
        f.endFill();
        var g = this.game.add.bitmapText(208, 37, "myfont", "LEVEL RESULT", 28);
        this.menu_result.addChild(g);
        var h = this.game.add.tileSprite(144.95, 104, 360, 229, "bkg_pattern");
        this.menu_result.addChild(h);
        var i = 25;
        this.star_r_1 = this.menu_result.create(320, 161.25 + i, "star"),
        this.star_r_1.anchor.setTo(.5, .5),
        this.star_r_1.frame = 0,
        this.star_r_2 = this.menu_result.create(241.3, 186.8 + i, "star"),
        this.star_r_2.anchor.setTo(.5, .5),
        this.star_r_2.scale.setTo(.9, .9),
        this.star_r_2.frame = 1,
        this.star_r_3 = this.menu_result.create(398.25, 186.8 + i, "star"),
        this.star_r_3.anchor.setTo(.5, .5),
        this.star_r_3.scale.setTo(.9, .9),
        this.star_r_3.frame = 2;
        var j = this.game.add.graphics(155, 310);
        this.menu_result.addChild(j),
        j.beginFill(16569617),
        j.drawRect(0, 0, 340, 6.7),
        j.endFill();
        var k = this.menu_result.create(75.3, 420.3, "btn_home");
        k.anchor.setTo(.5, .5),
        k.inputEnabled = !0,
        k.input.useHandCursor = !0,
        k.events.onInputOver.add(this.over, this),
        k.events.onInputOut.add(this.out, this),
        k.events.onInputDown.add(this.result_home_pressed, this);
        var l = this.menu_result.create(570.35, 420.3, "btn_back");
        l.scale.setTo(-1, 1),
        l.anchor.setTo(.5, .5),
        l.inputEnabled = !0,
        l.input.useHandCursor = !0,
        l.events.onInputOver.add(this.over, this),
        l.events.onInputOut.add(this.out, this),
        l.events.onInputDown.add(this.result_next_pressed, this),
        this.result_flare = this.menu_result.create(220, 220, "flare"),
        this.result_flare.anchor.setTo(.5, .5),
        this.result_flare.tint = 16776960,
        this.result_flare.blendMode = PIXI.blendModes.ADD,
        this.menu_levels = this.game.add.group();
        var e = this.game.add.tileSprite(0, 24, 640, 66, "bkg_pattern");
        this.menu_levels.addChild(e);
        var f = this.game.add.graphics(0, 76.1);
        this.menu_levels.addChild(f),
        f.beginFill(16569617),
        f.drawRect(0, 0, 640, 6.7),
        f.endFill();
        var m = this.game.add.bitmapText(208, 37, "myfont", "SELECT LEVEL", 28);
        this.menu_levels.addChild(m);
        for (var n = 0; n < 10; n++) {
            var o = 301;
            n < 5 && (o = 174);
            var p = 116;
            p += n < 5 ? 105 * n : 105 * (n - 5);
            var q = this.menu_levels.create(p, o, "btn_levels");
            q.anchor.setTo(.5, .5),
            q.inputEnabled = !0,
            q.input.useHandCursor = !0,
            q.events.onInputOver.add(this.over, this),
            q.events.onInputOut.add(this.out, this),
            q.events.onInputDown.add(this.levelPressed, this);
            var r = this.game.add.bitmapText(0, 0, "myfont", n + 1, 34);
            r.anchor.setTo(.56, .4),
            q.addChild(r);
            var s = this.game.add.group();
            s.y = -39,
            q.addChild(s);
            var t = s.create(0, -4.25, "star");
            t.anchor.setTo(.5, .5),
            t.scale.setTo(.4, .4),
            t.frame = 0;
            var u = s.create(-27.85, 5.95, "star");
            u.anchor.setTo(.5, .5),
            u.scale.setTo(.35, .35),
            u.frame = 0;
            var v = s.create(27.85, 5.95, "star");
            v.anchor.setTo(.5, .5),
            v.scale.setTo(.35, .35),
            v.frame = 0,
            q.label = r,
            q.level = n,
            q.s_1 = t,
            q.s_2 = u,
            q.s_3 = v,
            q.open = !0,
            this.levels_buttons[n] = q
        }
        var w = this.menu_levels.create(75.3, 420.3, "btn_home");
        w.anchor.setTo(.5, .5),
        w.inputEnabled = !0,
        w.input.useHandCursor = !0,
        w.events.onInputOver.add(this.over, this),
        w.events.onInputOut.add(this.out, this),
        w.events.onInputDown.add(this.levels_home_pressed, this),
        this.initLevels(),
        this.menu_credits = this.game.add.group();
        var e = this.game.add.tileSprite(0, 24, 640, 66, "bkg_pattern");
        this.menu_credits.addChild(e);
        var f = this.game.add.graphics(0, 76.1);
        this.menu_credits.addChild(f),
        f.beginFill(16569617),
        f.drawRect(0, 0, 640, 6.7),
        f.endFill();
        var g = this.game.add.bitmapText(320, 37, "myfont", "CREDITS", 28);
        g.anchor.setTo(.5, 0),
        this.menu_credits.addChild(g);
        var h = this.game.add.tileSprite(144.95, 104, 360, 229, "bkg_pattern");
        this.menu_credits.addChild(h);
        var x = this.menu_credits.create(75.3, 420.3, "btn_home");
        x.anchor.setTo(.5, .5),
        x.inputEnabled = !0,
        x.input.useHandCursor = !0,
        x.events.onInputOver.add(this.over, this),
        x.events.onInputOut.add(this.out, this),
        x.events.onInputDown.add(this.credits_home_pressed, this);
        var g = this.game.add.bitmapText(320, 137, "myfont", "GAME DESIGN AND DEVELOPMENT\nANDRIY PIDVIRNYY\nAKA\nFREES\n\nMUSIC BY\nKEVIN MACLEOD", 16);
        if (g.align = "center",
        g.anchor.setTo(.5, 0),
        this.menu_credits.addChild(g),
        this.menu_levels.y = -800,
        this.menu_credits.y = -800,
        0 == this.menu_to_show)
            this.menu_result.y = -800,
            this.menu_splash.y = -800;
        else if (1 == this.menu_to_show)
            this.menu_main.y = -800,
            this.menu_splash.y = -800,
            this.setResult();
        else if (2 == this.menu_to_show) {
            this.menu_main.y = -800,
            this.menu_result.y = -800;
            var y = this.game.add.tween(this.splash_logo).to({
                alpha: 0
            }, 150, "Linear", !1);
            y.delay(2e3),
            y.start();
            var z = this.game.add.tween(this.splash_graphics).to({
                alpha: 0
            }, 100, "Linear", !1);
            z.delay(2150),
            z.onComplete.add(this.spalsh_alpha_callback, this),
            z.start()
        }
    },
    spalsh_alpha_callback: function() {
        this.menu_splash.y = -800,
        this.menu_splash.visible = !1,
        this.swap_menus(null, this.menu_main)
    },
    shutdown: function() {
        this.background.destroy(),
        this.background = null,
        this.menu_main.destroy(),
        this.menu_main = null,
        this.menu_result.destroy(),
        this.menu_result = null,
        this.menu_credits.destroy(),
        this.menu_credits = null,
        this.menu_levels.destroy(),
        this.menu_levels = null,
        this.menu_splash.destroy(),
        this.menu_splash = null
    },
    sound_pressed: function(a, b) {
        sound_ON_OFF(),
        sound_enabled ? a.frame = 0 : a.frame = 1
    },
    initLevels: function() {
        for (var a = 0; a < 10; a++)
            levelsStars[a] >= 0 ? (this.levels_buttons[a].label.alpha = 1,
            this.levels_buttons[a].open = !0,
            1 != levelsStars[a] && 2 != levelsStars[a] || (this.levels_buttons[a].s_1.frame = levelsStars[a],
            this.levels_buttons[a].s_2.frame = 0,
            this.levels_buttons[a].s_3.frame = 0),
            3 != levelsStars[a] && 4 != levelsStars[a] || (this.levels_buttons[a].s_1.frame = 2,
            this.levels_buttons[a].s_2.frame = levelsStars[a] - 2,
            this.levels_buttons[a].s_3.frame = 0),
            5 != levelsStars[a] && 6 != levelsStars[a] || (this.levels_buttons[a].s_1.frame = 2,
            this.levels_buttons[a].s_2.frame = 2,
            this.levels_buttons[a].s_3.frame = levelsStars[a] - 4)) : (this.levels_buttons[a].label.alpha = .4,
            this.levels_buttons[a].open = !1,
            this.levels_buttons[a].s_1.frame = 0,
            this.levels_buttons[a].s_2.frame = 0,
            this.levels_buttons[a].s_3.frame = 0)
    },
    levelPressed: function(a, b) {
        a.open && (s_menu.stop(),
        currentLevel = a.level,
        // parent.cmgGameEvent && parent.cmgGameEvent("start", "" + (currentLevel + 1)),
        this.state.start("Game", !0, !1))
    },
    setResult: function() {
        this.star_r_1.frame = 0,
        this.star_r_2.frame = 0,
        this.star_r_3.frame = 0;
        var a = 0;
        if (1 == currentStars || 2 == currentStars) {
            var b = this.game.add.tween(this.star_r_1.scale).to({
                x: 0,
                y: 0
            }, 100, "Linear", !1);
            b.to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !1),
            b.delay(200),
            b.onStart.add(this.star_appear, this),
            b.start();
            this.game.add.tween(this.star_r_1).to({
                frame: currentStars
            }, 1, "Linear", !0, 300);
            a = 450
        }
        if (3 == currentStars || 4 == currentStars) {
            var b = this.game.add.tween(this.star_r_1.scale).to({
                x: 0,
                y: 0
            }, 100, "Linear", !1);
            b.to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !1),
            b.delay(200),
            b.onStart.add(this.star_appear, this),
            b.start();
            var d = (this.game.add.tween(this.star_r_1).to({
                frame: 2
            }, 1, "Linear", !0, 300),
            this.game.add.tween(this.star_r_2.scale).to({
                x: 0,
                y: 0
            }, 100, "Linear", !1));
            d.to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !1),
            d.delay(650),
            d.onStart.add(this.star_appear, this),
            d.start();
            this.game.add.tween(this.star_r_2).to({
                frame: currentStars - 2
            }, 1, "Linear", !0, 750);
            a = 900
        }
        if (5 == currentStars || 6 == currentStars) {
            var b = this.game.add.tween(this.star_r_1.scale).to({
                x: 0,
                y: 0
            }, 100, "Linear", !1);
            b.to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !1),
            b.delay(200),
            b.onStart.add(this.star_appear, this),
            b.start();
            var d = (this.game.add.tween(this.star_r_1).to({
                frame: 2
            }, 1, "Linear", !0, 300),
            this.game.add.tween(this.star_r_2.scale).to({
                x: 0,
                y: 0
            }, 100, "Linear", !1));
            d.to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !1),
            d.delay(650),
            d.onStart.add(this.star_appear, this),
            d.start();
            var f = (this.game.add.tween(this.star_r_2).to({
                frame: 2
            }, 1, "Linear", !0, 750),
            this.game.add.tween(this.star_r_3.scale).to({
                x: 0,
                y: 0
            }, 100, "Linear", !1));
            f.to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !1),
            f.delay(1100),
            f.onStart.add(this.star_appear, this),
            f.start();
            this.game.add.tween(this.star_r_3).to({
                frame: currentStars - 4
            }, 1, "Linear", !0, 1200);
            a = 1400
        }
        this.result_flare.scale.setTo(0, 0),
        this.result_flare.x = 200;
        var h = this.game.add.tween(this.result_flare.scale).to({
            x: 1,
            y: 1
        }, 100, "Linear", !1);
        h.to({
            x: 0,
            y: 0
        }, 100, "Linear", !1),
        h.delay(a),
        h.start();
        var i = this.game.add.tween(this.result_flare).to({
            x: 440
        }, 100, "Linear", !1);
        i.delay(a),
        i.start(),
        levelsStars[currentLevel] = currentStars,
        currentLevel < 9 && (currentLevel += 1,
        levelsStars[currentLevel] < 0 && (levelsStars[currentLevel] = 0)),
        save()
    },
    star_appear: function() {
        s_star.play()
    },
    result_home_pressed: function(a, b) {
        this.swap_menus(this.menu_result, this.menu_main)
    },
    credits_home_pressed: function(a, b) {
        this.swap_menus(this.menu_credits, this.menu_main)
    },
    levels_home_pressed: function(a, b) {
        this.swap_menus(this.menu_levels, this.menu_main)
    },
    result_next_pressed: function(a, b) {
        this.swap_menus(this.menu_result, this.menu_levels),
        this.initLevels()
    },
    credits_pressed: function(a, b) {
        this.swap_menus(this.menu_main, this.menu_credits)
    },
    play_pressed: function(a, b) {
        // parent.cmgGameEvent && parent.cmgGameEvent("start"),
        this.swap_menus(this.menu_main, this.menu_levels),
        this.initLevels()
    },
    over: function(a, b) {
        a.label && !a.open || (a.scaleOrig || (a.scaleOrig = new Phaser.Point(a.scale.x,a.scale.y)),
        a.scale.setTo(1.05 * a.scaleOrig.x, 1.05 * a.scaleOrig.y))
    },
    out: function(a, b) {
        a.label && !a.open || a.scale.setTo(a.scaleOrig.x, a.scaleOrig.y)
    },
    swap_menus: function(a, b) {
        s_splash.play();
        this.game.add.tween(a).to({
            y: -800
        }, 200, "Linear", !0);
        b.x = 0,
        b.y = -800;
        this.game.add.tween(b).to({
            y: 0
        }, 200, "Linear", !0, 200)
    },
    update: function() {
        allLevelsUnlocked && (this.initLevels(),
        allLevelsUnlocked = !1);
        var a = 0 - .05 * (this.game.input.x - 320)
          , b = 0 - .05 * (this.game.input.y - 240);
        this.background.x = .15 * a + .85 * this.background.x,
        this.background.y = .15 * b + .85 * this.background.y
    },
    startGame: function(a) {}
},
ParkingFury.BlankState = function(a) {}
,
ParkingFury.BlankState.prototype = {
    create: function() {
        this.game.world.scale.set(1),
        this.state.start("Game", !0, !1)
    }
},
ParkingFury.Game = function(a) {
    this.gamePaused = !1,
    this.pressTimer = 0,
    this.asphalt,
    this.spark,
    this.car,
    this.carSpeed,
    this.cursors,
    this.wasd,
    this.worldScale = .8,
    this.globalGroup,
    this.globalBmp,
    this.globalBmpImage,
    this.carIndex = 0,
    this.cars = [],
    this.parkZone = null,
    this.parkZones = [],
    this.parkZonesPositions = [],
    this.parkPolys = [],
    this.missions = [],
    this.contactsCount = 0,
    this.missionMessage = !1,
    this.stars = 6,
    this.hitTimer = 0,
    this.gui,
    this.gui_stars,
    this.gui_star_1,
    this.gui_star_2,
    this.gui_star_3,
    this.gui_complete,
    this.gui_complete_check,
    this.gui_complete_fail,
    this.text_complete,
    this.check_fail_rect,
    this.check_fail_inProgress = !1,
    this.gui_pause,
    this.gui_pause_btn,
    this.up_bmp,
    this.up_bmp_image,
    this.levelFinished,
    this.gui_wheel,
    this.gui_gas,
    this.gui_brake,
    this.gui_gas_pressed = !1,
    this.gui_brake_pressed = !1,
    this.gui_wheel_pressed = !1,
    this.wheel_left = !1,
    this.wheel_right = !1,
    this.wheelPointer = null,
    this.wheelTouchPosition = null,
    this.music_engine_played = !1,
    this.temp_textures = []
}
,
ParkingFury.Game.prototype = {
    create: function() {
        this.game.world.scale.set(1),
        this.game.time.desiredFps = 60;
        var a = currentLevel;
        s_ingame.play(),
        this.gamePaused = !1,
        this.pressTimer = 0,
        this.carSpeed = 0,
        this.worldScale = .8,
        this.carIndex = 0,
        this.cars = [],
        this.parkZone = null,
        this.parkZones = [],
        this.parkZonesPositions = [],
        this.parkPolys = [],
        this.missions = [],
        this.contactsCount = 0,
        this.missionMessage = !1,
        this.stars = 6,
        this.hitTimer = 0,
        this.missionMessage = !1,
        this.check_fail_inProgress = !1,
        this.levelFinished = !1,
        this.music_engine_played = !1,
        this.game.time.advancedTiming = !0,
        this.game.world.setBounds(0, 0, 3e3, 3e3),
        this.game.physics.startSystem(Phaser.Physics.P2JS),
        this.asphalt = 1 == a || 2 == a || 3 == a || 5 == a || 6 == a || 7 == a ? this.game.add.tileSprite(0, 0, 3e3, 3e3, "Bruk.png") : this.game.add.tileSprite(0, 0, 3e3, 3e3, "asphalt_1.jpg"),
        this.globalBmp = this.game.add.bitmapData(3e3, 3e3),
        this.globalBmpImage = this.globalBmp.addToWorld(),
        this.globalBmp.smoothed = !1,
        this.globalGroup = this.game.make.group(),
        this.cursors = this.game.input.keyboard.createCursorKeys(),
        this.wasd = {
            up: this.game.input.keyboard.addKey(Phaser.Keyboard.W),
            down: this.game.input.keyboard.addKey(Phaser.Keyboard.S),
            left: this.game.input.keyboard.addKey(Phaser.Keyboard.A),
            right: this.game.input.keyboard.addKey(Phaser.Keyboard.D)
        },
        this.prepare_render_textures(),
        this.load_json_level_decals(a),
        this.load_json_ground_layer(a),
        this.load_json_missions(a),
        this.load_json_level_physics(a),
        this.load_json_level_objects(a),
        this.game.camera.follow(this.car.camPoint, Phaser.Camera.FOLLOW_LOCKON, .1, .1),
        this.load_json_level_up(a),
        this.globalBmp.shadow(),
        this.spark = this.game.add.sprite(-300, -200, "spark"),
        this.spark.animations.add("blam"),
        this.spark.anchor.setTo(.5, .5),
        this.spark.animations.play("blam", 30, !1),
        this.gui = this.game.add.group(),
        this.game.stage.addChild(this.gui),
        this.gui_stars = this.game.make.group();
        this.gui_stars.create(0, 5, "gui_stars_bkg");
        if (this.gui_star_1 = this.gui_stars.create(32.9, 23.95, "star"),
        this.gui_star_1.anchor.setTo(.5, .5),
        this.gui_star_1.scale.setTo(.324, .324),
        this.gui_star_1.frame = 2,
        this.gui_star_2 = this.gui_stars.create(70.7, 23.95, "star"),
        this.gui_star_2.anchor.setTo(.5, .5),
        this.gui_star_2.scale.setTo(.324, .324),
        this.gui_star_2.frame = 2,
        this.gui_star_3 = this.gui_stars.create(107.75, 23.95, "star"),
        this.gui_star_3.anchor.setTo(.5, .5),
        this.gui_star_3.scale.setTo(.324, .324),
        this.gui_star_3.frame = 2,
        this.gui.addChild(this.gui_stars),
        mobile_browser) {
            this.gui_pause_btn = this.gui.create(640, 5);
            var c = this.game.add.sprite(0, 0, "gui_stars_bkg");
            this.gui_pause_btn.addChild(c),
            c.scale.setTo(-1, 1);
            var d = this.game.add.bitmapText(-110, 7, "myfont", "PAUSE", 22);
            this.gui_pause_btn.addChild(d),
            this.gui_pause_btn.inputEnabled = !0,
            this.gui_pause_btn.input.useHandCursor = !0,
            this.gui_pause_btn.events.onInputOver.add(this.over, this),
            this.gui_pause_btn.events.onInputOut.add(this.out, this),
            this.gui_pause_btn.events.onInputDown.add(this.pause_pressed, this)
        }
        this.gui_complete = this.game.make.group(),
        this.gui_complete.position.setTo(170, -240);
        this.gui_complete.create(-45, -45, "gui_mission_complete");
        this.gui_complete_check = this.gui_complete.create(-22, -38, "check"),
        this.gui_complete_fail = this.gui_complete.create(-33, -38, "fail"),
        this.text_complete = this.game.add.bitmapText(190, 5, "myfont", "MISSION COMPLETE!", 22),
        this.text_complete.anchor.setTo(.5, .5),
        this.gui_complete.addChild(this.text_complete),
        this.check_fail_rect = new Phaser.Rectangle(0,0,0,74),
        this.gui_complete_check.crop(this.check_fail_rect),
        this.gui_complete_fail.crop(this.check_fail_rect),
        this.gui.addChild(this.gui_complete),
        this.gui_pause = this.game.make.group(),
        this.gui_pause.position.setTo(320, -240);
        var g = (this.gui_pause.create(-195, -45, "gui_mission_complete"),
        this.gui_pause.create(-80, 50, "btn_home"));
        g.inputEnabled = !0,
        g.input.useHandCursor = !0,
        g.events.onInputOver.add(this.over, this),
        g.events.onInputOut.add(this.out, this),
        g.events.onInputDown.add(this.home_pressed, this);
        var h = this.gui_pause.create(40, 50, "btn_restart");
        h.inputEnabled = !0,
        h.input.useHandCursor = !0,
        h.events.onInputOver.add(this.over, this),
        h.events.onInputOut.add(this.out, this),
        h.events.onInputDown.add(this.restart_pressed, this);
        var i = this.game.add.bitmapText(40, 5, "myfont", "GAME PAUSED", 22);
        if (i.anchor.setTo(.5, .5),
        this.gui_pause.addChild(i),
        this.gui.addChild(this.gui_pause),
        mobile_browser) {
            this.gui_wheel = this.gui.create(95, 390),
            this.gui_wheel.anchor.setTo(.5, .5),
            this.gui_wheel.alpha = .9,
            this.gui_wheel.inputEnabled = !0,
            this.gui_wheel.input.useHandCursor = !0,
            this.gui_wheel.events.onInputDown.add(this.wheel_down, this),
            this.gui_wheel.events.onInputOut.add(this.wheel_up, this),
            this.gui_wheel.events.onInputUp.add(this.wheel_up, this),
            this.gui_wheel.hitArea = new Phaser.Rectangle(-110,-110,220,220);
            var j = this.game.add.sprite(0, 0, "gui_wheel");
            j.anchor.setTo(.5, .5),
            this.gui_wheel.addChild(j),
            this.gui_wheel.label = j,
            this.gui_gas = this.gui.create(590, 400),
            this.gui_gas.anchor.setTo(.5, .5),
            this.gui_gas.alpha = .9,
            this.gui_gas.inputEnabled = !0,
            this.gui_gas.input.useHandCursor = !0,
            this.gui_gas.events.onInputDown.add(this.gas_down, this),
            this.gui_gas.events.onInputOut.add(this.gas_up, this),
            this.gui_gas.events.onInputUp.add(this.gas_up, this),
            this.gui_gas.hitArea = new Phaser.Rectangle(-45,-80,90,160);
            var k = this.game.add.sprite(0, 0, "gui_pedal_gas");
            k.anchor.setTo(.5, .5),
            this.gui_gas.addChild(k),
            this.gui_gas.label = k,
            this.gui_brake = this.gui.create(495, 428),
            this.gui_brake.anchor.setTo(.5, .5),
            this.gui_brake.alpha = .9,
            this.gui_brake.inputEnabled = !0,
            this.gui_brake.input.useHandCursor = !0,
            this.gui_brake.events.onInputDown.add(this.brake_down, this),
            this.gui_brake.events.onInputOut.add(this.brake_up, this),
            this.gui_brake.events.onInputUp.add(this.brake_up, this),
            this.gui_brake.hitArea = new Phaser.Rectangle(-45,-55,90,110);
            var l = this.game.add.sprite(0, 0, "gui_pedal_brake");
            l.anchor.setTo(.5, .5),
            this.gui_brake.addChild(l),
            this.gui_brake.label = l
        }
        this.game.world.scale.set(this.worldScale),
        this.blinkFlares()
    },
    gas_down: function(a, b) {
        this.gui_gas_pressed = !0,
        a.label.scale.setTo(.94, .94)
    },
    gas_up: function(a, b) {
        this.gui_gas_pressed = !1,
        a.label.scale.setTo(1, 1)
    },
    brake_down: function(a, b) {
        this.gui_brake_pressed = !0,
        a.label.scale.setTo(.94, .94)
    },
    brake_up: function(a, b) {
        this.gui_brake_pressed = !1,
        a.label.scale.setTo(1, 1)
    },
    wheel_down: function(a, b) {
        this.gui_wheel_pressed = !0,
        this.wheelPointer = b,
        this.wheelTouchPosition = new Phaser.Point(b.x,b.y)
    },
    wheel_up: function(a, b) {
        this.gui_wheel_pressed = !1,
        this.wheelPointer = null,
        this.wheelTouchPosition = null
    },
    over: function(a, b) {
        a.scale.x = 1.05,
        a.scale.y = 1.05
    },
    out: function(a, b) {
        a.scale.x = 1,
        a.scale.y = 1
    },
    home_pressed: function(a, b) {
        this.missionMessage = !0,
        this.game.state.start("MainMenu", !0, !1)
    },
    restart_pressed: function(a, b) {
        // parent.cmgGameEvent && parent.cmgGameEvent("replay", "" + (currentLevel + 1)),
        this.missionMessage = !0,
        this.game.state.start("BlankState", !0, !1)
    },
    pause_pressed: function(a, b) {
        this.pause_ON_OFF()
    },
    shutdown: function() {
        s_ingame.stop(),
        this.up_bmp.destroy(),
        this.up_bmp_image.destroy(),
        this.up_bmp = null,
        this.up_bmp_image = null,
        this.gui.removeChild(this.gui_stars),
        this.gui.removeChild(this.gui_complete),
        this.gui.removeChild(this.gui_pause),
        this.game.stage.removeChild(this.gui),
        this.gui_stars.destroy(),
        this.gui_stars = null,
        this.gui_complete.destroy(),
        this.gui_complete = null,
        this.gui_pause.destroy(),
        this.gui_pause = null,
        mobile_browser && (this.gui.removeChild(this.gui_wheel),
        this.gui.removeChild(this.gui_gas),
        this.gui.removeChild(this.gui_brake),
        this.gui_wheel.destroy(),
        this.gui_wheel = null,
        this.gui_gas.destroy(),
        this.gui_gas = null,
        this.gui_brake.destroy(),
        this.gui_brake = null),
        this.gui.destroy(),
        this.gui = null,
        this.asphalt.destroy(),
        this.asphalt = null,
        this.spark.destroy(),
        this.spark = null,
        this.globalGroup.destroy(),
        this.globalBmp.destroy(),
        this.globalBmpImage.destroy(),
        this.globalGroup = null,
        this.globalBmp = null,
        this.globalBmpImage = null,
        this.cars[0].destroy(),
        this.cars = null,
        this.parkZone = null,
        this.parkZones = null,
        this.parkZonesPositions = null,
        this.parkPolys = null,
        this.missions = null,
        this.car.destroy(),
        this.car = null
    },
    gui_show_mission_complete: function() {
        this.gui_complete_check.visible = !0,
        this.gui_complete_fail.visible = !1,
        this.levelFinished ? this.text_complete.text = "LEVEL CLEARED!" : this.text_complete.text = "MISSION COMPLETE!",
        this.gui_complete.y = -240;
        var a = this.game.add.tween(this.gui_complete).to({
            y: 240
        }, 200, "Linear", !1);
        a.to({
            y: 720
        }, 300, "Linear", !1, 1200),
        a.onComplete.add(this.mission_message_disabled, this),
        a.start(),
        this.check_fail_rect.width = 0,
        this.check_fail_rect.height = 74;
        var b = this.game.add.tween(this.check_fail_rect).to({
            width: 86
        }, 150, "Linear", !1);
        b.delay(400),
        b.onComplete.add(this.gui_check_fail_tween_complete, this),
        b.onStart.add(this.gui_check_fail_tween_start, this),
        b.start(),
        this.check_fail_inProgress = !0,
        this.missionMessage = !0
    },
    gui_show_failed: function() {
        this.gui_complete_check.visible = !1,
        this.gui_complete_fail.visible = !0,
        this.text_complete.text = "LEVEL FAILED :(",
        this.gui_complete.y = -240;
        var a = this.game.add.tween(this.gui_complete).to({
            y: 240
        }, 200, "Linear", !1);
        a.to({
            y: 720
        }, 300, "Linear", !1, 1200),
        a.onComplete.add(this.mission_message_disabled, this),
        a.start(),
        this.check_fail_rect.width = 0,
        this.check_fail_rect.height = 77;
        var b = this.game.add.tween(this.check_fail_rect).to({
            width: 67
        }, 150, "Linear", !1);
        b.delay(400),
        b.onComplete.add(this.gui_check_fail_tween_complete, this),
        b.onStart.add(this.gui_check_fail_tween_start, this),
        b.start(),
        this.check_fail_inProgress = !0,
        this.missionMessage = !0
    },
    gui_check_fail_tween_start: function() {
        s_check.play()
    },
    gui_check_fail_tween_complete: function() {
        this.check_fail_inProgress = !1
    },
    mission_message_disabled: function() {
        0 == this.stars ? (this.game.state.start("BlankState", !0, !1)) : this.levelFinished ? (currentStars = this.stars,
        this.game.state.start("MainMenu", !0, !1, "result")) : (this.missionMessage = !1,
        this.missions[this.carIndex - 1].visible = !1,
        this.missions[this.carIndex].visible = !0,
        this.game.camera.follow(this.car.camPoint, Phaser.Camera.FOLLOW_LOCKON, .1, .1),
        this.blinkFlares())
    },
    prepare_render_textures: function() {
        render_textures_created || (this.make_texture("map_part_plitka_1.json", "map_part_plitka_1"),
        this.make_texture("map_part_plitka_2.json", "map_part_plitka_2"),
        this.make_texture("map_part_plitka_3.json", "map_part_plitka_3"),
        this.make_texture("map_part_trava_1.json", "map_part_trava_1"),
        this.make_texture("map_part_trava_2.json", "map_part_trava_2"),
        this.make_texture("map_part_trava_3.json", "map_part_trava_3"),
        render_textures_created = !0)
    },
    make_texture: function(a, b) {
        var c = this.game.cache.getJSON(a)
          , d = this.game.make.group()
          , e = this.game.make.tileSprite(c.base_sprite.x, c.base_sprite.y, c.base_sprite.w, c.base_sprite.h, c.base_sprite.texture);
        d.addChild(e);
        var f = this.game.add.graphics(1500, 1500);
        f.beginFill(16777215);
        for (i in c.shape_points)
            0 == i ? f.moveTo(c.shape_points[i][0] + c.base_sprite.fixX, c.shape_points[i][1] + c.base_sprite.fixY) : f.lineTo(c.shape_points[i][0] + c.base_sprite.fixX, c.shape_points[i][1] + c.base_sprite.fixY);
        f.endFill(),
        e.mask = f;
        for (i in c.bordurs) {
            var g = d.create(c.bordurs[i].x, c.bordurs[i].y, c.bordurs[i].name);
            g.angle = c.bordurs[i].rotation,
            g.scale.setTo(c.bordurs[i].scaleX, c.bordurs[i].scaleY)
        }
        var h = d.generateTexture();
        this.game.world.remove(d, !0),
        d = null,
        this.game.world.remove(f, !0),
        f = null,
        this.game.cache.addImage(b, null, h.getCanvas()),
        h = null,
        c = null
    },
    load_json_missions: function(a) {
        var b = this.game.cache.getJSON("level_" + a + "_missions");
        for (i in b.frames) {
            var c = this.game.add.group();
            for (ii in b.frames[i].objects) {
                var d = c.create(b.frames[i].objects[ii].x, b.frames[i].objects[ii].y, b.frames[i].objects[ii].name);
                d.angle = b.frames[i].objects[ii].rotation,
                d.scale.setTo(b.frames[i].objects[ii].scaleX, b.frames[i].objects[ii].scaleY)
            }
            this.missions[i] = c,
            c.visible = !1
        }
        this.missions[0].visible = !0,
        b = null
    },
    load_json_level_objects: function(a) {
        var b = this.game.cache.getJSON("level_" + a)
          , c = this.game.make.group();
        for (i in b.objects) {
            var d = c.create(b.objects[i].x, b.objects[i].y, b.objects[i].name);
            d.angle = b.objects[i].rotation,
            d.scale.setTo(b.objects[i].scaleX, b.objects[i].scaleY)
        }
        this.globalBmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1),
        this.game.stage.updateTransform(),
        this.globalBmp.drawGroup(c),
        this.globalBmp.shadow(),
        d = null,
        this.game.world.remove(c, !0),
        c.destroy(),
        c = null,
        b = null
    },
    load_json_ground_layer: function(a) {
        for (var b = this.game.cache.getJSON("level_" + a + "_ground"), c = this.game.make.group(), d = 0; d < b.ground_objects.length; d++)
            if ("bitmap" == b.ground_objects[d].type) {
                var e = c.create(b.ground_objects[d].x, b.ground_objects[d].y, b.ground_objects[d].name);
                e.angle = b.ground_objects[d].rotation,
                e.scale.setTo(b.ground_objects[d].scaleX, b.ground_objects[d].scaleY),
                e.anchor.setTo(.5, .5),
                e = null
            } else {
                var f = this.game.make.group()
                  , g = this.game.add.tileSprite(b.ground_objects[d].x, b.ground_objects[d].y, b.ground_objects[d].w, b.ground_objects[d].h, b.ground_objects[d].texture);
                f.addChild(g);
                var h = this.game.add.graphics(0, 0);
                h.beginFill(16777215);
                for (ii in b.ground_objects[d].points)
                    0 == ii ? h.moveTo(b.ground_objects[d].points[ii][0] - b.ground_objects[d].x, b.ground_objects[d].points[ii][1] - b.ground_objects[d].y) : h.lineTo(b.ground_objects[d].points[ii][0] - b.ground_objects[d].x, b.ground_objects[d].points[ii][1] - b.ground_objects[d].y);
                h.endFill(),
                g.mask = h;
                var i = f.generateTexture();
                this.game.world.remove(h, !0),
                h.destroy(),
                h = null,
                this.game.world.remove(g, !0),
                g.destroy(),
                g = null,
                this.game.world.remove(f, !0),
                f.destroy(),
                f = null,
                c.create(b.ground_objects[d].x, b.ground_objects[d].y, i),
                this.temp_textures.push(i)
            }
        if (mobile_browser)
            this.globalBmp.shadow(),
            this.game.stage.updateTransform(),
            this.globalBmp.drawGroup(c),
            this.globalBmp.shadow(),
            this.game.world.remove(c, !0),
            c.destroy(),
            c = null;
        else {
            var j = this.game.add.bitmapData(3e3, 3e3)
              , k = j.addToWorld();
            this.game.stage.updateTransform(),
            j.smoothed = !1,
            j.drawGroup(c),
            this.game.world.remove(c, !0),
            c.destroy(),
            c = null,
            this.globalBmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1),
            this.game.stage.updateTransform(),
            this.globalBmp.draw(k),
            this.globalBmp.shadow(),
            this.game.world.remove(k, !0),
            k.destroy(),
            j.destroy(),
            k = null,
            j = null
        }
        for (; this.temp_textures.length > 0; ) {
            var l = this.temp_textures.pop();
            l.destroy(!0),
            l = null
        }
        this.temp_textures = [],
        b = null
    },
    load_json_level_decals: function(a) {
        var b = this.game.cache.getJSON("level_" + a + "_decals")
          , c = this.game.make.group();
        for (i in b.shapes) {
            var d = this.game.make.group()
              , e = this.game.add.tileSprite(b.shapes[i].x, b.shapes[i].y, b.shapes[i].w, b.shapes[i].h, b.shapes[i].texture);
            d.addChild(e);
            var f = this.game.add.graphics(0, 0);
            f.beginFill(16777215);
            for (ii in b.shapes[i].points)
                0 == ii ? f.moveTo(b.shapes[i].points[ii][0] - b.shapes[i].x, b.shapes[i].points[ii][1] - b.shapes[i].y) : f.lineTo(b.shapes[i].points[ii][0] - b.shapes[i].x, b.shapes[i].points[ii][1] - b.shapes[i].y);
            f.endFill(),
            e.mask = f;
            var g = d.generateTexture();
            this.game.world.remove(f, !0),
            f.destroy(),
            f = null,
            this.game.world.remove(e, !0),
            e.destroy(),
            e = null,
            this.game.world.remove(d, !0),
            d.destroy(),
            d = null;
            var h = c.create(b.shapes[i].x, b.shapes[i].y, g)
        }
        for (i in b.decals) {
            var h = c.create(b.decals[i].x, b.decals[i].y, b.decals[i].name);
            h.scale.setTo(b.decals[i].scaleX, b.decals[i].scaleY),
            h.angle = b.decals[i].rotation
        }
        this.globalBmp.shadow(),
        this.game.stage.updateTransform(),
        this.globalBmp.drawGroup(c),
        this.game.world.remove(c),
        c.destroy(),
        c = null,
        b = null
    },
    load_json_level_up: function(a) {
        var b = this.game.cache.getJSON("level_" + a)
          , c = this.game.make.group();
        for (i in b.up) {
            c.create(b.up[i].x, b.up[i].y, b.up[i].name).angle = b.up[i].rotation
        }
        mobile_browser || (this.globalBmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1),
        this.game.stage.updateTransform(),
        this.globalBmp.drawGroup(c),
        this.globalBmp.shadow()),
        this.up_bmp = this.game.add.bitmapData(3e3, 3e3),
        this.up_bmp_image = this.up_bmp.addToWorld(),
        this.up_bmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1),
        this.game.stage.updateTransform(),
        this.up_bmp.smoothed = !1,
        this.up_bmp.drawGroup(c),
        this.up_bmp.shadow(),
        this.game.world.remove(c),
        c.destroy(!0),
        c = null,
        b = null
    },
    load_json_level_physics: function(a) {
        var b = !1
          , c = this.game.cache.getJSON("level_" + a + "_phys");
        for (i in c.boxes) {
            var d = this.game.add.sprite(c.boxes[i].x, c.boxes[i].y);
            this.game.physics.p2.enable(d, b),
            d.body.clearShapes(),
            d.body.addRectangle(c.boxes[i].scaleX, c.boxes[i].scaleY, 0, 0, 0),
            d.body.static = !0,
            d.body.angle = c.boxes[i].rotation
        }
        for (i in c.circles) {
            var e = this.game.add.sprite(c.circles[i].x, c.circles[i].y);
            this.game.physics.p2.enable(e, b),
            e.body.clearShapes(),
            e.body.addCircle(c.circles[i].radius, 0, 0, 0),
            e.body.static = !0
        }
        this.parkZone = this.game.add.sprite(100, 0),
        this.game.physics.p2.enable(this.parkZone, b),
        this.parkZone.body.clearShapes(),
        this.parkZone.body.addRectangle(110, 230, 0, 0, 0).sensor = !0,
        this.parkZone.body.static = !0,
        this.parkZone.body.angle = 0;
        for (i in c.park) {
            var g = new Object;
            g.x = c.park[i].x,
            g.y = c.park[i].y,
            g.angle = c.park[i].rotation,
            this.parkZonesPositions[c.park[i].order - 1] = g;
            var h = new Phaser.Polygon([c.park[i].points[0], c.park[i].points[1], c.park[i].points[2], c.park[i].points[3]]);
            this.parkPolys[c.park[i].order - 1] = h
        }
        this.parkZone.body.x = this.parkZonesPositions[0].x,
        this.parkZone.body.y = this.parkZonesPositions[0].y,
        this.parkZone.body.angle = this.parkZonesPositions[0].angle;
        for (i in c.cars)
            this.load_json_car(c.cars[i].x, c.cars[i].y, c.cars[i].rotation, c.cars[i].order, c.cars[i].type);
        this.car = this.cars[0],
        this.car.body.mass = 1,
        this.car.body.onBeginContact.add(this.carOnContact, this),
        this.car.body.onEndContact.add(this.carOnEndContact, this),
        c = null
    },
    load_json_car: function(a, b, c, d, e) {
        var g, f = this.game.cache.getJSON("car_" + e);
        g = this.game.add.sprite(a, b),
        this.game.physics.p2.enable(g, !1);
        var h = this.game.make.sprite(f.wheels.wheel_l_x, f.wheels.wheel_l_y, "car_wheel")
          , j = this.game.make.sprite(f.wheels.wheel_r_x, f.wheels.wheel_r_y, "car_wheel");
        h.anchor.setTo(.5, .5),
        j.anchor.setTo(.5, .5),
        g.addChild(h),
        g.addChild(j),
        g.wheel_l = h,
        g.wheel_r = j;
        var k = this.game.make.sprite(f.shadow.x, f.shadow.y, "car_shadow");
        k.scale.setTo(f.shadow.scaleX, f.shadow.scaleY),
        g.addChild(k);
        var l = this.game.make.sprite(f.car_image.x, f.car_image.y, f.car_image.image);
        l.anchor.setTo(1, 0),
        l.angle = -90,
        1 != e && 2 != e || l.scale.setTo(.92, .92),
        g.addChild(l),
        g.body.clearShapes();
        for (i in f.boxes)
            g.body.addRectangle(f.boxes[i].scaleX, f.boxes[i].scaleY, f.boxes[i].x, f.boxes[i].y, 0);
        for (i in f.circles)
            g.body.addCircle(f.circles[i].radius, f.circles[i].x, f.circles[i].y, 0);
        g.body.angularDamping = .999,
        g.body.damping = .999,
        g.body.rotation = .017453292519 * c,
        g.body.mass = 30,
        this.cars[d - 1] = g;
        var m = this.game.make.sprite(f.cam_point.x, f.cam_point.y);
        g.addChild(m),
        g.camPoint = m;
        var n = this.game.make.sprite(f.hitpoints[0][0], f.hitpoints[0][1]);
        g.addChild(n);
        var o = this.game.make.sprite(f.hitpoints[1][0], f.hitpoints[1][1]);
        g.addChild(o);
        var p = this.game.make.sprite(f.hitpoints[2][0], f.hitpoints[2][1]);
        g.addChild(p);
        var q = this.game.make.sprite(f.hitpoints[3][0], f.hitpoints[3][1]);
        g.addChild(q),
        g.pPoints = [n, o, p, q],
        g.flares = [];
        for (i in f.flares) {
            var r = this.game.make.sprite(f.flares[i][0], f.flares[i][1], "flare");
            if (r.anchor.setTo(.5, .5),
            r.scale.setTo(.5, .5),
            r.blendMode = PIXI.blendModes.ADD,
            r.tint = 16737792,
            g.addChild(r),
            g.flares[i] = r,
            r.visible = !1,
            0 == i || 1 == i) {
                var s = this.game.make.sprite(f.flares[i][0], f.flares[i][1], "flare");
                s.anchor.setTo(.5, .5),
                s.scale.setTo(.5, .5),
                s.blendMode = PIXI.blendModes.ADD,
                s.tint = 16711680,
                g.addChild(s),
                0 == i ? g.flares[4] = s : g.flares[5] = s,
                s.visible = !1
            }
        }
        return f = null,
        g
    },
    blinkFlares: function() {
        for (var a = 0; a < 4; a++) {
            this.car.flares[a].tint = 16737792,
            this.car.flares[a].visible = !0,
            this.car.flares[a].alpha = 0;
            var b = this.game.add.tween(this.car.flares[a]).to({
                alpha: 1
            }, 300, "Linear", !1);
            b.to({
                alpha: 0
            }, 300, "Linear", !1, 0),
            b.to({
                alpha: 1
            }, 300, "Linear", !1, 0),
            b.to({
                alpha: 0
            }, 300, "Linear", !1, 0),
            b.start()
        }
    },
    changeCar: function() {
        this.carIndex += 1,
        this.carIndex == this.cars.length ? (this.carIndex -= 1,
        this.levelFinished = !0,
        this.gui_show_mission_complete()) : (this.gui_show_mission_complete(),
        this.car.body.mass = 30,
        this.car.body.onBeginContact.remove(this.carOnContact, this),
        this.car.body.onEndContact.remove(this.carOnEndContact, this),
        this.contactsCount = 0,
        this.car.flares[4].visible = !1,
        this.car.flares[5].visible = !1,
        this.car = this.cars[this.carIndex],
        this.car.body.onBeginContact.add(this.carOnContact, this),
        this.car.body.onEndContact.add(this.carOnEndContact, this),
        this.car.body.mass = 1,
        this.car.body.setZeroVelocity(),
        this.carSpeed = 0,
        this.parkZone.body.x = this.parkZonesPositions[this.carIndex].x,
        this.parkZone.body.y = this.parkZonesPositions[this.carIndex].y,
        this.parkZone.body.angle = this.parkZonesPositions[this.carIndex].angle)
    },
    carOnContact: function(a, b, c, d, e) {
        if (a) {
            if (a.data.shapes[0].sensor)
                this.contactsCount += 1;
            else if (this.hitTimer < 0) {
                if (this.hitTimer = 30,
                this.stars -= 1,
                s_hit.play(),
                e[0]) {
                    var f = e[0].bodyA.position
                      , g = e[0].contactPointA
                      , h = this.game.physics.p2.mpxi(f[0] + g[0])
                      , i = this.game.physics.p2.mpxi(f[1] + g[1]);
                    this.spark.x = h,
                    this.spark.y = i,
                    this.spark.animations.play("blam", 30, !1)
                }
                5 == this.stars && (this.gui_star_3.frame = 1,
                this.gui_star_3.scale.setTo(0, 0),
                this.game.add.tween(this.gui_star_3.scale).to({
                    x: .324,
                    y: .324
                }, 500, Phaser.Easing.Elastic.Out, !0)),
                4 == this.stars && (this.gui_star_3.frame = 0,
                this.gui_star_3.scale.setTo(0, 0),
                this.game.add.tween(this.gui_star_3.scale).to({
                    x: .324,
                    y: .324
                }, 500, Phaser.Easing.Elastic.Out, !0)),
                3 == this.stars && (this.gui_star_2.frame = 1,
                this.gui_star_2.scale.setTo(0, 0),
                this.game.add.tween(this.gui_star_2.scale).to({
                    x: .324,
                    y: .324
                }, 500, Phaser.Easing.Elastic.Out, !0)),
                2 == this.stars && (this.gui_star_2.frame = 0,
                this.gui_star_2.scale.setTo(0, 0),
                this.game.add.tween(this.gui_star_2.scale).to({
                    x: .324,
                    y: .324
                }, 500, Phaser.Easing.Elastic.Out, !0)),
                1 == this.stars && (this.gui_star_1.frame = 1,
                this.gui_star_1.scale.setTo(0, 0),
                this.game.add.tween(this.gui_star_1.scale).to({
                    x: .324,
                    y: .324
                }, 500, Phaser.Easing.Elastic.Out, !0)),
                0 == this.stars && (this.gui_star_1.frame = 0,
                this.gui_star_1.scale.setTo(0, 0),
                this.game.add.tween(this.gui_star_1.scale).to({
                    x: .324,
                    y: .324
                }, 500, Phaser.Easing.Elastic.Out, !0),
                this.gui_show_failed())
            }
        } else
            console.log("You last hit: The wall :)")
    },
    carOnEndContact: function(a, b, c, d, e) {
        this.missionMessage || a && a.data.shapes[0].sensor && (this.contactsCount -= 1,
        this.contactsCount < 0 && (this.contactsCount = 0))
    },
    pause_ON_OFF: function() {
        if (!this.missionMessage && !this.levelFinished) {
            if (this.gamePaused = !this.gamePaused,
            this.gamePaused) {
                this.gui_pause.y = -240;
                var a = this.game.add.tween(this.gui_pause).to({
                    y: 140
                }, 150, "Linear", !1);
                a.start()
            }
            if (!this.gamePaused) {
                var a = this.game.add.tween(this.gui_pause).to({
                    y: 740
                }, 200, "Linear", !1);
                a.start()
            }
        }
    },
    update: function() {
        if (this.pressTimer -= 1,
        (this.game.input.keyboard.isDown(Phaser.Keyboard.P) || this.game.input.keyboard.isDown(Phaser.Keyboard.ESC)) && this.pressTimer < 0 && (this.pressTimer = 20,
        this.pause_ON_OFF()),
        !this.gamePaused) {
            this.check_fail_inProgress && (this.gui_complete_check.updateCrop(),
            this.gui_complete_fail.updateCrop()),
            this.hitTimer -= 1;
            for (var a = 0; a < 6; a++)
                this.car.flares[a].rotation = 0 - this.car.body.rotation;
            if (this.contactsCount > 0 && !this.missionMessage && this.carSpeed > -.4 && this.carSpeed < .4) {
                for (var b = 0, a = 0; a < 4; a++)
                    this.parkPolys[this.carIndex].contains(this.car.pPoints[a].world.x * (1 / this.worldScale), this.car.pPoints[a].world.y * (1 / this.worldScale)) && (b += 1);
                4 == b && this.changeCar()
            }
            if (this.car.body.setZeroVelocity(),
            this.gui_wheel_pressed)
                if (this.wheelPointer) {
                    var c = this.gui_wheel.label.angle
                      , d = this.wheelPointer.x - this.wheelTouchPosition.x
                      , e = this.wheelPointer.y - this.wheelTouchPosition.y;
                    this.wheelTouchPosition.x < this.gui_wheel.x && (e = -e),
                    this.wheelTouchPosition.y > this.gui_wheel.y && (d = -d);
                    var f = (d + e) / 2;
                    this.gui_wheel.label.angle = f + c,
                    this.gui_wheel.label.angle > 90 && (this.gui_wheel.label.angle = 90),
                    this.gui_wheel.label.angle < -90 && (this.gui_wheel.label.angle = -90),
                    this.wheelTouchPosition.x = this.wheelPointer.x,
                    this.wheelTouchPosition.y = this.wheelPointer.y
                } else
                    this.wheel_right = !1,
                    this.wheel_left = !1,
                    console.log("wheel pressed but pointer == null");
            else
                mobile_browser && (this.gui_wheel.label.angle *= .92,
                this.gui_wheel.label.angle <= 2 && this.gui_wheel.label.angle >= -2 && (this.gui_wheel.label.angle = 0));
            mobile_browser ? (this.car.wheel_l.angle = .44 * this.gui_wheel.label.angle,
            this.car.wheel_r.angle = this.car.wheel_l.angle) : this.cursors.left.isDown && !this.missionMessage || this.wasd.left.isDown && !this.missionMessage || this.wheel_left && !this.missionMessage ? this.car.wheel_l.angle > -40 && (this.car.wheel_l.angle = this.car.wheel_r.angle -= 2) : this.cursors.right.isDown && !this.missionMessage || this.wasd.right.isDown && !this.missionMessage || this.wheel_right && !this.missionMessage ? this.car.wheel_l.angle < 40 && (this.car.wheel_l.angle = this.car.wheel_r.angle += 2) : (this.car.wheel_l.angle *= .92,
            this.car.wheel_l.angle <= 3 && this.car.wheel_l.angle >= -3 && (this.car.wheel_l.angle = 0),
            this.car.wheel_r.angle = this.car.wheel_l.angle),
            this.cursors.up.isDown && !this.missionMessage || this.gui_gas_pressed && !this.missionMessage || this.wasd.up.isDown && !this.missionMessage ? (this.music_engine_played || (this.music_engine_played = !0,
            s_engine.play()),
            this.carSpeed += this.carSpeed < 4 ? .08 : 0) : this.cursors.down.isDown && !this.missionMessage || this.gui_brake_pressed && !this.missionMessage || this.wasd.down.isDown && !this.missionMessage ? (this.music_engine_played || (this.music_engine_played = !0,
            s_engine.play()),
            this.carSpeed += this.carSpeed > -2.8 ? this.carSpeed > .3 ? -.3 : -.1 : 0,
            this.car.flares[4].visible = !0,
            this.car.flares[5].visible = !0) : (this.music_engine_played = !1,
            this.carSpeed <= -.1 && (this.carSpeed += .1),
            this.carSpeed >= .1 && (this.carSpeed -= .1),
            this.carSpeed > -.1 && this.carSpeed < .1 && (this.carSpeed = 0),
            this.missionMessage || (this.car.flares[4].visible = !1,
            this.car.flares[5].visible = !1)),
            this.car.body.rotation += this.car.wheel_l.angle * this.carSpeed / this.car.wheel_l.x * .017453292519;
            var g = 0;
            g = this.car.body.rotation + this.car.wheel_l.rotation;
            var h = this.carSpeed * Math.cos(g)
              , i = this.carSpeed * Math.sin(g)
              , j = new Phaser.Point(h,i)
              , k = new Phaser.Point;
            k.x = 1,
            k.y = 0;
            var l = Math.cos(this.car.body.rotation)
              , m = Math.sin(this.car.body.rotation);
            k = new Phaser.Point(l * k.x - m * k.y,m * k.x + l * k.y);
            var n = k.dot(j);
            j.x = k.x * n,
            j.y = k.y * n,
            this.car.body.applyImpulse([-3 * j.x, -3 * j.y], 0, 0)
        }
    }
};
