var PoolClub;
(function (PoolClub) {
    class AudioManager {
        static init(game) {
            AudioManager.game = game;
            AudioManager.loopPlayingKey = null;
            AudioManager.audioSprite = AudioManager.game.add.audioSprite("audio-sprite");
            AudioManager.setMusicMuted(PoolClub.GameVars.gameData.musicMuted);
            AudioManager.setEffectsMuted(PoolClub.GameVars.gameData.effectsMuted);
            AudioManager.ballHitEffectPlayedTime = AudioManager.game.time.time;
            AudioManager.cushionHitEffectPlayedTime = AudioManager.game.time.time;
            AudioManager.pocketHitEffectPlayedTime = AudioManager.game.time.time;
            AudioManager.runningTime = false;
            AudioManager.musicWasMutedBefore = AudioManager.isMusicMuted;
            AudioManager.effectsWereMutedBefore = AudioManager.isEffectsMuted;
        }
        static get isMusicMuted() {
            return AudioManager._isMusicMuted;
        }
        static setMusicMuted(value, writeToGameData = true) {
            AudioManager._isMusicMuted = value;
            if (AudioManager._isMusicMuted && AudioManager.loopPlayingKey) {
                AudioManager.audioSprite.stop(AudioManager.loopPlayingKey);
            }
            else if (!AudioManager._isMusicMuted && AudioManager.loopPlayingKey) {
                AudioManager.audioSprite.play(AudioManager.loopPlayingKey);
            }
            if (writeToGameData) {
                PoolClub.GameVars.gameData.musicMuted = AudioManager._isMusicMuted;
                PoolClub.GameManager.writeGameData();
            }
        }
        static get isEffectsMuted() {
            return AudioManager._isEffectsMuted;
        }
        static setEffectsMuted(value, writeToGameData = true) {
            AudioManager._isEffectsMuted = value;
            if (writeToGameData) {
                PoolClub.GameVars.gameData.effectsMuted = AudioManager._isEffectsMuted;
                PoolClub.GameManager.writeGameData();
            }
        }
        static playEffect(key, volume) {
            if (key === null || typeof key === "undefined") {
                return;
            }
            if (AudioManager._isEffectsMuted) {
                return;
            }
            if (key === AudioManager.TIME_RUNNING_OUT) {
                if (AudioManager.runningTime) {
                    return;
                }
                else {
                    AudioManager.runningTime = true;
                }
            }
            let omitEffect = false;
            if (key === AudioManager.BALL_HIT) {
                if (AudioManager.game.time.time - AudioManager.ballHitEffectPlayedTime < AudioManager.MIN_TIME) {
                    omitEffect = true;
                }
                else {
                    AudioManager.ballHitEffectPlayedTime = AudioManager.game.time.time;
                }
            }
            else if (key === AudioManager.CUSHION_HIT) {
                if (AudioManager.game.time.time - AudioManager.cushionHitEffectPlayedTime < AudioManager.MIN_TIME) {
                    omitEffect = true;
                }
                else {
                    AudioManager.cushionHitEffectPlayedTime = AudioManager.game.time.time;
                }
            }
            else if (key === AudioManager.POCKET) {
                if (AudioManager.game.time.time - AudioManager.pocketHitEffectPlayedTime < AudioManager.MIN_TIME) {
                    omitEffect = true;
                }
                else {
                    AudioManager.pocketHitEffectPlayedTime = AudioManager.game.time.time;
                }
            }
            if (!omitEffect) {
                AudioManager.audioSprite.play(key, volume);
            }
        }
        static stopEffect(key, fade) {
            if (key === null || typeof key === "undefined") {
                return;
            }
            if (key === AudioManager.TIME_RUNNING_OUT) {
                AudioManager.runningTime = false;
            }
            if (fade) {
                const sound = AudioManager.audioSprite.get(key);
                sound.fadeOut(850);
            }
            else {
                AudioManager.audioSprite.stop(key);
            }
        }
        static playMusic(key, loop, volume) {
            if (this._isMusicMuted) {
                if (loop) {
                    AudioManager.loopPlayingKey = key;
                }
                return;
            }
            loop = loop || false;
            if (key !== this.loopPlayingKey) {
                AudioManager.audioSprite.play(key, volume);
            }
            if (loop) {
                if (AudioManager.loopPlayingKey && (AudioManager.loopPlayingKey !== key)) {
                    AudioManager.stopMusic(AudioManager.loopPlayingKey, true, true);
                }
                AudioManager.loopPlayingKey = key;
            }
        }
        static stopMusic(key, fade, loop) {
            if (key === null || typeof key === "undefined") {
                return;
            }
            if (fade) {
                const sound = this.audioSprite.get(key);
                sound.fadeOut(850);
            }
            else {
                AudioManager.audioSprite.stop(key);
            }
            if (loop) {
                AudioManager.loopPlayingKey = null;
            }
        }
        static temporaryMute() {
            AudioManager.musicWasMutedBefore = AudioManager.isMusicMuted;
            AudioManager.effectsWereMutedBefore = AudioManager.isEffectsMuted;
            AudioManager.setEffectsMuted(true, false);
            AudioManager.setMusicMuted(true, false);
        }
        static temporaryUnmute() {
            if (AudioManager.effectsWereMutedBefore === undefined || !AudioManager.musicWasMutedBefore === undefined) {
                return;
            }
            AudioManager.setEffectsMuted(AudioManager.effectsWereMutedBefore, false);
            AudioManager.setMusicMuted(AudioManager.musicWasMutedBefore, false);
        }
    }
    AudioManager.BALL_HIT = "ball_hit";
    AudioManager.POCKET = "pocket";
    AudioManager.CUSHION_HIT = "cushion_hit";
    AudioManager.LOSE_POINTS = "lose_points";
    AudioManager.CUE_HIT = "cue_hit";
    AudioManager.ADD_TIME = "add_time";
    AudioManager.BTN_NORMAL = "click_btn";
    AudioManager.GIFT_CARD_SWISH = "gift_card_swish";
    AudioManager.GIFT_OPENS = "gift_opens";
    AudioManager.LOSE = "lose";
    AudioManager.WIN = "win";
    AudioManager.SOUNDTRACK = "soundtrack";
    AudioManager.INTRO_TITLE = "intro_title";
    AudioManager.TIME_RUNNING_OUT = null;
    AudioManager.COMBO = "combo";
    AudioManager.COMBO_2 = "combo2";
    AudioManager.MIN_TIME = 75;
    PoolClub.AudioManager = AudioManager;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class Game extends Phaser.Game {
        constructor() {
            let renderer;
            if (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i)) {
                renderer = Phaser.CANVAS;
            }
            else {
                renderer = Phaser.AUTO;
            }
            super(PoolClub.GameConstants.GAME_WIDTH, PoolClub.GameConstants.GAME_HEIGHT, renderer, "content", null, false, true);
            Game.currentInstance = this;
            this.state.add("Boot", PoolClub.Boot, true);
            this.state.add("PreLoader", PoolClub.PreLoader, false);
            this.state.add("SplashState", PoolClub.SplashState, false);
            this.state.add("PoolState", PoolClub.PoolState, false);
            this.state.start("Boot");
        }
    }
    PoolClub.Game = Game;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class GameConstants {
    }
    GameConstants.GAME_WIDTH = 1024;
    GameConstants.GAME_HEIGHT = 640;
    GameConstants.VERSION = "1.0.0";
    GameConstants.DEVELOPMENT = false;
    GameConstants.DEBUG = false;
    GameConstants.VERBOSE = false;
    GameConstants.SHOW_DEV_BUTTONS_ON_SOLO = false;
    GameConstants.SHOW_PVBOT_CHEAT_BUTTONS = false;
    GameConstants.LOG_SERVER_INFO = false;
    GameConstants.LOG_BOT_SERVER_INFO = false;
    GameConstants.ASSETS_PATH = "assets";
    GameConstants.TIME_SOLO_MATCH = 90;
    GameConstants.PHYS_SCALE = .01;
    GameConstants.BALL_RADIUS = 1400;
    GameConstants.FRICTION = 1;
    GameConstants.POCKET_RADIUS = 2300;
    GameConstants.MIN_VELOCITY = 2;
    GameConstants.CUSHION_RESTITUTION = .6;
    GameConstants.BALL_RESTITUTION = .91;
    GameConstants.BITMAP_SIZE = 64;
    GameConstants.BLACK_SQUARE = "black-square";
    GameConstants.BLUE_SQUARE = "blue_square";
    GameConstants.WHITE_SQUARE = "white-square";
    GameConstants.RED_SQUARE = "red-square";
    GameConstants.ORANGE_SQUARE = "orange-square";
    GameConstants.YELLOW_SQUARE = "yellow-square";
    GameConstants.GREEN_SQUARE = "green-square";
    GameConstants.GREY_SQUARE = "grey-square";
    GameConstants.DARK_BLUE_SQUARE = "dark-blue-square";
    GameConstants.BALL_TYPE_SOLID = "ball solid";
    GameConstants.BALL_TYPE_STRIPED = "ball striped";
    GameConstants.BALL_TYPE_BLACK = "ball black";
    GameConstants.BALL_TYPE_NONE = "ball none";
    GameConstants.LEFT = "left";
    GameConstants.RIGHT = "right";
    GameConstants.UP = "up";
    GameConstants.DOWN = "down";
    GameConstants.NO_GAME = "no_game";
    GameConstants.SOLO_MODE = "solo";
    GameConstants.PVP_MODE = "pvp";
    GameConstants.PVBOT_MODE = "pvbot";
    GameConstants.NOTIFICATION_NONE = "notification none";
    GameConstants.NOTIFICATION_CUE_BALL_POTTED = "notification cue ball potted";
    GameConstants.NOTIFICATION_WRONG_BALL_POTTED = "notification wrong ball potted";
    GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED = "notification wrong ball touched";
    GameConstants.NOTIFICATION_NO_BALL_TOUCHED = "notification no ball touched";
    GameConstants.NOTIFICATION_NO_WALL_COLLISION = "notification no wall collision";
    GameConstants.NOTIFICATION_TIMEOUT = "notification timeout";
    GameConstants.NOTIFICATION_ILEGAL_BREAK = "notification ilegal";
    GameConstants.NOTIFICATION_YOUR_TURN = "notification your turn";
    GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS = "first time instructions";
    GameConstants.GAME_UNDECIDED = "game_undecided";
    GameConstants.PLAYER_WIN = "player_win";
    GameConstants.PLAYER_LOSE = "player_lose";
    GameConstants.PLAYER_RESIGNS = "player_resigns";
    GameConstants.ADVERSARY_LEFT_ROOM = "adversary_left_room";
    GameConstants.MIN_PTS_UNLOCK_TABLE = 200;
    GameConstants.MIN_PTS_UNLOCK_CUE = 100;
    GameConstants.TIME_BONUS_ON_POCKET_BALL = 5;
    GameConstants.MIN_CARDS_WON_AT_A_TIME = 6;
    GameConstants.MAX_CARDS_WON_AT_A_TIME = 15;
    GameConstants.RULES_TEXT = "Pocket all stripe and solid balls before the clock runs out.\n" +
        "Each pocketed ball adds 50 pts and " + GameConstants.TIME_BONUS_ON_POCKET_BALL + "s. The cue ball deducts 20 pts.";
    GameConstants.PLAYER = "player";
    GameConstants.ADVERSARY = "adversary";
    GameConstants.MESSAGE_TYPE_SHOT = "SHOT";
    GameConstants.MESSAGE_TYPE_BALLS_STOPPED = "BALLS_STOPPED";
    GameConstants.MESSAGE_TYPE_CUE_ROTATION = "CUE_ROTATION";
    GameConstants.MESSAGE_TYPE_POCKET_SELECTED = "POCKET_SELECTED";
    GameConstants.MESSAGE_TYPE_CUE_BALL = "CUE_BALL";
    GameConstants.MESSAGE_TYPE_BALL_8_POCKETED = "BALL_8_POCKETED";
    GameConstants.BALLS_INITIAL_POSITIONS = [
        [-21000, 0],
        [21000, 0],
        [23424.8, 1400],
        [30699.2, -5600],
        [28274.4, 4200],
        [25849.6, 2800],
        [28274.4, -4200],
        [28274.4, 1400],
        [25849.6, 0],
        [28274.4, -1400],
        [25849.6, -2800],
        [30699.2, 0],
        [30699.2, 2800],
        [30699.2, -2800],
        [30699.2, 5600],
        [23424.8, -1400]
    ];
    GameConstants.BALLS_INITIAL_POSITIONS_SOLO = [
        [-21000, 0],
        [21000, 0],
        [23424.8, 1400],
        [30699.2, -5600 - 4000],
        [28274.4, 4200 + 4000],
        [25849.6, 2800],
        [28274.4, -4200 - 4000],
        [28274.4, 1400],
        [25849.6, 0],
        [28274.4, -1400],
        [25849.6, -2800],
        [30699.2, 0],
        [30699.2, 2800 + 4000],
        [30699.2, -2800 - 4000],
        [30699.2, 5600 + 4000],
        [23424.8, -1400]
    ];
    GameConstants.SAVED_GAME_DATA_KEY = "pool-club-data-key";
    PoolClub.GameConstants = GameConstants;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class GameManager {
        static init(game) {
            GameManager.game = game;
            GameManager.setBilliardConstants();
            PokiSDK.init().then(() => {
                console.log("Poki SDK successfully initialized");
                GameManager.readGameData();
            }).catch(() => {
                console.log("Initialized, but the user likely has adblock");
                GameManager.readGameData();
            });
            PokiSDK.setDebug(false);
        }
        static initGameDistributionSDK() {
            const w = window;
            w["GD_OPTIONS"] = {
                "gameId": "bd64b14f79bd47188f9acb4d3786ee86",
                "onEvent": function (event) {
                    switch (event.name) {
                        case "SDK_GAME_START":
                            GameManager.game.paused = false;
                            if (PoolClub.GameVars.typeAd === "MainMenu") {
                                PoolClub.MatchManagerSolo.endSoloGame(PoolClub.GameConstants.PLAYER_RESIGNS);
                            }
                            else if (PoolClub.GameVars.typeAd === "Reset") {
                                GameManager.enterSoloGame();
                            }
                            break;
                        case "SDK_GAME_PAUSE":
                            GameManager.game.paused = true;
                            break;
                        case "SDK_GDPR_TRACKING":
                            console.log("SDK_GDPR_TRACKING");
                            break;
                        case "SDK_GDPR_TARGETING":
                            console.log("SDK_GDPR_TARGETING");
                            break;
                        default:
                            break;
                    }
                },
            };
            (function (d, s, id) {
                var js, fjs = d.getElementsByTagName(s)[0];
                if (d.getElementById(id)) {
                    return;
                }
                js = d.createElement(s);
                js.id = id;
                js.src = "https://html5.api.gamedistribution.com/main.min.js";
                fjs.parentNode.insertBefore(js, fjs);
            }(document, "script", "gamedistribution-jssdk"));
        }
        static resetNonSOLOVars() {
            if (PoolClub.GameConstants.LOG_SERVER_INFO || PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("resetNonSOLOVars");
            }
            PoolClub.GameVars.adversaryData = null;
            PoolClub.GameVars.gameData.playerData.ballsMoving = false;
            PoolClub.GameVars.gameData.playerData.canPocketBlackBall = false;
            PoolClub.GameVars.gameData.playerData.id = "";
            PoolClub.GameVars.gameData.playerData.sessionId = "";
            PoolClub.GameVars.gameData.playerData.set = false;
            PoolClub.GameVars.gameData.playerData.typeBalls = PoolClub.GameConstants.BALL_TYPE_NONE;
        }
        static readGameData() {
            GameManager.getGameStorageData(PoolClub.GameConstants.SAVED_GAME_DATA_KEY, function (gameData) {
                if (gameData) {
                    PoolClub.GameVars.gameData = JSON.parse(gameData);
                }
                else {
                    GameManager.resetGameVars();
                }
                GameManager.startGame();
            }, function (error) {
                GameManager.log("error retriving saved game data.", error);
            });
        }
        static onGameAssetsLoaded() {
            PokiSDK.gameLoadingFinished();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                PoolClub.AudioManager.init(GameManager.game);
                PoolClub.RewardsManager.init(GameManager.game);
                GameManager.enterSplash();
            });
        }
        static enterSoloGame() {
            PoolClub.GameVars.introseen = true;
            GameManager.resetMatchVars();
            PoolClub.GameVars.gameMode = PoolClub.GameConstants.SOLO_MODE;
            GameManager.game.state.start("PoolState", true, false);
        }
        static enterPVBotGame() {
            GameManager.fullscreenFilter(function () {
                GameManager.resetMatchVars();
                PoolClub.RulesManager.init(PoolClub.GameVars.gameData.playerData, PoolClub.GameVars.adversaryData);
                GameManager.onPVBotTurnChange(null);
            });
        }
        static enterSplash() {
            GameManager.resetNonSOLOVars();
            GameManager.game.state.start("SplashState", true, false);
        }
        static enterPortaitSelectionScreen() {
            GameManager.exitFullscreen();
            GameManager.game.state.start("PlayerRegisteringState", true, false);
        }
        static writeGameData() {
            GameManager.setGameStorageData(PoolClub.GameConstants.SAVED_GAME_DATA_KEY, PoolClub.GameVars.gameData, function () {
                GameManager.log("game data successfully saved");
            }, function (error) {
                GameManager.log("error saving game data", error);
            });
        }
        static log(text, error, color) {
            if (!PoolClub.GameConstants.VERBOSE) {
                return;
            }
            if (error) {
                console.error(text + ":", error);
            }
            else {
                console.log("%c " + text, "color:" + color);
            }
        }
        static changePowerBar() {
            if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT) {
                PoolClub.GameVars.gameData.powerBarSide = PoolClub.GameConstants.RIGHT;
            }
            else {
                PoolClub.GameVars.gameData.powerBarSide = PoolClub.GameConstants.LEFT;
            }
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.changePowerBar();
            }
            GameManager.writeGameData();
        }
        static validatePocketedBalls() {
            let ballsToRemoveFromPocketedBalls = [];
            for (let i = 0; i < PoolClub.GameVars.pocketedBalls.length; i++) {
                let ballId = PoolClub.GameVars.pocketedBalls[i];
                for (let j = 0; j < PoolClub.GameVars.ballsData.length; j++) {
                    let ballData = PoolClub.GameVars.ballsData[j];
                    if (ballData.id === ballId && ballData.active) {
                        ballsToRemoveFromPocketedBalls.push(ballId);
                    }
                }
            }
            if (ballsToRemoveFromPocketedBalls.length > 0) {
                for (let i = ballsToRemoveFromPocketedBalls.length - 1; i >= 0; i--) {
                    let index = PoolClub.GameVars.pocketedBalls.indexOf(ballsToRemoveFromPocketedBalls[i]);
                    PoolClub.GameVars.pocketedBalls.splice(index, 1);
                }
            }
            let ballsToAddToPocketedBalls = [];
            for (let i = 0; i < PoolClub.GameVars.ballsData.length; i++) {
                let ballData = PoolClub.GameVars.ballsData[i];
                if (!ballData.active) {
                    let needAdd = false;
                    for (let j = 0; j < PoolClub.GameVars.pocketedBalls.length; j++) {
                        let ballId = PoolClub.GameVars.pocketedBalls[j];
                        if (ballId === ballData.id) {
                            needAdd = true;
                            break;
                        }
                    }
                    if (needAdd) {
                        ballsToAddToPocketedBalls.push(ballData.id);
                    }
                }
            }
            if (ballsToAddToPocketedBalls.length > 0) {
                for (let i = ballsToAddToPocketedBalls.length - 1; i >= 0; i--) {
                    PoolClub.GameVars.pocketedBalls.push(ballsToAddToPocketedBalls[i]);
                }
            }
        }
        static exitFullscreen() {
            if (GameManager.game.device.touch && GameManager.game.scale.compatibility.supportsFullScreen) {
                GameManager.game.scale.stopFullScreen();
            }
        }
        static fullscreenFilter(onSuccess) {
            if (GameManager.game.device.touch && GameManager.game.scale.compatibility.supportsFullScreen && !(GameManager.game.device.iOS && GameManager.game.device.mobileSafari)) {
                GameManager.game.scale.startFullScreen();
                GameManager.game.time.events.add(.1 * Phaser.Timer.SECOND, function () {
                    onSuccess();
                }, this);
            }
            else {
                onSuccess();
            }
        }
        static onPVPTurnChange(state) {
        }
        static setupBotMatchData() {
            PoolClub.GameVars.adversaryData = {
                nick: this.game.rnd.pick(PoolClub.Utils.getRandomUsernameList()),
                avatar: this.game.rnd.pick(PoolClub.Utils.getRandomAvatarImageList()),
                equipedCue: this.game.rnd.pick(PoolClub.RewardsManager.getCuesList()),
                sessionId: "bot",
                id: "",
                set: false,
                ballsMoving: false,
                typeBalls: PoolClub.GameConstants.BALL_TYPE_NONE,
                canPocketBlackBall: false
            };
            PoolClub.GameVars.gameData.playerData.sessionId = "player";
        }
        static onPVBotTurnChange(state) {
        }
        static onPlayerJoinedPVP(players, isPlayerA) {
            if (PoolClub.GameConstants.LOG_SERVER_INFO) {
                console.error("onPlayerJoinedPVP()");
            }
            if (!players.playerB) {
                if (isPlayerA) {
                    PoolClub.GameVars.gameData.playerData.sessionId = players.playerA.sessionId;
                    PoolClub.GameVars.gameData.playerData.id = players.playerA.id;
                }
                else {
                    PoolClub.GameVars.adversaryData = players.playerA;
                }
            }
            else {
                if (isPlayerA) {
                    PoolClub.GameVars.adversaryData = players.playerB;
                }
                else {
                    PoolClub.GameVars.gameData.playerData.sessionId = players.playerB.sessionId;
                    PoolClub.GameVars.gameData.playerData.id = players.playerB.id;
                }
            }
        }
        static startGame() {
            GameManager.game.state.start("PreLoader", true, false);
        }
        static resetGameVars() {
            let nonSolo = { gamesPlayed: 0, gamesWon: 0, gamesLost: 0 };
            let solo = { highScore: 0, combos: 0, superCombos: 0 };
            let rewards = { starProgress: 0, cards: [], allUnlocked: false };
            let statistics = { nonSolo: nonSolo, solo: solo, rewards: rewards };
            PoolClub.GameVars.gameData = {
                playerData: {
                    nick: "Player",
                    avatar: GameManager.game.rnd.pick(PoolClub.Utils.getRandomAvatarImageList()),
                    equipedCue: "NO_CUE_SELECTED",
                    sessionId: "player",
                    id: "",
                    set: false,
                    ballsMoving: false,
                    typeBalls: PoolClub.GameConstants.BALL_TYPE_NONE,
                    canPocketBlackBall: false
                },
                equippedTable: "NO_TABLE_SELECTED",
                musicMuted: false,
                effectsMuted: false,
                powerBarSide: PoolClub.GameConstants.LEFT,
                statistics: statistics,
                soloTutorial: true,
                multiplayerTutorial: true,
            };
            if (PoolClub.GameConstants.DEVELOPMENT) {
                PoolClub.GameVars.gameData = {
                    playerData: {
                        nick: "Player",
                        avatar: GameManager.game.rnd.pick(PoolClub.Utils.getRandomAvatarImageList()),
                        equipedCue: "NO_CUE_SELECTED",
                        sessionId: "player",
                        id: "",
                        set: false,
                        ballsMoving: false,
                        typeBalls: PoolClub.GameConstants.BALL_TYPE_NONE,
                        canPocketBlackBall: false
                    },
                    equippedTable: "NO_TABLE_SELECTED",
                    musicMuted: false,
                    effectsMuted: false,
                    powerBarSide: PoolClub.GameConstants.RIGHT,
                    statistics: statistics,
                    soloTutorial: true,
                    multiplayerTutorial: true,
                };
            }
        }
        static resetMatchVars() {
            PoolClub.GameVars.gameMode = PoolClub.GameConstants.NO_GAME;
            PoolClub.GameVars.pocketedBalls = [];
            PoolClub.GameVars.ballsData = [];
            this.resetSoloMatchScoreAndTime();
            PoolClub.GameVars.shotCount = 0;
            PoolClub.GameVars.timerPVP = 30;
            PoolClub.GameVars.startMatch = false;
            PoolClub.GameVars.gameEnded = PoolClub.GameConstants.GAME_UNDECIDED;
            PoolClub.GameVars.currentTurn = null;
            PoolClub.GameVars.firstShot = true;
            PoolClub.GameVars.rematch = false;
            PoolClub.GameVars.timeMatch = 0;
            PoolClub.GameVars.paused = false;
            PoolClub.GameVars.shotRunning = false;
            PoolClub.GameVars.turnSet = true;
            PoolClub.GameVars.wallCollisions = [];
            PoolClub.GameVars.english = 0;
            PoolClub.GameVars.verticalSpin = 0;
            PoolClub.GameVars.GUIButtonDown = false;
            PoolClub.GameVars.draggingCueBall = false;
            PoolClub.GameVars.skipShowingPocketAndCue = false;
            PoolClub.GameVars.pocketIdWhereBlackFell = -1;
            PoolClub.GameVars.canStart = false;
            if (PoolClub.GameConstants.DEVELOPMENT) {
                PoolClub.GameVars.gameMode = PoolClub.GameConstants.NO_GAME;
                PoolClub.GameVars.pocketedBalls = [];
                PoolClub.GameVars.ballsData = [];
                PoolClub.GameVars.startMatch = false;
                PoolClub.GameVars.gameEnded = PoolClub.GameConstants.GAME_UNDECIDED;
                PoolClub.GameVars.currentTurn = null;
                PoolClub.GameVars.firstShot = true;
                PoolClub.GameVars.rematch = false;
                PoolClub.GameVars.timeMatch = 0;
            }
        }
        static resetSoloMatchScoreAndTime() {
            if (PoolClub.GameVars.resetScoreAndTime || (!PoolClub.GameVars.playerPoints && !PoolClub.GameVars.timerSolo)) {
                if (PoolClub.GameConstants.DEVELOPMENT) {
                    PoolClub.GameVars.playerPoints = 0;
                    PoolClub.GameVars.timerSolo = 50;
                }
                else {
                    PoolClub.GameVars.playerPoints = 0;
                    PoolClub.GameVars.timerSolo = PoolClub.GameConstants.TIME_SOLO_MATCH;
                }
            }
            PoolClub.GameVars.resetScoreAndTime = true;
        }
        static setBilliardConstants() {
            PoolClub.GameVars.pocketArray = [];
            let pocket = { id: 0, position: new Billiard.Vector2D(-42e3 - PoolClub.GameConstants.POCKET_RADIUS / 4, -21e3 - PoolClub.GameConstants.POCKET_RADIUS / 4), dropPosition: new Billiard.Vector2D(-42840 - PoolClub.GameConstants.POCKET_RADIUS / 2, -21840 - PoolClub.GameConstants.POCKET_RADIUS / 4) };
            PoolClub.GameVars.pocketArray.push(pocket);
            pocket = { id: 1, position: new Billiard.Vector2D(0, -21e3 - PoolClub.GameConstants.POCKET_RADIUS), dropPosition: new Billiard.Vector2D(0, -21420 - PoolClub.GameConstants.POCKET_RADIUS) };
            PoolClub.GameVars.pocketArray.push(pocket);
            pocket = { id: 2, position: new Billiard.Vector2D(42e3 + PoolClub.GameConstants.POCKET_RADIUS / 4, -21e3 - PoolClub.GameConstants.POCKET_RADIUS / 4), dropPosition: new Billiard.Vector2D(42840 + PoolClub.GameConstants.POCKET_RADIUS / 2, -21840 - PoolClub.GameConstants.POCKET_RADIUS / 4) };
            PoolClub.GameVars.pocketArray.push(pocket);
            pocket = { id: 3, position: new Billiard.Vector2D(-42e3 - PoolClub.GameConstants.POCKET_RADIUS / 4, 21e3 + PoolClub.GameConstants.POCKET_RADIUS / 4), dropPosition: new Billiard.Vector2D(-42840 - PoolClub.GameConstants.POCKET_RADIUS / 2, 21840 + PoolClub.GameConstants.POCKET_RADIUS / 4) };
            PoolClub.GameVars.pocketArray.push(pocket);
            pocket = { id: 4, position: new Billiard.Vector2D(0, 21e3 + PoolClub.GameConstants.POCKET_RADIUS), dropPosition: new Billiard.Vector2D(0, 21420 + PoolClub.GameConstants.POCKET_RADIUS) };
            PoolClub.GameVars.pocketArray.push(pocket);
            pocket = { id: 5, position: new Billiard.Vector2D(42e3 + PoolClub.GameConstants.POCKET_RADIUS / 4, 21e3 + PoolClub.GameConstants.POCKET_RADIUS / 4), dropPosition: new Billiard.Vector2D(42840 + PoolClub.GameConstants.POCKET_RADIUS / 2, 21840 + PoolClub.GameConstants.POCKET_RADIUS / 4) };
            PoolClub.GameVars.pocketArray.push(pocket);
            PoolClub.GameVars.lineArray = [];
            PoolClub.GameVars.vertexArray = [];
            let line = { name: "AB", direction: null, normal: null, p1: new Billiard.Vector2D(-42e3, -24360), p2: new Billiard.Vector2D(-38640, -21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            let vertex = { name: "B", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "BC", direction: null, normal: null, p1: new Billiard.Vector2D(-38640, -21e3), p2: new Billiard.Vector2D(-3360, -21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "C", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "CD", direction: null, normal: null, p1: new Billiard.Vector2D(-3360, -21e3), p2: new Billiard.Vector2D(-1680, -24360), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            line = { name: "EF", direction: null, normal: null, p1: new Billiard.Vector2D(1680, -24360), p2: new Billiard.Vector2D(3360, -21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "F", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "FG", direction: null, normal: null, p1: new Billiard.Vector2D(3360, -21e3), p2: new Billiard.Vector2D(38640, -21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "G", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "GH", direction: null, normal: null, p1: new Billiard.Vector2D(38640, -21e3), p2: new Billiard.Vector2D(42e3, -24360), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            line = { name: "IJ", direction: null, normal: null, p1: new Billiard.Vector2D(45360, -21e3), p2: new Billiard.Vector2D(42e3, -17640), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "J", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "JK", direction: null, normal: null, p1: new Billiard.Vector2D(42e3, -17640), p2: new Billiard.Vector2D(42e3, 17640), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "K", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "KL", direction: null, normal: null, p1: new Billiard.Vector2D(42e3, 17640), p2: new Billiard.Vector2D(45360, 21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            line = { name: "MN", direction: null, normal: null, p1: new Billiard.Vector2D(42e3, 24360), p2: new Billiard.Vector2D(38640, 21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "N", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "NO", direction: null, normal: null, p1: new Billiard.Vector2D(38640, 21e3), p2: new Billiard.Vector2D(3360, 21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "O", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "OP", direction: null, normal: null, p1: new Billiard.Vector2D(3360, 21e3), p2: new Billiard.Vector2D(1680, 24360), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            line = { name: "QR", direction: null, normal: null, p1: new Billiard.Vector2D(-1680, 24360), p2: new Billiard.Vector2D(-3360, 21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "R", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "RS", direction: null, normal: null, p1: new Billiard.Vector2D(-3360, 21e3), p2: new Billiard.Vector2D(-38640, 21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "S", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "ST", direction: null, normal: null, p1: new Billiard.Vector2D(-38640, 21e3), p2: new Billiard.Vector2D(-42e3, 24360), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            line = { name: "UV", direction: null, normal: null, p1: new Billiard.Vector2D(-45360, 21e3), p2: new Billiard.Vector2D(-42e3, 17640), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "V", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "VW", direction: null, normal: null, p1: new Billiard.Vector2D(-42e3, 17640), p2: new Billiard.Vector2D(-42e3, -17640), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            vertex = { name: "W", position: new Billiard.Vector2D(line.p2.x, line.p2.y) };
            PoolClub.GameVars.vertexArray.push(vertex);
            line = { name: "WX", direction: null, normal: null, p1: new Billiard.Vector2D(-42e3, -17640), p2: new Billiard.Vector2D(-45360, -21e3), p3: null, p4: null, p5: null, p6: null };
            PoolClub.GameVars.lineArray.push(line);
            for (let i = 0; i < PoolClub.GameVars.lineArray.length; i++) {
                let line = PoolClub.GameVars.lineArray[i];
                line.direction = new Billiard.Vector2D(line.p2.x - line.p1.x, line.p2.y - line.p1.y).normalize();
                line.normal = line.direction.getLeftNormal();
                let r = line.normal.times(PoolClub.GameConstants.BALL_RADIUS);
                line.p3 = line.p1.plus(r);
                line.p4 = line.p2.plus(r);
                let s = line.normal.times(.525 * PoolClub.GameConstants.BALL_RADIUS);
                line.p5 = line.p1.plus(s);
                line.p6 = line.p2.plus(s);
            }
        }
        static getGameStorageData(key, successCb, failureCb) {
            try {
                const gameDataStr = localStorage.getItem(key);
                successCb(gameDataStr);
            }
            catch (_a) {
                successCb(null);
            }
        }
        static setGameStorageData(key, value, successCb, failureCb) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
                successCb();
            }
            catch (_a) {
            }
        }
    }
    PoolClub.GameManager = GameManager;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class GameVars {
        static areValidDomains(domains) {
            let isValid = false;
            for (let i = 0; i < domains.length; i++) {
                if (window.location.hostname.indexOf(domains[i]) !== -1) {
                    isValid = true;
                    break;
                }
            }
            return isValid;
        }
        static extractLineArrayString() {
            const lineArray = [];
            for (let i = 0; i < GameVars.lineArray.length; i++) {
                lineArray.push({
                    name: GameVars.lineArray[i].name,
                    direction: { x: GameVars.lineArray[i].direction.x, y: GameVars.lineArray[i].direction.y },
                    normal: { x: GameVars.lineArray[i].normal.x, y: GameVars.lineArray[i].normal.y },
                    p1: { x: GameVars.lineArray[i].p1.x, y: GameVars.lineArray[i].p1.y },
                    p2: { x: GameVars.lineArray[i].p2.x, y: GameVars.lineArray[i].p2.y },
                    p3: { x: GameVars.lineArray[i].p3.x, y: GameVars.lineArray[i].p3.y },
                    p4: { x: GameVars.lineArray[i].p4.x, y: GameVars.lineArray[i].p4.y },
                    p5: { x: GameVars.lineArray[i].p5.x, y: GameVars.lineArray[i].p5.y },
                    p6: { x: GameVars.lineArray[i].p6.x, y: GameVars.lineArray[i].p6.y }
                });
            }
            return JSON.stringify(lineArray);
        }
        static extractVertexArrayString() {
            const vertexArray = [];
            for (let i = 0; i < GameVars.vertexArray.length; i++) {
                vertexArray.push({
                    name: GameVars.vertexArray[i].name,
                    position: { x: GameVars.vertexArray[i].position.x, y: GameVars.vertexArray[i].position.y }
                });
            }
            return JSON.stringify(vertexArray);
        }
        static extractPocketArrayString() {
            const pocketArray = [];
            for (let i = 0; i < GameVars.pocketArray.length; i++) {
                pocketArray.push({
                    id: GameVars.pocketArray[i].id,
                    position: { x: GameVars.pocketArray[i].position.x, y: GameVars.pocketArray[i].position.y },
                    dropPosition: { x: GameVars.pocketArray[i].dropPosition.x, y: GameVars.pocketArray[i].dropPosition.y },
                });
            }
            return JSON.stringify(pocketArray);
        }
        static extractBallsArrayString() {
            const ballsArray = [];
            for (let i = 0; i < GameVars.ballArray.length; i++) {
                ballsArray.push({
                    id: GameVars.ballArray[i].id,
                    active: GameVars.ballArray[i].active,
                    position: { x: GameVars.ballArray[i].position.x, y: GameVars.ballArray[i].position.y },
                });
            }
            return JSON.stringify(ballsArray);
        }
    }
    PoolClub.GameVars = GameVars;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class RewardsManager {
        static init(game) {
            RewardsManager.game = game;
            this.unlockedCards = [];
        }
        static getCuesList() {
            let answer = [];
            for (let i = 0; i < this.cardsJSONData.length; i++) {
                if (this.cardsJSONData[i].type === "cue") {
                    answer.push(this.cardsJSONData[i].id);
                }
                else {
                    continue;
                }
            }
            if (answer.length === 0) {
                throw "No cues found";
            }
            return answer;
        }
        static getMaxForCardType(type) {
            return (type === "cue") ? PoolClub.GameConstants.MIN_PTS_UNLOCK_CUE : PoolClub.GameConstants.MIN_PTS_UNLOCK_TABLE;
        }
        static getCurrentStarProgress() {
            return PoolClub.GameVars.gameData.statistics.rewards.starProgress;
        }
        static getCueSpriteFrames(cardId) {
            let cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase.type !== "cue") {
                throw "Cannot request sprite data from table card. Check card_data.json";
            }
            if (cardOnDatabase.spriteFrames) {
                return cardOnDatabase.spriteFrames;
            }
            else {
                return 1;
            }
        }
        static getCueSpriteIntermittent(cardId) {
            let cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase.type !== "cue") {
                throw "Cannot request animation data from table card. Check card_data.json";
            }
            return cardOnDatabase.intermittentAnimation;
        }
        static getTableTunnelColour(cardId) {
            return 0x3A2A3A;
        }
        static getMostLikelyNextCard() {
            let highestCardId = "";
            let highestCardPoints = 0;
            for (let card of PoolClub.GameVars.gameData.statistics.rewards.cards) {
                if (highestCardPoints <= card.cardPoints) {
                    const cardType = this.getCardType(card.cardName);
                    const typeMax = this.getMaxForCardType(cardType);
                    if (card.cardPoints >= typeMax) {
                        continue;
                    }
                    highestCardId = card.cardName;
                    highestCardPoints = card.cardPoints;
                }
            }
            return { cardId: highestCardId, cardPoints: highestCardPoints };
        }
        static getCardPoints(cardId) {
            const cardOnDatabase = PoolClub.GameVars.gameData.statistics.rewards.cards.filter(obj => obj.cardName === cardId)[0];
            if (cardOnDatabase) {
                return cardOnDatabase.cardPoints;
            }
            else {
                throw cardId.toString() + " not found in gameData";
            }
        }
        static getCardType(cardId) {
            const cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase) {
                return cardOnDatabase.type;
            }
            else {
                throw cardId + " not found in gameData";
            }
        }
        static getRandomCardIds(requestedCardsCount = 3) {
            let cuesAvailable = [];
            let tablesAvailable = [];
            PoolClub.GameVars.gameData.statistics.rewards.cards.forEach(cardData => {
                if (RewardsManager.unlockedCards.indexOf(cardData.cardName) < 0) {
                    if (RewardsManager.getCardType(cardData.cardName) === "cue") {
                        if (cardData.cardName !== PoolClub.GameVars.gameData.playerData.equipedCue) {
                            cuesAvailable.push(cardData.cardName);
                        }
                    }
                    else {
                        if (cardData.cardName !== PoolClub.GameVars.gameData.equippedTable) {
                            tablesAvailable.push(cardData.cardName);
                        }
                    }
                }
            });
            let selectedCues = new Set();
            while (selectedCues.size < 2 && cuesAvailable.length > 0) {
                const randomIndex = this.game.rnd.integerInRange(0, cuesAvailable.length - 1);
                selectedCues.add(cuesAvailable[randomIndex]);
                cuesAvailable.splice(randomIndex, 1);
            }
            let selectedTables = new Set();
            while (selectedTables.size < 1 && tablesAvailable.length > 0) {
                const randomIndex = this.game.rnd.integerInRange(0, tablesAvailable.length - 1);
                selectedTables.add(tablesAvailable[randomIndex]);
                tablesAvailable.splice(randomIndex, 1);
            }
            return Array.from(selectedCues.values()).concat(Array.from(selectedTables.values()));
        }
        static resetStarCount() {
            PoolClub.GameVars.gameData.statistics.rewards.starProgress = 0;
        }
        static unlockAllCards() {
            let cardArray = PoolClub.GameVars.gameData.statistics.rewards.cards;
            cardArray.forEach(card => {
                if (RewardsManager.unlockedCards.indexOf(card.cardName) < 0 &&
                    card.cardName !== PoolClub.GameVars.gameData.playerData.equipedCue &&
                    card.cardName !== PoolClub.GameVars.gameData.equippedTable) {
                    const cardType = RewardsManager.getCardType(card.cardName);
                    const progMaxValue = (cardType === "cue") ? PoolClub.GameConstants.MIN_PTS_UNLOCK_CUE : PoolClub.GameConstants.MIN_PTS_UNLOCK_TABLE;
                    card.cardPoints = progMaxValue;
                    this.updateUnlockedCardsArray(card.cardName);
                }
            });
            PoolClub.GameManager.writeGameData();
        }
        static equipTable(cardId) {
            if (RewardsManager.getCardType(cardId) !== "table") {
                throw "Cannot equip cue as table";
            }
            else {
                PoolClub.GameVars.gameData.equippedTable = cardId;
            }
        }
        static equipCue(cardId) {
            if (RewardsManager.getCardType(cardId) !== "cue") {
                throw "Cannot equip table as cue";
            }
            else {
                PoolClub.GameVars.gameData.playerData.equipedCue = cardId;
            }
        }
        static prepareRewardStats() {
            let victoryData = { starUnlocked: 0, recentlyUnlockedCardIds: [], numberOfCardsUnlocked: [] };
            if (!PoolClub.GameVars.gameData.statistics.rewards.allUnlocked) {
                PoolClub.GameVars.gameData.statistics.rewards.starProgress++;
                const numberOfCardsToUnlock = 3;
                const potentialUnlockableCards = RewardsManager.getRandomCardIds(numberOfCardsToUnlock);
                if (potentialUnlockableCards.length < 1) {
                    PoolClub.GameVars.gameData.statistics.rewards.allUnlocked = true;
                    PoolClub.GameManager.enterSplash();
                }
                else {
                    victoryData.starUnlocked = 1;
                    if (PoolClub.GameVars.gameData.statistics.rewards.starProgress === 2) {
                        victoryData.starUnlocked = 2;
                    }
                    else if (PoolClub.GameVars.gameData.statistics.rewards.starProgress === 3) {
                        victoryData.starUnlocked = 3;
                        RewardsManager.resetStarCount();
                        victoryData.recentlyUnlockedCardIds = potentialUnlockableCards;
                        victoryData.numberOfCardsUnlocked = RewardsManager.fillNumberArrayWithIntRange(victoryData.recentlyUnlockedCardIds.length, PoolClub.GameConstants.MIN_CARDS_WON_AT_A_TIME, PoolClub.GameConstants.MAX_CARDS_WON_AT_A_TIME);
                        for (let i = 0; i < victoryData.recentlyUnlockedCardIds.length; i++) {
                            RewardsManager.incrementCardPoint(victoryData.recentlyUnlockedCardIds[i], victoryData.numberOfCardsUnlocked[i]);
                        }
                    }
                }
            }
            return victoryData;
        }
        static incrementCardPoint(cardId, incrementValue) {
            let currentPoints = this.getCardPoints(cardId);
            currentPoints += incrementValue;
            const cardType = RewardsManager.getCardType(cardId);
            const progMaxValue = (cardType === "cue") ? PoolClub.GameConstants.MIN_PTS_UNLOCK_CUE : PoolClub.GameConstants.MIN_PTS_UNLOCK_TABLE;
            const finalPoints = Math.min(progMaxValue, currentPoints);
            for (let i = 0; i < PoolClub.GameVars.gameData.statistics.rewards.cards.length; i++) {
                if (PoolClub.GameVars.gameData.statistics.rewards.cards[i].cardName === cardId) {
                    RewardsManager.setCardPoints(cardId, finalPoints, cardType);
                }
            }
        }
        static initialEquip() {
        }
        static updateUnlockedCardsArray(cardId) {
            if (RewardsManager.unlockedCards.indexOf(cardId) < 0) {
                RewardsManager.unlockedCards.push(cardId);
            }
        }
        static setCardPoints(cardId, points, cardType) {
            for (let i = 0; i < PoolClub.GameVars.gameData.statistics.rewards.cards.length; i++) {
                if (PoolClub.GameVars.gameData.statistics.rewards.cards[i].cardName === cardId) {
                    const cardTypeMax = RewardsManager.getMaxForCardType(cardType);
                    if (points >= cardTypeMax) {
                        PoolClub.GameVars.gameData.statistics.rewards.cards[i].cardPoints = cardTypeMax;
                        this.updateUnlockedCardsArray(cardId);
                    }
                    else {
                        PoolClub.GameVars.gameData.statistics.rewards.cards[i].cardPoints = points;
                    }
                    return;
                }
            }
            PoolClub.GameManager.log("Failed to find " + cardId);
        }
        static updateCardDatabase() {
        }
        static populateCardDatabase() {
        }
        static fillNumberArrayWithIntRange(count, min, max) {
            let answer = [];
            for (let i = 0; i < count; i++) {
                answer.push(RewardsManager.game.rnd.integerInRange(min, max));
            }
            return answer;
        }
    }
    PoolClub.RewardsManager = RewardsManager;
})(PoolClub || (PoolClub = {}));
window.onload = () => {
    const game = new PoolClub.Game();
    window.addEventListener('keydown', ev => {
        if (['ArrowDown', 'ArrowUp', ' '].includes(ev.key)) {
            ev.preventDefault();
        }
    });
    window.addEventListener('wheel', ev => ev.preventDefault(), { passive: false });
};
var PoolClub;
(function (PoolClub) {
    class Boot extends Phaser.State {
        static onFullScreenChange() {
            const aspectRatio = screen.width / screen.height;
            PoolClub.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT = (PoolClub.GameConstants.GAME_WIDTH / PoolClub.GameConstants.GAME_HEIGHT) / aspectRatio;
            if (aspectRatio <= 1.35) {
                PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .75;
            }
            else if (aspectRatio <= 1.55) {
                PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .8;
            }
            else if (aspectRatio <= 1.65) {
                PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .9;
            }
            else {
                PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = 1;
            }
            Boot.setScaleMultipliers();
            PoolClub.Game.currentInstance.scale.refresh();
        }
        static enterIncorrectOrientation() {
            document.getElementById("orientation").style.display = "block";
            document.getElementById("content").style.display = "none";
        }
        static leaveIncorrectOrientation() {
            document.getElementById("orientation").style.display = "none";
            document.getElementById("content").style.display = "block";
            if (Boot.currentInstance) {
                PoolClub.Game.currentInstance.time.events.add(150, function () {
                    PoolClub.Game.currentInstance.state.restart(true, false);
                }, this);
            }
        }
        static onBlur() {
            PoolClub.AudioManager.temporaryMute();
        }
        static onFocus() {
            PoolClub.AudioManager.temporaryUnmute();
        }
        static setScaleMultipliers() {
            PoolClub.GameVars.scaleXMult = PoolClub.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT * PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT;
            PoolClub.GameVars.scaleYMult = PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT;
            PoolClub.GameVars.scaleXMultInverse = 1 / PoolClub.GameVars.scaleXMult;
            PoolClub.GameVars.scaleYMultInverse = 1 / PoolClub.GameVars.scaleYMult;
            PoolClub.GameManager.log("scaleX:" + PoolClub.GameVars.scaleXMult + ", "
                + "scaleY:" + PoolClub.GameVars.scaleYMult);
        }
        init() {
            Boot.currentInstance = this;
            this.input.maxPointers = 1;
            this.game.stage.backgroundColor = "#05060a";
            this.game.stage.disableVisibilityChange = true;
            this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
            this.game.scale.pageAlignHorizontally = true;
            if (this.game.device.desktop) {
                this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                PoolClub.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT = 1;
                PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = 1;
                this.game.scale.pageAlignHorizontally = true;
                this.bootedInWrongOrientation = false;
            }
            else {
                this.game.scale.scaleMode = Phaser.ScaleManager.EXACT_FIT;
                if (this.game.scale.compatibility.supportsFullScreen) {
                    this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;
                    this.game.scale.onFullScreenChange.add(Boot.onFullScreenChange, this);
                }
                else {
                    console.log("Device does not support fullscreen");
                }
                let aspectRatio = window.innerWidth / window.innerHeight;
                PoolClub.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT = (PoolClub.GameConstants.GAME_WIDTH / PoolClub.GameConstants.GAME_HEIGHT) / aspectRatio;
                if (aspectRatio <= 1.35) {
                    PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .75;
                }
                else if (aspectRatio <= 1.55) {
                    PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .8;
                }
                else if (aspectRatio <= 1.65) {
                    PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .9;
                }
                else {
                    PoolClub.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = 1;
                }
                this.game.scale.pageAlignVertically = true;
                this.game.scale.forceOrientation(true, false);
                this.game.scale.enterIncorrectOrientation.add(Boot.enterIncorrectOrientation, Boot);
                this.game.scale.leaveIncorrectOrientation.add(Boot.leaveIncorrectOrientation, Boot);
                this.bootedInWrongOrientation = window.innerHeight > window.innerWidth ? true : false;
            }
            this.game.onBlur.add(Boot.onBlur, this);
            this.game.onFocus.add(Boot.onFocus, this);
            Boot.setScaleMultipliers();
            if (PoolClub.GameConstants.DEVELOPMENT) {
                this.game.time.advancedTiming = true;
            }
        }
        preload() {
            this.load.crossOrigin = "anonymous";
            this.load.path = PoolClub.GameConstants.ASSETS_PATH;
            this.load.image("game-title", "/game_title.png");
            this.load.image("preload_cue", "/preload-cue.png");
            this.load.image("preload_cue_ball", "/preload-cue-ball.png");
        }
        create() {
            if (this.bootedInWrongOrientation) {
                return;
            }
            PoolClub.GameManager.init(this.game);
        }
        shutdown() {
            Boot.currentInstance = null;
            super.shutdown();
        }
    }
    PoolClub.Boot = Boot;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class SwitchButton extends Phaser.Group {
        constructor(game, isOn, typeSwitch) {
            super(game, null, "switch-button");
            this.isOn = isOn;
            this.typeSwitch = typeSwitch;
            const button = new Phaser.Button(this.game, 0, 0, "texture_atlas_1", this.onDown, this);
            button.anchor.set(.5);
            this.add(button);
            if (this.isOn) {
                button.setFrames("btn_switch_on_on.png", "btn_switch_on_off.png", "btn_switch_on_on.png", "btn_switch_on_off.png");
            }
            else {
                button.setFrames("btn_switch_off_on.png", "btn_switch_off_off.png", "btn_switch_off_on.png", "btn_switch_off_off.png");
            }
        }
        onDown(button) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            this.isOn = !this.isOn;
            if (this.isOn) {
                button.setFrames("btn_switch_on_on.png", "btn_switch_on_off.png", "btn_switch_on_on.png", "btn_switch_on_off.png");
            }
            else {
                button.setFrames("btn_switch_off_on.png", "btn_switch_off_off.png", "btn_switch_off_on.png", "btn_switch_off_off.png");
            }
            if (this.typeSwitch === SwitchButton.MUSIC) {
                if (PoolClub.GameVars.gameData.musicMuted || PoolClub.GameVars.gameData.effectsMuted) {
                    PoolClub.AudioManager.setMusicMuted(false);
                    PoolClub.AudioManager.setEffectsMuted(false);
                }
                else {
                    PoolClub.AudioManager.setMusicMuted(true);
                    PoolClub.AudioManager.setEffectsMuted(true);
                }
            }
            else if (this.typeSwitch === SwitchButton.POWER) {
                PoolClub.GameManager.changePowerBar();
            }
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
    }
    SwitchButton.MUSIC = "music";
    SwitchButton.POWER = "power";
    PoolClub.SwitchButton = SwitchButton;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class AnimatedStarBox extends Phaser.Group {
        constructor(game, useFixedTexture) {
            super(game, null, "animated-star-box");
            this.starsDistBetween = 60;
            this.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.boxContainerImage = new Phaser.Image(game, 0, 0, "texture_atlas_1", useFixedTexture ? "box_stars_fixed.png" : "box_stars.png");
            this.boxContainerImage.anchor.set(.5);
            this.add(this.boxContainerImage);
            this.starImages = [];
            if (useFixedTexture) {
                this.createStarsSmallVersion(-26, 0, "star_void.png");
            }
            else {
                this.createStars(-15, 0, "star_void.png");
            }
        }
        setStarActive(star) {
            this.starImages[star].frameName = "star_full.png";
            this.starImages[star].visible = true;
        }
        animateStarToFullScale(index) {
            this.starImages[index].frameName = "star_full.png";
            this.starImages[index].scale.set(0);
            this.game.add.tween(this.starImages[index].scale)
                .to({ x: 1, y: 1 }, 500, Phaser.Easing.Elastic.Out, true, 500);
            this.game.time.events.add(Phaser.Timer.SECOND * .75, function () {
                const sparkleSprite = new Phaser.Sprite(this.game, this.starImages[index].x, this.starImages[index].y, "texture_atlas_1");
                sparkleSprite.anchor.set(0.5);
                const sparkleFrames = PoolClub.Utils.createAnimFramesArr("sparkle_effect", 14, false, 0, 15);
                sparkleSprite.animations.add("sparkle", sparkleFrames).play(24, false, true);
                this.add(sparkleSprite);
                this.swapChildren(sparkleSprite, this.starImages[index]);
            }, this);
        }
        animateGiftBox() {
        }
        createStars(x, y, imageName) {
            for (let i = 0; i < 3; i++) {
                const boxContainerImage = new Phaser.Image(this.game, x + this.starsDistBetween * (i - 1), y, "texture_atlas_1", imageName);
                boxContainerImage.anchor.set(0.5);
                this.starImages.push(boxContainerImage);
                this.add(this.starImages[i]);
            }
        }
        fadeOutStarsBox() {
            for (let i = 0; i < this.starImages.length; i++) {
                this.game.add.tween(this.starImages[i])
                    .to({ alpha: 0 }, 750, Phaser.Easing.Cubic.Out, true);
            }
            this.game.add.tween(this.boxContainerImage)
                .to({ alpha: 0 }, 750, Phaser.Easing.Cubic.Out, true);
        }
        createStarsSmallVersion(x, y, imageName) {
            this.starsDistBetween = 34;
            for (let i = 0; i < 3; i++) {
                const boxContainerImage = new Phaser.Image(this.game, x + this.starsDistBetween * (i - 1), y, "texture_atlas_1", imageName);
                boxContainerImage.anchor.set(0.5);
                boxContainerImage.scale.set(0.6);
                boxContainerImage.visible = false;
                this.starImages.push(boxContainerImage);
                this.add(this.starImages[i]);
            }
        }
    }
    PoolClub.AnimatedStarBox = AnimatedStarBox;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class CueContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "cue-container");
            CueContainer.currentInstance = this;
            this.settingPower = false;
            this.angle = 180;
            this.lastRotationTransmitted = this.rotation;
            this.timeRotationTransmitted = this.game.time.time;
            this.shooting = false;
            this.down_px = 0;
            this.down_py = 0;
            this.impulseFactor = 0;
            this.aimDirectionVector = new Billiard.Vector2D(1, 0);
            this.startAim = false;
            this.downTimer = -0.1;
            this.doIntermittentCueAnim = false;
            this.doIntermittentCueAnimCounter = 1.0;
            this.cue = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_1", "cue.png");
            this.cue.anchor.y = .5;
            this.cue.anchor.x = -.04;
            this.add(this.cue);
            if (this.game.device.touch) {
                this.game.input.onUp.add(this.onUp, this);
                this.game.input.onDown.add(this.onDownTouch, this);
            }
            else {
                this.game.input.onUp.add(this.shoot, this);
                this.game.input.onDown.add(this.onDownDesktop, this);
            }
            this.cue.visible = false;
        }
        update() {
            super.update();
            if (this.downTimer >= 0) {
                this.downTimer -= this.game.time.physicsElapsed;
            }
            if (!this.cue.visible || this.shooting || PoolClub.SpinCircleLayer.currentInstance.visible ||
                PoolClub.GameVars.paused || PoolClub.GameVars.GUIButtonDown) {
                return;
            }
            this.animateCue();
            const cueBall = PoolClub.GameVars.ballArray[0];
            this.position.x = cueBall.mc.x;
            this.position.y = cueBall.mc.y;
            if (this.game.device.touch) {
                if (this.settingPower) {
                    this.cue.x = this.impulseFactor * CueContainer.MAX_DELTA_CUE;
                }
                else {
                    if (this.game.input.activePointer.isDown && !this.settingPower) {
                        if (this.startAim) {
                            const dx = (this.game.input.activePointer.x - this.parent.x) / PoolClub.GameVars.scaleXMult - cueBall.mc.x;
                            const dy = this.game.input.activePointer.y - this.parent.y - cueBall.mc.y;
                            let pointerAngle = 180 / Math.PI * Math.atan2(dy, dx);
                            let deltaAngle = Billiard.Maths.angleDiff(pointerAngle, this.startAng);
                            this.angle = this.startCue + deltaAngle;
                            this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                            this.transmitCueRotation();
                        }
                        else {
                            this.startCue = this.angle;
                            const dx = (this.game.input.activePointer.x - this.parent.x) / PoolClub.GameVars.scaleXMult - cueBall.mc.x;
                            const dy = this.game.input.activePointer.y - this.parent.y - cueBall.mc.y;
                            this.startAng = 180 / Math.PI * Math.atan2(dy, dx);
                            this.startAim = true;
                        }
                    }
                    else {
                        this.startAim = false;
                    }
                }
            }
            else {
                if (this.settingPower) {
                    if (cueBall.handIcon) {
                        cueBall.handIcon.visible = false;
                    }
                    const x = this.down_px - this.game.input.activePointer.x;
                    const y = this.down_py - this.game.input.activePointer.y;
                    const transf_x = x * Math.cos(this.rotation) + y * Math.sin(this.rotation);
                    this.impulseFactor = Billiard.Maths.fixNumber(-Phaser.Math.clamp(transf_x, -CueContainer.MAX_DELTA_CUE, 0) / CueContainer.MAX_DELTA_CUE);
                    this.cue.x = this.impulseFactor * CueContainer.MAX_DELTA_CUE;
                }
                else if (!PoolClub.SpinCircleLayer.discardClick) {
                    let cueBall = PoolClub.GameVars.ballArray[0];
                    const dx = cueBall.mc.x - this.game.input.activePointer.x + this.parent.x;
                    const dy = cueBall.mc.y - this.game.input.activePointer.y + this.parent.y;
                    this.rotation = Math.atan2(dy, dx);
                    this.transmitCueRotation();
                    this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                }
            }
        }
        showCueAndUpdatePos() {
            this.cue.visible = true;
            this.cue.x = 0;
            this.cue.alpha = 0;
            this.game.add.tween(this.cue)
                .to({ alpha: 1 }, 300, Phaser.Easing.Cubic.Out, true);
            let cueBall = PoolClub.GameVars.ballArray[0];
            this.position.x = cueBall.mc.x;
            this.position.y = cueBall.mc.y;
            this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
        }
        moveCue(rotation) {
            let difference = this.rotation - rotation;
            let times = Math.floor((difference - (-Math.PI)) / (Math.PI * 2));
            let shortAngle = (difference - (times * (Math.PI * 2))) * -1;
            let newAngle = this.rotation + shortAngle;
            let cueBall = PoolClub.GameVars.ballArray[0];
            let randTime = Math.random() * 600 + 300;
            this.position.x = cueBall.mc.x;
            this.position.y = cueBall.mc.y;
            this.game.add.tween(this)
                .to({ rotation: newAngle }, randTime, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function () {
                this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
            }, this);
        }
        moveCueTo(x, y) {
            this.game.add.tween(this.position)
                .to({ x: x, y: y }, 200, Phaser.Easing.Linear.None, true);
        }
        hideCue() {
            this.cue.visible = false;
            this.cue.x = 0;
            this.shooting = false;
        }
        shoot(p) {
            if (p && !p.withinGame) {
                return;
            }
            this.settingPower = false;
            if (this.downTimer > 0) {
                this.cancelShot();
                this.downTimer = -0.1;
                return;
            }
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                PoolClub.MatchManagerPVP.cueRotated(this.rotation);
            }
            if (this.impulseFactor > 0) {
                this.shooting = true;
                this.game.add.tween(this.cue)
                    .to({ x: -5 }, 75, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(this.applyImpulse, this);
            }
            else {
                this.impulseFactor = 0;
                const cueBall = PoolClub.GameVars.ballArray[0];
                if (cueBall.handIcon) {
                    cueBall.handIcon.visible = true;
                }
            }
        }
        shootReceived(vector, deltaScrew, english) {
            this.shooting = true;
            this.game.add.tween(this.cue)
                .to({ x: 100 }, 400, Phaser.Easing.Cubic.Out, true, 500);
            this.game.add.tween(this.cue)
                .to({ x: -5 }, 200, Phaser.Easing.Cubic.Out, true, 1000)
                .onComplete.add(function () { this.applyReceivedImpulse(vector, deltaScrew, english); }, this);
        }
        applyReceivedImpulse(velocity, deltaScrew, english, impulseFactor) {
            let cueBall = PoolClub.GameVars.ballArray[0];
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                cueBall.hideHandIcon();
            }
            cueBall.velocity = velocity;
            cueBall.deltaScrew = deltaScrew;
            cueBall.english = english;
            let shotData = {
                cueSpeed: { vx: cueBall.velocity.x, vy: cueBall.velocity.y },
                deltaScrew: { x: cueBall.deltaScrew.x, y: cueBall.deltaScrew.y },
                english: cueBall.english
            };
            PoolClub.MatchManager.ballHasBeenShot(shotData);
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.CUE_HIT, cueBall.velocity.magnitude / 1.9e3);
        }
        onUpTimeOut() {
            if (!this.settingPower) {
                return;
            }
            this.cancelShot();
        }
        updateCueSprite() {
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                return;
            }
            else {
                let playerCue = PoolClub.GameVars.gameData.playerData.equipedCue;
                let adversaryCue = PoolClub.GameVars.adversaryData.equipedCue;
                const playerCueHasIntermittentAnim = PoolClub.RewardsManager.getCueSpriteIntermittent(playerCue);
                const adversaryCueHasIntermittentAnim = PoolClub.RewardsManager.getCueSpriteIntermittent(adversaryCue);
                if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                    if (!playerCueHasIntermittentAnim) {
                        this.doIntermittentCueAnim = false;
                    }
                    else {
                        this.doIntermittentCueAnim = true;
                    }
                    this.cue.play("playerCueLoop");
                }
                else {
                    if (!adversaryCueHasIntermittentAnim) {
                        this.doIntermittentCueAnim = false;
                    }
                    else {
                        this.doIntermittentCueAnim = true;
                    }
                    this.cue.play("adversaryCueLoop");
                }
            }
        }
        aimHelper() {
            if (this.game.device.desktop || (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE && PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY)) {
                return;
            }
            let cueBall = PoolClub.GameVars.ballArray[0];
            let viableBalls = [];
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                const ball = PoolClub.GameVars.ballArray[i];
                if (ball.id === 0 || !ball.active) {
                    continue;
                }
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    if (PoolClub.GuideContainer.currentInstance.isBallProhibited(ball.id)) {
                        continue;
                    }
                }
                if (!this.clearLineOfSight(cueBall.position, ball.position)) {
                    continue;
                }
                viableBalls.push(ball);
            }
            if (viableBalls.length < 1) {
                return;
            }
            viableBalls = this.sortAndPruneViableBalls(viableBalls);
            const dxFinal = viableBalls[0].position.x - cueBall.position.x;
            const dyFinal = viableBalls[0].position.y - cueBall.position.y;
            let angle = Math.atan2(dyFinal, dxFinal) * 180 / Math.PI + 180;
            if (Math.abs(this.angle - angle) > 180) {
                angle -= 360;
            }
            this.angle = angle + -.15 + .3 * Math.random();
            this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
        }
        sortAndPruneViableBalls(viableBalls) {
            let list = [];
            for (let i = 0; i < viableBalls.length; i++) {
                let ball = viableBalls[i];
                let b1Closest = Number.MAX_VALUE;
                let pocketIndex = -1;
                for (let j = 0; j < PoolClub.GameVars.pocketArray.length; j++) {
                    const b1XDiff = ball.position.x - PoolClub.GameVars.pocketArray[j].position.x;
                    const b1YDiff = ball.position.y - PoolClub.GameVars.pocketArray[j].position.y;
                    const b1Dist = b1XDiff * b1XDiff + b1YDiff * b1YDiff;
                    if (b1Dist < b1Closest) {
                        b1Closest = b1Dist;
                        pocketIndex = j;
                    }
                }
                list.push({ index: i, distance: b1Closest, pocketIndex: pocketIndex });
            }
            list = list.sort((n1, n2) => n1.distance - n2.distance);
            let answer = [];
            let culledBalls = [];
            for (let i = 0; i < list.length; i++) {
                const ballIndex = list[i].index;
                const pocketIndex = list[i].pocketIndex;
                const ball = viableBalls[ballIndex];
                const pocket = PoolClub.GameVars.pocketArray[pocketIndex];
                if (!this.clearLineOfSight(ball.position, pocket.position, ball.position)) {
                    culledBalls.push(viableBalls[ballIndex]);
                    continue;
                }
                else {
                    answer.push(viableBalls[ballIndex]);
                }
            }
            return answer.length > 0 ? answer : culledBalls;
        }
        clearLineOfSight(start, target, excludeBallPos) {
            if (!excludeBallPos) {
                excludeBallPos = target;
            }
            let c = new Billiard.Point(start.x, start.y);
            let p = new Billiard.Point(target.x, target.y);
            let g = 2 * PoolClub.GameConstants.BALL_RADIUS;
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                const ball = PoolClub.GameVars.ballArray[i];
                if (ball.id === 0 || ball.position === excludeBallPos || !ball.active) {
                    continue;
                }
                let u = new Billiard.Point(ball.position.x, ball.position.y);
                var h = Billiard.Maths.lineIntersectCircle(c, p, u, g);
                if (h.intersects) {
                    return false;
                }
            }
            return true;
        }
        applyImpulse() {
            let cueBall = PoolClub.GameVars.ballArray[0];
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                cueBall.hideHandIcon();
            }
            cueBall.velocity = this.aimDirectionVector.times(this.impulseFactor * CueContainer.MAX_IMPULSE);
            this.impulseFactor = 0;
            let screw;
            if (PoolClub.GameVars.verticalSpin > 0) {
                screw = .035;
            }
            else if (PoolClub.GameVars.verticalSpin < 0) {
                screw = .0425;
            }
            else {
                screw = 0;
            }
            cueBall.deltaScrew = this.aimDirectionVector.times(cueBall.velocity.magnitude * screw * PoolClub.GameVars.verticalSpin);
            cueBall.english = PoolClub.GameVars.english;
            let shotData = {
                cueSpeed: { vx: cueBall.velocity.x, vy: cueBall.velocity.y },
                deltaScrew: { x: cueBall.deltaScrew.x, y: cueBall.deltaScrew.y },
                english: cueBall.english
            };
            PoolClub.MatchManager.ballHasBeenShot(shotData);
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.CUE_HIT, cueBall.velocity.magnitude / 1.9e3);
        }
        animateCue() {
            if (this.doIntermittentCueAnim) {
                if (this.doIntermittentCueAnimCounter < 0) {
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                        this.cue.play("cueLoop", 24, false);
                    }
                    else {
                        if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                            this.cue.play("playerCueLoop", 24, false);
                        }
                        else {
                            this.cue.play("adversaryCueLoop", 24, false);
                        }
                    }
                    this.doIntermittentCueAnimCounter = this.game.rnd.realInRange(2, 8);
                }
                else {
                    this.doIntermittentCueAnimCounter -= this.game.time.physicsElapsed;
                }
            }
        }
        onDownDesktop() {
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                    if (PoolClub.SpinCircleLayer.discardClick) {
                        PoolClub.SpinCircleLayer.discardClick = false;
                    }
                }
            }
            else {
                if (PoolClub.SpinCircleLayer.discardClick) {
                    PoolClub.SpinCircleLayer.discardClick = false;
                }
            }
            if (this.downTimer < 0) {
                this.downTimer = 0.15;
            }
            this.settingPower = true;
            this.down_px = this.game.input.activePointer.x;
            this.down_py = this.game.input.activePointer.y;
        }
        cancelShot() {
            this.cue.x = 0;
            this.impulseFactor = 0;
            this.settingPower = false;
            const cueBall = PoolClub.GameVars.ballArray[0];
            if (cueBall.handIcon) {
                cueBall.handIcon.visible = true;
            }
        }
        onDownTouch() {
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                    if (PoolClub.SpinCircleLayer.discardClick) {
                        PoolClub.SpinCircleLayer.discardClick = false;
                    }
                }
            }
            else {
                if (PoolClub.SpinCircleLayer.discardClick) {
                    PoolClub.SpinCircleLayer.discardClick = false;
                }
            }
        }
        onUp(pointer) {
            if (PoolClub.GameVars.shotRunning || PoolClub.SpinCircleLayer.currentInstance.visible || PoolClub.SpinCircleLayer.discardClick ||
                this.settingPower || PoolClub.GameVars.paused ||
                PoolClub.GameVars.GUIButtonDown) {
                if (PoolClub.GameVars.GUIButtonDown) {
                    PoolClub.GameVars.GUIButtonDown = false;
                }
                return;
            }
            if (pointer.timeUp - pointer.timeDown < 300) {
                let cueBall = PoolClub.GameVars.ballArray[0];
                let px = (pointer.x - this.parent.x) / PoolClub.GameConstants.PHYS_SCALE * PoolClub.GameVars.scaleXMultInverse;
                let py = (pointer.y - this.parent.y) / PoolClub.GameConstants.PHYS_SCALE * PoolClub.GameVars.scaleYMultInverse;
                let dx;
                let dy;
                for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                    let ball = PoolClub.GameVars.ballArray[i];
                    if (ball.id !== 0) {
                        dx = ball.position.x - px;
                        dy = ball.position.y - py;
                        let d = Math.sqrt(dx * dx + dy * dy);
                        if (d < 2.5 * PoolClub.GameConstants.BALL_RADIUS) {
                            px = ball.position.x;
                            py = ball.position.y;
                            break;
                        }
                    }
                }
                dx = px - cueBall.position.x;
                dy = py - cueBall.position.y;
                let angle = Math.atan2(dy, dx) * 180 / Math.PI + 180;
                angle += -.15 + .3 * Math.random();
                if (Math.abs(this.angle - angle) > 180) {
                    angle -= 360;
                }
                this.game.add.tween(this)
                    .to({ angle: angle }, 180, Phaser.Easing.Cubic.Out, true)
                    .onUpdateCallback(function () {
                    this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                }, this)
                    .onComplete.add(this.transmitCueRotation, this);
            }
        }
        transmitCueRotation() {
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE && PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                if (Math.abs(this.rotation - this.lastRotationTransmitted) > CueContainer.DELTA_ROTATIION && this.game.time.time - this.timeRotationTransmitted > CueContainer.DELTA_TIME) {
                    this.timeRotationTransmitted = this.game.time.time;
                    this.lastRotationTransmitted = this.rotation;
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                        PoolClub.MatchManagerPVP.cueRotated(this.rotation);
                    }
                }
            }
        }
    }
    CueContainer.MAX_IMPULSE = 2200;
    CueContainer.MAX_DELTA_CUE = 150;
    CueContainer.DELTA_ROTATIION = 5 / 180 * Math.PI;
    CueContainer.DELTA_TIME = 1250;
    PoolClub.CueContainer = CueContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class DebugObjectsContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "debug-objects-container");
            this.graphics = new Phaser.Graphics(this.game);
            this.add(this.graphics);
            this.cueBallGraphics = new Phaser.Graphics(this.game);
            this.add(this.cueBallGraphics);
        }
        drawCircle(p, radius, color) {
            this.graphics.lineStyle(1, color);
            this.graphics.drawCircle(p.x * PoolClub.GameConstants.PHYS_SCALE, p.y * PoolClub.GameConstants.PHYS_SCALE, 2 * radius * PoolClub.GameConstants.PHYS_SCALE);
        }
        clearCueBallGraphics() {
            this.cueBallGraphics.clear();
        }
        drawCueBallTrajectoryPoint(p, color) {
            this.cueBallGraphics.lineStyle(1, color, 1);
            this.cueBallGraphics.beginFill(color, 1);
            this.cueBallGraphics.drawCircle(p.x * PoolClub.GameConstants.PHYS_SCALE, p.y * PoolClub.GameConstants.PHYS_SCALE, 5);
            this.cueBallGraphics.endFill();
        }
        drawPoint(p, color) {
            this.graphics.lineStyle(1, color, 1);
            this.graphics.beginFill(color, 1);
            this.graphics.drawCircle(p.x * PoolClub.GameConstants.PHYS_SCALE, p.y * PoolClub.GameConstants.PHYS_SCALE, 5);
            this.graphics.endFill();
        }
        drawLine(p1, p2, color) {
            this.graphics.lineStyle(1, color, 1);
            this.graphics.moveTo(p1.x * PoolClub.GameConstants.PHYS_SCALE, p1.y * PoolClub.GameConstants.PHYS_SCALE);
            this.graphics.lineTo(p2.x * PoolClub.GameConstants.PHYS_SCALE, p2.y * PoolClub.GameConstants.PHYS_SCALE);
        }
    }
    DebugObjectsContainer.WHITE = 0xFFFFFF;
    DebugObjectsContainer.RED = 0xFF0000;
    DebugObjectsContainer.GREEN = 0x00FF00;
    DebugObjectsContainer.BLUE = 0x0000FF;
    DebugObjectsContainer.YELLOW = 0xFFFF00;
    PoolClub.DebugObjectsContainer = DebugObjectsContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class GuideContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "guide-container");
            GuideContainer.currentInstance = this;
            this.guide = new Phaser.Graphics(this.game);
            this.add(this.guide);
            this.prohibitedBalls = [];
            this.guideWidth = 2;
            this.guideAlpha = 1;
            this.alpha = 0;
            this.game.add.tween(this)
                .to({ alpha: 1 }, 300, Phaser.Easing.Cubic.Out, true);
        }
        update() {
            super.update();
            if (PoolClub.GameVars.shotRunning || !PoolClub.GameVars.startMatch) {
                return;
            }
            this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
            let cueBallPos = PoolClub.GameVars.ballArray[0].position;
            let distantPoint = cueBallPos.plus(PoolClub.CueContainer.currentInstance.aimDirectionVector.times(5e5));
            let distantPointPosition = new Billiard.Point(distantPoint.x, distantPoint.y);
            let intersectedBalls = [];
            let intersectionPoints = [];
            let cueBallCenter = new Billiard.Point(cueBallPos.x, cueBallPos.y);
            for (let i = 1, ln = PoolClub.GameVars.ballArray.length; i < ln; i++) {
                let ball = PoolClub.GameVars.ballArray[i];
                if (ball.active) {
                    let ballPosition = new Billiard.Point(ball.position.x, ball.position.y);
                    let intersection = Billiard.Maths.lineIntersectCircle(cueBallCenter, distantPointPosition, ballPosition, 2 * PoolClub.GameConstants.BALL_RADIUS);
                    if (intersection.intersects) {
                        intersectedBalls.push(ball);
                        if (intersection.enter !== null) {
                            intersectionPoints.push(intersection.enter);
                        }
                    }
                }
            }
            let touchedBall;
            let circleCenter = null;
            if (intersectedBalls.length > 0) {
                let minSquaredDistance = 1e10;
                for (let i = 0, ln = intersectedBalls.length; i < ln; i++) {
                    let squaredDistance = (intersectedBalls[i].position.x - cueBallPos.x) * (intersectedBalls[i].position.x - cueBallPos.x) + (intersectedBalls[i].position.y - cueBallPos.y) * (intersectedBalls[i].position.y - cueBallPos.y);
                    if (squaredDistance < minSquaredDistance) {
                        minSquaredDistance = squaredDistance;
                        touchedBall = intersectedBalls[i];
                        circleCenter = intersectionPoints[i];
                    }
                }
                this.guide.clear();
                this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                this.guide.moveTo(cueBallPos.x * PoolClub.GameConstants.PHYS_SCALE, cueBallPos.y * PoolClub.GameConstants.PHYS_SCALE);
                if (circleCenter) {
                    this.guide.lineTo(circleCenter.x * PoolClub.GameConstants.PHYS_SCALE, circleCenter.y * PoolClub.GameConstants.PHYS_SCALE);
                }
                let drawTrajectoryLines = true;
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    if (!PoolClub.GameVars.laserGuideActive) {
                        if (this.isBallProhibited(touchedBall.id)) {
                            this.guide.lineStyle(this.guideWidth * 1.35, 0xFF0000, this.guideAlpha);
                            drawTrajectoryLines = false;
                        }
                    }
                }
                if (circleCenter) {
                    this.guide.drawCircle(circleCenter.x * PoolClub.GameConstants.PHYS_SCALE, circleCenter.y * PoolClub.GameConstants.PHYS_SCALE, 2 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE);
                }
                if (drawTrajectoryLines) {
                    if (!circleCenter) {
                        this.guide.clear();
                        return;
                    }
                    let w = Billiard.Maths.findBearing(circleCenter.x - cueBallPos.x, circleCenter.y - cueBallPos.y);
                    let b = Billiard.Maths.findBearing(touchedBall.position.x - circleCenter.x, touchedBall.position.y - circleCenter.y);
                    let P = Math.abs(Billiard.Maths.angleDiff(b, w));
                    let touchedBallLineLength = 5 * PoolClub.GameConstants.BALL_RADIUS * ((90 - P) / 90);
                    if (PoolClub.GameVars.laserGuideActive) {
                        touchedBallLineLength = 80000;
                    }
                    let touchedBallLineEnd = new Billiard.Point(touchedBall.position.x + Math.cos(b * Math.PI / 180) * touchedBallLineLength, touchedBall.position.y + Math.sin(b * Math.PI / 180) * touchedBallLineLength);
                    this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                    this.guide.moveTo(touchedBall.position.x * PoolClub.GameConstants.PHYS_SCALE, touchedBall.position.y * PoolClub.GameConstants.PHYS_SCALE);
                    this.guide.lineTo(touchedBallLineEnd.x * PoolClub.GameConstants.PHYS_SCALE, touchedBallLineEnd.y * PoolClub.GameConstants.PHYS_SCALE);
                    let C = Billiard.Maths.findBearing(circleCenter.x - cueBallPos.x, circleCenter.y - cueBallPos.y);
                    let T = Billiard.Maths.findBearing(touchedBallLineEnd.x - circleCenter.x, touchedBallLineEnd.y - circleCenter.y);
                    P = Billiard.Maths.angleDiff(T, C);
                    let whiteBallLineEnd = 5 * PoolClub.GameConstants.BALL_RADIUS * P / 90;
                    if (PoolClub.GameVars.laserGuideActive) {
                        whiteBallLineEnd = 80000 * P;
                    }
                    let E = T - 90;
                    let M = new Billiard.Point(circleCenter.x + whiteBallLineEnd * Math.cos(E * Math.PI / 180), circleCenter.y + whiteBallLineEnd * Math.sin(E * Math.PI / 180));
                    this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                    this.guide.moveTo(circleCenter.x * PoolClub.GameConstants.PHYS_SCALE, circleCenter.y * PoolClub.GameConstants.PHYS_SCALE);
                    this.guide.lineTo(M.x * PoolClub.GameConstants.PHYS_SCALE, M.y * PoolClub.GameConstants.PHYS_SCALE);
                }
            }
            else {
                for (let i = 0; i < 4; i++) {
                    const intersection = Billiard.Maths.lineIntersectLine(cueBallCenter, distantPointPosition, PoolClub.StageContainer.CUSHION_VERTEXES[i], PoolClub.StageContainer.CUSHION_VERTEXES[i + 1]);
                    if (intersection) {
                        circleCenter = intersection;
                    }
                }
                if (circleCenter) {
                    this.guide.clear();
                    this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                    this.guide.moveTo(cueBallPos.x * PoolClub.GameConstants.PHYS_SCALE, cueBallPos.y * PoolClub.GameConstants.PHYS_SCALE);
                    this.guide.lineTo(circleCenter.x * PoolClub.GameConstants.PHYS_SCALE, circleCenter.y * PoolClub.GameConstants.PHYS_SCALE);
                    this.guide.drawCircle(circleCenter.x * PoolClub.GameConstants.PHYS_SCALE, circleCenter.y * PoolClub.GameConstants.PHYS_SCALE, 2 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE);
                }
            }
        }
        setGuideProhibitedBalls(ballIds, prohibited) {
            for (let i = 0; i < ballIds.length; i++) {
                const index = this.prohibitedBalls.indexOf(ballIds[i]);
                if (prohibited) {
                    if (index < 0) {
                        this.prohibitedBalls.push(ballIds[i]);
                    }
                }
                else {
                    if (index > -1) {
                        this.prohibitedBalls.splice(index, 1);
                    }
                }
            }
        }
        isBallProhibited(ballId) {
            return this.prohibitedBalls.indexOf(ballId) > -1;
        }
    }
    PoolClub.GuideContainer = GuideContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class PocketedBallsTrail extends Phaser.Group {
        constructor(game) {
            super(game, null, "pocketed-balls-trail");
            this.x = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 485 : -485;
            this.y = -PocketedBallsTrail.RAILS_LENGTH / 2;
            this.railTweens = [];
            this.rails = new Phaser.Image(this.game, 0, 0, "texture_atlas_2", "rack_back_01.png");
            this.rails.anchor.x = .5;
            this.add(this.rails);
            this.cover = new Phaser.Image(this.game, 0, 0, "texture_atlas_2", "rack_front_01.png");
            this.cover.anchor.x = .5;
            this.add(this.cover);
            this.rails.scale.x = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 1 : -1;
            this.cover.scale.x = this.rails.scale.x;
        }
        pauseGame() {
            for (let i = 0; i < this.railTweens.length; i++) {
                this.railTweens[i].pause();
            }
        }
        resumeGame() {
            for (let i = 0; i < this.railTweens.length; i++) {
                this.railTweens[i].resume();
            }
        }
        addBall(ball) {
            let numBallsWaiting = 0;
            for (let i = 1; i < PoolClub.GameVars.ballArray.length; i++) {
                if (PoolClub.GameVars.ballArray[i].waitingToTheRail) {
                    numBallsWaiting++;
                }
            }
            ball.mc.shade.frameName = "shade_potted_ball.png";
            ball.waitingToTheRail = true;
            const delay = 1500 + 500 * numBallsWaiting + Math.round(150 * Math.random());
            const numPocketedBalls = this.children.length - 2 + numBallsWaiting;
            this.game.time.events.add(delay, function () {
                ball.waitingToTheRail = false;
                ball.mc.pocketTween = true;
                ball.mc.scale.set(PocketedBallsTrail.SCALE_FACTOR);
                ball.mc.position.set(0, 20);
                ball.shadow.destroy();
                this.addAt(ball.mc, 1);
                const vy = 2.5 + .65 * Math.random();
                const dy = PocketedBallsTrail.RAILS_LENGTH - numPocketedBalls * PoolClub.GameConstants.BALL_RADIUS * 2 * PoolClub.GameConstants.PHYS_SCALE - 8;
                const t = dy / vy * 1000 / 60 * (1 / PocketedBallsTrail.SCALE_FACTOR);
                ball.velocity = new Billiard.Vector2D(0, vy);
                const railTween = this.game.add.tween(ball.mc)
                    .to({ y: dy }, t, Phaser.Easing.Linear.None, true);
                railTween.onComplete.add(function () {
                    ball.mc.pocketTween = false;
                    ball.velocity = new Billiard.Vector2D(0, 0);
                    if (numPocketedBalls !== 0) {
                        PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BALL_HIT, .015);
                    }
                    const i = this.railTweens.indexOf(railTween);
                    this.railTweens.splice(i, 1);
                }, this);
                this.railTweens.push(railTween);
            }, this);
        }
        changeSide() {
            this.x = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 485 : -485;
            this.rails.scale.x = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 1 : -1;
            this.cover.scale.x = this.rails.scale.x;
        }
        setPocketedBalls() {
            for (let i = 0; i < PoolClub.GameVars.pocketedBalls.length; i++) {
                let ballId = PoolClub.GameVars.pocketedBalls[i];
                for (let j = 1; j < PoolClub.GameVars.ballArray.length; j++) {
                    let ball = PoolClub.GameVars.ballArray[j];
                    if (ballId === PoolClub.GameVars.ballArray[j].id) {
                        ball.mc.shade.frameName = "shade_potted_ball.png";
                        ball.mc.position.set(0, PocketedBallsTrail.RAILS_LENGTH - i * PoolClub.GameConstants.BALL_RADIUS * 2 * PoolClub.GameConstants.PHYS_SCALE - 8);
                        ball.mc.scale.set(PocketedBallsTrail.SCALE_FACTOR);
                        this.add(ball.mc);
                    }
                }
            }
        }
    }
    PocketedBallsTrail.RAILS_LENGTH = 448;
    PocketedBallsTrail.SCALE_FACTOR = .9;
    PoolClub.PocketedBallsTrail = PocketedBallsTrail;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class PoolState extends Phaser.State {
        init() {
            PoolState.currentInstance = this;
            this.playerSetPVP = false;
            this.victoryLayer = null;
            this.loseLayer = null;
            this.adversaryLeftLayer = null;
            this.notificationLayer = null;
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.MatchManagerSolo.init(this.game);
            }
        }
        create() {
            this.createStage();
            if (PoolClub.GameVars.playerPoints === 0) {
                this.game.camera.flash(0x203161, 750);
            }
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            PoolClub.AudioManager.stopMusic(PoolClub.AudioManager.INTRO_TITLE, true);
            PoolClub.AudioManager.playMusic(PoolClub.AudioManager.SOUNDTRACK, true);
        }
        shutdown() {
            PoolState.currentInstance = null;
            super.shutdown();
        }
        update() {
            PoolClub.MatchManager.update();
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                if (!this.playerSetPVP) {
                    PoolClub.MatchManagerPVP.playerSet();
                    this.playerSetPVP = true;
                }
            }
            super.update();
        }
        createStage() {
            const background = this.add.image(PoolClub.GameConstants.GAME_WIDTH / 2, PoolClub.GameConstants.GAME_HEIGHT / 2, "texture_atlas_2", "background.png");
            background.anchor.set(.5);
            background.scale.set(PoolClub.GameConstants.GAME_WIDTH / background.width, PoolClub.GameConstants.GAME_HEIGHT / background.height);
            this.stageContainer = new PoolClub.StageContainer(this.game);
            this.add.existing(this.stageContainer);
            this.hud = new PoolClub.HUD(this.game);
            this.add.existing(this.hud);
            this.gui = new PoolClub.GUI(this.game);
            this.add.existing(this.gui);
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                this.pocketEffect = new Phaser.Image(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, 160, "texture_atlas_1", "timer_up_arrow.png");
                this.pocketEffect.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                this.pocketEffect.alpha = 0;
                this.pocketEffect.scale.y = .2;
                this.pocketEffect.anchor.set(.5, 1);
                this.add.existing(this.pocketEffect);
                this.effectOnTween = false;
            }
            this.groupMessagesLayer = new Phaser.Group(this.game);
            this.add.existing(this.groupMessagesLayer);
            this.groupPauseLayers = new Phaser.Group(this.game);
            this.add.existing(this.groupPauseLayers);
            this.spinCircleLayer = new PoolClub.SpinCircleLayer(this.game);
            this.groupPauseLayers.add(this.spinCircleLayer);
            if (PoolClub.GameVars.startMatch) {
                throw "Match already started";
            }
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.GameVars.timeMatch = Date.now();
            }
            this.startGame();
        }
        startGame() {
            if (PoolClub.GameVars.canStart) {
                return;
            }
            PoolClub.GameVars.startMatch = true;
            PoolClub.GameVars.canStart = true;
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.MatchManagerSolo.startGame();
            }
            else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                PoolClub.MatchManagerPVP.startGame();
            }
            else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                PoolClub.MatchManagerPVBot.startGame();
            }
            else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.NO_GAME) {
                throw "No game mode selected";
            }
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.gameEnded === PoolClub.GameConstants.GAME_UNDECIDED) {
                    PoolClub.MatchManagerSolo.startSoloTime();
                }
                else {
                    this.endGame();
                    return;
                }
            }
            this.startStage();
        }
        ballPocketed(ballId) {
            this.hud.ballPocketed(ballId);
        }
        updateBallsHUD() {
            this.hud.updateBallsHUD();
        }
        startStage() {
            this.stageContainer.start();
            this.hud.start();
            this.gui.start();
        }
        showSpinCircleLayer() {
            this.stageContainer.pauseGame();
            this.spinCircleLayer.show();
        }
        onNonSoloTimeOut(playerTurn) {
            this.hideSpinCircleLayer();
            if (this.game.device.touch && !playerTurn) {
                this.gui.forceSettingContainer.disable();
                this.gui.forceSettingContainer.hide();
            }
        }
        hideSpinCircleLayer() {
            this.stageContainer.resumeGame();
            this.gui.setRedPointPosition();
            this.spinCircleLayer.hide();
        }
        resetSpinCircleLayer() {
            this.spinCircleLayer.reset();
        }
        pauseGame() {
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                this.hideNotificationLayer();
            }
            this.pauseLayer = new PoolClub.PauseLayer(this.game);
            this.groupPauseLayers.add(this.pauseLayer);
            this.stageContainer.pauseGame();
        }
        resumeGame() {
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            this.stageContainer.resumeGame();
        }
        showVictoryLayer(victoryData) {
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.stageContainer.hideGuide("Showing victory layer");
            this.stageContainer.hideCue("Showing victory layer");
            this.stageContainer.hideSelectPocket("Showing victory layer");
            PoolState.currentInstance.victoryLayer = new PoolClub.VictoryLayer(this.game);
            PoolState.currentInstance.victoryLayer.init(victoryData);
            this.groupPauseLayers.add(PoolState.currentInstance.victoryLayer);
        }
        hideVictoryLayer() {
            PoolState.currentInstance.victoryLayer.destroy();
            PoolState.currentInstance.endGame();
        }
        showLoseLayer(victoryData) {
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.stageContainer.hideGuide("Showing lose layer");
            this.stageContainer.hideCue("Showing lose layer");
            this.stageContainer.hideSelectPocket("Showing lose layer");
            PoolState.currentInstance.loseLayer = new PoolClub.LosePVPLayer(this.game);
            this.groupPauseLayers.add(PoolState.currentInstance.loseLayer);
        }
        hideLoseLayer() {
            PoolState.currentInstance.loseLayer.destroy();
            this.endGame();
        }
        showAdversaryLeftLayer() {
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.stageContainer.hideGuide("Showing adversary left layer");
            this.stageContainer.hideCue("Showing adversary left layer");
            this.stageContainer.hideSelectPocket("Showing adversary left layer");
            let cueBall = PoolClub.GameVars.ballArray[0];
            cueBall.hideHandIcon();
            PoolState.currentInstance.adversaryLeftLayer = new PoolClub.AdversaryLeftLayer(this.game);
            this.groupPauseLayers.add(PoolState.currentInstance.adversaryLeftLayer);
        }
        hideAdversaryLeftLayer() {
            PoolState.currentInstance.adversaryLeftLayer.destroy();
            this.endGame();
        }
        showSoloRetryLayer() {
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.stageContainer.hideGuide("Showing retry layer");
            this.stageContainer.hideCue("Showing retry layer");
            this.soloRetryLayer = new PoolClub.RetrySoloLayer(this.game);
            this.groupPauseLayers.add(this.soloRetryLayer);
        }
        hideRetryLayer() {
            this.stageContainer.resumeGame();
            this.soloRetryLayer.destroy();
        }
        showNotificationLayer(type, isPlayerTurn, opponentChoosingPocket) {
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            this.notificationLayer = new PoolClub.NotificationLayer(this.game, type, isPlayerTurn, opponentChoosingPocket);
            this.groupMessagesLayer.add(this.notificationLayer);
        }
        hideNotificationLayer() {
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
        }
        endGame() {
            PoolClub.GameManager.enterSplash();
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            }
        }
        newTurn() {
            this.gui.newTurn();
            this.stageContainer.newTurn();
        }
        changePowerBar() {
            this.pauseLayer.changePower();
            if (this.gui.forceSettingContainer !== null) {
                this.gui.forceSettingContainer.changeSide();
            }
            this.stageContainer.pocketedBallsTrail.changeSide();
        }
        showPocketEffect(cueBallPocketed) {
            this.pocketEffect.frameName = cueBallPocketed ? "minus.png" : "timer_up_arrow.png";
            this.pocketEffect.scale.y = PoolClub.GameVars.scaleYMult * .2;
            this.pocketEffect.x = cueBallPocketed ? PoolClub.GameConstants.GAME_WIDTH / 2 + 360 : PoolClub.GameConstants.GAME_WIDTH / 2;
            this.pocketEffect.y = cueBallPocketed ? 20 : 125;
            this.pocketEffect.anchor.y = cueBallPocketed ? 0 : 1;
            let endY = cueBallPocketed ? 60 : 85;
            if (!this.effectOnTween) {
                this.effectOnTween = true;
                this.game.add.tween(this.pocketEffect.scale)
                    .to({ y: PoolClub.GameVars.scaleYMult }, 500, Phaser.Easing.Cubic.In, true);
                let tweenA = this.game.add.tween(this.pocketEffect)
                    .to({ alpha: 1 }, 500, Phaser.Easing.Cubic.In, true);
                let tweenB = this.game.add.tween(this.pocketEffect)
                    .to({ y: endY, alpha: 0 }, 500, Phaser.Easing.Cubic.Out);
                tweenA.chain(tweenB);
                this.game.time.events.add(1125, function () {
                    this.effectOnTween = false;
                }, this);
            }
        }
        changePowerBarSide() {
            if (this.gui.forceSettingContainer) {
                this.gui.forceSettingContainer.changeSide();
            }
        }
        showAdversaryEmoticon(emoticonID) {
        }
        onPlayerEmoticonShown() {
            this.game.time.events.add(1500, function () {
                this.gui.showChatButton();
            }, this);
        }
    }
    PoolClub.PoolState = PoolState;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class StageContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "stage-container");
            StageContainer.currentInstance = this;
            this.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.position.set(PoolClub.GameConstants.GAME_WIDTH / 2, 365);
            this.pocketedBallsTrail = new PoolClub.PocketedBallsTrail(this.game);
            this.add(this.pocketedBallsTrail);
            this.tunnelContainer = new Phaser.Group(this.game);
            if (PoolClub.GameConstants.DEBUG) {
                this.tunnelContainer.visible = false;
            }
            this.add(this.tunnelContainer);
            this.glows = [];
            for (let i = 0; i < PoolClub.GameVars.pocketArray.length; i++) {
                let glow = new Phaser.Image(this.game, PoolClub.GameVars.pocketArray[i].position.x * PoolClub.GameConstants.PHYS_SCALE, PoolClub.GameVars.pocketArray[i].position.y * PoolClub.GameConstants.PHYS_SCALE, "texture_atlas_1", "glow.png");
                glow.anchor.set(.5);
                glow.alpha = 0;
                glow.visible = false;
                this.add(glow);
                this.glows.push(glow);
            }
            let tableLayer2 = new Phaser.Image(this.game, 0, 0, "texture_atlas_2", "table_fill_1.png");
            tableLayer2.anchor.set(.5);
            if (PoolClub.GameConstants.DEBUG) {
                tableLayer2.visible = false;
            }
            this.add(tableLayer2);
            let tableLayer1 = new Phaser.Graphics(this.game, 0, 0);
            tableLayer1.beginFill(0x3A2A3A);
            tableLayer1.drawRect(-tableLayer2.width * 0.446, -tableLayer2.height * 0.426, tableLayer2.width * 0.892, tableLayer2.height * 0.852);
            this.tunnelContainer.add(tableLayer1);
            this.ballsContainer = new PoolClub.BallsContainer(this.game);
            this.add(this.ballsContainer);
            this.guideContainer = new PoolClub.GuideContainer(this.game);
            this.add(this.guideContainer);
            const tableLayer3 = new Phaser.Image(this.game, 0, 0, "texture_atlas_2", "table_1.png");
            tableLayer3.anchor.set(.5);
            if (PoolClub.GameConstants.DEBUG) {
                tableLayer3.visible = false;
            }
            this.add(tableLayer3);
            this.cueContainer = new PoolClub.CueContainer(this.game);
            this.add(this.cueContainer);
            if (PoolClub.GameConstants.DEBUG) {
                this.addDebugObjectsContainer();
            }
            else {
                this.debugObjectContainer = null;
            }
        }
        static onContact(contactEvent) {
            let ball = contactEvent.ball;
            let contact = {
                collisionType: contactEvent.collisionType,
                type: null,
                target: null,
                targetVelocity: null,
                position: ball.position,
                targetPosition: contactEvent.target.position,
                velocity: null,
                screw: ball.screw,
                deltaScrew: null,
            };
            if (contactEvent.collisionType === Billiard.Engine.BALL) {
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                        PoolClub.MatchManagerPVP.setTouchedBall(ball.id);
                    }
                    else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                        PoolClub.MatchManagerPVBot.setTouchedBall(ball.id);
                    }
                }
                contact.target = contactEvent.target;
                contact.targetVelocity = contactEvent.targetVelocity;
                contact.deltaScrew = contactEvent.deltaScrew;
                contact.type = contactEvent.collisionType;
                ball.contactArray.push(contact);
                const relativeVelocity = contactEvent.ballVelocity.minus(contactEvent.targetVelocity).magnitude;
                let volumeEffect = relativeVelocity / 6e3;
                volumeEffect = volumeEffect > 1 ? 1 : volumeEffect;
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BALL_HIT, volumeEffect);
            }
            else if (contactEvent.collisionType === Billiard.Engine.VERTEX || contactEvent.collisionType === Billiard.Engine.LINE) {
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                        PoolClub.MatchManagerPVP.setTouchedCushion(true);
                    }
                }
                ball.contactArray.push(contact);
                PoolClub.GameVars.wallCollisions.push(ball.id);
                PoolClub.GameVars.wallCollisions = StageContainer.currentInstance.removeDuplicates(PoolClub.GameVars.wallCollisions);
                const normalVelocity = contactEvent.normalVelocity.magnitude;
                let volumeEffect = normalVelocity / 6e3;
                volumeEffect = volumeEffect > 1 ? 1 : volumeEffect;
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.CUSHION_HIT, volumeEffect);
            }
            else if (contactEvent.collisionType === Billiard.Engine.POCKET) {
                ball.active = false;
                ball.contactArray.push(contact);
                if (ball.id === 0) {
                    PoolClub.AudioManager.playEffect(PoolClub.AudioManager.LOSE_POINTS);
                }
                else {
                    PoolClub.AudioManager.playEffect(PoolClub.AudioManager.ADD_TIME);
                }
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.POCKET);
                StageContainer.currentInstance.playPocketAnimation(contactEvent);
            }
        }
        update() {
            if ((PoolClub.GameVars.paused && PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) || !PoolClub.GameVars.startMatch) {
                return;
            }
            if (PoolClub.GameVars.shotRunning) {
                this.billiardEngine.update();
                for (let i = 0, ln = PoolClub.GameVars.ballArray.length; i < ln; i++) {
                    let ball = PoolClub.GameVars.ballArray[i];
                    if (ball.active && ball.velocity.magnitudeSquared !== 0) {
                        ball.mc.x = ball.position.x * PoolClub.GameConstants.PHYS_SCALE;
                        ball.mc.y = ball.position.y * PoolClub.GameConstants.PHYS_SCALE;
                        ball.shadow.x = ball.mc.x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (ball.mc.x / 300);
                        ball.shadow.y = ball.mc.y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (ball.mc.y / 150);
                        ball.mc.updateRotation(ball.velocity.x * PoolClub.GameConstants.PHYS_SCALE * ball.grip, ball.velocity.y * PoolClub.GameConstants.PHYS_SCALE * ball.grip, ball.ySpin);
                    }
                }
            }
            super.update();
        }
        start() {
            this.billiardEngine = new Billiard.Engine(StageContainer.onContact, PoolClub.GameVars.ballArray, PoolClub.GameVars.lineArray, PoolClub.GameVars.vertexArray, PoolClub.GameVars.pocketArray);
            this.billiardEngine.friction = PoolClub.GameConstants.FRICTION;
            this.billiardEngine.ballRadius = PoolClub.GameConstants.BALL_RADIUS;
            this.billiardEngine.pocketRadius = PoolClub.GameConstants.POCKET_RADIUS;
            this.billiardEngine.physScale = PoolClub.GameConstants.PHYS_SCALE;
            this.billiardEngine.minVelocity = PoolClub.GameConstants.MIN_VELOCITY;
            this.billiardEngine.cushionRestitution = PoolClub.GameConstants.CUSHION_RESTITUTION;
            this.billiardEngine.ballRestitution = PoolClub.GameConstants.BALL_RESTITUTION;
            this.ballsContainer.startGame();
            this.pocketedBallsTrail.setPocketedBalls();
            this.showCue("starting match");
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                this.showGuide("your turn");
            }
            else {
                if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                    this.showGuide("your turn");
                }
                else {
                    this.hideGuide("not your turn");
                }
            }
        }
        pauseGame() {
            PoolClub.GameVars.paused = true;
            PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
            this.pocketedBallsTrail.pauseGame();
        }
        resumeGame() {
            PoolClub.GameVars.paused = false;
            this.pocketedBallsTrail.resumeGame();
        }
        removeDuplicates(arr) {
            let unique_array = [];
            for (let i = 0; i < arr.length; i++) {
                if (unique_array.indexOf(arr[i]) === -1) {
                    unique_array.push(arr[i]);
                }
            }
            return unique_array;
        }
        newTurn() {
            this.updateCueSprite();
            this.showCue("Stage container new turn");
            this.cueContainer.aimHelper();
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                    this.showGuide("Stage container new turn and your turn");
                }
                else {
                    this.hideGuide("Stage container new turn and not your turn");
                }
                if (PoolClub.GameVars.skipShowingPocketAndCue) {
                    this.hideGuide("skipShowingPocket");
                    this.hideCue("skipShowingPocket");
                }
            }
            else {
                this.showGuide("Stage container new turn");
            }
            this.ballsContainer.newTurn();
        }
        ballHasBeenShot() {
            this.hideCue("Stage container ball has been shot");
            this.hideGuide("Stage container ball has been shot");
            this.ballsContainer.ballHasBeenShot();
        }
        showSetCueBall(reason) {
            if (reason) {
                PoolClub.GameManager.log("Showing setCueBall because " + reason, null, "purple");
            }
            this.ballsContainer.setCueBall();
        }
        hideGuide(reason) {
            if (reason) {
                PoolClub.GameManager.log("Hiding guide because " + reason, null, "blue");
            }
            this.guideContainer.visible = false;
        }
        showGuide(reason) {
            if (reason) {
                PoolClub.GameManager.log("Showing guide because " + reason, null, "orange");
            }
            this.guideContainer.visible = true;
        }
        setGuideProhibitedBalls(ballIds, prohibited) {
            this.guideContainer.setGuideProhibitedBalls(ballIds, prohibited);
        }
        hideCue(reason) {
            if (reason) {
                PoolClub.GameManager.log("Hiding cue because " + reason, null, "darkblue");
            }
            this.cueContainer.hideCue();
        }
        updateCueSprite() {
            this.cueContainer.updateCueSprite();
        }
        showCue(reason) {
            if (reason) {
                PoolClub.GameManager.log("Showing cue because " + reason, null, "darkorange");
            }
            this.cueContainer.showCueAndUpdatePos();
        }
        showSelectPocket(reason) {
            if (reason) {
                PoolClub.GameManager.log("Showing pocket selector because " + reason, null, "green");
            }
        }
        setRivalPocket(pocketId) {
        }
        hideSelectPocket(reason) {
            if (reason) {
                PoolClub.GameManager.log("Hiding pocket selector because " + reason, null, "darkorange");
            }
        }
        addBallToTrail(ball) {
            this.pocketedBallsTrail.addBall(ball);
        }
        playPocketAnimation(contactEvent) {
            let ball = contactEvent.ball;
            let pocket = contactEvent.target;
            let speed = contactEvent.speed;
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.MatchManagerSolo.ballPocketed(ball);
            }
            else {
                if (ball.id === 8) {
                    PoolClub.GameVars.pocketIdWhereBlackFell = pocket.id;
                }
                if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                    PoolClub.MatchManagerPVP.ballPocketed(ball);
                }
                else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                    PoolClub.MatchManagerPVBot.ballPocketed(ball);
                }
            }
            ball.mc.pocketTween = true;
            if (ball.id === 0) {
                ball.shadow.visible = false;
            }
            else {
                ball.shadow.parent.removeChild(ball.shadow);
            }
            let t;
            if (speed < 1e3) {
                t = 150;
            }
            else if (speed < 2e3) {
                t = 120;
            }
            else if (speed < 3e3) {
                t = 90;
            }
            else if (speed < 5e3) {
                t = 60;
            }
            else {
                t = 30;
            }
            this.game.add.tween(ball.mc.scale)
                .to({ x: .925, y: .925 }, t, Phaser.Easing.Cubic.Out, true);
            ball.velocity = new Billiard.Vector2D((pocket.dropPosition.x - ball.mc.x) / t, (pocket.dropPosition.y - ball.mc.y) / t);
            this.game.add.tween(ball.mc)
                .to({
                x: pocket.dropPosition.x * PoolClub.GameConstants.PHYS_SCALE,
                y: pocket.dropPosition.y * PoolClub.GameConstants.PHYS_SCALE
            }, t, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function () {
                ball.mc.parent.removeChild(ball.mc);
                this.tunnelContainer.add(ball.mc);
                this.game.add.tween(ball.mc.scale)
                    .to({ x: .65, y: .65 }, 1.75 * t, Phaser.Easing.Linear.None, true);
                ball.velocity = new Billiard.Vector2D((.7 * pocket.dropPosition.x - ball.mc.x) / t, (.7 * pocket.dropPosition.y - ball.mc.y) / t);
                let pocketTween = this.game.add.tween(ball.mc)
                    .to({
                    x: 0.7 * pocket.dropPosition.x * PoolClub.GameConstants.PHYS_SCALE,
                    y: 0.7 * pocket.dropPosition.y * PoolClub.GameConstants.PHYS_SCALE
                }, 1.75 * t, Phaser.Easing.Linear.None, true);
                if (ball.id === 0) {
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                        pocketTween.onComplete.add(this.releaseCueBall, this, 0, [contactEvent]);
                    }
                    else {
                        pocketTween.onComplete.add(function () {
                            this.tunnelContainer.removeChild(ball.mc);
                            ball.mc.pocketTween = false;
                            ball.velocity = new Billiard.Vector2D(0, 0);
                        }, this);
                    }
                }
                else {
                    pocketTween.onComplete.add(function () {
                        this.tunnelContainer.removeChild(ball.mc);
                        ball.mc.pocketTween = false;
                        ball.velocity = new Billiard.Vector2D(0, 0);
                    }, this);
                }
            }, this);
        }
        releaseCueBall(ball, tween, args) {
            const cueBall = PoolClub.GameVars.ballArray[0];
            const contactEvent = args[0];
            const pocket = contactEvent.target;
            let outPocketId;
            let outVelocity;
            PoolClub.GameManager.log(pocket.id);
            switch (pocket.id) {
                case 0:
                    outPocketId = 5;
                    outVelocity = new Billiard.Vector2D(-1, -1).normalize().times(200);
                    break;
                case 1:
                    outPocketId = 4;
                    outVelocity = new Billiard.Vector2D(0, -1).normalize().times(200);
                    break;
                case 2:
                    outPocketId = 3;
                    outVelocity = new Billiard.Vector2D(1, -1).normalize().times(200);
                    break;
                case 3:
                    outPocketId = 2;
                    outVelocity = new Billiard.Vector2D(-1, 1).normalize().times(200);
                    break;
                case 4:
                    outPocketId = 1;
                    outVelocity = new Billiard.Vector2D(0, 1).normalize().times(200);
                    break;
                case 5:
                    outPocketId = 0;
                    outVelocity = new Billiard.Vector2D(1, 1).normalize().times(200);
                    break;
                default:
            }
            const outPocket = PoolClub.GameVars.pocketArray[outPocketId];
            const tweenTime = 200;
            this.game.add.tween(cueBall.mc.scale)
                .to({ x: 1, y: 1 }, tweenTime, Phaser.Easing.Linear.None, true);
            this.game.add.tween(cueBall.mc)
                .to({
                x: outPocket.position.x * PoolClub.GameConstants.PHYS_SCALE,
                y: outPocket.position.y * PoolClub.GameConstants.PHYS_SCALE
            }, tweenTime, Phaser.Easing.Linear.None, true)
                .onComplete.add(function () {
                const x = cueBall.mc.x;
                const y = cueBall.mc.y;
                this.tunnelContainer.removeChild(cueBall.mc);
                this.ballsContainer.add(cueBall.mc);
                cueBall.position.x = x / PoolClub.GameConstants.PHYS_SCALE;
                cueBall.position.y = y / PoolClub.GameConstants.PHYS_SCALE;
                cueBall.velocity = outVelocity;
                cueBall.active = true;
                let glow = this.glows[outPocketId];
                glow.visible = true;
                this.game.add.tween(glow)
                    .to({ alpha: 1 }, 120, Phaser.Easing.Cubic.Out, true, 0, 0, true)
                    .onComplete.add(function () {
                    this.glows[outPocketId].visible = false;
                }, this);
                this.game.time.events.add(200, function () {
                    cueBall.mc.pocketTween = false;
                    cueBall.shadow.visible = true;
                }, this);
            }, this);
        }
        addDebugObjectsContainer() {
            this.debugObjectContainer = new PoolClub.DebugObjectsContainer(this.game);
            this.add(this.debugObjectContainer);
            for (let i = 0; i < PoolClub.GameVars.pocketArray.length; i++) {
                this.debugObjectContainer.drawPoint(PoolClub.GameVars.pocketArray[i].position, PoolClub.DebugObjectsContainer.RED);
                this.debugObjectContainer.drawPoint(PoolClub.GameVars.pocketArray[i].dropPosition, PoolClub.DebugObjectsContainer.GREEN);
                this.debugObjectContainer.drawCircle(PoolClub.GameVars.pocketArray[i].position, PoolClub.GameConstants.POCKET_RADIUS, PoolClub.DebugObjectsContainer.WHITE);
            }
            for (let i = 0; i < PoolClub.GameVars.lineArray.length; i++) {
                this.debugObjectContainer.drawLine(PoolClub.GameVars.lineArray[i].p1, PoolClub.GameVars.lineArray[i].p2, PoolClub.DebugObjectsContainer.GREEN);
                this.debugObjectContainer.drawLine(PoolClub.GameVars.lineArray[i].p3, PoolClub.GameVars.lineArray[i].p4, PoolClub.DebugObjectsContainer.YELLOW);
                this.debugObjectContainer.drawLine(PoolClub.GameVars.lineArray[i].p5, PoolClub.GameVars.lineArray[i].p6, PoolClub.DebugObjectsContainer.BLUE);
            }
        }
    }
    StageContainer.CUSHION_VERTEXES = [
        new Billiard.Point(-42e3 + PoolClub.GameConstants.BALL_RADIUS, -21e3 + PoolClub.GameConstants.BALL_RADIUS),
        new Billiard.Point(42e3 - PoolClub.GameConstants.BALL_RADIUS, -21e3 + PoolClub.GameConstants.BALL_RADIUS),
        new Billiard.Point(42e3 - PoolClub.GameConstants.BALL_RADIUS, 21e3 - PoolClub.GameConstants.BALL_RADIUS),
        new Billiard.Point(-42e3 + PoolClub.GameConstants.BALL_RADIUS, 21e3 - PoolClub.GameConstants.BALL_RADIUS),
        new Billiard.Point(-42e3 + PoolClub.GameConstants.BALL_RADIUS, -21e3 + PoolClub.GameConstants.BALL_RADIUS)
    ];
    PoolClub.StageContainer = StageContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class Ball extends Phaser.Group {
        constructor(game, ballRadius, n, ballObject) {
            super(game, null, "ball");
            this.n = n;
            this.ballObject = ballObject;
            this.pocketTween = false;
            this.ballRotation = [1, 0, 0, 0];
            this.circRad = ballRadius;
            let spriteSheetPrefix;
            if (this.n <= 8) {
                this.ballType = PoolClub.GameConstants.BALL_TYPE_SOLID;
                spriteSheetPrefix = "solid_";
            }
            else {
                this.ballType = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                spriteSheetPrefix = "stripes_";
            }
            this.ballImage = new Phaser.Image(game, 0, 0, "texture_atlas_1", "solid_0.png");
            this.ballImage.anchor.set(.5);
            this.ballImage.width = 2 * this.circRad;
            this.ballImage.height = 2 * this.circRad;
            this.addChild(this.ballImage);
            if (this.ballType === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                this.ballImage.frameName = spriteSheetPrefix + this.n.toString() + ".png";
            }
            else {
                this.ballImage.frameName = spriteSheetPrefix + this.n.toString() + "_0.png";
            }
            this.spotHolder = new Phaser.Group(game);
            this.add(this.spotHolder);
            this.spot = new Phaser.Sprite(game, 0, 0, "texture_atlas_1");
            this.spot.anchor.set(.5);
            this.spot.frameName = "spot_" + n + ".png";
            this.spotHolder.addChild(this.spot);
            this.shade = new Phaser.Image(game, 0, 0, "texture_atlas_1", "shade.png");
            this.shade.anchor.set(.5);
            this.shade.width = 2.2 * this.circRad;
            this.shade.height = 2.2 * this.circRad;
            this.addChild(this.shade);
            this.updateRotation(10 * Math.random() - 5, 10 * Math.random() - 5, 10 * Math.random() - 5);
        }
        update() {
            if (PoolClub.PoolState.currentInstance.victoryLayer || PoolClub.PoolState.currentInstance.loseLayer) {
                if (this.pocketTween) {
                    PoolClub.StageContainer.currentInstance.pauseGame();
                    this.pocketTween = false;
                }
                return;
            }
            if (this.pocketTween) {
                this.updateRotation(this.ballObject.velocity.x, this.ballObject.velocity.y, 0);
            }
            super.update();
        }
        updateRotation(t, s, h) {
            let r = Math.sqrt(t * t + h * h + s * s);
            if (r > 0.1) {
                this.ballRotation = this.rotateQuat(this.ballRotation, h / r, -t / r, s / r, r / this.circRad);
                this.ballRotation = this.normalize(this.ballRotation);
                this.renderBall(this.ballRotation);
            }
        }
        rotateQuat(t, s, h, i, a) {
            let o = Math.sqrt(s * s + h * h + i * i);
            let r = s / o;
            let e = h / o;
            let l = i / o;
            let p = Math.sin(.5 * a);
            let n = r * p;
            let d = e * p;
            let c = l * p;
            let M = Math.cos(.5 * a);
            let P = t[0];
            let y = t[1];
            let H = t[2];
            let R = t[3];
            let g = P * M + y * c - H * d + R * n;
            let b = -P * c + y * M + H * n + R * d;
            let u = P * d - y * n + H * M + R * c;
            let m = -P * n - y * d - H * c + R * M;
            return [g, b, u, m];
        }
        renderBall(q) {
            const qy = q[0];
            const qx = q[1];
            const qz = q[2];
            const qw = q[3];
            const rotationY = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz) + Math.PI;
            const rotationX = Math.asin(2 * qx * qy + 2 * qz * qw) + Math.PI;
            const test = qx * qy + qz * qw;
            if (!(test > .499 || test < -.499)) {
                this.angle = Billiard.Maths._180_DIV_PI * rotationY;
                this.shade.angle = -this.angle;
                if (this.ballType === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                    const v = (rotationX - Billiard.Maths.PI_2) / Math.PI;
                    const rotationIndex = 41 - Math.round(41 * v);
                    this.ballImage.frameName = "stripes_" + (this.n) + "_" + rotationIndex.toString() + ".png";
                }
                if (this.spotHolder) {
                    const rotationZ = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz) + Math.PI;
                    if (rotationX < Billiard.Maths.PI_2 || rotationX > 3 * Billiard.Maths.PI_2) {
                        if (rotationZ > Billiard.Maths.PI_2 && rotationZ < 3 * Billiard.Maths.PI_2) {
                            this.spotHolder.y = this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = this.circRad * Math.sin(rotationZ);
                        }
                        else {
                            this.spotHolder.y = -this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = -this.circRad * Math.sin(rotationZ);
                        }
                    }
                    else {
                        if (rotationZ > Billiard.Maths.PI_2 && rotationZ < 3 * Billiard.Maths.PI_2) {
                            this.spotHolder.y = -this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = -this.circRad * Math.sin(rotationZ);
                        }
                        else {
                            this.spotHolder.y = this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = this.circRad * Math.sin(rotationZ);
                        }
                    }
                    const dist = Math.sqrt(this.spotHolder.x * this.spotHolder.x + this.spotHolder.y * this.spotHolder.y);
                    const distRatio = dist / this.circRad;
                    const scaleY = Math.cos(distRatio * Billiard.Maths.PI_2);
                    const spotDir = Math.atan2(this.spotHolder.y, this.spotHolder.x);
                    if (scaleY < 0.1) {
                        this.spotHolder.visible = false;
                    }
                    else {
                        const spotScale = 0.8;
                        this.spotHolder.visible = true;
                        this.spotHolder.scale.set(.8, scaleY * spotScale);
                    }
                    this.spotHolder.angle = Billiard.Maths._180_DIV_PI * spotDir + 90;
                    this.spot.angle = -this.spotHolder.angle;
                }
            }
        }
        normalize(t) {
            let s = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2] + t[3] * t[3]);
            return [t[0] / s, t[1] / s, t[2] / s, t[3] / s];
        }
    }
    PoolClub.Ball = Ball;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class BallObject {
        constructor(game, n, x, y, active) {
            this.game = game;
            this.id = n;
            this.active = active;
            if (this.active) {
                this.shadow = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "shadow.png");
                this.shadow.anchor.set(.5);
            }
            else {
                this.shadow = null;
            }
            this.mc = new PoolClub.Ball(this.game, PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE, n, this);
            this.position = new Billiard.Vector2D(x, y);
            this.velocity = new Billiard.Vector2D(0, 0);
            this.lastCollisionObject = null;
            this.firstContact = false;
            this.contactArray = [];
            this.waitingToTheRail = false;
            if (this.id === 0) {
                this.screw = 0;
                this.english = 0;
                this.deltaScrew = new Billiard.Vector2D(0, 0);
            }
            this.grip = 1;
            this.ySpin = 0;
            this.mc.x = this.position.x * PoolClub.GameConstants.PHYS_SCALE;
            this.mc.y = this.position.y * PoolClub.GameConstants.PHYS_SCALE;
            if (this.shadow) {
                this.shadow.x = this.mc.x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.x / 300);
                this.shadow.y = this.mc.y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.y / 150);
            }
        }
        setPosition(x, y) {
            this.mc.x = x;
            this.mc.y = y;
            this.shadow.x = this.mc.x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.x / 300);
            this.shadow.y = this.mc.y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.y / 150);
            this.position.x = this.mc.x / PoolClub.GameConstants.PHYS_SCALE;
            this.position.y = this.mc.y / PoolClub.GameConstants.PHYS_SCALE;
        }
        destroy() {
            this.mc.destroy();
            this.shadow.destroy();
        }
    }
    PoolClub.BallObject = BallObject;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class BallsContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "balls-container");
            BallsContainer.currentInstance = this;
            this.shadowsContainer = new Phaser.Group(this.game);
            this.add(this.shadowsContainer);
        }
        destroy(destroyChildren, soft) {
            BallsContainer.currentInstance = null;
            super.destroy(destroyChildren, soft);
        }
        update() {
            if (!PoolClub.GameVars.startMatch || !PoolClub.GameVars.ballArray) {
                return;
            }
            super.update();
            let cueBall = PoolClub.GameVars.ballArray[0];
            if (PoolClub.GameVars.draggingCueBall) {
                cueBall.update();
            }
            if (PoolClub.GameConstants.DEBUG) {
                PoolClub.StageContainer.currentInstance.debugObjectContainer.drawCueBallTrajectoryPoint(cueBall.position, PoolClub.DebugObjectsContainer.RED);
            }
        }
        startGame() {
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                if (PoolClub.GameVars.ballArray[i].active) {
                    this.add(PoolClub.GameVars.ballArray[i].mc);
                    this.shadowsContainer.add(PoolClub.GameVars.ballArray[i].shadow);
                }
            }
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                this.alpha = 0;
                this.game.add.tween(this)
                    .to({ alpha: 1 }, 500, Phaser.Easing.Cubic.Out, true);
            }
        }
        newTurn() {
            const cueBall = PoolClub.GameVars.ballArray[0];
            cueBall.firstContact = false;
        }
        ballHasBeenShot() {
            if (PoolClub.GameConstants.DEBUG) {
                PoolClub.StageContainer.currentInstance.debugObjectContainer.clearCueBallGraphics();
            }
        }
        removeBalls() {
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                this.remove(PoolClub.GameVars.ballArray[i].mc);
                this.shadowsContainer.remove(PoolClub.GameVars.ballArray[i].shadow);
            }
        }
        resetBalls() {
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                this.add(PoolClub.GameVars.ballArray[i].mc);
                this.shadowsContainer.add(PoolClub.GameVars.ballArray[i].shadow);
            }
        }
        setCueBall() {
            let cueBall = PoolClub.GameVars.ballArray[0];
            if (!cueBall.active) {
                cueBall.active = true;
                cueBall.mc.pocketTween = false;
                cueBall.velocity = new Billiard.Vector2D(0, 0);
                cueBall.grip = 1;
                cueBall.ySpin = 0;
                cueBall.screw = 0;
                cueBall.english = 0;
                cueBall.deltaScrew = new Billiard.Vector2D(0, 0);
                let x = PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[0][0];
                let y = PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[0][1];
                let exceptionalPosition = false;
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    if (PoolClub.GameVars.currentTurn !== PoolClub.GameConstants.ADVERSARY) {
                        while (!PoolClub.CueBallObject.isValidPosition(x, y)) {
                            x = this.game.rnd.realInRange(-38000, 38000);
                            y = this.game.rnd.realInRange(-19000, 19000);
                            exceptionalPosition = true;
                        }
                    }
                }
                cueBall.position = new Billiard.Vector2D(x, y);
                cueBall.mc.scale.set(1);
                cueBall.mc.x = cueBall.position.x * PoolClub.GameConstants.PHYS_SCALE;
                cueBall.mc.y = cueBall.position.y * PoolClub.GameConstants.PHYS_SCALE;
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    if (exceptionalPosition) {
                        if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                            PoolClub.MatchManagerPVP.sendCueBallPosition(cueBall.mc.x, cueBall.mc.y);
                        }
                    }
                }
                cueBall.shadow.visible = true;
                cueBall.shadow.x = cueBall.mc.x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (cueBall.mc.x / 300);
                cueBall.shadow.y = cueBall.mc.y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (cueBall.mc.y / 150);
                this.add(cueBall.mc);
                cueBall.mc.alpha = 0;
                this.game.add.tween(cueBall.mc)
                    .to({ alpha: 1 }, 300, Phaser.Easing.Cubic.Out, true);
            }
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.currentTurn !== PoolClub.GameConstants.ADVERSARY) {
                    PoolClub.GameVars.draggingCueBall = true;
                    cueBall.addHandIcon();
                }
            }
        }
    }
    PoolClub.BallsContainer = BallsContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class CueBallObject extends PoolClub.BallObject {
        constructor(game, n, x, y) {
            super(game, n, x, y, true);
            this.cueBallBig = null;
            this.handIcon = null;
        }
        static changePosition(x, y) {
            let newX = x;
            let newY = y;
            let upperLeftCushionPoint = PoolClub.StageContainer.CUSHION_VERTEXES[0];
            let lowerRightCushionPoint = PoolClub.StageContainer.CUSHION_VERTEXES[2];
            if (x < upperLeftCushionPoint.x) {
                newX = upperLeftCushionPoint.x * .999;
            }
            else if (x > lowerRightCushionPoint.x) {
                newX = lowerRightCushionPoint.x * .999;
            }
            if (y < upperLeftCushionPoint.y) {
                newY = upperLeftCushionPoint.y * .999;
            }
            else if (y > lowerRightCushionPoint.y) {
                newY = lowerRightCushionPoint.y * .999;
            }
            if (PoolClub.GameVars.firstShot && x > -21000) {
                newX = -21000;
            }
            for (let i = 1, ln = PoolClub.GameVars.ballArray.length; i < ln; i++) {
                if (PoolClub.GameVars.ballArray[i].active) {
                    let dx = PoolClub.GameVars.ballArray[i].position.x - newX;
                    let dy = PoolClub.GameVars.ballArray[i].position.y - newY;
                    let d = Math.sqrt(dx * dx + dy * dy);
                    if (d < PoolClub.GameConstants.BALL_RADIUS * 2) {
                        return null;
                    }
                }
            }
            return { x: newX * PoolClub.GameConstants.PHYS_SCALE, y: newY * PoolClub.GameConstants.PHYS_SCALE };
        }
        static isValidPosition(x, y, id) {
            let isValid = true;
            let upperLeftCushionPoint = PoolClub.StageContainer.CUSHION_VERTEXES[0];
            let lowerRightCushionPoint = PoolClub.StageContainer.CUSHION_VERTEXES[2];
            if (PoolClub.GameVars.firstShot) {
                if (x < upperLeftCushionPoint.x || y < upperLeftCushionPoint.y || x > -21000 || y > lowerRightCushionPoint.y) {
                    isValid = false;
                }
            }
            else {
                if (x < upperLeftCushionPoint.x || y < upperLeftCushionPoint.y || x > lowerRightCushionPoint.x || y > lowerRightCushionPoint.y) {
                    isValid = false;
                }
            }
            if (isValid) {
                for (let i = 1, ln = PoolClub.GameVars.ballArray.length; i < ln; i++) {
                    if (PoolClub.GameVars.ballArray[i].active) {
                        if (id && id === PoolClub.GameVars.ballArray[i].id) {
                            continue;
                        }
                        let dx = PoolClub.GameVars.ballArray[i].position.x - x;
                        let dy = PoolClub.GameVars.ballArray[i].position.y - y;
                        let d = Math.sqrt(dx * dx + dy * dy);
                        if (d < PoolClub.GameConstants.BALL_RADIUS * 2) {
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            return isValid;
        }
        update() {
            if (PoolClub.GameVars.draggingCueBall && this.cueBallBig && this.cueBallBig.alpha > 0) {
                let x = (this.game.input.activePointer.x - PoolClub.StageContainer.currentInstance.x) * PoolClub.GameVars.scaleXMultInverse;
                let y = (this.game.input.activePointer.y - PoolClub.StageContainer.currentInstance.y) * PoolClub.GameVars.scaleYMultInverse;
                let point = { x: x, y: y };
                point = CueBallObject.changePosition(x / PoolClub.GameConstants.PHYS_SCALE, y / PoolClub.GameConstants.PHYS_SCALE);
                if (point) {
                    this.cueBallBig.x = point.x;
                    this.cueBallBig.y = point.y;
                    this.mc.x = point.x;
                    this.mc.y = point.y;
                    this.shadow.x = this.mc.x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.x / 300);
                    this.shadow.y = this.mc.y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.y / 150);
                }
            }
            if (this.handIcon) {
                this.handIcon.x = this.mc.x + 30;
                this.handIcon.y = this.mc.y;
            }
        }
        setPositionReceived(x, y) {
            this.game.add.tween(this.mc)
                .to({ x: x, y: y }, 200, Phaser.Easing.Linear.None, true);
            this.game.add.tween(this.shadow)
                .to({
                x: x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (x / 300),
                y: y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (y / 150)
            }, 200, Phaser.Easing.Linear.None, true)
                .onComplete.add(function () {
                PoolClub.CueContainer.currentInstance.showCueAndUpdatePos();
                PoolClub.MatchManager.cueBallSet(x, y);
            }, this);
            this.position.x = x / PoolClub.GameConstants.PHYS_SCALE;
            this.position.y = y / PoolClub.GameConstants.PHYS_SCALE;
        }
        setPositioOnShoot(x, y) {
            this.mc.x = x;
            this.mc.y = y;
            this.shadow.x = x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (x / 300);
            this.shadow.y = y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (y / 150);
            this.position.x = x / PoolClub.GameConstants.PHYS_SCALE;
            this.position.y = y / PoolClub.GameConstants.PHYS_SCALE;
        }
        addHandIcon() {
            if (this.handIcon) {
                this.handIcon.destroy();
                this.handIcon = null;
            }
            this.handIcon = new Phaser.Image(this.game, this.mc.x, this.mc.y, "texture_atlas_1", "hand-icon.png");
            this.handIcon.anchor.set(.5);
            this.handIcon.scale.set(.8);
            PoolClub.StageContainer.currentInstance.add(this.handIcon);
            if (this.cueBallBig) {
                this.cueBallBig.destroy();
                this.cueBallBig = null;
            }
            this.cueBallBig = new Phaser.Image(this.game, this.mc.x, this.mc.y, "texture_atlas_1", "cue_ball.png");
            this.cueBallBig.anchor.set(.5);
            this.cueBallBig.scale.set(0.5);
            this.cueBallBig.alpha = 0;
            if (this.game.device.desktop) {
                const scaleDiff = this.mc.width * this.mc.scale.x / this.cueBallBig.width * this.cueBallBig.scale.x;
                this.cueBallBig.scale.set(scaleDiff);
            }
            this.cueBallBig.inputEnabled = true;
            this.cueBallBig.events.onInputDown.add(this.onDown, this);
            this.cueBallBig.events.onInputUp.add(this.onUp, this);
            PoolClub.StageContainer.currentInstance.add(this.cueBallBig);
            this.handIcon.alpha = 0;
            this.game.add.tween(this.handIcon)
                .to({ alpha: 1 }, 300, Phaser.Easing.Cubic.Out, true);
            this.game.add.tween(this.handIcon.scale)
                .to({ x: 0.9, y: 0.9 }, 500, Phaser.Easing.Cubic.InOut, true, 0, -1, true);
        }
        hideHandIcon() {
            if (!PoolClub.GameVars.draggingCueBall) {
                return;
            }
            PoolClub.GameVars.draggingCueBall = false;
            this.handIcon.destroy();
            this.handIcon = null;
            this.cueBallBig.destroy();
            this.cueBallBig = null;
        }
        onDown() {
            if (this.game.device.desktop) {
                const scaleDiff = this.mc.width * this.mc.scale.x / this.cueBallBig.width * this.cueBallBig.scale.x;
                this.cueBallBig.scale.set(scaleDiff);
                this.mc.alpha = 0;
            }
            PoolClub.BallsContainer.currentInstance.bringToTop(this.mc);
            PoolClub.StageContainer.currentInstance.hideCue("Moving cue ball");
            PoolClub.StageContainer.currentInstance.hideGuide("Moving cue ball");
            this.handIcon.destroy();
            this.handIcon = null;
            this.cueBallBig.alpha = .65;
        }
        onUp() {
            if (!PoolClub.GameVars.draggingCueBall) {
                return;
            }
            PoolClub.StageContainer.currentInstance.showCue("Just placed white ball");
            this.cueBallBig.destroy();
            this.cueBallBig = null;
            this.addHandIcon();
            this.position.x = this.mc.x / PoolClub.GameConstants.PHYS_SCALE;
            this.position.y = this.mc.y / PoolClub.GameConstants.PHYS_SCALE;
            this.mc.alpha = 1;
            PoolClub.MatchManager.cueBallSet(this.mc.x, this.mc.y);
        }
        onUpTimeOut() {
            if (!PoolClub.GameVars.draggingCueBall) {
                return;
            }
            PoolClub.GameVars.draggingCueBall = false;
            this.cueBallBig.destroy();
            this.cueBallBig = null;
            if (this.handIcon) {
                this.handIcon.destroy();
                this.handIcon = null;
            }
            this.mc.x = this.position.x * PoolClub.GameConstants.PHYS_SCALE;
            this.mc.y = this.position.y * PoolClub.GameConstants.PHYS_SCALE;
            this.shadow.x = this.mc.x + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.x / 300);
            this.shadow.y = this.mc.y + .35 * PoolClub.GameConstants.BALL_RADIUS * PoolClub.GameConstants.PHYS_SCALE * (this.mc.y / 150);
            this.mc.alpha = 1;
            PoolClub.MatchManager.cueBallSet(this.mc.x, this.mc.y);
        }
    }
    PoolClub.CueBallObject = CueBallObject;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class CueBallSpinButton extends Phaser.Group {
        constructor(game) {
            super(game, null, "cue-ball-spin-button");
            this.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.cueBallButton = new Phaser.Button(this.game, 0, 0, "texture_atlas_1", this.onUpCueBallButton, this);
            this.cueBallButton.forceOut = true;
            this.cueBallButton.setFrames("btn_spin_on.png", "btn_spin_off.png", "btn_spin_on.png", "btn_spin_off.png");
            if (this.game.device.touch) {
                this.cueBallButton.onInputDown.add(function () {
                    PoolClub.GameVars.GUIButtonDown = true;
                    this.cueBallButton.scale.set(this.cueBallButton.scale.x * 1.1, this.cueBallButton.scale.y * 1.1);
                }, this, 5);
            }
            this.cueBallButton.onInputOver.add(function () { this.cueBallButton.scale.set(this.cueBallButton.scale.x * 1.1, this.cueBallButton.scale.y * 1.1); }, this);
            this.cueBallButton.onInputOut.add(function () { this.cueBallButton.scale.set(1, 1); }, this);
            this.cueBallButton.anchor.set(.5);
            this.add(this.cueBallButton);
            this.redDot = new Phaser.Graphics(this.game, 0, 0);
            this.redDot.beginFill(0xFA2E63);
            this.redDot.drawCircle(0, 0, 7);
            this.add(this.redDot);
        }
        disable() {
            this.cueBallButton.alpha = .6;
            this.cueBallButton.inputEnabled = false;
            this.redDot.x = 0;
            this.redDot.y = 0;
        }
        enable() {
            this.cueBallButton.alpha = 1;
            this.cueBallButton.inputEnabled = true;
            this.redDot.x = 0;
            this.redDot.y = 0;
        }
        setRedPointPosition(english, verticalSpin) {
            if (english && verticalSpin) {
                const x = PoolClub.GUI.CUE_BALL_BUTTON_SCALE * PoolClub.SpinCircleLayer.SPIN_CIRCLE_RADIUS * english;
                const y = -PoolClub.GUI.CUE_BALL_BUTTON_SCALE * PoolClub.SpinCircleLayer.SPIN_CIRCLE_RADIUS * verticalSpin;
                this.game.add.tween(this.cueBallButton.scale)
                    .to({ x: 1.125, y: 1.125 }, 175, Phaser.Easing.Cubic.Out, true, 0, 0, true);
                this.game.add.tween(this.redDot)
                    .to({ x: x, y: y }, 350, Phaser.Easing.Cubic.Out, true, 400);
            }
            else {
                this.redDot.x = PoolClub.GUI.CUE_BALL_BUTTON_SCALE * PoolClub.SpinCircleLayer.SPIN_CIRCLE_RADIUS * PoolClub.GameVars.english;
                this.redDot.y = -PoolClub.GUI.CUE_BALL_BUTTON_SCALE * PoolClub.SpinCircleLayer.SPIN_CIRCLE_RADIUS * PoolClub.GameVars.verticalSpin;
            }
        }
        onUpCueBallButton() {
            this.cueBallButton.scale.set(1, 1);
            if (PoolClub.GameVars.shotRunning || (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE && PoolClub.GameVars.currentTurn !== PoolClub.GameConstants.PLAYER)) {
                return;
            }
            PoolClub.MatchManager.showSpinCircleLayer();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
    }
    PoolClub.CueBallSpinButton = CueBallSpinButton;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class ForceSettingContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "force-setting-container");
            this.x = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 0 : PoolClub.GameConstants.GAME_WIDTH;
            this.y = PoolClub.GameConstants.GAME_HEIGHT / 2 + 40;
            this.canMove = true;
            this.initialY = 0;
            this.powerBarEmpty = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_2", "power_bar_empty.png");
            this.powerBarEmpty.anchor.set(0, .5);
            this.powerBarEmpty.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.powerBarEmpty.inputEnabled = true;
            this.powerBarEmpty.events.onInputDown.add(this.onDownPowerBarEmpty, this);
            this.powerBarEmpty.events.onInputUp.add(this.onUpPowerBarEmpty, this);
            this.add(this.powerBarEmpty);
            this.maskHeight = 505 * PoolClub.GameVars.scaleYMult;
            this.powerMask = new Phaser.Graphics(this.game, 0, -this.maskHeight * 0.5);
            this.powerMask.beginFill(0xffffff);
            this.powerMask.drawRect(0, 0, this.powerBarEmpty.width, this.maskHeight);
            this.add(this.powerMask);
            this.forceBar = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_2", "power_bar_full.png");
            this.forceBar.anchor.set(0, .5);
            this.forceBar.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.forceBar.mask = this.powerMask;
            this.add(this.forceBar);
            this.cue = new Phaser.Sprite(this.game, this.powerBarEmpty.x + this.powerBarEmpty.width * 0.5 - 8, 0, "texture_atlas_1", "cue_power.png");
            this.cue.anchor.set(.5);
            this.cue.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(this.cue);
            if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.RIGHT) {
                this.powerBarEmpty.scale.x *= -1;
                this.forceBar.scale.x *= -1;
                this.powerMask.scale.x *= -1;
                this.cue.scale.x *= -1;
                this.cue.x *= -1;
            }
            this.visible = false;
        }
        update() {
            if (PoolClub.CueContainer.currentInstance.settingPower && this.canMove) {
                let localY = this.game.input.activePointer.y - this.y - this.initialY;
                localY += 230;
                localY = Phaser.Math.clamp(localY, 0, 430);
                PoolClub.CueContainer.currentInstance.impulseFactor = Billiard.Maths.fixNumber(localY / 430);
                this.cue.y = localY;
                this.powerMask.scale.y = 1 - (localY / 430);
                if (this.powerMask.scale.y === 0) {
                    this.powerMask.scale.y = .001;
                }
            }
        }
        changeSide() {
            this.powerBarEmpty.scale.x *= -1;
            this.forceBar.scale.x *= -1;
            this.powerMask.scale.x *= -1;
            this.cue.scale.x *= -1;
            this.cue.x *= -1;
            if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT) {
                if (this.canMove) {
                    this.x = 0;
                }
                else {
                    this.x = -100;
                }
            }
            else {
                if (this.canMove) {
                    this.x = PoolClub.GameConstants.GAME_WIDTH;
                }
                else {
                    this.x = PoolClub.GameConstants.GAME_WIDTH + 100;
                }
            }
        }
        show() {
            this.visible = true;
        }
        hide() {
            this.canMove = false;
            this.game.add.tween(this.cue)
                .to({ y: 0 }, 150, Phaser.Easing.Cubic.Out, true);
            this.game.add.tween(this)
                .to({ x: this.x - (100 * (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 1 : -1)) }, 200, Phaser.Easing.Cubic.In, true, 100);
            this.game.add.tween(this.powerMask.scale)
                .to({ y: 1 }, 150, Phaser.Easing.Cubic.Out, true);
        }
        disable() {
            PoolClub.CueContainer.currentInstance.settingPower = false;
            PoolClub.CueContainer.currentInstance.impulseFactor = 0;
        }
        reset() {
            this.canMove = true;
            this.powerMask.scale.y = 1;
            this.cue.y = 0;
            this.game.add.tween(this)
                .to({ x: PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT ? 0 : PoolClub.GameConstants.GAME_WIDTH }, 200, Phaser.Easing.Cubic.Out, true);
            this.disable();
        }
        onDownPowerBarEmpty() {
            this.initialY = this.game.input.activePointer.y - 110;
            PoolClub.CueContainer.currentInstance.settingPower = true;
        }
        onUpPowerBarEmpty() {
            PoolClub.CueContainer.currentInstance.settingPower = false;
            if (PoolClub.CueContainer.currentInstance.impulseFactor > 0) {
                this.hide();
                PoolClub.CueContainer.currentInstance.shoot();
            }
        }
    }
    PoolClub.ForceSettingContainer = ForceSettingContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class GUI extends Phaser.Group {
        constructor(game) {
            super(game, null, "gui");
            if (PoolClub.GameConstants.DEVELOPMENT) {
                const winButton = new Phaser.Button(this.game, 920, 25, "texture_atlas_0");
                winButton.anchor.set(1.0, 0.5);
                winButton.inputEnabled = true;
                winButton.events.onInputDown.add(this.onClickForceWin, this);
                winButton.setFrames("btn_force_win_on.png", "btn_force_win_off.png", "btn_force_win_on.png");
                winButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                this.add(winButton);
                const loseButton = new Phaser.Button(this.game, 920, 75, "texture_atlas_0");
                loseButton.anchor.set(1.0, 0.5);
                loseButton.inputEnabled = true;
                loseButton.events.onInputDown.add(this.onClickForceLose, this);
                loseButton.setFrames("btn_force_lose_on.png", "btn_force_lose_off.png", "btn_force_lose_on.png");
                loseButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                this.add(loseButton);
                const resetButton = new Phaser.Button(this.game, 150, 40, "texture_atlas_0");
                resetButton.anchor.set(1.0, 0.5);
                resetButton.inputEnabled = true;
                resetButton.events.onInputDown.add(this.onClickForceReset, this);
                resetButton.setFrames("btn_menu_on.png", "btn_menu_off.png", "btn_menu_on.png");
                resetButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                this.add(resetButton);
            }
            let pauseButton_px;
            let cueBallButton_px;
            pauseButton_px = 50 * PoolClub.GameVars.scaleXMult;
            cueBallButton_px = PoolClub.GameConstants.GAME_WIDTH - 50 * PoolClub.GameVars.scaleXMult;
            const pauseButton = new Phaser.Button(this.game, pauseButton_px, 50 * PoolClub.GameVars.scaleYMult, "texture_atlas_1");
            pauseButton.anchor.set(.5);
            pauseButton.events.onInputUp.add(this.onClickPause, this);
            if (this.game.device.touch) {
                pauseButton.onInputDown.add(function () {
                    PoolClub.GameVars.GUIButtonDown = true;
                    pauseButton.scale.set(pauseButton.scale.x * 1.1, pauseButton.scale.y * 1.1);
                }, this, 5);
            }
            pauseButton.onInputOver.add(function () {
                pauseButton.scale.set(pauseButton.scale.x * 1.1, pauseButton.scale.y * 1.1);
            }, this);
            pauseButton.onInputOut.add(function () {
                pauseButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            }, this);
            pauseButton.setFrames("btn_pause_on.png", "btn_pause_off.png", "btn_pause_on.png");
            pauseButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(pauseButton);
            this.cueBallSpinButton = new PoolClub.CueBallSpinButton(this.game);
            this.cueBallSpinButton.x = cueBallButton_px;
            this.cueBallSpinButton.y = 50 * PoolClub.GameVars.scaleYMult;
            this.add(this.cueBallSpinButton);
            if (this.game.device.touch) {
                this.forceSettingContainer = new PoolClub.ForceSettingContainer(this.game);
                this.add(this.forceSettingContainer);
            }
            else {
                this.forceSettingContainer = null;
            }
        }
        setRedPointPosition(english, verticalSpin) {
            this.cueBallSpinButton.setRedPointPosition(english, verticalSpin);
        }
        start() {
            if (this.game.device.touch) {
                if (this.forceSettingContainer) {
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    }
                    else if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    }
                }
            }
            this.checkCueBallButtonValidity();
        }
        newTurn() {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                this.cueBallSpinButton.enable();
            }
            else {
                this.cueBallSpinButton.disable();
            }
            if (this.game.device.touch) {
                if (this.forceSettingContainer) {
                    if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    }
                    else if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    }
                }
            }
            this.checkCueBallButtonValidity();
            PoolClub.MatchManager.resetSpinCircleLayer();
        }
        disableSpinButton() {
            this.cueBallSpinButton.disable();
        }
        checkCueBallButtonValidity() {
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                    this.cueBallSpinButton.enable();
                }
                else {
                    this.cueBallSpinButton.disable();
                }
            }
            else {
                this.cueBallSpinButton.enable();
            }
        }
        onClickPause(b) {
            b.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            PoolClub.MatchManager.showPauseLayer();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
        onClickForceWin() {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            throw "tbi";
        }
        onClickForceLose() {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.GameVars.playerPoints = 0;
                PoolClub.MatchManagerSolo.endSoloGame(PoolClub.GameConstants.PLAYER_LOSE);
            }
        }
        onClickForceReset() {
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
                PoolClub.MatchManagerSolo.reset();
            }
        }
    }
    GUI.CUE_BALL_BUTTON_SCALE = .13;
    PoolClub.GUI = GUI;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class SpinCircleLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "spin-circle");
            SpinCircleLayer.currentInstance = this;
            SpinCircleLayer.discardClick = false;
            this.canMove = false;
            let transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .8;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputUp.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const ballContainer = new Phaser.Group(this.game);
            ballContainer.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            ballContainer.x = PoolClub.GameConstants.GAME_WIDTH / 2;
            ballContainer.y = PoolClub.GameConstants.GAME_HEIGHT / 2;
            this.add(ballContainer);
            const circle = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "cue_ball.png");
            circle.anchor.set(.5);
            circle.inputEnabled = true;
            circle.input.pixelPerfectClick = true;
            circle.input.pixelPerfectAlpha = 0.5;
            circle.events.onInputDown.add(this.onDownCircle, this);
            circle.events.onInputUp.add(this.onUpCircle, this);
            circle.events.onInputOut.add(this.onUpCircle, this);
            ballContainer.add(circle);
            this.redDot = new Phaser.Graphics(this.game, PoolClub.GameVars.english, PoolClub.GameVars.verticalSpin);
            this.redDot.beginFill(0xf1004f);
            this.redDot.drawCircle(0, 0, 40);
            ballContainer.add(this.redDot);
            this.alpha = 0;
            this.visible = false;
            this.game.add.tween(this)
                .to({ alpha: 1 }, 400, Phaser.Easing.Cubic.Out, true);
        }
        show() {
            this.visible = true;
            this.game.add.tween(this)
                .to({ alpha: 1 }, 400, Phaser.Easing.Cubic.Out, true);
        }
        hide() {
            SpinCircleLayer.discardClick = false;
            this.visible = false;
            this.alpha = 0;
        }
        reset() {
            this.redDot.scale.set(1, 1);
            this.redDot.position.set(0, 0);
        }
        destroy() {
            SpinCircleLayer.currentInstance = null;
            SpinCircleLayer.discardClick = false;
            super.destroy();
        }
        update() {
            super.update();
            if (this.canMove) {
                this.redDot.scale.set(3, 3);
                const x = (this.game.input.activePointer.x - PoolClub.GameConstants.GAME_WIDTH / 2) * PoolClub.GameVars.scaleXMultInverse;
                const y = (this.game.input.activePointer.y - PoolClub.GameConstants.GAME_HEIGHT / 2) * PoolClub.GameVars.scaleYMultInverse;
                const d = Math.sqrt(x * x + y * y);
                if (d < SpinCircleLayer.SPIN_CIRCLE_RADIUS) {
                    this.redDot.position.set(x, y);
                }
                else {
                    const dir = new Phaser.Point(x, y).normalize();
                    this.redDot.position.set(dir.x * SpinCircleLayer.SPIN_CIRCLE_RADIUS, dir.y * SpinCircleLayer.SPIN_CIRCLE_RADIUS);
                }
            }
        }
        onDownTransparentLayer() {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            const english = Math.floor(1000 * this.redDot.x / SpinCircleLayer.SPIN_CIRCLE_RADIUS) / 1000;
            const verticalSpin = -Math.floor(1000 * this.redDot.y / SpinCircleLayer.SPIN_CIRCLE_RADIUS) / 1000;
            PoolClub.MatchManager.hideSpinCircleLayer(english, verticalSpin);
        }
        onDownCircle() {
            const x = (this.game.input.activePointer.x - PoolClub.GameConstants.GAME_WIDTH / 2) * PoolClub.GameVars.scaleXMultInverse;
            const y = (this.game.input.activePointer.y - PoolClub.GameConstants.GAME_HEIGHT / 2) * PoolClub.GameVars.scaleYMultInverse;
            const d = Math.sqrt(x * x + y * y);
            this.canMove = true;
        }
        onUpCircle() {
            this.canMove = false;
            this.redDot.scale.set(1, 1);
        }
    }
    SpinCircleLayer.currentInstance = null;
    SpinCircleLayer.discardClick = false;
    SpinCircleLayer.SPIN_CIRCLE_RADIUS = 160;
    PoolClub.SpinCircleLayer = SpinCircleLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class HUD extends Phaser.Group {
        constructor(game) {
            super(game, null, "hud");
            this.x = PoolClub.GameConstants.GAME_WIDTH / 2;
            this.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.sumPoints = false;
            this.counter = 0;
            this.timerSXOffset = 14;
            this.sidesAssigned = false;
            this.sumTime = false;
            this.counterTime = 0;
            const hudBg = new Phaser.Image(this.game, 0, 5, "texture_atlas_1", "hudBg.png");
            hudBg.anchor.set(.5, 0);
            this.add(hudBg);
            this.matchDataContainer = this.game.add.group();
            this.add(this.matchDataContainer);
            this.matchDataContainer.y = -20;
            this.pocketedBalls = [];
            this.createSoloModeHud();
            this.superText = new Phaser.Image(this.game, 0, PoolClub.GameConstants.GAME_HEIGHT * .25, "texture_atlas_2", "superText.png");
            this.superText.anchor.set(.5);
            this.superText.scale.set(0);
            this.superText.alpha = 0;
            this.add(this.superText);
            this.comboText = new Phaser.Image(this.game, 0, PoolClub.GameConstants.GAME_HEIGHT * .25, "texture_atlas_2", "comboText.png");
            this.comboText.anchor.set(.5);
            this.comboText.scale.set(0);
            this.comboText.alpha = 0;
            this.add(this.comboText);
            this.newHighScoreText = new Phaser.Image(this.game, 500, PoolClub.GameConstants.GAME_HEIGHT * .075, "texture_atlas_2", "tab_record.png");
            this.newHighScoreText.anchor.set(.5);
            this.newHighScoreText.alpha = 0;
            this.add(this.newHighScoreText);
            this.rackCompletedEffect = new Phaser.Image(this.game, 500, PoolClub.GameConstants.GAME_HEIGHT * .075, "texture_atlas_2", "tab_rack.png");
            this.rackCompletedEffect.anchor.set(.5);
            this.rackCompletedEffect.alpha = 0;
            this.add(this.rackCompletedEffect);
            this.comboTextTween1 = null;
            this.comboTextTween2 = null;
            if (PoolClub.GameVars.playNewHighScore) {
                this.showHighScoreEffect();
                PoolClub.GameVars.playNewHighScore = false;
            }
            else if (PoolClub.GameVars.playerPoints !== 0) {
                this.showRackCompletedEffect();
            }
        }
        start() {
        }
        update() {
            super.update();
            this.updateSoloScore();
        }
        newTurn() {
            for (let ballId of this.pocketedBalls) {
                this.updateBallSet(ballId);
            }
            if (this.sidesAssigned) {
                this.pocketedBalls = [];
            }
        }
        ballPocketed(id) {
            this.sumPoints = true;
            this.pocketedBalls.push(id);
            this.updateBallSet(id);
        }
        assignSidesForNonSOLO(leftSideType) {
            this.populateBallSetNonSOLO(leftSideType !== PoolClub.GameConstants.BALL_TYPE_SOLID);
        }
        updateBallsHUD() {
            this.ballPocketed();
        }
        updateSoloTimer() {
            if (!this.sumTime) {
                this.timer.text = (Math.max(PoolClub.GameVars.timerSolo, 0)) + "";
                this.updateTimersLabel();
                if (PoolClub.GameVars.timerSolo <= 20) {
                    PoolClub.AudioManager.playEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
                }
                else {
                    PoolClub.AudioManager.stopEffect(PoolClub.AudioManager.TIME_RUNNING_OUT);
                }
            }
        }
        showComboEffect(delay = 0) {
            this.comboTextTween1 = this.game.add.tween(this.comboText.scale)
                .to({ x: 1, y: 1 }, 600, Phaser.Easing.Elastic.Out, true, delay);
            this.comboTextTween1.onStart.add(function () {
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.COMBO_2);
                this.createExplosionArray(this.comboText.x, this.comboText.y + 50, 10);
            }, this);
            this.game.add.tween(this.comboText)
                .to({ alpha: 1 }, 400, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function () {
                this.comboTextTween2 = this.game.add.tween(this.comboText)
                    .to({ alpha: 0 }, 400, Phaser.Easing.Cubic.Out, true, 1800)
                    .onComplete.add(function () {
                    this.comboText.scale.set(0);
                }, this);
            }, this);
        }
        showSuperComboEffect(delay) {
            this.game.add.tween(this.superText.scale)
                .to({ x: 1, y: 1 }, 600, Phaser.Easing.Elastic.Out, true, delay);
            if (this.comboTextTween1) {
                this.comboTextTween1.pendingDelete = true;
            }
            if (this.comboTextTween2) {
                this.comboTextTween2.pendingDelete = true;
            }
            const tween = this.game.add.tween(this.superText);
            tween.to({ alpha: 1 }, 400, Phaser.Easing.Cubic.Out, true, delay);
            tween.onStart.add(function () {
                this.showComboEffect(600);
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.COMBO);
                this.createExplosionArray(this.superText.x, this.superText.y - 30, 10);
            }, this);
            tween.onComplete.add(function () {
                this.game.add.tween(this.superText)
                    .to({ alpha: 0 }, 400, Phaser.Easing.Cubic.Out, true, 800)
                    .onComplete.add(function () {
                    this.superText.scale.set(0);
                }, this);
            }, this);
        }
        showHighScoreEffect() {
            this.alphaHudElements(0);
            this.comboTextTween1 = this.game.add.tween(this.newHighScoreText)
                .to({ x: 35 }, 250, Phaser.Easing.Cubic.Out, true, 250);
            this.game.add.tween(this.newHighScoreText)
                .to({ alpha: 1 }, 250, Phaser.Easing.Linear.None, true);
            this.comboTextTween1.onStart.add(function () {
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.COMBO_2);
            }, this);
            this.comboTextTween1.onComplete.add(function () {
                this.game.add.tween(this.newHighScoreText)
                    .to({ x: -15 }, 1500, Phaser.Easing.Linear.None, true)
                    .onComplete.add(function () {
                    this.game.add.tween(this.newHighScoreText)
                        .to({ x: -200 }, 150, Phaser.Easing.Cubic.In, true);
                    this.game.add.tween(this.newHighScoreText)
                        .to({ alpha: 0 }, 250, Phaser.Easing.Linear.None, true, 100)
                        .onComplete.add(function () {
                        this.alphaHudElements(1);
                        this.newHighScoreText.x = 400;
                    }, this);
                }, this);
            }, this);
        }
        showRackCompletedEffect() {
            this.alphaHudElements(0);
            this.comboTextTween1 = this.game.add.tween(this.rackCompletedEffect)
                .to({ x: 35 }, 250, Phaser.Easing.Cubic.Out, true, 250);
            this.game.add.tween(this.rackCompletedEffect)
                .to({ alpha: 1 }, 250, Phaser.Easing.Linear.None, true);
            this.comboTextTween1.onStart.add(function () {
                PoolClub.AudioManager.playEffect(PoolClub.AudioManager.COMBO_2);
            }, this);
            this.comboTextTween1.onComplete.add(function () {
                this.game.add.tween(this.rackCompletedEffect)
                    .to({ x: -15 }, 1500, Phaser.Easing.Linear.None, true)
                    .onComplete.add(function () {
                    this.game.add.tween(this.rackCompletedEffect)
                        .to({ x: -200 }, 150, Phaser.Easing.Cubic.In, true);
                    this.game.add.tween(this.rackCompletedEffect)
                        .to({ alpha: 0 }, 150, Phaser.Easing.Linear.None, true, 100)
                        .onComplete.add(function () {
                        this.alphaHudElements(1);
                        this.rackCompletedEffect.x = 400;
                    }, this);
                }, this);
            }, this);
        }
        alphaHudElements(value) {
            this.game.add.tween(this.timer)
                .to({ alpha: value }, 250, Phaser.Easing.Linear.None, true);
            this.game.add.tween(this.timerS)
                .to({ alpha: value }, 250, Phaser.Easing.Linear.None, true);
            this.game.add.tween(this.points)
                .to({ alpha: value }, 250, Phaser.Easing.Linear.None, true);
            this.game.add.tween(this.highscoreValueLabel)
                .to({ alpha: value }, 250, Phaser.Easing.Linear.None, true);
            this.game.add.tween(this.highScoreLabel)
                .to({ alpha: value }, 250, Phaser.Easing.Linear.None, true);
            for (let i = 0; i < 15; i++) {
                this.game.add.tween(this.ballsSet[i])
                    .to({ alpha: value }, 250, Phaser.Easing.Linear.None, true);
            }
        }
        createSoloModeHud() {
            this.createPocketedBallsSetsSolo();
            this.populateBallSetSolo();
            this.timer = new Phaser.Text(this.game, 0, 86, PoolClub.GameVars.timerSolo.toString(), { font: "52px Teko-SemiBold", fontWeight: "400", fill: "#E5FFFF" });
            this.timer.anchor.set(0.5, 1);
            this.matchDataContainer.add(this.timer);
            this.timerS = new Phaser.Text(this.game, 0, this.timer.y - 3, "s", { font: "27px Teko-SemiBold", fontWeight: "400", fill: "#E5FFFF" });
            this.timerS.anchor.set(0, 1);
            this.matchDataContainer.add(this.timerS);
            this.updateTimersLabel();
            this.points = new Phaser.Text(this.game, 390, 60, PoolClub.Utils.validNumber(PoolClub.GameVars.playerPoints) + " points", { font: "28px Teko-SemiBold", fontWeight: "400", fill: "#E5FFFF" });
            this.points.anchor.set(1, .5);
            this.matchDataContainer.add(this.points);
            this.highScoreLabel = new Phaser.Text(this.game, 220, 101, "HIGHSCORE:", { font: "28px Teko-Light", fontWeight: "400", fill: "#E5FFFF" });
            this.highScoreLabel.anchor.set(0, .5);
            this.matchDataContainer.add(this.highScoreLabel);
            this.highscoreValueLabel = new Phaser.Text(this.game, this.highScoreLabel.x + this.highScoreLabel.width + 10, this.highScoreLabel.y, PoolClub.Utils.validNumber(PoolClub.GameVars.gameData.statistics.solo.highScore), { font: "28px Teko-Light", fontWeight: "400", fill: "#E5FFFF" });
            this.highscoreValueLabel.anchor.set(0, .5);
            this.matchDataContainer.add(this.highscoreValueLabel);
        }
        createExplosionArray(x, y, explosionCount) {
            const xDelta = 20;
            let startX = -(xDelta * (explosionCount * .5));
            for (let i = 0; i < explosionCount; i++) {
                const sparkleSprite = new Phaser.Sprite(this.game, startX + (i * xDelta), y, "texture_atlas_1");
                sparkleSprite.anchor.set(0.5);
                sparkleSprite.angle = (360 / explosionCount) * i;
                const sparkleFrames = PoolClub.Utils.createAnimFramesArr("sparkle_effect", 14, false, 0, 15);
                sparkleSprite.animations.add("sparkle", sparkleFrames).play(24, false, true);
                this.add(sparkleSprite);
                sparkleSprite.sendToBack();
            }
        }
        updateBallSet(ballId) {
            for (let entry of this.ballsSet) {
                if (entry.frameName === "ball_icon_" + ballId + ".png") {
                    entry.frameName = "ball_icon_0.png";
                }
            }
        }
        updateSoloScore() {
            if (this.sumPoints) {
                let num = parseInt(this.points.text.replace(/,/g, ""));
                if (PoolClub.GameVars.playerPoints > 999999) {
                    this.points.setStyle({ font: "28px Teko-SemiBold" }, true);
                    if (PoolClub.GameVars.playerPoints > 9999999) {
                        this.points.setStyle({ font: "24px Teko-SemiBold" }, true);
                    }
                }
                if (num < PoolClub.GameVars.playerPoints) {
                    num++;
                    this.points.text = PoolClub.Utils.validNumber(num) + " points";
                    this.points.fill = "#1CCE68";
                    if (num > PoolClub.GameVars.gameData.statistics.solo.highScore) {
                        this.highscoreValueLabel.text = PoolClub.Utils.validNumber(PoolClub.GameVars.gameData.statistics.solo.highScore);
                    }
                }
                else if (num > PoolClub.GameVars.playerPoints) {
                    if (this.counter === 3) {
                        num--;
                        this.points.text = PoolClub.Utils.validNumber(num) + " points";
                        this.points.fill = "#FA2E63";
                        if (num > PoolClub.GameVars.gameData.statistics.solo.highScore) {
                            this.highscoreValueLabel.text = PoolClub.Utils.validNumber(PoolClub.GameVars.gameData.statistics.solo.highScore);
                        }
                        this.counter = 0;
                    }
                    else {
                        this.counter++;
                    }
                }
                else {
                    this.counter = 0;
                    this.sumPoints = false;
                    this.points.fill = "#E5FFFF";
                }
            }
            if (this.sumTime) {
                let num = parseInt(this.timer.text);
                if (num < PoolClub.GameVars.timerSolo) {
                    if (this.counterTime === 3) {
                        num++;
                        this.timer.text = num + "";
                        this.updateTimersLabel();
                        this.counterTime = 0;
                    }
                    else {
                        this.counterTime++;
                    }
                }
                else {
                    this.sumTime = false;
                }
            }
        }
        updateTimersLabel() {
            if (PoolClub.GameVars.timerSolo > 999) {
                this.timerS.x = this.timer.x + this.timerSXOffset * 3.125;
            }
            else if (PoolClub.GameVars.timerSolo > 99) {
                this.timerS.x = this.timer.x + this.timerSXOffset * 2.5;
            }
            else if (PoolClub.GameVars.timerSolo > 9) {
                this.timerS.x = this.timer.x + this.timerSXOffset * 2;
            }
            else {
                this.timerS.x = this.timer.x + this.timerSXOffset;
            }
        }
        createPocketedBallsSetsSolo() {
            this.ballsSet = [];
            let x = -377;
            for (let i = 0; i < 15; i++) {
                let ballSocket = new Phaser.Image(this.game, x, 98, "texture_atlas_1", "ball_icon_0.png");
                ballSocket.anchor.set(0.5);
                this.matchDataContainer.add(ballSocket);
                this.ballsSet.push(ballSocket);
                x += 40;
            }
        }
        populateBallSetNonSOLO(sidesInverted) {
            this.sidesAssigned = true;
            let imageId = sidesInverted ? 9 : 1;
            for (let i = 0; i < 14; i++) {
                this.ballsSet[i].frameName = "ball_icon_" + imageId + ".png";
                if (i === 6) {
                    if (sidesInverted) {
                        imageId = 0;
                    }
                    else {
                        imageId++;
                    }
                }
                imageId++;
            }
        }
        populateBallSetSolo() {
            let imageId = 1;
            for (let i = 0; i < 15; i++) {
                this.ballsSet[i].frameName = "ball_icon_" + imageId + ".png";
                imageId++;
            }
        }
    }
    PoolClub.HUD = HUD;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class AdversaryLeftLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "adversary-left-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .75;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const text = new Phaser.Text(this.game, PoolClub.GameConstants.GAME_WIDTH * .5, 350, "ADVERSARY CONNECTION LOST", { font: "60px Teko-SemiBold", fontWeight: "600", fill: "#EB3359" });
            text.stroke = "#673952";
            text.strokeThickness = 5;
            text.anchor.set(.5);
            this.add(text);
            this.showButtonsTimer = 1;
        }
        update() {
            if (!this.buttonsCreated) {
                if (this.showButtonsTimer < 0) {
                    this.buttonsCreated = true;
                    const buttonHome = new Phaser.Button(this.game, PoolClub.GameConstants.GAME_WIDTH / 2 - 120 * PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / 2 + 275, "texture_atlas_1", this.onClickHome, this);
                    buttonHome.setFrames("btn_close_on.png", "btn_close_off.png", "btn_close_on.png", "btn_close_off.png");
                    buttonHome.anchor.set(.5);
                    if (this.game.device.touch) {
                        buttonHome.onInputDown.add(function () { buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1); }, this);
                    }
                    buttonHome.onInputOver.add(function () { buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1); }, this);
                    buttonHome.onInputOut.add(function () { buttonHome.scale.set(1, 1); }, this);
                    buttonHome.forceOut = true;
                    buttonHome.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                    this.add(buttonHome);
                    const buttonNewRival = new Phaser.Button(this.game, PoolClub.GameConstants.GAME_WIDTH / 2 + 50 * PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / 2 + 275, "texture_atlas_1", this.onClickNewRival, this);
                    buttonNewRival.setFrames("btn_new_rival_on.png", "btn_new_rival.png", "btn_new_rival_on.png", "btn_new_rival.png");
                    buttonNewRival.anchor.set(.5);
                    if (this.game.device.touch) {
                        buttonNewRival.onInputDown.add(function () { buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1); }, this);
                    }
                    buttonNewRival.onInputOver.add(function () { buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1); }, this);
                    buttonNewRival.onInputOut.add(function () { buttonNewRival.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult); }, this);
                    buttonNewRival.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                    this.add(buttonNewRival);
                }
                else {
                    this.showButtonsTimer -= this.game.time.physicsElapsed;
                }
            }
        }
        onClickHome(b) {
            b.clearFrames();
            PoolClub.MatchManager.hideAdversaryLeftLayer();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
        onClickNewRival(b) {
            b.clearFrames();
            PoolClub.MatchManager.hideAdversaryLeftLayer();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
        onDownTransparentLayer() {
        }
    }
    PoolClub.AdversaryLeftLayer = AdversaryLeftLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class EndGamePortraitContainer extends Phaser.Group {
        constructor(game, messageImageFilename) {
            super(game, null, "end-game-portrait-container");
            const portraitPackY = 280;
            this.messageImage = new Phaser.Image(game, PoolClub.GameConstants.GAME_WIDTH / 2, portraitPackY + 64, "texture_atlas_1", messageImageFilename);
            this.messageImage.anchor.set(0.5);
            this.messageImage.scale.set(PoolClub.GameVars.scaleXMult, .001);
            this.add(this.messageImage);
        }
    }
    PoolClub.EndGamePortraitContainer = EndGamePortraitContainer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class LosePVPLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "lose-pvp-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const buttonHome = new Phaser.Button(this.game, PoolClub.GameConstants.GAME_WIDTH / 2 - 120 * PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / 2 + 275, "texture_atlas_1", this.onClickHome, this);
            buttonHome.setFrames("btn_close_on.png", "btn_close_off.png", "btn_close_on.png", "btn_close_off.png");
            buttonHome.anchor.set(.5);
            if (this.game.device.touch) {
                buttonHome.onInputDown.add(function () { buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1); }, this);
            }
            buttonHome.onInputOver.add(function () { buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1); }, this);
            buttonHome.onInputOut.add(function () { buttonHome.scale.set(1, 1); }, this);
            buttonHome.forceOut = true;
            buttonHome.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(buttonHome);
            const buttonNewRival = new Phaser.Button(this.game, PoolClub.GameConstants.GAME_WIDTH / 2 + 50 * PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / 2 + 275, "texture_atlas_1", this.onClickNewRival, this);
            buttonNewRival.setFrames("btn_new_rival_on.png", "btn_new_rival.png", "btn_new_rival_on.png", "btn_new_rival.png");
            buttonNewRival.anchor.set(.5);
            if (this.game.device.touch) {
                buttonNewRival.onInputDown.add(function () { buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1); }, this);
            }
            buttonNewRival.onInputOver.add(function () { buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1); }, this);
            buttonNewRival.onInputOut.add(function () { buttonNewRival.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult); }, this);
            buttonNewRival.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(buttonNewRival);
            PoolClub.AudioManager.playMusic(PoolClub.AudioManager.LOSE);
        }
        onClickHome(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.MatchManager.hideLoseLayer();
            });
        }
        onClickNewRival(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.MatchManager.hideLoseLayer();
            });
        }
        onDownTransparentLayer() {
        }
    }
    PoolClub.LosePVPLayer = LosePVPLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class PauseLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "pause-layer");
            PauseLayer.currentInstance = this;
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            let backButton_px;
            backButton_px = 50 * PoolClub.GameVars.scaleXMult;
            const backButton = new Phaser.Button(this.game, backButton_px, 50 * PoolClub.GameVars.scaleYMult, "texture_atlas_1", this.onClickExit, this);
            backButton.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png", "btn_back_off.png");
            backButton.forceOut = true;
            backButton.anchor.set(.5);
            if (this.game.device.touch) {
                backButton.onInputDown.add(function () { backButton.scale.set(backButton.scale.x * 1.1, backButton.scale.y * 1.1); }, this);
            }
            backButton.onInputOver.add(function () { backButton.scale.set(backButton.scale.x * 1.1, backButton.scale.y * 1.1); }, this);
            backButton.onInputOut.add(function () { backButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult); }, this);
            backButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(backButton);
            let scaledItemsContainer = new Phaser.Group(this.game);
            scaledItemsContainer.x = PoolClub.GameConstants.GAME_WIDTH / 2;
            scaledItemsContainer.y = PoolClub.GameConstants.GAME_HEIGHT / 2;
            scaledItemsContainer.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(scaledItemsContainer);
            const restartButton = new Phaser.Button(this.game, 0, -8, "texture_atlas_1", this.onClickReset, this);
            restartButton.setFrames("btn_restart_on.png", "btn_restart_off.png", "btn_restart_on.png", "btn_restart_off.png");
            restartButton.anchor.set(.5);
            restartButton.scale.set(1);
            if (this.game.device.touch) {
                restartButton.onInputDown.add(function () { restartButton.scale.set(restartButton.scale.x * 1.1, restartButton.scale.y * 1.1); }, this);
            }
            restartButton.onInputOver.add(function () { restartButton.scale.set(restartButton.scale.x * 1.1, restartButton.scale.y * 1.1); }, this);
            restartButton.onInputOut.add(function () { restartButton.scale.set(1); }, this);
            scaledItemsContainer.add(restartButton);
            const soloHomeButton = new Phaser.Button(this.game, 0, 100, "texture_atlas_1", this.onClickSoloHome, this);
            soloHomeButton.setFrames("btn_close_on.png", "btn_close_off.png", "btn_close_on.png", "btn_close_off.png");
            soloHomeButton.anchor.set(.5);
            if (this.game.device.touch) {
                soloHomeButton.onInputDown.add(function () { soloHomeButton.scale.set(soloHomeButton.scale.x * 1.1, soloHomeButton.scale.y * 1.1); }, this);
            }
            soloHomeButton.onInputOver.add(function () { soloHomeButton.scale.set(soloHomeButton.scale.x * 1.1, soloHomeButton.scale.y * 1.1); }, this);
            soloHomeButton.onInputOut.add(function () { soloHomeButton.scale.set(1); }, this);
            scaledItemsContainer.add(soloHomeButton);
            const rulesText = new Phaser.Text(this.game, 0, 160, PoolClub.GameConstants.RULES_TEXT, { font: this.game.device.desktop ? "28px Teko-SemiBold" : "38px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8", align: "center", stroke: "#2f3237", strokeThickness: 3 });
            rulesText.anchor.set(0.5, 0);
            scaledItemsContainer.add(rulesText);
            const audioSwitchButton = new PoolClub.SwitchButton(this.game, !PoolClub.GameVars.gameData.musicMuted, PoolClub.SwitchButton.MUSIC);
            audioSwitchButton.x = -90;
            audioSwitchButton.y = -100;
            scaledItemsContainer.add(audioSwitchButton);
            const audioLabel = new Phaser.Text(this.game, audioSwitchButton.x, audioSwitchButton.y - 40, "AUDIO", { font: "24px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8", align: "center", stroke: "#2f3237", strokeThickness: 3 });
            audioLabel.anchor.set(.5);
            scaledItemsContainer.add(audioLabel);
            if (this.game.device.touch) {
                const switchStartingState = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.RIGHT;
                const powerSwitchButton = new PoolClub.SwitchButton(this.game, switchStartingState, PoolClub.SwitchButton.POWER);
                powerSwitchButton.x = 90;
                powerSwitchButton.y = -100;
                scaledItemsContainer.add(powerSwitchButton);
                const powerTextLeft = "RAIL: RIGHT";
                const powerTextRight = "RAIL: LEFT";
                this.powerLabel = new Phaser.Text(this.game, powerSwitchButton.x, powerSwitchButton.y - 40, powerTextLeft, { font: "24px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8", align: "center", stroke: "#2f3237", strokeThickness: 3 });
                this.powerLabel.anchor.set(.5);
                scaledItemsContainer.add(this.powerLabel);
                if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.RIGHT) {
                    this.powerLabel.text = powerTextRight;
                }
                if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                    scaledItemsContainer.y += 100;
                }
            }
            else {
                audioSwitchButton.x = 0;
                audioLabel.x = 0;
            }
            this.alpha = 0;
            this.game.add.tween(this)
                .to({ alpha: 1 }, 400, Phaser.Easing.Cubic.Out, true);
        }
        changePower() {
            const powerTextLeft = "RAIL: RIGHT";
            const powerTextRight = "RAIL: LEFT";
            if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT) {
                this.powerLabel.text = powerTextLeft;
            }
            else {
                this.powerLabel.text = powerTextRight;
            }
        }
        destroy() {
            PauseLayer.currentInstance = null;
            super.destroy();
        }
        onClickExit(b) {
            b.clearFrames();
            PoolClub.MatchManager.hidePauseLayer();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
        onClickResign(b) {
            b.clearFrames();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            PoolClub.MatchManager.hideNotificationLayer();
            PoolClub.MatchManager.hidePauseLayer();
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                if (PoolClub.GameConstants.LOG_SERVER_INFO) {
                    console.error("sending GameConstants.MESSAGE_TYPE_RESIGN");
                }
                PoolClub.MatchManagerPVP.matchOverDueToResignation(PoolClub.GameVars.gameData.playerData.sessionId);
            }
            else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                if (PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                    console.error("sending GameConstants.MESSAGE_TYPE_RESIGN");
                }
                PoolClub.MatchManagerPVBot.matchOverDueToResignation(true);
            }
        }
        onClickReset(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.GameVars.paused = false;
                PoolClub.GameVars.rematch = true;
                PoolClub.GameManager.enterSoloGame();
            });
        }
        onClickSoloHome(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.MatchManager.hidePauseLayer();
                PoolClub.MatchManagerSolo.endSoloGame(PoolClub.GameConstants.PLAYER_RESIGNS);
            });
        }
        onDownTransparentLayer() {
        }
    }
    PoolClub.PauseLayer = PauseLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class RetrySoloLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "retry-solo-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const gameOverBanner = new Phaser.Image(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, PoolClub.GameConstants.GAME_HEIGHT / 2, "texture_atlas_1", "game_over.png");
            gameOverBanner.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            gameOverBanner.anchor.set(.5);
            this.add(gameOverBanner);
            this.game.add.tween(gameOverBanner.scale)
                .from({ x: 0, y: 0 }, 500, Phaser.Easing.Elastic.Out, true, 500);
            const buttonRestart = new Phaser.Button(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, PoolClub.GameConstants.GAME_HEIGHT / 2 + 200, "texture_atlas_1", this.onClickReset, this);
            buttonRestart.setFrames("btn_play_again_on.png", "btn_play_again_off.png", "btn_play_again_on.png");
            buttonRestart.anchor.set(.5);
            if (this.game.device.touch) {
                buttonRestart.onInputDown.add(function () { buttonRestart.scale.set(buttonRestart.scale.x * 1.1, buttonRestart.scale.y * 1.1); }, this);
            }
            buttonRestart.onInputOver.add(function () { buttonRestart.scale.set(buttonRestart.scale.x * 1.1, buttonRestart.scale.y * 1.1); }, this);
            buttonRestart.onInputOut.add(function () { buttonRestart.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult); }, this);
            buttonRestart.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(buttonRestart);
            let buttonHome_px;
            buttonHome_px = 50 * PoolClub.GameVars.scaleXMult;
            const buttonHome = new Phaser.Button(this.game, buttonHome_px, 50 * PoolClub.GameVars.scaleYMult, "texture_atlas_1", this.onClickHome, this);
            buttonHome.setFrames("btn_close_on.png", "btn_close_off.png", "btn_close_on.png");
            buttonHome.anchor.set(.5);
            if (this.game.device.touch) {
                buttonHome.onInputDown.add(function () { buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1); }, this);
            }
            buttonHome.onInputOver.add(function () { buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1); }, this);
            buttonHome.onInputOut.add(function () { buttonHome.scale.set(1, 1); }, this);
            buttonHome.forceOut = true;
            buttonHome.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(buttonHome);
            PoolClub.AudioManager.playMusic(PoolClub.AudioManager.LOSE);
        }
        onClickHome(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.MatchManager.hidePauseLayer();
                PoolClub.MatchManager.hideRetryLayer();
                PoolClub.MatchManagerSolo.endSoloGame(PoolClub.GameConstants.PLAYER_RESIGNS);
            });
        }
        onClickReset(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            b.clearFrames();
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                PoolClub.GameVars.paused = false;
                PoolClub.GameVars.rematch = true;
                PoolClub.GameManager.enterSoloGame();
            });
        }
        onDownTransparentLayer() {
        }
    }
    PoolClub.RetrySoloLayer = RetrySoloLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class VictoryLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "victory-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            this.buttonRestart = new Phaser.Button(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, PoolClub.GameConstants.GAME_HEIGHT / 2 + 200, "texture_atlas_1", this.onClickReset, this);
            this.buttonRestart.setFrames("btn_play_again_on.png", "btn_play_again_off.png", "btn_play_again_on.png");
            this.buttonRestart.anchor.set(.5);
            if (this.game.device.touch) {
                this.buttonRestart.onInputDown.add(function () { this.buttonRestart.scale.set(this.buttonRestart.scale.x * 1.1, this.buttonRestart.scale.y * 1.1); }, this);
            }
            this.buttonRestart.onInputOver.add(function () { this.buttonRestart.scale.set(this.buttonRestart.scale.x * 1.1, this.buttonRestart.scale.y * 1.1); }, this);
            this.buttonRestart.onInputOut.add(function () { this.buttonRestart.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult); }, this);
            this.buttonRestart.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(this.buttonRestart);
            let buttonHome_px;
            buttonHome_px = 50 * PoolClub.GameVars.scaleXMult;
            this.buttonHome = new Phaser.Button(this.game, buttonHome_px, 50 * PoolClub.GameVars.scaleYMult, "texture_atlas_1", this.onClickHome, this);
            this.buttonHome.setFrames("btn_close_on.png", "btn_close_off.png", "btn_close_on.png");
            this.buttonHome.anchor.set(.5);
            if (this.game.device.touch) {
                this.buttonHome.onInputDown.add(function () { this.buttonHome.scale.set(this.buttonHome.scale.x * 1.1, this.buttonHome.scale.y * 1.1); }, this);
            }
            this.buttonHome.onInputOver.add(function () { this.buttonHome.scale.set(this.buttonHome.scale.x * 1.1, this.buttonHome.scale.y * 1.1); }, this);
            this.buttonHome.onInputOut.add(function () { this.buttonHome.scale.set(1, 1); }, this);
            this.buttonHome.forceOut = true;
            this.buttonHome.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(this.buttonHome);
            PoolClub.AudioManager.playMusic(PoolClub.AudioManager.WIN);
            if (!PoolClub.GameVars.gameData.statistics.rewards.allUnlocked) {
                this.animStarBox = new PoolClub.AnimatedStarBox(game);
                this.animStarBox.y = 475;
                this.animStarBox.x = PoolClub.GameConstants.GAME_WIDTH * 0.5;
                this.animStarBox.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
                this.add(this.animStarBox);
            }
        }
        init(victoryData) {
            if (!victoryData) {
                throw "Error reading victory data";
            }
            if (victoryData.starUnlocked === 3) {
                this.endGamePortraitContainer.visible = false;
                this.buttonHome.alpha = 0;
                if (this.buttonRestart) {
                    this.buttonRestart.visible = false;
                }
                if (this.buttonNewRival) {
                    this.buttonNewRival.visible = false;
                }
            }
            if (this.animStarBox) {
                for (let i = 0; i < 3; i++) {
                    if (i === victoryData.starUnlocked - 1) {
                        this.animStarBox.animateStarToFullScale(i);
                        break;
                    }
                    else {
                        this.animStarBox.setStarActive(i);
                    }
                }
            }
        }
        onClickReset(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.GameVars.paused = false;
                PoolClub.GameVars.rematch = true;
                PoolClub.GameManager.enterSoloGame();
            });
        }
        onClickHome(b) {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            if (!PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.AudioManager.setMusicMuted(true, false);
            }
            PokiSDK.gameplayStop();
            PokiSDK.commercialBreak().then(() => {
                console.log("Commercial break finished, proceeding to game");
                PokiSDK.gameplayStart();
                if (!PoolClub.GameVars.gameData.musicMuted) {
                    PoolClub.AudioManager.setMusicMuted(false, false);
                }
                b.clearFrames();
                PoolClub.MatchManager.hideVictoryLayer();
            });
        }
        onDownTransparentLayer() {
        }
    }
    PoolClub.VictoryLayer = VictoryLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class MatchManager {
        static init(game, sessionId) {
            MatchManager.game = game;
            PoolClub.GameVars.gameOver = false;
            PoolClub.GameVars.english = 0;
            PoolClub.GameVars.verticalSpin = 0;
            PoolClub.GameVars.turnSet = true;
            PoolClub.GameVars.draggingCueBall = false;
            PoolClub.GameVars.pocketIdWhereBlackFell = -1;
        }
        static update() {
            if (!PoolClub.GameVars.startMatch || !PoolClub.GameVars.ballArray) {
                return;
            }
            PoolClub.GameVars.shotRunning = false;
            for (let i = 0, ln = PoolClub.GameVars.ballArray.length; i < ln; i++) {
                let ball = PoolClub.GameVars.ballArray[i];
                if (ball.active && ball.velocity.magnitudeSquared > 0) {
                    PoolClub.GameVars.shotRunning = true;
                    break;
                }
            }
            const cueBall = PoolClub.GameVars.ballArray[0];
            if (cueBall.mc.pocketTween) {
                PoolClub.GameVars.shotRunning = true;
            }
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.MatchManagerSolo.update();
            }
            else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                PoolClub.MatchManagerPVP.update();
            }
            else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                PoolClub.MatchManagerPVBot.update();
            }
        }
        static showPauseLayer() {
            PoolClub.PoolState.currentInstance.pauseGame();
        }
        static hideNotificationLayer() {
            PoolClub.PoolState.currentInstance.hideNotificationLayer();
        }
        static hidePauseLayer() {
            PoolClub.PoolState.currentInstance.resumeGame();
        }
        static showSoloRetryLayer() {
            PoolClub.PoolState.currentInstance.showSoloRetryLayer();
        }
        static hideRetryLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.hideRetryLayer();
            }
        }
        static showVictoryLayer(victoryData) {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.showVictoryLayer(victoryData);
            }
        }
        static hideVictoryLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.hideVictoryLayer();
            }
        }
        static showLoseLayer(victoryData) {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.showLoseLayer();
            }
        }
        static hideLoseLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.hideLoseLayer();
            }
        }
        static showAdversaryLeftLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.showAdversaryLeftLayer();
            }
        }
        static hideAdversaryLeftLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.hideAdversaryLeftLayer();
            }
        }
        static ballHasBeenShot(shotData) {
            PoolClub.GameVars.shotRunning = true;
            PoolClub.GameVars.turnSet = false;
            PoolClub.GameVars.shotCount++;
            PoolClub.PoolState.currentInstance.gui.disableSpinButton();
            PoolClub.StageContainer.currentInstance.ballHasBeenShot();
        }
        static reset() {
            PoolClub.GameVars.paused = false;
            PoolClub.GameVars.rematch = true;
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.GameManager.enterSoloGame();
            }
        }
        static showSpinCircleLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.showSpinCircleLayer();
            }
        }
        static hideSpinCircleLayer(english, verticalSpin) {
            PoolClub.GameVars.english = english;
            PoolClub.GameVars.verticalSpin = verticalSpin;
            PoolClub.PoolState.currentInstance.hideSpinCircleLayer();
        }
        static resetSpinCircleLayer() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.resetSpinCircleLayer();
            }
        }
        static ballPocketed(ball) {
            const id = ball.id;
            PoolClub.PoolState.currentInstance.hud.ballPocketed(id);
            if (id !== 0) {
                PoolClub.StageContainer.currentInstance.addBallToTrail(ball);
                PoolClub.GameVars.pocketedBalls.push(id);
            }
        }
        static setRedPointPosition() {
            if (PoolClub.PoolState.currentInstance) {
                PoolClub.PoolState.currentInstance.gui.setRedPointPosition();
            }
        }
        static setCueAimDirection() {
            PoolClub.CueContainer.currentInstance.aimDirectionVector = new Billiard.Vector2D(-Math.cos(PoolClub.CueContainer.currentInstance.rotation), -Math.sin(PoolClub.CueContainer.currentInstance.rotation));
        }
        static forceCueToShoot(shotData) {
            PoolClub.CueContainer.currentInstance.shootReceived(shotData.vector, shotData.deltaScrew, shotData.english);
        }
        static savePosition(velocity, deltaScrew, english) {
            PoolClub.GameVars.ballsData.length = 0;
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                let ballData = { id: PoolClub.GameVars.ballArray[i].id, active: PoolClub.GameVars.ballArray[i].active, x: PoolClub.GameVars.ballArray[i].position.x, y: PoolClub.GameVars.ballArray[i].position.y };
                PoolClub.GameVars.ballsData.push(ballData);
            }
            let ballsData = [];
            for (let i = 0; i < PoolClub.GameVars.ballsData.length; i++) {
                let ball = PoolClub.GameVars.ballsData[i];
                let newBall = { id: ball.id, x: ball.x, y: ball.y, active: ball.active };
                if (ball.id === 0 && ball.active === false) {
                    newBall.x = PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[0][0];
                    newBall.y = PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[0][1];
                }
                ballsData.push(newBall);
            }
        }
        static cueBallSet(x, y) {
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                PoolClub.MatchManagerPVP.sendCueBallPosition(x, y);
            }
            PoolClub.StageContainer.currentInstance.newTurn();
        }
        static pocketSelected(pocketId) {
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVP_MODE) {
                    PoolClub.MatchManagerPVP.sendSelectedPocket(pocketId);
                }
                else if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                    PoolClub.MatchManagerPVBot.sendSelectedPocket(pocketId);
                }
            }
        }
        static rackBalls(rndSeed) {
            let seed = rndSeed || Billiard.Maths.fixNumber(Math.random()).toString();
            const prng = new Phaser.RandomDataGenerator([(seed).toString()]);
            if (PoolClub.GameVars.gameMode === PoolClub.GameConstants.SOLO_MODE) {
                PoolClub.GameVars.ballArray = [];
                let ballIndexes = [2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15];
                let cueBallObject;
                cueBallObject = new PoolClub.CueBallObject(this.game, 0, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[0][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[0][1]);
                PoolClub.GameVars.ballArray.push(cueBallObject);
                let ballObject;
                ballObject = new PoolClub.BallObject(this.game, 1, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[1][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[1][1], true);
                PoolClub.GameVars.ballArray.push(ballObject);
                ballObject = new PoolClub.BallObject(this.game, 8, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[8][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[8][1], true);
                PoolClub.GameVars.ballArray.push(ballObject);
                let i = prng.pick(ballIndexes);
                let ballIndexesAux = ballIndexes.slice();
                if (i <= 7) {
                    ballIndexesAux = ballIndexesAux.splice(6, 7);
                }
                else {
                    ballIndexesAux = ballIndexesAux.splice(0, 6);
                }
                let j = prng.pick(ballIndexesAux);
                ballObject = new PoolClub.BallObject(this.game, i, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[3][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[3][1], true);
                PoolClub.GameVars.ballArray.push(ballObject);
                ballObject = new PoolClub.BallObject(this.game, j, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[14][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[14][1], true);
                PoolClub.GameVars.ballArray.push(ballObject);
                let index = ballIndexes.indexOf(i);
                ballIndexes.splice(index, 1);
                index = ballIndexes.indexOf(j);
                ballIndexes.splice(index, 1);
                ballIndexes = PoolClub.Utils.shuffle(ballIndexes, prng);
                index = 0;
                for (let i = 0; i < PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO.length; i++) {
                    if (i !== 0 && i !== 1 && i !== 8 && i !== 3 && i !== 14) {
                        ballObject = new PoolClub.BallObject(this.game, ballIndexes[index], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[i][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[i][1], true);
                        PoolClub.GameVars.ballArray.push(ballObject);
                        index++;
                    }
                }
                for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                    ballObject = PoolClub.GameVars.ballArray[i];
                    let x = ballObject.position.x + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                    let y = ballObject.position.y + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                    ballObject.position = new Billiard.Vector2D(x, y);
                }
                for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                    let ballData = { id: PoolClub.GameVars.ballArray[i].id, active: true, x: PoolClub.GameVars.ballArray[i].position.x, y: PoolClub.GameVars.ballArray[i].position.y };
                    PoolClub.GameVars.ballsData.push(ballData);
                }
            }
            else {
                PoolClub.GameVars.ballArray = [];
                for (let i = 0; i < PoolClub.GameConstants.BALLS_INITIAL_POSITIONS.length; i++) {
                    if (i === 0) {
                        let cueBallObject;
                        cueBallObject = new PoolClub.CueBallObject(this.game, i, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[i][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[i][1]);
                        PoolClub.GameVars.ballArray.push(cueBallObject);
                    }
                    else {
                        let ballObject = new PoolClub.BallObject(this.game, i, PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[i][0], PoolClub.GameConstants.BALLS_INITIAL_POSITIONS[i][1], true);
                        let x = ballObject.position.x + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                        let y = ballObject.position.y + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                        ballObject.position = new Billiard.Vector2D(x, y);
                        PoolClub.GameVars.ballArray.push(ballObject);
                    }
                }
            }
        }
        static showAdversaryEmoticon(emoticonID) {
        }
        static cueBallSpinSet(data) {
            const english = data.english;
            const verticalSpin = data.verticalSpin;
            PoolClub.PoolState.currentInstance.gui.cueBallSpinButton.setRedPointPosition(english, verticalSpin);
        }
    }
    PoolClub.MatchManager = MatchManager;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class MatchManagerPVBot extends PoolClub.MatchManager {
        static init(game) {
            super.init(game);
            MatchManagerPVBot.game = game;
            MatchManagerPVBot.doWriteGameData = false;
            MatchManagerPVBot.sidesAlreadyAssigned = false;
            PoolClub.GameManager.validatePocketedBalls();
            PoolClub.GameVars.currentTurn = PoolClub.GameConstants.PLAYER;
            this.game.state.start("PoolState", true, false);
        }
        static startGame() {
            PoolClub.MatchManager.rackBalls();
            if (PoolClub.GameVars.firstShot && PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                PoolClub.StageContainer.currentInstance.showSetCueBall("Game start and local player's turn");
                PoolClub.PoolState.currentInstance.showNotificationLayer(PoolClub.GameConstants.NOTIFICATION_NONE, true, false);
            }
            else {
                PoolClub.PoolState.currentInstance.showNotificationLayer(PoolClub.GameConstants.NOTIFICATION_NONE, false, false);
            }
            PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([8], true);
            MatchManagerPVBot.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVBot.pocketedBalls = [];
            Billiard.Bot.init(PoolClub.GameConstants.FRICTION, PoolClub.GameConstants.BALL_RADIUS, PoolClub.GameConstants.POCKET_RADIUS, PoolClub.GameConstants.PHYS_SCALE, PoolClub.GameConstants.MIN_VELOCITY, PoolClub.GameConstants.CUSHION_RESTITUTION, PoolClub.GameConstants.BALL_RESTITUTION, PoolClub.GameVars.extractLineArrayString(), PoolClub.GameVars.extractVertexArrayString(), PoolClub.GameVars.extractPocketArrayString(), MatchManagerPVBot.calculateBotDifficulty());
        }
        static update() {
            if (PoolClub.GameVars.gameOver) {
                return;
            }
            if (!PoolClub.GameVars.shotRunning && !PoolClub.GameVars.turnSet) {
                PoolClub.GameVars.turnSet = true;
                MatchManagerPVBot.ballsStoppedMoving(MatchManagerPVBot.pocketedBalls, MatchManagerPVBot.firstTouchedBall, PoolClub.GameVars.pocketIdWhereBlackFell);
            }
        }
        static ballPocketed(ball) {
            if (ball.id === 8) {
                PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED, data: null });
            }
            PoolClub.PoolState.currentInstance.ballPocketed(ball.id);
            MatchManagerPVBot.pocketedBalls.push(ball.id);
            super.ballPocketed(ball);
        }
        static newTurn(state) {
            if (PoolClub.GameVars.gameOver) {
                return;
            }
            MatchManagerPVBot.implementStateMessages(state);
            PoolClub.GameVars.firstShot = false;
            PoolClub.GameVars.shotRunning = false;
            PoolClub.GameVars.english = 0;
            PoolClub.GameVars.verticalSpin = 0;
            MatchManagerPVBot.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVBot.pocketedBalls = [];
            PoolClub.MatchManager.setCueAimDirection();
            PoolClub.PoolState.currentInstance.newTurn();
        }
        static endPVBotGame(reason) {
            PoolClub.GameVars.gameOver = true;
            PoolClub.GameVars.gameEnded = reason;
            PoolClub.GameVars.paused = true;
            if (reason === PoolClub.GameConstants.PLAYER_LOSE) {
                PoolClub.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                MatchManagerPVBot.doWriteGameData = true;
                super.showLoseLayer();
            }
            else if (reason === PoolClub.GameConstants.PLAYER_WIN) {
                PoolClub.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                PoolClub.GameVars.gameData.statistics.nonSolo.gamesWon++;
                MatchManagerPVBot.doWriteGameData = true;
                let victoryData = PoolClub.RewardsManager.prepareRewardStats();
                super.showVictoryLayer(victoryData);
            }
            else if (reason === PoolClub.GameConstants.PLAYER_RESIGNS) {
                PoolClub.PoolState.currentInstance.endGame();
            }
            if (MatchManagerPVBot.doWriteGameData) {
                PoolClub.GameManager.writeGameData();
            }
        }
        static matchOverDueToResignation(playerResigned) {
            if (PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("matchOverDueToResignation()");
            }
            if (playerResigned) {
                MatchManagerPVBot.endPVBotGame(PoolClub.GameConstants.PLAYER_RESIGNS);
            }
            else {
                MatchManagerPVBot.endPVBotGame(PoolClub.GameConstants.PLAYER_WIN);
            }
        }
        static setTouchedBall(ballId) {
            if (ballId === 0) {
                return;
            }
            if (MatchManagerPVBot.firstTouchedBall === PoolClub.GameConstants.BALL_TYPE_NONE) {
                if (ballId < 8) {
                    MatchManagerPVBot.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_SOLID;
                }
                else if (ballId > 8) {
                    MatchManagerPVBot.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                }
                else {
                    MatchManagerPVBot.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_BLACK;
                }
            }
            else {
                return;
            }
        }
        static sendSelectedPocket(pocketId) {
            if (PoolClub.GameVars.currentTurn !== PoolClub.GameConstants.ADVERSARY) {
                PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_POCKET_SELECTED, data: pocketId });
                PoolClub.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static adversaryCueBallPosition(position) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                let cueBall = PoolClub.GameVars.ballArray[0];
                cueBall.setPositionReceived(position.x * PoolClub.GameConstants.PHYS_SCALE, position.y * PoolClub.GameConstants.PHYS_SCALE);
            }
        }
        static adversaryRotatedCue(cueRotation) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                PoolClub.CueContainer.currentInstance.moveCue(cueRotation);
            }
        }
        static showPocketSelected(num) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                PoolClub.StageContainer.currentInstance.showSelectPocket("Setting pocket rival chose");
                PoolClub.StageContainer.currentInstance.setRivalPocket(num);
                PoolClub.StageContainer.currentInstance.showCue("adversary selected pocket set");
                PoolClub.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static shotDataReceived(shotData) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                let shotDataFinal = {
                    vector: new Billiard.Vector2D(shotData.cueSpeed.vx, shotData.cueSpeed.vy),
                    deltaScrew: new Billiard.Vector2D(shotData.deltaScrew.x, shotData.deltaScrew.y),
                    english: shotData.english
                };
                super.forceCueToShoot(shotDataFinal);
            }
        }
        static ballsStoppedMoving(balls, firstBall, blackBallPocket) {
            let data = {
                playerTurn: PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER,
                balls: balls,
                firstBall: firstBall,
                blackBallPocket: blackBallPocket
            };
            PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_BALLS_STOPPED, data: data });
            if (PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_BALLS_STOPPED");
            }
        }
        static ballHasBeenShot(shotData) {
            PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_SHOT, data: shotData });
            if (PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_SHOT");
            }
        }
        static matchFinished(winnerId, delay = 0) {
            if (delay > 0) {
                MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND, function () {
                    if (PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                        console.error("matchFinished()");
                    }
                    if (PoolClub.GameVars.gameData.playerData.sessionId === winnerId) {
                        MatchManagerPVBot.endPVBotGame(PoolClub.GameConstants.PLAYER_WIN);
                    }
                    else {
                        MatchManagerPVBot.endPVBotGame(PoolClub.GameConstants.PLAYER_LOSE);
                    }
                }, this);
            }
            else {
                if (PoolClub.GameConstants.LOG_BOT_SERVER_INFO) {
                    console.error("matchFinished()");
                }
                if (PoolClub.GameVars.gameData.playerData.sessionId === winnerId) {
                    MatchManagerPVBot.endPVBotGame(PoolClub.GameConstants.PLAYER_WIN);
                }
                else {
                    MatchManagerPVBot.endPVBotGame(PoolClub.GameConstants.PLAYER_LOSE);
                }
            }
        }
        static cueRotated(cueRotation) {
            PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_CUE_ROTATION, data: cueRotation });
        }
        static calculateBotDifficulty() {
            let base = 3;
            let maximum = 5;
            const played = PoolClub.GameVars.gameData.statistics.nonSolo.gamesPlayed;
            const won = PoolClub.GameVars.gameData.statistics.nonSolo.gamesWon;
            if (played < 3) {
                return 3;
            }
            if (played < 7) {
                maximum = 5;
            }
            else if (played < 15) {
                maximum = 7;
            }
            else {
                maximum = 9;
            }
            let additionalDifficulty = (maximum - base) * (won / played);
            let skill = base + additionalDifficulty;
            return skill;
        }
        static startBotFiringSequence(canMoveCueBall, canPocketBlackBall, botBallsType, botWakeTime, selectPocketTimeAfterWake, shootTimeAfterWake) {
            MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND * botWakeTime, function () {
                if (canMoveCueBall) {
                    let cueBallPos = Billiard.Bot.getCueBallPosition(PoolClub.GameVars.extractBallsArrayString(), botBallsType);
                    PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_CUE_BALL, data: { x: cueBallPos.x, y: cueBallPos.y } });
                }
                const shotData = Billiard.Bot.getShot(PoolClub.GameVars.extractBallsArrayString(), PoolClub.GameVars.shotCount, botBallsType === PoolClub.GameConstants.BALL_TYPE_NONE ? "" : botBallsType, 20000);
                const deltaScrew = PoolClub.CueContainer.currentInstance.aimDirectionVector.times(new Billiard.Vector2D(shotData.velocity.x, shotData.velocity.y).magnitude *
                    shotData.screw *
                    shotData.verticalSpin);
                if (PoolClub.GameVars.sabotageBot) {
                    shotData.velocity.x = 0;
                    shotData.velocity.y = 0;
                }
                let shotDataForRulesManager = {
                    cueSpeed: { vx: shotData.velocity.x, vy: shotData.velocity.y },
                    deltaScrew: { x: deltaScrew.x, y: deltaScrew.y },
                    english: shotData.english
                };
                MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND * selectPocketTimeAfterWake, function () {
                    if (canPocketBlackBall) {
                        PoolClub.RulesManager.sendMessage({ type: PoolClub.GameConstants.MESSAGE_TYPE_POCKET_SELECTED, data: shotData.pocket8Ball });
                    }
                    const v = new Billiard.Vector2D(shotData.velocity.x, shotData.velocity.y).normalize();
                    let cueAngle = Math.atan2(-v.y, -v.x);
                    MatchManagerPVBot.cueRotated(cueAngle);
                }, PoolClub.GameManager);
                MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND * shootTimeAfterWake, function () {
                    MatchManagerPVBot.ballHasBeenShot(shotDataForRulesManager);
                }, PoolClub.GameManager);
            }, PoolClub.GameManager);
        }
        static implementStateMessages(state) {
            PoolClub.GameVars.skipShowingPocketAndCue = false;
            const isPlayerTurn = PoolClub.GameVars.gameData.playerData.sessionId === state.currentTurn;
            if (state.fault === PoolClub.GameConstants.NOTIFICATION_TIMEOUT) {
                let cueBall = PoolClub.GameVars.ballArray[0];
                cueBall.onUpTimeOut();
                PoolClub.CueContainer.currentInstance.onUpTimeOut();
                PoolClub.PoolState.currentInstance.onNonSoloTimeOut(isPlayerTurn);
            }
            let player = PoolClub.GameVars.gameData.playerData.sessionId === state.human.sessionId ? state.human : state.bot;
            let adversary = PoolClub.GameVars.gameData.playerData.sessionId === state.bot.sessionId ? state.human : state.bot;
            if (isPlayerTurn) {
                PoolClub.GameVars.currentTurn = PoolClub.GameConstants.PLAYER;
            }
            else {
                PoolClub.GameVars.currentTurn = PoolClub.GameConstants.ADVERSARY;
            }
            if (!MatchManagerPVBot.sidesAlreadyAssigned) {
                if (player.typeBalls === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                    PoolClub.PoolState.currentInstance.hud.assignSidesForNonSOLO(PoolClub.GameConstants.BALL_TYPE_SOLID);
                    PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([9, 10, 11, 12, 13, 14, 15], true);
                    MatchManagerPVBot.sidesAlreadyAssigned = true;
                }
                else if (player.typeBalls === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                    PoolClub.PoolState.currentInstance.hud.assignSidesForNonSOLO(PoolClub.GameConstants.BALL_TYPE_STRIPED);
                    PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([1, 2, 3, 4, 5, 6, 7], true);
                    MatchManagerPVBot.sidesAlreadyAssigned = true;
                }
            }
            if (state.ballInHand) {
                PoolClub.StageContainer.currentInstance.showSetCueBall("Foul commited by non local player");
            }
            PoolClub.StageContainer.currentInstance.hideSelectPocket("Not local player's turn or not time to choose pocket");
            let opponentChoosingPocket = false;
            if (!isPlayerTurn && adversary.canPocketBlackBall) {
                opponentChoosingPocket = true;
                PoolClub.GameVars.skipShowingPocketAndCue = true;
            }
            PoolClub.PoolState.currentInstance.showNotificationLayer(state.fault, isPlayerTurn, opponentChoosingPocket);
            if (isPlayerTurn && player.canPocketBlackBall) {
                PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([8], false);
                PoolClub.StageContainer.currentInstance.showSelectPocket("It's time to choose pocket");
                PoolClub.GameVars.skipShowingPocketAndCue = true;
            }
            if (!isPlayerTurn) {
                MatchManagerPVBot.startBotFiringSequence(state.ballInHand, adversary.canPocketBlackBall, adversary.typeBalls, 3.6, 1, 2);
            }
        }
    }
    PoolClub.MatchManagerPVBot = MatchManagerPVBot;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class MatchManagerPVP extends PoolClub.MatchManager {
        static init(game, currentTurnPlayer_SessionId) {
            super.init(game);
            MatchManagerPVP.game = game;
            MatchManagerPVP.doWriteGameData = false;
            MatchManagerPVP.sidesAlreadyAssigned = false;
            if (!PoolClub.GameVars.gameData.playerData) {
                console.error("playerData corrupt");
            }
            if (!PoolClub.GameVars.adversaryData) {
                console.error("adversaryData corrupt");
            }
            PoolClub.GameManager.validatePocketedBalls();
            if (PoolClub.GameVars.gameData.playerData.sessionId === currentTurnPlayer_SessionId) {
                PoolClub.GameVars.currentTurn = PoolClub.GameConstants.PLAYER;
            }
            else {
                PoolClub.GameVars.currentTurn = PoolClub.GameConstants.ADVERSARY;
            }
            this.game.state.start("PoolState", true, false);
        }
        static startGame() {
            if (PoolClub.GameVars.firstShot && PoolClub.GameVars.currentTurn === PoolClub.GameConstants.PLAYER) {
                PoolClub.StageContainer.currentInstance.showSetCueBall("Game start and local player's turn");
                PoolClub.PoolState.currentInstance.showNotificationLayer(PoolClub.GameConstants.NOTIFICATION_NONE, true, false);
            }
            else {
                PoolClub.PoolState.currentInstance.showNotificationLayer(PoolClub.GameConstants.NOTIFICATION_NONE, false, false);
            }
            PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([8], true);
            MatchManagerPVP.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVP.pocketedBalls = [];
        }
        static update() {
            if (PoolClub.GameVars.gameOver) {
                return;
            }
            if (!PoolClub.GameVars.shotRunning && !PoolClub.GameVars.turnSet) {
                PoolClub.GameVars.turnSet = true;
                MatchManagerPVP.ballsStoppedMoving(MatchManagerPVP.pocketedBalls, MatchManagerPVP.firstTouchedBall, PoolClub.GameVars.pocketIdWhereBlackFell);
            }
        }
        static ballPocketed(ball) {
            PoolClub.PoolState.currentInstance.ballPocketed(ball.id);
            MatchManagerPVP.pocketedBalls.push(ball.id);
            super.ballPocketed(ball);
        }
        static newTurn(state) {
            if (PoolClub.GameVars.gameOver) {
                return;
            }
            MatchManagerPVP.implementStateMessages(state);
            PoolClub.GameVars.firstShot = false;
            PoolClub.GameVars.shotRunning = false;
            PoolClub.GameVars.english = 0;
            PoolClub.GameVars.verticalSpin = 0;
            MatchManagerPVP.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVP.pocketedBalls = [];
            PoolClub.GameVars.timerSolo = 20;
            PoolClub.MatchManager.setCueAimDirection();
            PoolClub.PoolState.currentInstance.newTurn();
        }
        static endPVPGame(reason) {
            PoolClub.GameVars.gameOver = true;
            PoolClub.GameVars.gameEnded = reason;
            PoolClub.GameVars.paused = true;
            if (reason === PoolClub.GameConstants.PLAYER_LOSE) {
                PoolClub.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                MatchManagerPVP.doWriteGameData = true;
                super.showLoseLayer();
            }
            else if (reason === PoolClub.GameConstants.PLAYER_WIN) {
                PoolClub.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                PoolClub.GameVars.gameData.statistics.nonSolo.gamesWon++;
                MatchManagerPVP.doWriteGameData = true;
                let victoryData = PoolClub.RewardsManager.prepareRewardStats();
                super.showVictoryLayer(victoryData);
            }
            else if (reason === PoolClub.GameConstants.PLAYER_RESIGNS) {
                PoolClub.PoolState.currentInstance.endGame();
            }
            else if (reason === PoolClub.GameConstants.ADVERSARY_LEFT_ROOM) {
                super.showAdversaryLeftLayer();
            }
            if (MatchManagerPVP.doWriteGameData) {
                PoolClub.GameManager.writeGameData();
            }
        }
        static matchOverDueToResignation(resigningPlayerSessionId) {
            if (PoolClub.GameConstants.LOG_SERVER_INFO) {
                console.error("matchOverDueToResignation()");
            }
            if (PoolClub.GameVars.gameData.playerData.sessionId === resigningPlayerSessionId) {
                MatchManagerPVP.endPVPGame(PoolClub.GameConstants.PLAYER_RESIGNS);
            }
            else {
                MatchManagerPVP.endPVPGame(PoolClub.GameConstants.PLAYER_WIN);
            }
        }
        static adversaryLeftRoomPVP() {
            PoolClub.GameManager.log("ADVERSARY LEFT ROOM");
            if (PoolClub.GameVars.gameOver || PoolClub.GameVars.gameMode === PoolClub.GameConstants.PVBOT_MODE) {
                return;
            }
            if (PoolClub.GameConstants.LOG_SERVER_INFO) {
                console.error("adversaryLeftRoomPVP()");
            }
            MatchManagerPVP.endPVPGame(PoolClub.GameConstants.ADVERSARY_LEFT_ROOM);
        }
        static setTouchedBall(ballId) {
            if (ballId === 0) {
                return;
            }
            if (MatchManagerPVP.firstTouchedBall === PoolClub.GameConstants.BALL_TYPE_NONE) {
                if (ballId < 8) {
                    MatchManagerPVP.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_SOLID;
                }
                else if (ballId > 8) {
                    MatchManagerPVP.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                }
                else {
                    MatchManagerPVP.firstTouchedBall = PoolClub.GameConstants.BALL_TYPE_BLACK;
                }
            }
            else {
                return;
            }
        }
        static setTouchedCushion(touchedCushion) {
        }
        static sendCueBallPosition(x, y) {
        }
        static sendSelectedPocket(pocketId) {
        }
        static adversaryCueBallPosition(position) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                let cueBall = PoolClub.GameVars.ballArray[0];
                cueBall.setPositionReceived(position.x, position.y);
            }
        }
        static adversaryRotatedCue(cueRotation) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                PoolClub.CueContainer.currentInstance.moveCue(cueRotation);
            }
        }
        static showPocketSelected(num) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                PoolClub.StageContainer.currentInstance.showSelectPocket("Setting pocket rival chose");
                PoolClub.StageContainer.currentInstance.setRivalPocket(num);
                PoolClub.StageContainer.currentInstance.showCue("adversary selected pocket set");
                PoolClub.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static shotDataReceived(shotData) {
            if (PoolClub.GameVars.currentTurn === PoolClub.GameConstants.ADVERSARY) {
                let shotDataFinal = {
                    vector: new Billiard.Vector2D(shotData.cueSpeed.vx, shotData.cueSpeed.vy),
                    deltaScrew: new Billiard.Vector2D(shotData.deltaScrew.x, shotData.deltaScrew.y),
                    english: shotData.english
                };
                super.forceCueToShoot(shotDataFinal);
            }
        }
        static cueRotated(cueRotation) {
        }
        static ballsStoppedMoving(balls, firstBall, blackBallPocket) {
        }
        static ballHasBeenShot(shotData) {
        }
        static matchFinished(winnerId) {
            if (PoolClub.GameConstants.LOG_SERVER_INFO) {
                console.error("matchFinished()");
            }
            if (PoolClub.GameVars.gameData.playerData.sessionId === winnerId) {
                MatchManagerPVP.endPVPGame(PoolClub.GameConstants.PLAYER_WIN);
            }
            else {
                MatchManagerPVP.endPVPGame(PoolClub.GameConstants.PLAYER_LOSE);
            }
        }
        static playerSet() {
            if (PoolClub.GameConstants.LOG_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_PLAYER_SET");
            }
        }
        static implementStateMessages(state) {
            if (!state.playerA || !state.playerB) {
                return;
            }
            PoolClub.GameVars.skipShowingPocketAndCue = false;
            const isPlayerTurn = PoolClub.GameVars.gameData.playerData.sessionId === state.currentTurn;
            if (state.fault === PoolClub.GameConstants.NOTIFICATION_TIMEOUT) {
                let cueBall = PoolClub.GameVars.ballArray[0];
                cueBall.onUpTimeOut();
                PoolClub.CueContainer.currentInstance.onUpTimeOut();
                PoolClub.PoolState.currentInstance.onNonSoloTimeOut(isPlayerTurn);
            }
            let player = PoolClub.GameVars.gameData.playerData.sessionId === state.playerA.sessionId ? state.playerA : state.playerB;
            let adversary = PoolClub.GameVars.gameData.playerData.sessionId === state.playerB.sessionId ? state.playerA : state.playerB;
            if (isPlayerTurn) {
                PoolClub.GameVars.currentTurn = PoolClub.GameConstants.PLAYER;
            }
            else {
                PoolClub.GameVars.currentTurn = PoolClub.GameConstants.ADVERSARY;
            }
            if (!MatchManagerPVP.sidesAlreadyAssigned) {
                if (player.typeBalls === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                    PoolClub.PoolState.currentInstance.hud.assignSidesForNonSOLO(PoolClub.GameConstants.BALL_TYPE_SOLID);
                    PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([9, 10, 11, 12, 13, 14, 15], true);
                    MatchManagerPVP.sidesAlreadyAssigned = true;
                }
                else if (player.typeBalls === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                    PoolClub.PoolState.currentInstance.hud.assignSidesForNonSOLO(PoolClub.GameConstants.BALL_TYPE_STRIPED);
                    PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([1, 2, 3, 4, 5, 6, 7], true);
                    MatchManagerPVP.sidesAlreadyAssigned = true;
                }
            }
            if (state.ballInHand && PoolClub.StageContainer.currentInstance) {
                PoolClub.StageContainer.currentInstance.showSetCueBall("Foul commited by non local player");
            }
            PoolClub.StageContainer.currentInstance.hideSelectPocket("Not local player's turn or not time to choose pocket");
            let opponentChoosingPocket = false;
            if (!isPlayerTurn && adversary.canPocketBlackBall) {
                opponentChoosingPocket = true;
                PoolClub.GameVars.skipShowingPocketAndCue = true;
            }
            PoolClub.PoolState.currentInstance.showNotificationLayer(state.fault, isPlayerTurn, opponentChoosingPocket);
            if (isPlayerTurn && player.canPocketBlackBall) {
                PoolClub.StageContainer.currentInstance.setGuideProhibitedBalls([8], false);
                PoolClub.StageContainer.currentInstance.showSelectPocket("It's time to choose pocket");
                PoolClub.GameVars.skipShowingPocketAndCue = true;
            }
        }
    }
    PoolClub.MatchManagerPVP = MatchManagerPVP;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class MatchManagerSolo extends PoolClub.MatchManager {
        static init(game) {
            super.init(game);
            MatchManagerSolo.game = game;
            MatchManagerSolo.doWriteGameData = false;
            MatchManagerSolo.currentTurnStreak = 0;
            MatchManagerSolo.comboTicker = 0;
            MatchManagerSolo.newHighScore = false;
        }
        static startGame() {
            PoolClub.MatchManager.rackBalls();
            PoolClub.GameManager.validatePocketedBalls();
            if (PoolClub.GameVars.gameData.soloTutorial) {
                PoolClub.PoolState.currentInstance.showNotificationLayer(PoolClub.GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS);
                PoolClub.GameVars.gameData.soloTutorial = false;
                PoolClub.GameManager.writeGameData();
            }
        }
        static update() {
            if (!PoolClub.GameVars.shotRunning && !PoolClub.GameVars.turnSet) {
                this.newTurn();
                MatchManagerSolo.currentTurnStreak = 0;
                MatchManagerSolo.comboTicker = 0;
            }
            if (MatchManagerSolo.comboTicker > 0) {
                MatchManagerSolo.comboTicker -= this.game.time.physicsElapsed;
            }
            else if (MatchManagerSolo.currentTurnStreak > 0) {
                MatchManagerSolo.currentTurnStreak = 0;
            }
        }
        static ballPocketed(ball) {
            super.ballPocketed(ball);
            const id = ball.id;
            if (id === 0) {
                PoolClub.PoolState.currentInstance.showPocketEffect(true);
                PoolClub.GameVars.playerPoints -= 20;
            }
            else {
                PoolClub.GameVars.timerSolo += PoolClub.GameConstants.TIME_BONUS_ON_POCKET_BALL;
                PoolClub.GameVars.playerPoints += 50;
                PoolClub.PoolState.currentInstance.showPocketEffect(false);
                if (MatchManagerSolo.currentTurnStreak === 1) {
                    PoolClub.GameVars.playerPoints += 0;
                    PoolClub.PoolState.currentInstance.hud.showComboEffect(700);
                    MatchManagerSolo.addCombo();
                }
                else if (MatchManagerSolo.currentTurnStreak >= 2) {
                    PoolClub.GameVars.playerPoints += 0;
                    PoolClub.PoolState.currentInstance.hud.showSuperComboEffect(500);
                    MatchManagerSolo.addSuperCombo();
                }
                MatchManagerSolo.currentTurnStreak++;
                MatchManagerSolo.comboTicker = 3;
            }
            if (PoolClub.GameVars.pocketedBalls.length === 15) {
                let cueBall = PoolClub.GameVars.ballArray[0];
                this.game.add.tween(cueBall.mc)
                    .to({ alpha: 0 }, 350, Phaser.Easing.Cubic.Out, true, 500)
                    .onComplete.add(function () {
                    MatchManagerSolo.resetBalls();
                }, this);
                this.game.add.tween(cueBall.shadow)
                    .to({ alpha: 0 }, 350, Phaser.Easing.Cubic.Out, true, 500);
            }
            if (!MatchManagerSolo.newHighScore && PoolClub.GameVars.playerPoints > PoolClub.GameVars.gameData.statistics.solo.highScore && PoolClub.GameVars.gameData.statistics.solo.highScore > 0) {
                if (PoolClub.GameVars.pocketedBalls.length === 15) {
                    PoolClub.GameVars.playNewHighScore = true;
                }
                else {
                    PoolClub.PoolState.currentInstance.hud.showHighScoreEffect();
                }
                MatchManagerSolo.newHighScore = true;
            }
        }
        static addCombo() {
            PoolClub.GameVars.gameData.statistics.solo.combos++;
            PoolClub.GameManager.writeGameData();
        }
        static addSuperCombo() {
            PoolClub.GameVars.gameData.statistics.solo.superCombos++;
            PoolClub.GameManager.writeGameData();
        }
        static checkCombos() {
            var api_awards = [];
            if (PoolClub.GameVars.gameData.statistics.solo.combos === 10) {
                api_awards.push("pool_clubs_vks0005");
            }
            if (PoolClub.GameVars.gameData.statistics.solo.superCombos === 10) {
                api_awards.push("pool_clubs_vks0006");
            }
            LaggedAPI.Achievements.save(api_awards, function (response) {
                if (response.success) {
                    console.log("achievement saved");
                }
                else {
                    console.log(response.errormsg);
                }
            });
        }
        static newTurn() {
            if (PoolClub.GameVars.gameOver) {
                return;
            }
            PoolClub.GameVars.firstShot = false;
            PoolClub.GameVars.shotRunning = false;
            PoolClub.GameVars.turnSet = true;
            PoolClub.GameVars.english = 0;
            PoolClub.GameVars.verticalSpin = 0;
            if (PoolClub.GameVars.pocketedBalls.length >= 15) {
                MatchManagerSolo.resetBalls();
            }
            PoolClub.MatchManager.setCueAimDirection();
            PoolClub.PoolState.currentInstance.newTurn();
            PoolClub.GameVars.ballsData.length = 0;
            for (let i = 0; i < PoolClub.GameVars.ballArray.length; i++) {
                let ballData = { id: PoolClub.GameVars.ballArray[i].id, active: PoolClub.GameVars.ballArray[i].active, x: PoolClub.GameVars.ballArray[i].position.x, y: PoolClub.GameVars.ballArray[i].position.y };
                PoolClub.GameVars.ballsData.push(ballData);
            }
            PoolClub.GameManager.log("ballData:" + JSON.stringify(PoolClub.GameVars.ballsData));
        }
        static resetBalls() {
            PoolClub.GameVars.pocketedBalls = [];
            PoolClub.GameVars.ballsData = [];
            PoolClub.GameVars.canStart = false;
            PoolClub.GameVars.firstShot = true;
            PoolClub.GameVars.resetScoreAndTime = false;
            PoolClub.GameManager.enterSoloGame();
        }
        static computeSoloStats() {
            if (PoolClub.GameVars.playerPoints > PoolClub.GameVars.gameData.statistics.solo.highScore) {
                PoolClub.GameVars.gameData.statistics.solo.highScore = PoolClub.GameVars.playerPoints;
                MatchManagerSolo.doWriteGameData = true;
            }
        }
        static endSoloGame(reason) {
            PoolClub.GameVars.gameOver = true;
            PoolClub.GameVars.gameEnded = reason;
            PoolClub.GameVars.paused = true;
            MatchManagerSolo.computeSoloStats();
            if (reason === PoolClub.GameConstants.PLAYER_LOSE) {
                super.showSoloRetryLayer();
            }
            else if (reason === PoolClub.GameConstants.PLAYER_WIN) {
                MatchManagerSolo.doWriteGameData = true;
                let victoryData = PoolClub.RewardsManager.prepareRewardStats();
                super.showVictoryLayer(victoryData);
            }
            else if (reason === PoolClub.GameConstants.PLAYER_RESIGNS) {
                PoolClub.PoolState.currentInstance.endGame();
            }
            if (MatchManagerSolo.doWriteGameData) {
                PoolClub.GameManager.writeGameData();
            }
        }
        static startSoloTime() {
            this.game.time.events.loop(Phaser.Timer.SECOND, function () {
                if (PoolClub.GameVars.paused || !PoolClub.GameVars.startMatch) {
                    return;
                }
                PoolClub.GameVars.timerSolo--;
                PoolClub.PoolState.currentInstance.hud.updateSoloTimer();
                if (PoolClub.GameVars.timerSolo === -1) {
                    this.endSoloGame(PoolClub.GameConstants.PLAYER_LOSE);
                }
            }, this);
        }
    }
    PoolClub.MatchManagerSolo = MatchManagerSolo;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class RulesManager {
        static init(playerData, botData) {
            RulesManager.offlineState = ({
                human: null,
                bot: null,
                currentTurn: null,
                changeTurn: false,
                numberShots: 0,
                balls: [],
                ballInHand: true,
                pocketSelected: -1,
                fault: PoolClub.GameConstants.NOTIFICATION_NONE,
                playerLeft: false,
                winnerSessionId: null
            });
            for (let i = 0; i < 16; i++) {
                let ball = { id: i, active: true };
                RulesManager.offlineState.balls.push(ball);
            }
            RulesManager.setupPlayerAndBot(playerData, botData);
        }
        static sendMessage(message) {
            RulesManager.onMessage(message);
        }
        static onMessage(message) {
            switch (message.type) {
                case PoolClub.GameConstants.MESSAGE_TYPE_BALLS_STOPPED:
                    RulesManager.offlineState.human.ballsMoving = false;
                    RulesManager.updateState(message.data);
                    RulesManager.decideTurn();
                    if (!RulesManager.offlineState.winnerSessionId) {
                        PoolClub.GameManager.onPVBotTurnChange(RulesManager.offlineState);
                    }
                    else {
                        PoolClub.MatchManagerPVBot.matchFinished(this.offlineState.winnerSessionId);
                    }
                    break;
                case PoolClub.GameConstants.MESSAGE_TYPE_POCKET_SELECTED:
                    RulesManager.offlineState.pocketSelected = message.data;
                    PoolClub.MatchManagerPVBot.showPocketSelected(message.data);
                    break;
                case PoolClub.GameConstants.MESSAGE_TYPE_CUE_ROTATION:
                    PoolClub.MatchManagerPVBot.adversaryRotatedCue(message.data);
                    break;
                case PoolClub.GameConstants.MESSAGE_TYPE_CUE_BALL:
                    PoolClub.MatchManagerPVBot.adversaryCueBallPosition(message.data);
                    break;
                case PoolClub.GameConstants.MESSAGE_TYPE_SHOT:
                    RulesManager.offlineState.human.ballsMoving = true;
                    RulesManager.offlineState.bot.ballsMoving = true;
                    PoolClub.MatchManagerPVBot.shotDataReceived(message.data);
                    break;
                case PoolClub.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED:
                    if (!RulesManager.offlineState.human.canPocketBlackBall && !RulesManager.offlineState.bot.canPocketBlackBall) {
                        if (RulesManager.offlineState.currentTurn === RulesManager.offlineState.human.sessionId) {
                            RulesManager.offlineState.winnerSessionId = RulesManager.offlineState.bot.sessionId;
                        }
                        else {
                            RulesManager.offlineState.winnerSessionId = RulesManager.offlineState.human.sessionId;
                        }
                        PoolClub.MatchManagerPVBot.matchFinished(RulesManager.offlineState.winnerSessionId, 2);
                        RulesManager.offlineState.winnerSessionId = null;
                    }
                    break;
                default:
            }
        }
        static timeOut() {
            RulesManager.offlineState.changeTurn = true;
            RulesManager.offlineState.ballInHand = true;
            RulesManager.offlineState.fault = PoolClub.GameConstants.NOTIFICATION_TIMEOUT;
            RulesManager.offlineState.pocketSelected = -1;
            RulesManager.decideTurn();
            PoolClub.GameManager.onPVBotTurnChange(RulesManager.offlineState);
        }
        static setupPlayerAndBot(playerData, botData) {
            RulesManager.offlineState.human = playerData;
            RulesManager.offlineState.bot = botData;
            RulesManager.offlineState.currentTurn = RulesManager.offlineState.human.sessionId;
            RulesManager.offlineState.numberShots += 1;
        }
        static updateState(data) {
            let balls = data.balls;
            let firstBallTouch = data.firstBall;
            let blackBallPocket = data.blackBallPocket;
            let player;
            if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                player = this.offlineState.human;
            }
            else {
                player = this.offlineState.bot;
            }
            let fault = false;
            let typeFault = PoolClub.GameConstants.NOTIFICATION_NONE;
            if (firstBallTouch === PoolClub.GameConstants.BALL_TYPE_NONE) {
                fault = true;
                typeFault = PoolClub.GameConstants.NOTIFICATION_NO_BALL_TOUCHED;
            }
            if (firstBallTouch === PoolClub.GameConstants.BALL_TYPE_BLACK && !player.canPocketBlackBall) {
                fault = true;
                typeFault = PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
            }
            if (firstBallTouch === PoolClub.GameConstants.BALL_TYPE_SOLID && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                fault = true;
                typeFault = PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
            }
            if (firstBallTouch === PoolClub.GameConstants.BALL_TYPE_STRIPED && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                fault = true;
                typeFault = PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
            }
            for (let i = 0; i < balls.length; i++) {
                if (balls[i] === 0) {
                    fault = true;
                    typeFault = PoolClub.GameConstants.NOTIFICATION_CUE_BALL_POTTED;
                }
                else if (balls[i] === 8 && !player.canPocketBlackBall) {
                    fault = true;
                    typeFault = PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
                }
                else if (balls[i] < 8 && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                    fault = true;
                    typeFault = PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
                }
                else if (balls[i] > 8 && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                    fault = true;
                    typeFault = PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
                }
            }
            let pocketBall = false;
            let win = -1;
            for (let i = 0; i < balls.length; i++) {
                if (balls[i] === 0) {
                    continue;
                }
                else if (balls[i] < 8 && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                    pocketBall = true;
                }
                else if (balls[i] > 8 && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                    pocketBall = true;
                }
                else if (balls[i] !== 8 && player.typeBalls === PoolClub.GameConstants.BALL_TYPE_NONE) {
                    pocketBall = true;
                }
                else if (balls[i] === 8) {
                    if (player.canPocketBlackBall) {
                        if (fault) {
                            win = 0;
                        }
                        else {
                            if (this.offlineState.pocketSelected === blackBallPocket) {
                                win = 1;
                            }
                            else {
                                win = 0;
                            }
                        }
                    }
                    else {
                        win = 0;
                    }
                }
            }
            if (win !== -1) {
                if (win === 0) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.winnerSessionId = this.offlineState.bot.sessionId;
                    }
                    else {
                        this.offlineState.winnerSessionId = this.offlineState.human.sessionId;
                    }
                }
                else if (win === 1) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.winnerSessionId = this.offlineState.human.sessionId;
                    }
                    else {
                        this.offlineState.winnerSessionId = this.offlineState.bot.sessionId;
                    }
                }
            }
            if (player.typeBalls === PoolClub.GameConstants.BALL_TYPE_NONE && !fault) {
                let solidBalls = 0;
                let stripedBalls = 0;
                for (let i = 0; i < balls.length; i++) {
                    if (balls[i] === 0 || balls[i] === 8) {
                        continue;
                    }
                    else if (balls[i] < 8) {
                        solidBalls++;
                    }
                    else if (balls[i] > 8) {
                        stripedBalls++;
                    }
                }
                if (solidBalls > 0 && stripedBalls === 0) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.human.typeBalls = PoolClub.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.bot.typeBalls = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                    }
                    else {
                        this.offlineState.bot.typeBalls = PoolClub.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.human.typeBalls = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                    }
                }
                else if (stripedBalls > 0 && solidBalls === 0) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.bot.typeBalls = PoolClub.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.human.typeBalls = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                    }
                    else {
                        this.offlineState.human.typeBalls = PoolClub.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.bot.typeBalls = PoolClub.GameConstants.BALL_TYPE_STRIPED;
                    }
                }
            }
            if (fault) {
                this.offlineState.changeTurn = true;
                this.offlineState.ballInHand = true;
            }
            else {
                if (pocketBall) {
                    this.offlineState.changeTurn = false;
                }
                else {
                    this.offlineState.changeTurn = true;
                }
                this.offlineState.ballInHand = false;
            }
            this.offlineState.fault = typeFault;
            this.offlineState.pocketSelected = -1;
            for (let i = 0; i < balls.length; i++) {
                for (let j = 0; j < this.offlineState.balls.length; j++) {
                    if (balls[i] === this.offlineState.balls[j].id) {
                        this.offlineState.balls[j].active = false;
                        if (this.offlineState.balls[j].id === 0) {
                            this.offlineState.balls[j].active = true;
                        }
                    }
                }
            }
            this.offlineState.bot.canPocketBlackBall = RulesManager.canPocketBlackBall(this.offlineState.bot.typeBalls);
            this.offlineState.human.canPocketBlackBall = RulesManager.canPocketBlackBall(this.offlineState.human.typeBalls);
        }
        static decideTurn() {
            if (this.offlineState.changeTurn) {
                if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                    this.offlineState.currentTurn = this.offlineState.bot.sessionId;
                }
                else {
                    this.offlineState.currentTurn = this.offlineState.human.sessionId;
                }
            }
            else {
                if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                    this.offlineState.currentTurn = this.offlineState.human.sessionId;
                }
                else {
                    this.offlineState.currentTurn = this.offlineState.bot.sessionId;
                }
            }
            this.offlineState.numberShots += 1;
        }
        static canPocketBlackBall(typeBalls) {
            let result = true;
            for (let i = 0; i < RulesManager.offlineState.balls.length; i++) {
                if (RulesManager.offlineState.balls[i].id === 0 || RulesManager.offlineState.balls[i].id === 8) {
                    continue;
                }
                if (!RulesManager.offlineState.balls[i].active) {
                    continue;
                }
                if (typeBalls === PoolClub.GameConstants.BALL_TYPE_NONE) {
                    result = false;
                }
                else if (typeBalls === PoolClub.GameConstants.BALL_TYPE_SOLID) {
                    if (RulesManager.offlineState.balls[i].id < 8) {
                        result = false;
                    }
                }
                else if (typeBalls === PoolClub.GameConstants.BALL_TYPE_STRIPED) {
                    if (RulesManager.offlineState.balls[i].id > 8) {
                        result = false;
                    }
                }
            }
            return result;
        }
    }
    PoolClub.RulesManager = RulesManager;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class NotificationLayer extends Phaser.Group {
        constructor(game, type, isPlayerTurn, opponentChoosingPocket) {
            super(game, null, "messages-layer");
            NotificationLayer.currentInstance = this;
            this.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.x = PoolClub.GameConstants.GAME_WIDTH / 2;
            this.y = PoolClub.GameConstants.GAME_HEIGHT / 2;
            this.notificationDurationScaleModifier = 0.4;
            this.layerFadeDuration = 1000 * this.notificationDurationScaleModifier;
            this.layerDisplayDuration = 7000 * this.notificationDurationScaleModifier;
            this.alpha = 0;
            this.game.add.tween(this)
                .to({ alpha: 1 }, this.layerFadeDuration, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function () {
                NotificationLayer.currentInstance.hideNotification();
            }, this);
            if (PoolClub.GameVars.gameMode !== PoolClub.GameConstants.SOLO_MODE) {
                this.showNonSOLONotification(type, isPlayerTurn, opponentChoosingPocket);
            }
            else {
                if (type === PoolClub.GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS) {
                    const transparentBackground = new Phaser.Sprite(this.game, 0, 145, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
                    transparentBackground.anchor.set(0.5, 0);
                    transparentBackground.alpha = .6;
                    this.add(transparentBackground);
                    const rulesText = new Phaser.Text(this.game, 0, 160, PoolClub.GameConstants.RULES_TEXT, { font: this.game.device.desktop ? "28px Teko-SemiBold" : "38px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8", align: "center", stroke: "#2f3237", strokeThickness: 3 });
                    rulesText.anchor.set(0.5, 0);
                    this.add(rulesText);
                    transparentBackground.scale.set((rulesText.width + 40) / 64, (rulesText.height + 30) / 64);
                    this.layerDisplayDuration = 16000 * this.notificationDurationScaleModifier;
                }
            }
        }
        hideNotification() {
            if (!this.game) {
                return;
            }
            this.game.add.tween(this)
                .to({ alpha: 0 }, this.layerFadeDuration, Phaser.Easing.Cubic.Out, true, this.layerDisplayDuration)
                .onComplete.add(function () {
                PoolClub.PoolState.currentInstance.hideNotificationLayer();
            }, this);
        }
        showNonSOLONotification(type, isPlayerTurn, opponentChoosingPocket) {
            const turnImageSwipeDuration = 1000 * this.notificationDurationScaleModifier;
            const turnImageDisplayDuration = 5000 * this.notificationDurationScaleModifier;
            const text = new Phaser.Text(this.game, 0, 0, "", { font: "30px Teko-SemiBold", fontWeight: "600", fill: "#EB3359", align: "center" });
            text.stroke = "#673952";
            text.strokeThickness = 5;
            text.anchor.set(0.5);
            this.add(text);
            const turnImage = new Phaser.Image(this.game, PoolClub.GameConstants.GAME_WIDTH + 100, 240, "texture_atlas_1", isPlayerTurn ? "your_turn.png" : "rivals_turn.png");
            turnImage.anchor.set(0.5);
            this.add(turnImage);
            this.game.add.tween(turnImage)
                .to({ x: 50 }, turnImageSwipeDuration, Phaser.Easing.Exponential.Out, true, this.layerFadeDuration)
                .onComplete.add(function () {
                this.game.add.tween(turnImage)
                    .to({ x: turnImage.x - 100 }, turnImageDisplayDuration, Phaser.Easing.Linear.None, true)
                    .onComplete.add(function () {
                    this.game.add.tween(turnImage).to({ x: -PoolClub.GameConstants.GAME_WIDTH - 100 }, turnImageSwipeDuration, Phaser.Easing.Exponential.In, true);
                }, this);
            }, this);
            if (type === PoolClub.GameConstants.NOTIFICATION_CUE_BALL_POTTED) {
                text.text = "CUE BALL POCKETED";
            }
            else if (type === PoolClub.GameConstants.NOTIFICATION_NO_BALL_TOUCHED) {
                text.text = "NO BALL TOUCHED";
            }
            else if (type === PoolClub.GameConstants.NOTIFICATION_TIMEOUT) {
                text.text = "OUT OF TIME";
            }
            else if (type === PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_POTTED) {
                text.text = "WRONG BALL POCKETED";
            }
            else if (type === PoolClub.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED) {
                text.text = "WRONG BALL TOUCHED FIRST";
            }
            else if (type === PoolClub.GameConstants.NOTIFICATION_NONE) {
                text.visible = false;
            }
            if (opponentChoosingPocket) {
                if (text.visible) {
                    text.text += "\n";
                }
                else {
                    text.visible = true;
                }
                text.text += "OPPONENT CHOOSING POCKET";
            }
            const iconFoul = new Phaser.Image(this.game, 0, text.y, "texture_atlas_1", "icon_foul.png");
            iconFoul.anchor.set(1, .5);
            const iconHalfWidth = iconFoul.width * 0.5;
            text.x += iconHalfWidth * 1.2;
            iconFoul.x = text.x - (text.width * 0.5);
            iconFoul.visible = text.visible;
            this.add(iconFoul);
        }
    }
    PoolClub.NotificationLayer = NotificationLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class PreloadBar extends Phaser.Group {
        constructor(game) {
            super(game, null, "preloadbar");
            this.x = PoolClub.GameConstants.GAME_WIDTH / 2;
            this.y = 395;
            this.f = 0;
            this.scale.x = PoolClub.GameVars.scaleXMult;
            this.scale.y = PoolClub.GameVars.scaleYMult;
            this.preloadCue = new Phaser.Image(this.game, -PreloadBar.RECT_WIDTH / 2, 0, "preload_cue");
            this.preloadCue.anchor.set(1, .5);
            this.add(this.preloadCue);
            this.preloadCueBall = new Phaser.Image(this.game, PreloadBar.RECT_WIDTH / 2 + 22, 0, "preload_cue_ball");
            this.preloadCueBall.anchor.set(.5);
            this.add(this.preloadCueBall);
            const graphics = new Phaser.Graphics(this.game);
            graphics.lineStyle(2, 0xFFFFFF);
            graphics.drawRoundedRect(-PreloadBar.RECT_WIDTH / 2, -PreloadBar.RECT_HEIGTH / 2, PreloadBar.RECT_WIDTH, PreloadBar.RECT_HEIGTH, 6);
            this.add(graphics);
            this.percentageLabel = new Phaser.Text(this.game, 0, 52, "0%", { font: "40px Teko-SemiBold", fontWeight: "400", fill: "#FFFFFF" });
            this.percentageLabel.anchor.set(.5);
            this.percentageLabel.visible = false;
            this.add(this.percentageLabel);
        }
        update() {
            super.update();
            this.f++;
            if (this.f === 10) {
                this.percentageLabel.visible = true;
            }
        }
        updateLoadedPercentage(loadProgress) {
            this.percentageLabel.text = loadProgress + "%";
            this.preloadCue.x = -PreloadBar.RECT_WIDTH / 2 + loadProgress / 100 * (PreloadBar.RECT_WIDTH + 6);
            if (loadProgress === 100) {
                this.game.add.tween(this.preloadCue)
                    .to({ x: this.preloadCue.x - 36 }, 300, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function () {
                    this.game.add.tween(this.preloadCue)
                        .to({ x: this.preloadCue.x + 40 }, 100, Phaser.Easing.Cubic.Out, true)
                        .onComplete.add(function () {
                        this.game.add.tween(this.preloadCueBall)
                            .to({ x: (PoolClub.GameConstants.GAME_WIDTH / 2 + 50) * PoolClub.GameVars.scaleXMultInverse }, 250, Phaser.Easing.Cubic.Out, true)
                            .onComplete.add(function () {
                            if (this.game.device.desktop && PoolClub.GameVars.gameData.musicMuted) {
                                this.percentageLabel.visible = false;
                            }
                            else {
                                if (this.game.device.touch) {
                                    this.percentageLabel.text = "Tap anywhere to start";
                                }
                                else {
                                    this.percentageLabel.text = "Click anyhwere to start";
                                }
                            }
                            this.game.add.tween(this.percentageLabel)
                                .to({ alpha: .35 }, 400, Phaser.Easing.Cubic.Out, true, 0, -1, true);
                            PoolClub.PreLoader.currentInstance.cueBallDisappeared();
                        }, this);
                    }, this);
                }, this);
            }
        }
    }
    PreloadBar.RECT_WIDTH = 290;
    PreloadBar.RECT_HEIGTH = 26;
    PoolClub.PreloadBar = PreloadBar;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class PreLoader extends Phaser.State {
        init() {
            PreLoader.currentInstance = this;
        }
        preload() {
            Phaser.Canvas.setBackgroundColor(this.game.canvas, "#000000");
            PokiSDK.gameLoadingStart();
            this.generateBitmapData();
            this.composeScene();
            this.loadAssets();
        }
        create() {
        }
        cueBallDisappeared() {
            if (this.game.device.desktop && PoolClub.GameVars.gameData.musicMuted) {
                PoolClub.GameManager.fullscreenFilter(PoolClub.GameManager.onGameAssetsLoaded);
            }
            else {
                if (this.game.device.iOS) {
                    window.addEventListener("touchstart", PreLoader.currentInstance.goFullScreen);
                }
                else {
                    window.addEventListener("mousedown", PreLoader.currentInstance.goFullScreen);
                }
            }
        }
        shutdown() {
            PreLoader.currentInstance = this;
            if (!(this.game.device.desktop && PoolClub.GameVars.gameData.musicMuted)) {
                if (this.game.device.iOS) {
                    window.removeEventListener("touchstart", PreLoader.currentInstance.goFullScreen);
                }
                else {
                    window.removeEventListener("mousedown", PreLoader.currentInstance.goFullScreen);
                }
            }
            super.shutdown();
        }
        goFullScreen() {
            PoolClub.GameManager.fullscreenFilter(PoolClub.GameManager.onGameAssetsLoaded);
        }
        updateLoadedPercentage() {
            this.preloadBar.updateLoadedPercentage(this.load.progress);
        }
        generateBitmapData() {
            let bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BLACK_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#000000";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BLACK_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#000000";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.WHITE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FFFFFF";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.RED_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FF0000";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.ORANGE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FF9900";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.YELLOW_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FFFF00";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.GREEN_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#00FF00";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BLUE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#0f1726";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.GREY_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#2F3237";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.DARK_BLUE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#0E1932";
            bmd.ctx.fill();
        }
        composeScene() {
            this.add.text(PoolClub.GameConstants.GAME_WIDTH * .5, PoolClub.GameConstants.GAME_HEIGHT * .5, "ABCDEFG", { font: "30px Teko-SemiBold", fontWeight: "400", fill: "#542200" });
            this.add.text(PoolClub.GameConstants.GAME_WIDTH * .5, PoolClub.GameConstants.GAME_HEIGHT * .5, "ABCDEFG", { font: "30px Teko-Light", fontWeight: "400", fill: "#542200" });
            const background = this.add.sprite(0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.DARK_BLUE_SQUARE));
            background.scale.set(PoolClub.GameConstants.GAME_WIDTH / PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.GAME_HEIGHT / PoolClub.GameConstants.BITMAP_SIZE);
            const gameLogo = this.add.image(PoolClub.GameConstants.GAME_WIDTH / 2, 120, "game-title");
            gameLogo.anchor.set(.5);
            gameLogo.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.preloadBar = new PoolClub.PreloadBar(this.game);
            this.add.existing(this.preloadBar);
        }
        loadAssets() {
            if (PoolClub.GameConstants.DEVELOPMENT) {
                this.load.atlasJSONArray("texture_atlas_0", "/texture_atlas_0.png", "/texture_atlas_0.json");
            }
            this.load.atlasJSONArray("texture_atlas_1", "/texture_atlas_1.png", "/texture_atlas_1.json");
            this.load.atlasJSONArray("texture_atlas_2", "/texture_atlas_2.png", "/texture_atlas_2.json");
            this.load.audiosprite("audio-sprite", ["/audio/audiosprite.mp3", "/audio/audiosprite.ogg"], "/audio/audiosprite.json");
            this.load.onFileComplete.add(this.updateLoadedPercentage, this);
        }
    }
    PoolClub.PreLoader = PreLoader;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class SettingsLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "settings-layer");
            SettingsLayer.currentInstance = this;
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(PoolClub.GameConstants.GAME_WIDTH / 64, PoolClub.GameConstants.GAME_HEIGHT / 64);
            transparentBackground.alpha = .96;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            let backButton_px;
            backButton_px = 46 * PoolClub.GameVars.scaleXMult;
            const buttonBack = new Phaser.Button(this.game, backButton_px, 46 * PoolClub.GameVars.scaleYMult, "texture_atlas_1", this.onClickExit, this);
            buttonBack.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png");
            buttonBack.anchor.set(.5);
            buttonBack.forceOut = true;
            if (this.game.device.touch) {
                buttonBack.onInputDown.add(function () { buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1); }, this);
            }
            buttonBack.onInputOver.add(function () { buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1); }, this);
            buttonBack.onInputOut.add(function () { buttonBack.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult); }, this);
            buttonBack.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(buttonBack);
            const titleLabel = new Phaser.Text(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, 40, "SETTINGS", { font: "68px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8" });
            titleLabel.anchor.x = .5;
            titleLabel.stroke = "#2f3237";
            titleLabel.strokeThickness = 5;
            titleLabel.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(titleLabel);
            const scaledItemsContainer = new Phaser.Group(this.game);
            scaledItemsContainer.x = PoolClub.GameConstants.GAME_WIDTH / 2;
            scaledItemsContainer.y = PoolClub.GameConstants.GAME_HEIGHT / 2;
            scaledItemsContainer.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.add(scaledItemsContainer);
            const audioSwitchButton = new PoolClub.SwitchButton(this.game, !PoolClub.GameVars.gameData.musicMuted, PoolClub.SwitchButton.MUSIC);
            audioSwitchButton.x = -90;
            audioSwitchButton.y = 0;
            scaledItemsContainer.add(audioSwitchButton);
            const audioLabel = new Phaser.Text(this.game, audioSwitchButton.x, audioSwitchButton.y - 40, "AUDIO", { font: "24px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8", align: "center", stroke: "#2f3237", strokeThickness: 3 });
            audioLabel.anchor.set(.5);
            scaledItemsContainer.add(audioLabel);
            if (this.game.device.touch) {
                const switchStartingState = PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.RIGHT;
                const powerSwitchButton = new PoolClub.SwitchButton(this.game, switchStartingState, PoolClub.SwitchButton.POWER);
                powerSwitchButton.x = 90;
                powerSwitchButton.y = 0;
                scaledItemsContainer.add(powerSwitchButton);
                const powerTextLeft = "RAIL: RIGHT";
                const powerTextRight = "RAIL: LEFT";
                this.powerLabel = new Phaser.Text(this.game, powerSwitchButton.x, powerSwitchButton.y - 40, powerTextLeft, { font: "24px Teko-SemiBold", fontWeight: "600", fill: "#e7f6f8", align: "center", stroke: "#2f3237", strokeThickness: 3 });
                this.powerLabel.anchor.set(.5);
                scaledItemsContainer.add(this.powerLabel);
                if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.RIGHT) {
                    this.powerLabel.text = powerTextRight;
                }
            }
            else {
                audioSwitchButton.x = 0;
                audioLabel.x = 0;
            }
            this.alpha = 0;
            this.game.add.tween(this)
                .to({ alpha: 1 }, 400, Phaser.Easing.Cubic.Out, true);
        }
        changePower() {
            const powerTextLeft = "RAIL: RIGHT";
            const powerTextRight = "RAIL: LEFT";
            if (PoolClub.GameVars.gameData.powerBarSide === PoolClub.GameConstants.LEFT) {
                this.powerLabel.text = powerTextLeft;
            }
            else {
                this.powerLabel.text = powerTextRight;
            }
        }
        destroy() {
            SettingsLayer.currentInstance = null;
            super.destroy();
        }
        onClickExit(b) {
            b.clearFrames();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            PoolClub.SplashState.currentInstance.hideSettingsLayer();
        }
        onDownTransparentLayer() {
        }
    }
    PoolClub.SettingsLayer = SettingsLayer;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class SplashState extends Phaser.State {
        init() {
            SplashState.currentInstance = this;
            this.portraitButton = null;
            this.nameLabel = null;
            this.settingsLayer = null;
        }
        create() {
            const background = this.add.image(PoolClub.GameConstants.GAME_WIDTH / 2, PoolClub.GameConstants.GAME_HEIGHT / 2, "texture_atlas_1", "splash.png");
            background.anchor.set(.5);
            background.inputEnabled = true;
            background.events.onInputUp.add(() => {
            }, this);
            background.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / background.height);
            const leftSplashEdge = this.add.image(0, PoolClub.GameConstants.GAME_HEIGHT / 2, "texture_atlas_2", "splash_frame_border.png");
            leftSplashEdge.anchor.set(0, .5);
            leftSplashEdge.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / background.height);
            const rightSplashEdge = this.add.image(PoolClub.GameConstants.GAME_WIDTH, PoolClub.GameConstants.GAME_HEIGHT / 2, "texture_atlas_2", "splash_frame_border.png");
            rightSplashEdge.anchor.set(0, .5);
            rightSplashEdge.scale.set(-PoolClub.GameVars.scaleXMult, PoolClub.GameConstants.GAME_HEIGHT / background.height);
            const frameInside = this.add.image(PoolClub.GameConstants.GAME_WIDTH / 2, PoolClub.GameConstants.GAME_HEIGHT / 2, "texture_atlas_2", "splash_frame_inside.png");
            frameInside.anchor.set(.5);
            const adaptedXScale = ((PoolClub.GameVars.scaleXMult * PoolClub.GameConstants.GAME_WIDTH) - leftSplashEdge.width);
            frameInside.scale.set(adaptedXScale / (PoolClub.GameVars.scaleXMult * frameInside.width), PoolClub.GameConstants.GAME_HEIGHT / background.height);
            this.settingsButton = this.add.button(PoolClub.GameConstants.GAME_WIDTH, 0, "texture_atlas_1", this.showSettingsLayer, this);
            this.settingsButton.x -= this.settingsButton.width + (this.settingsButton.width * 0.617);
            this.settingsButton.y += this.settingsButton.height + (this.settingsButton.height * (.373 + 0.127));
            this.settingsButton.setFrames("btn_settings_on.png", "btn_settings_off.png", "btn_settings_on.png", "btn_settings_off.png");
            this.settingsButton.anchor.set(.617, .373);
            this.settingsButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            PoolClub.Utils.setButtonToInflateDeflate(this.settingsButton, this);
            const playButton_py = 530;
            const playButtonGlow = this.add.image(PoolClub.GameConstants.GAME_WIDTH / 2, playButton_py, "texture_atlas_1", "btn_play_light.png");
            playButtonGlow.anchor.set(.5);
            playButtonGlow.scale.set(0);
            const playButton = this.add.button(PoolClub.GameConstants.GAME_WIDTH / 2, playButton_py, "texture_atlas_1", this.onClickSolo);
            playButton.setFrames("btn_solo_on.png", "btn_solo_off.png", "btn_solo_on.png", "btn_solo_off.png");
            playButton.anchor.set(.5);
            playButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            PoolClub.Utils.setButtonToInflateDeflate(playButton, this);
            this.darkLayer = this.add.sprite(0, 0, this.game.cache.getBitmapData(PoolClub.GameConstants.DARK_BLUE_SQUARE));
            this.darkLayer.scale.set(PoolClub.GameConstants.GAME_WIDTH / PoolClub.GameConstants.BITMAP_SIZE, PoolClub.GameConstants.GAME_HEIGHT / PoolClub.GameConstants.BITMAP_SIZE);
            this.game.add.tween(this.darkLayer)
                .to({ alpha: 0 }, 450, Phaser.Easing.Cubic.Out, true, 150)
                .onComplete.add(function () {
                this.game.add.tween(playButtonGlow.scale)
                    .to({ x: PoolClub.GameVars.scaleXMult, y: PoolClub.GameVars.scaleYMult }, 450, Phaser.Easing.Cubic.Out, true, 500)
                    .onComplete.add(function () {
                    this.game.add.tween(playButtonGlow.scale)
                        .to({ x: PoolClub.GameVars.scaleXMult * 1.1, y: PoolClub.GameVars.scaleYMult * 1.1 }, 1000, Phaser.Easing.Cubic.Out, true, 0, -1, true);
                }, this);
            }, this);
            this.createIntroAnimation();
        }
        shutdown() {
            SplashState.currentInstance = null;
            super.shutdown();
        }
        refreshPortraitAndName(doWriteGameData) {
            this.portraitButton.setFrames(PoolClub.GameVars.gameData.playerData.avatar, PoolClub.GameVars.gameData.playerData.avatar, PoolClub.GameVars.gameData.playerData.avatar, PoolClub.GameVars.gameData.playerData.avatar);
            this.nameLabel.text = PoolClub.GameVars.gameData.playerData.nick;
            if (doWriteGameData) {
                PoolClub.GameManager.writeGameData();
            }
        }
        hideSettingsLayer() {
            this.settingsLayer.destroy();
        }
        createIntroAnimation() {
            if (PoolClub.GameVars.introseen || PoolClub.GameVars.gameData.musicMuted) {
                const gameLogo = new Phaser.Image(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, 120, "game-title");
                gameLogo.anchor.set(.5);
                this.add.existing(gameLogo);
            }
            else {
                const mcl = new PoolClub.MoveableCameraLens(this.game);
                mcl.addWaypoint(new Phaser.Point(263 * PoolClub.GameVars.scaleXMult, -119), 1, 0, .1);
                mcl.addWaypoint(new Phaser.Point(263 * PoolClub.GameVars.scaleXMult, -119), 500, 0, 1);
                mcl.addWaypoint(new Phaser.Point(0, 0), 400, 700, 2).onComplete.add(() => {
                    const gameLogo = new Phaser.Image(this.game, PoolClub.GameConstants.GAME_WIDTH / 2, 120, "game-title");
                    gameLogo.anchor.set(.5);
                    gameLogo.scale.set(0);
                    this.add.existing(gameLogo);
                    this.game.add.tween(gameLogo.scale)
                        .to({ x: PoolClub.GameVars.scaleXMult, y: PoolClub.GameVars.scaleYMult }, 700, Phaser.Easing.Elastic.Out, true, 2700).onComplete.add(() => {
                        PoolClub.AudioManager.playMusic(PoolClub.AudioManager.SOUNDTRACK, true);
                    }, this);
                }, this);
                mcl.addWaypoint(new Phaser.Point(0, 0), 3000, 0, 10, "Cubic.easeIn");
                this.add.existing(mcl);
                mcl.startAnimation();
                PoolClub.AudioManager.playMusic(PoolClub.AudioManager.INTRO_TITLE, true);
            }
        }
        showSettingsLayer() {
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
            this.settingsButton.scale.set(PoolClub.GameVars.scaleXMult, PoolClub.GameVars.scaleYMult);
            this.settingsLayer = new PoolClub.SettingsLayer(this.game);
            this.add.existing(this.settingsLayer);
        }
        onClickSolo() {
            PoolClub.GameManager.enterSoloGame();
            PoolClub.AudioManager.playEffect(PoolClub.AudioManager.BTN_NORMAL);
        }
    }
    PoolClub.SplashState = SplashState;
})(PoolClub || (PoolClub = {}));
var PhaserCachebuster;
(function (PhaserCachebuster) {
    class CacheBuster extends Phaser.Plugin {
        constructor(game, parent) {
            super(game, parent);
            this.patchLoader();
        }
        patchLoader() {
            Object.defineProperty(Phaser.Loader, "cacheBuster", {
                value: null
            });
            Phaser.Loader.prototype.transformUrl = function (url, file) {
                if (!url) {
                    return "";
                }
                if (this.cacheBuster !== null && null === url.match(/^(data:)/)) {
                    url += "?v=" + this.cacheBuster;
                }
                if (url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
                    return url;
                }
                else {
                    return this.baseURL + file.path + url;
                }
            };
        }
    }
    PhaserCachebuster.CacheBuster = CacheBuster;
})(PhaserCachebuster || (PhaserCachebuster = {}));
var PoolClub;
(function (PoolClub) {
    class MoveableCameraLens extends Phaser.Group {
        constructor(game) {
            super(game, null, "moveable-camera-lens");
            const focusImage = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "focus.png");
            focusImage.anchor.set(.5);
            this.add(focusImage);
            const pixel = 1 / 64;
            const maxScale = 100;
            const upperBlock = new Phaser.Image(this.game, 0, focusImage.y - (focusImage.height * .5), this.game.cache.getBitmapData(PoolClub.GameConstants.WHITE_SQUARE));
            upperBlock.scale.set(pixel * PoolClub.GameConstants.GAME_WIDTH * maxScale, pixel * PoolClub.GameConstants.GAME_HEIGHT * maxScale);
            upperBlock.tint = 0x060b23;
            upperBlock.anchor.set(.5, 1);
            this.add(upperBlock);
            const lowerBlock = new Phaser.Image(this.game, 0, focusImage.y + (focusImage.height * .5), this.game.cache.getBitmapData(PoolClub.GameConstants.WHITE_SQUARE));
            lowerBlock.scale.set(pixel * PoolClub.GameConstants.GAME_WIDTH * maxScale, pixel * PoolClub.GameConstants.GAME_HEIGHT * maxScale);
            lowerBlock.tint = 0x060b23;
            lowerBlock.anchor.set(.5, 0);
            this.add(lowerBlock);
            const leftBlock = new Phaser.Image(this.game, focusImage.x - focusImage.width * .5, focusImage.y, this.game.cache.getBitmapData(PoolClub.GameConstants.WHITE_SQUARE));
            leftBlock.scale.set(pixel * PoolClub.GameConstants.GAME_WIDTH * maxScale, pixel * focusImage.height);
            leftBlock.tint = 0x060b23;
            leftBlock.anchor.set(1, .5);
            this.add(leftBlock);
            const rightBlock = new Phaser.Image(this.game, focusImage.x + focusImage.width * .5, focusImage.y, this.game.cache.getBitmapData(PoolClub.GameConstants.WHITE_SQUARE));
            rightBlock.scale.set(pixel * PoolClub.GameConstants.GAME_WIDTH * maxScale, pixel * focusImage.height);
            rightBlock.tint = 0x060b23;
            rightBlock.anchor.set(0, .5);
            this.add(rightBlock);
            this.positionTweens = [];
            this.scaleTweens = [];
        }
        startAnimation() {
            this.positionTweens[0].start();
            this.scaleTweens[0].start();
        }
        addWaypoint(pos, duration, delay, scale, easing = "Quint.easeInOut") {
            const posTween = this.game.add.tween(this)
                .to({ x: (PoolClub.GameConstants.GAME_WIDTH * .5) + pos.x, y: (PoolClub.GameConstants.GAME_HEIGHT * .5) + pos.y }, duration, easing, false, delay);
            if (this.positionTweens.length === 0) {
                this.positionTweens.push(posTween);
            }
            else if (this.positionTweens.length > 0) {
                this.positionTweens[this.positionTweens.length - 1].onComplete.add(() => {
                    posTween.start();
                }, this);
                this.positionTweens.push(posTween);
            }
            if (scale) {
                const scaleTween = this.game.add.tween(this.scale)
                    .to({ x: scale * PoolClub.GameVars.scaleXMult, y: scale * PoolClub.GameVars.scaleYMult }, duration, easing, false, delay);
                if (this.scaleTweens.length === 0) {
                    this.scaleTweens.push(scaleTween);
                }
                else if (this.scaleTweens.length > 0) {
                    this.scaleTweens[this.scaleTweens.length - 1].onComplete.add(() => {
                        scaleTween.start();
                    }, this);
                    this.scaleTweens.push(scaleTween);
                }
            }
            return posTween;
        }
    }
    PoolClub.MoveableCameraLens = MoveableCameraLens;
})(PoolClub || (PoolClub = {}));
var PoolClub;
(function (PoolClub) {
    class Utils {
        static setButtonToInflateDeflate(b, context, alternateObjectToInflate) {
            const objectToInflate = alternateObjectToInflate ? alternateObjectToInflate : b;
            const oldXScale = objectToInflate.scale.x;
            const oldYScale = objectToInflate.scale.y;
            b.events.onInputDown.add(function () { objectToInflate.scale.set(oldXScale * 1.1, oldYScale * 1.1); }, context);
            b.events.onInputOver.add(function () { objectToInflate.scale.set(oldXScale * 1.1, oldYScale * 1.1); }, context);
            b.events.onInputOut.add(function () { objectToInflate.scale.set(oldXScale, oldYScale); }, context);
            b.events.onInputUp.add(function () { objectToInflate.scale.set(oldXScale, oldYScale); }, context);
        }
        static getRandomUsernameList() {
            return [
                "AllyCookie",
                "Branstoqu",
                "Bur_gizer",
                "Chatomadli",
                "ChoneKnotLou",
                "Conceme41",
                "CoooooopsFree",
                "Darklessra",
                "Garioney",
                "GrabsDrummer",
                "IamaBloom",
                "1k1nt1cs",
                "Issueinters",
                "Knottownce",
                "LightN_inja",
                "Multing",
                "Ravag3rma",
                "RockerPersonal",
                "Slip_korks",
                "Sportswaba",
                "Stori3sDas",
                "TagzBall",
                "0Th3reCoverag3",
                "UnowPlus",
                "Fistro",
                "CountOfMor",
                "Mistery2005",
                "KineticForce",
                "M. Rajoy",
                "ChumbaWumba",
                "PlayerTotal",
                "Barcelono",
                "BrainDamage",
                "LobotomyHero",
                "MiniRock",
                "LettuceJuice",
                "Camaleon",
                "Bloom",
                "buTTer",
                "tenderGlobe",
                "ColdFeet",
                "LovelLove",
                "StronGGGG",
                "PoopSY",
                "kidd_2005",
                "thunderblade",
                "Priapus",
                "koksy"
            ];
        }
        static getRandomAvatarImageList() {
            return [
                "billar_m01",
                "billar_m02",
                "billar_m03",
                "billar_m04",
                "billar_m05",
                "billar_m06",
                "billar_m07",
                "billar_m08",
                "billar_w01",
                "billar_w02",
                "billar_w03",
                "billar_w04",
                "billar_w05",
                "billar_w06",
                "billar_w07",
                "billar_w08"
            ];
        }
        static colourText(rulesText, startIndex, charCount, textColour, strokeColour) {
            const oldFill = rulesText.fill;
            const oldStroke = rulesText.stroke;
            rulesText.addColor(textColour, startIndex);
            rulesText.addColor(oldFill, startIndex + charCount);
            if (strokeColour) {
                rulesText.addStrokeColor(strokeColour, startIndex);
                rulesText.addStrokeColor(oldStroke, startIndex + charCount);
            }
        }
        static truncateName(name, limit = 10) {
            if (name.length > limit) {
                name = name.substr(0, limit);
                name += "...";
            }
            return name;
        }
        static validNumber(x) {
            return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        static getNumberOfDigitsInNumber(num) {
            if (num < 0) {
                throw "Invalid. Number must be larger than 0";
            }
            let digits = 1;
            let m = 10;
            while (m <= num) {
                digits++;
                m *= 10;
            }
            return digits;
        }
        static timeToString(time) {
            let minutes = Math.floor(time / 60);
            let seconds = time - (minutes * 60);
            if (minutes < 10) {
                minutes = "0" + minutes;
            }
            if (seconds < 10) {
                seconds = "0" + seconds;
            }
            return minutes + ":" + seconds;
        }
        static shuffle(array, prng) {
            let currentIndex = array.length, temporaryValue, randomIndex;
            while (0 !== currentIndex) {
                randomIndex = Math.floor(prng.frac() * currentIndex);
                currentIndex -= 1;
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
            return array;
        }
        static centerPoint(array) {
            let x = 0;
            let y = 0;
            for (let i = 0; i < array.length; i++) {
                x += array[i].x;
                y += array[i].y;
            }
            return { x: x / array.length, y: y / array.length };
        }
        static parseString(json) {
            json = json.replace(/id:/g, '"id":');
            json = json.replace(/active/g, '"active"');
            json = json.replace(/x:/g, '"x":');
            json = json.replace(/y:/g, '"y":');
            json = json.replace(/ballsData/g, '"ballsData"');
            json = json.replace(/english/g, '"english"');
            json = json.replace(/deltaScrewX/g, '"deltaScrewX"');
            json = json.replace(/deltaScrewY/g, '"deltaScrewY"');
            json = json.replace(/playerId/g, '"playerId"');
            return JSON.parse(json);
        }
        static stringify(object) {
            let str = JSON.stringify(object);
            return str.replace(/\"([^(\")"]+)\":/g, "$1:");
        }
        static createAnimFramesArr(filename, framesCount, reverse = false, timesToRepeatFinalFrame = 0, blankBufferBeforeAnim = 0) {
            let frames = [];
            for (let i = 0; i < framesCount; i++) {
                if (i === 0 && blankBufferBeforeAnim > 0) {
                    for (let j = 0; j < blankBufferBeforeAnim; j++) {
                        frames.push("blank.png");
                    }
                }
                frames.push(filename + "_" + (reverse ? (framesCount - 1 - i) : i).toString() + ".png");
                if (i === framesCount - 1 && timesToRepeatFinalFrame > 0) {
                    for (let j = 0; j < timesToRepeatFinalFrame; j++) {
                        frames.push(filename + "_" + (reverse ? (framesCount - 1 - i) : i).toString() + ".png");
                    }
                }
            }
            return frames;
        }
        static hash(str) {
            let hash = 5381;
            let i = str.length;
            while (i) {
                hash = (hash * 33) ^ str.charCodeAt(--i);
            }
            return hash >>> 0;
        }
    }
    PoolClub.Utils = Utils;
})(PoolClub || (PoolClub = {}));
//# sourceMappingURL=pool-club.min.js.map